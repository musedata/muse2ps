
&dA                                                                        
&dA &d@                                                                      &dA 
&dA &d@                   Global #define Definitions                         &dA 
&dA &d@                                                                      &dA 
&dA                                                                        

#define    DMUSE          0     
                               /* when program is being tested in the Dmuse environment
#define    XPOS_FIXED     1 
                               /* with Beethoven, try 1 first, then 0; with Haydn, use 1
#define    SFZ            0 
                               /* SFZ            = 1:  print sfortzando as sfz 
#define    NO_EDIT        0 
                               /* NO_EDIT        = 1:  do not process editorial data
#define    ROMAN_EDIT     0 
                               /* ROMAN_EDIT     = 1:  use Times Roman font for 
                               /*                        editorial marks: tr, dynamics
#define    OLD_REPEATERS  1 
                               /* OLD_REPEATERS  = 1:  use half notes instead of quarters
#define    CUSTOM_PAR     1 
                               /* allows use of custom parameters, for whatever reason
                               /* see code at CUSTOM_PAR 
#define    DEFAULT_DTIVFONT    37 
#define    DEFAULT_MDIRFONT    31 
                               /* default font for musical directions 

#define    TRUE           0 
#define    FALSE          1 
#define    YES            0 
#define    NO             1 
#define    OFF            0 
#define    ON             1 

&dA &d@     Actual Characters 

#define    DOT_CHAR      44 

&dA &d@     Font parameters 

#define   BEAM_OFFSET     12 
#define   TIE_OFFSET      25 
#define   LARGE_BRACK     42 
#define   SMALL_BRACK     43 

&dA &d@     Descriptive Definitions (array elements) 
  
#define    TIE_SNUM       1
#define    TIE_NTYPE      2
#define    TIE_VLOC       3
#define    TIE_FHDIS      4
#define    TIE_FSTEM      5
#define    TIE_NDX        6 
#define    TIE_STAFF      7 
#define    TIE_FOUND      8 
#define    TIE_FORCE      9 
#define    TIE_SUGG      10 
#define    TIE_COLOR     11 
#define    TIE_ARR_SZ    11 

#define    FIG_SNUM       1
#define    FIG_HOFF1      2
#define    FIG_HOFF2      3
#define    FIG_READY      4
 
#define    REG            1
#define    GRACE          2
#define    CUE            3
#define    CUEGRACE       4
 
#define    BM_SNUM        1
#define    BM_CNT         2
#define    BM_READY       3
#define    BM_STEM        4
#define    BM_TUPLE       5
#define    BM_SIZE        6 
#define    BM_SUGG        7 
#define    BM_COLOR       8 
#define    BM_SZ          8 
  
#define    SL_SNUM        1
#define    SL_YSHIFT      2
#define    SL_XSHIFT      3 
#define    SL_NEXTSNUM    4
#define    SL_BEAMF       5 
#define    SL_SUGG        6 
#define    SL_SIZE        6 
 
#define    TU_SNUM        1
#define    TU_Y1          2
#define    TU_Y2          3
#define    TU_FSTEM       4
 
#define    TYPE           1
#define    DIV            2
#define    CLAVE          3
#define    AX             4
#define    TEMP4          4
#define    NTYPE          5
#define    DOT            6
#define    TUPLE          7
#define    STAFFLOC       8
#define    SPACING        9
#define    STEM_FLAGS    10
#define    BEAM_FLAG     11
#define    BEAM_CODE     12
#define    LOCAL_XOFF    13 
#define    SUPER_FLAG    14
#define    SLUR_FLAG     15
#define    SUBFLAG_1     16
#define    SUBFLAG_2     17
#define    VIRT_NOTE     18
#define    SORTPAR1      18
#define    SORTPAR2      19
#define    TEMP2         19
#define    GLOBAL_XOFF   19
#define    TEXT_INDEX    20
#define    PASSNUM       21
#define    BACKTIE       22
#define    NOTE_DUR      23
#define    DINC_FLAG     24
#define    VIRT_STEM     25 
#define    ED_SUBFLAG_1  26 
#define    ED_SUBFLAG_2  27 
#define    STAFF_NUM     28 
#define    NUM_STAVES    28 
#define    MULTI_TRACK   29 
#define    TEMP1         30 
#define    SPN_NUM       30 
#define    OBY           31 
#define    SLUR_X        32 
#define    NODE_SHIFT    33 
#define    TRACK_NUM     34 
#define    BASE_40       35 
#define    NOTE_DISP     36 
#define    AX_DISP       37 
#define    AUG_DOTS      38 
#define    TSR_POINT     39 
#define    TS_SIZE       39 
&dA 
&dA &d@     ts(.) Array positions for arpeggio variables  (note doublings with other flags)
&dA 
#define    ARPEG_FLAG    16 
#define    ARPEG_TOP     26 
#define    ARPEG_BOTTOM  27 
#define    ARPEGGIO      33 
 
#define    TSR_LENG     116 
                                         
#define    NUMBER_OF_FIG  3
#define    FIG_SPACE      4
#define    FIG_DATA       5
#define    MIN_FIG_SPAC  20 
#define    FIG_DUR       23
 
#define    SIGN_POS       3
#define    SIGN_TYPE      4
#define    SUPER_TYPE     5
#define    FONT_NUM       6
#define    WEDGE_OFFSET   7
#define    S_TRACK_NUM    8 
#define    WEDGE_SPREAD  10 
#define    POSI_SHIFT1   11 
#define    ISOLATED      12 
#define    POSI_SHIFT2   13 
 
#define    DOLLAR_SPN     5 
#define    DIVSPQ         3
 
#define    CLEF_NUM       3
#define    CLEF_FONT      4
#define    CLEF_STAFF_POS 6
 
#define    BAR_NUMBER     3
#define    BAR_TYPE       4
#define    REPEAT         5
#define    BACK_ENDING    6
#define    FORW_ENDING    7
#define    BAR_FLAGS      8
#define    M_NUMBER      10 
 
#define    REGULAR        1
#define    HEAVY          2
#define    DOTTED         3
#define    DOUBLE_REG     5
#define    REG_HEAVY      6
#define    HEAVY_REG      9
#define    DOUBLE_HEAVY  10
#define    DOUBLE_DOTTED 15
 
#define    WEDGES         1
#define    DASHES         2
#define    OCT_UP         3
#define    OCT_DOWN       4
#define    DBL_OCT_UP     5
#define    DBL_OCT_DOWN   6
#define    NORMAL_TRANS  13 
 
#define    NOTE           1
#define    XNOTE          2
#define    REST           3
#define    CUE_NOTE       4
#define    XCUE_NOTE      5
#define    CUE_REST       6
#define    GR_NOTE        7
#define    XGR_NOTE       8
#define    NOTE_OR_REST   8
#define    FIGURES        9
#define    BAR_LINE      10
#define    SIGN          11
#define    WORDS         12
#define    MARK          13
#define    CLEF_CHG      14
#define    DESIGNATION   15
#define    METER_CHG     16
#define    DIV_CHG       17
#define    AX_CHG        18
#define    P_SUGGESTION  19 
 
#define    MUSICAL_DIR   11
#define    IREST         12
#define    BACKSPACE     13
 
#define    SEGNO          1
#define    PED            2
#define    END_PED        3
#define    LETTER_DYNAM   4
#define    RIGHT_JUST_STR 5 
#define    CENTER_STR     6 
#define    LEFT_JUST_STR  7 
#define    TIE_TERM       8 
#define    REH_MARK       9 

#define    BELOW          1 
#define    ABOVE          2 
 
#define    HEAD           0
#define    TAIL           1
 
#define    FULLSIZE       0
#define    CUESIZE        1
 
#define    THIRTY_SECOND  4
#define    SIXTEENTH      5
#define    EIGHTH         6
#define    QUARTER        7
#define    HALF           8
#define    WHOLE          9
#define    BREVE         10 
#define    LONGA         11 
#define    SLASH8         0 

#define    UP             0
#define    DOWN           1
#define    SINGLE_NOTE    0
#define    CHORD          1
 
#define    NO_BEAM        0
#define    END_BEAM       1
#define    START_BEAM     2
#define    CONT_BEAM      3 
 
*     Parametric Definitions
 
#define    MAX_STAFF      2 
#define    MAX_TIES      16 
#define    MAX_FIG        4
#define    MAX_PASS      10 
#define    MAX_OBJECTS 1000 
#define    MAX_M        400 
 
*     Other Definitions 
 
#define    DUMMY_VALUE 10000 
#define    INT1000000  1000000 
#define    INT10000    10000 
#define    INT100        100 
#define    INT9000      9000 
#define    BHPAR1         30 
#define    MAX_MEAS     2000 

&dA                                        
&dA &d@                                      &dA 
&dA &d@    Definitions added with mskpage    &dA 
&dA &d@                                      &dA 
&dA                                        

#define   M_NUM_FONT      37 
#define   NAMELEN         17 

#define   SUPERSIZE      192    
#define   MAX_BNOTES      32 
#define   N_SUPER         16 
#define   LIM1         20000 

#define   PRE_DIST         1 
#define   MNODE_TYPE       2 
#define   TIME_NUM         3 
#define   SNODE            4 
#define   ACT_FLAG         5 
#define   M_ADJ            6 
#define   MARR_TEMP        7 
#define   MARR_PARS        7 
                                
#define   CONTINUO         0 
                                /* 1 = set figured harmonies above staff 
#define   MAGIC1         300 

#define SUPERMAX          50 
#define N_SIZES           12            /* changed &dA03/15/04&d@ from 4 to 12 
#define TIE_DISTS        200 

&dA                                                                  
&dA &d@                                                                &dA 
&dA &d@               Global Variables and Global Program              &dA 
&dA &d@                                                                &dA 
&dA                                                                  

      str out.10000,line.480,temp.480,temp3.480,temp4.160 
      str slurstr.160,slurover.80,slurunder.80 
      str ttext.480,jtype.1 
      str tcode.4(MAX_M),tdata.80(MAX_M,2) 
      str sobl.120(30),tsdata.100(MAX_OBJECTS) 
      str tsr.TSR_LENG(MAX_OBJECTS)                           /* &dA05/14/03&d@ expanded length to 116
      str mrest_line.200                                      /* New &dA03/07/06
      str time_stamps.80(50) 
      str psfile_header.120(10) 
      str job_type.1 

      int finums,fioffs(50),part_order(50) 
      int tv1(MAX_M),tv2(MAX_M),tv3(MAX_M),tv5(MAX_M) 
      int tv4(MAX_M,2)                                        /* tv4 expanded to 2 dims. &dA12/21/10
      int tiecnt 
      int supcnt,supnums(12) 
      int mf(256),beampar(4,MAX_PASS,BM_SZ)                   /* &dA12/21/10&d@ expanded BM_SZ to 8
      int slurar(8,SL_SIZE),tuar(4,MAX_PASS,4) 
      int super_flag,slur_flag 
      int spc(255),nsp(36),claveax(50),measax(4,50)           /* &dA06/04/08&d@ expanding measax to (4,50)
      int zak(2,7),wak(9),hpar(200),vpar(200),bvpar(35),vpar20 
      int clef_vpos 
      int @n,old@n 
      int notesize,mtfont,twfont,curfont,mdirfont,dtivfont 
      int olddivspq,divspq 
      int cline(MAX_STAFF),clef(MAX_STAFF),key 
      int a1,a2,a5,a6 
      int c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17 
      int beamdata(4,MAX_PASS,31),beamcode(31) 
      int emptyspace(MAX_STAFF,45) 
      int ts(MAX_OBJECTS,TS_SIZE) 
      int sct,oldsct,maxsct,measnum 
      int esnum 
      int tsnum(MAX_PASS) 
      int pre_tsnum(MAX_PASS),pre_ctrarrf(MAX_PASS),pre_try(MAX_PASS) 
      int ntype,f8,inctype,jcode,pcode,passtype,passsize,stem 
      int firstoff,sigflag 
      int obx,oby,sobx,soby,sobcnt,snum 
      int c8flag(MAX_STAFF),transflag(MAX_STAFF),tuflag,passnum,spn 
      int ctrflag(MAX_PASS) 
      int mindist 
      int tnum,tden,nstaves 
      int scnt,urcnt 
      int vflag 
      int granddist,tword_height,outpnt 
      int note_dur 
      int minshort 
      int global_tpflag 
      int tpflag 
      int pcontrol,px,py,pyy,pxx 
      int putobjpar 
      int repeater_case 
      int textconflag 
      int min_space                                              /* added &dA11/19/07
      int slur_adjust                                            /* added &dA05/01/08

      bstr outslurs.8 
      label E(20),TT(6),SS(21),PSUG(20),TPF(5),TPFF(5),ADJS(5)    /* expanding PSUG &dA05/01/08
      table X(900000),Y(400000) 
      table FI(100000) 
      table UR(900000) 

      int curvedata(8,4,8) 

      int ndata(20,12)               /* 2nd dimension expanded to 12  &dA01/08/11
      int pcnt 
      int printpos(10) 
      int gl(2,45),gr(2,45) 
      int pseudo_gr(2,45) 
      int pseudo_gl(2,45) 

      int p,x,y,z
      int m_number 
      int xmindist 
      int opt_rest_flag 
      int fix_next_inctype 

      str hitestr.270 
      str fontspac.18000 
      str mfontspac.2400 

      int XFonts(12,19) 
      int sizenum 
      int kernmap(52,26) 
      int all_real_kernmaps(30,26,26) 
      int revsizes(24) 
      int revmap(400) 

      int art_flag 
      int single_line 
      int stem_change_flag 
      int dot_difference_flag 

      int multirest_flag 
      int key_reprint_flag 
      int mixed_note_head_flag 

      int suppress_key 
      int font_base,font_height,zero_height 
      int in_line_edslur 
      int large_clef_flag 
      int rest_collapse 
      int color_flag          

      int how_much_mrest(2) 
&dA 
&dA &d@   Variables initialized by get_options and possibly 
&dA &d@     altered by the control line 
&dA 
      int Source_type 
      int Addfiles,C_Addfiles 
      int Cfactor,C_Cfactor 
      int Debugg,C_Debugg 
      int Vspace_flag,C_Vspace_flag 
      int Granddist,C_Granddist 
      int Min_space,C_Min_space 
      int Just_flag,C_Just_flag 
      int Length_of_page,C_Length_of_page 
      int Marg_left,C_Marg_left 
      int Max_sys_cnt,C_Max_sys_cnt 
      int Minshort,C_Minshort 
      int W(32),C_W(32) 
      int Sys_width,C_Sys_width 
      int Top_of_page,C_Top_of_page 
      int Defeat_flag,C_Defeat_flag 
      int Notesize,C_Notesize 
      int Nparts 
      str Syscode.80,C_Syscode.80 
      str Group.80,C_Group.80 
      int eof_flag,C_eof_flag 
      str Work_name.180,C_Work_name.180 
      str Work_number.80,C_Work_number.80 
      str Composer.120,C_Composer.120 
      int tmess 
&dA 
&dA &d@   These variables are new additions to global from mskpage 
&dA 
      int f(32,17),f11,f12 
      str cjtype.1 
      str msk_beamcode.6(MAX_BNOTES),syscode.80,superline.180 
      int ldist,larr(300,MARR_PARS),marr(60,MARR_PARS),larc,marc,tarr(32) 
      int tdist(32,2) 
      int small(300),cflag,dxoff(32),dyoff(32) 
      int rec,crec,drec(32),beamfont 
      int hxpar(25),mhpar(32,25),mvpar(32,41),mvpar20(32) 
      int snode,dincf,maxnotesize,oldbarnum,cntype,coby,cz,csnode 
      int lowerlim,toplim,false_rmarg 
      int superdata(32,N_SUPER,SUPERSIZE) 
      int sp,vst(32),psq(32),x1,x2,y1,y2 
      int bcount,bdata(MAX_BNOTES,2),supernum 
      int mkey(32),mclef(32,2),mtcode(32),savtcode(32) 
      int gbar(2),gbarflag,tplace,w(32) 
      int olddist(32),dvar1,cdv 
      int lpt,intersys,sys_bottom,old_sys_bottom 

      str outfile.280 
      str tacetline.180,mvtline.180 
      str lbyte.1,last_jtype.1 
      int justflag,start_look,sys_count,firstsys 
      int adj_space,small2(300),scnt2 
      int mainyp,pn_left,psysnum,mnum 
      int no_action 
      int zcnt 

      table Z(400000),IF(900000) 
&dA 
&dA &d@   These variables are new additions to global from pspage 
&dA 
      str line2.480,xbyte.1(10) 
      str longslur.800(250) 
      str gstr.8000000 
      str slurpar06.600(11,11,6) 
      str slurpar14.600(11,11,6) 
      str slurpar16.600(11,11,6) 
      str slurpar18.600(11,11,6) 
      str slurpar21.300(11,11,6) 
      str mtloc.100 
      str color_line.8 

      bstr slmap.4500(750) 
      bstr bt.2500(250) 
      bstr dotted.2500 

      int beamt,qwid,stemchar,bthick,backloc(10),uxstart(10),uxstop(10) 
      int ibackloc(10),phpar(63),pvpar(45),pvpar20 
      int underflag,pos(256),urpos(256),underspc(12),hyphspc(12) 
      int beamext(435,12),tiearr(N_SIZES,4,TIE_DISTS,12) 
      int tupldata(7),tbflag 
      int z3 
      int ps_beamdata(MAX_BNOTES,3)        /* 2nd dimension increased from 2 to 3 &dA12/21/10
      int expar(8),sitflag 
      int barbreak(10,2),brkcnt,gapsize 
      int music_con(255),Beaminc(255),Wedginc(255),Tieinc(12,255) 
      int Mfontinc(12,255) 
      int postx,posty,slur_edit_flag 
      int figoff(32),nsz(32) 
      int hookbackshift(14) 
      int FA(7500) 
      int scx,scy,scb,scf 
      int glyph_record(140,256) 
      int sd_cnt,st_cnt,ct_cnt,sst_cnt,pd_cnt,pt_cnt,pt_cnt2,ppt_cnt 
      int ct_cnt2,ct_cnt3,ct_cnt4    /* New &dA12/26/10&d@ and &dA01/17/11&d@ 
      int pt_cnt3,pt_cnt4,pt_cnt5    /* New &dA12/26/10&d@ and &dA01/17/11&d@ 
      int if_cnt 
      int ycnt,zpnt,zpnt2 

      real slpara(8,55) 

      table NC(100) 
      table SD(200000)               /* slur dictionaries 
      table ST(50000)                /* primary slur table 
      table CT(40000)                /* character table 
      table CT2(10000)               /* "red   color" character table  New &dA12/26/10
      table CT3(10000)               /* "green color" character table  New &dA01/17/11
      table CT4(10000)               /* "blue  color" character table  New &dA01/17/11
      table SST(10000)               /* longslur table 
      table PD(20000)                /* PostScript dictionary output 
      table PT(20000)                /* PostScript character output 
      table PT2(1000)                /* Auxiliary PostScript character output
      table PT3(5000)                /* Red   Color PostScript character output  New &dA12/26/10
      table PT4(5000)                /* Green Color PostScript character output  New &dA01/17/11
      table PT5(5000)                /* Blue  Color PostScript character output  New &dA01/17/11
      table ZZ(2000)                 /* font/glyph usage table 
      table XX(200000)               /* "fontdict" table 
      table PPT(1200000)             /* combined Postscript character output

      glob slurpars: j:/release/internet/linux/compprogs/sparfils/allinone 
      glob postdict: j:/zprogs/apps/postdict 
      glob gfontspac: j:/release/internet/linux/compprogs/fontspac 
      glob gmfontspac: j:/release/internet/linux/compprogs/mfontspac 
      glob gkernspac: j:/release/internet/linux/compprogs/kernspac 

&dA                              
&dA &d@                            &dA 
&dA &d@       Global Program       &dA 
&dA &d@                            &dA 
&dA                              

&dK &d@     putc Autoset -> Mskpage -> Pspage 

      perform get_options 

      perform load_font_stuff 

      perform get_source 

      if Source_type = 0 
        perform my_autoset 
        perform my_mskpage 
      end 

      perform my_pspage 

      stop 

&dA                                                                       
&dA &d@                                                                     &dA 
&dA &d@             &dAÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@             &dA 
&dA &d@             &dA³          P R O C E D U R E S            ³&d@             &dA 
&dA &d@             &dAÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@             &dA 
&dA &d@                                                                     &dA 
&dA                                                                       

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P*  1. my_autoset                                               ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Input: from source file                                     ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Output: QQ table -> my_mskpage                              ³ 
&dA &d@³                                                                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure my_autoset 
        str pgroup.12 
        str temp5.20 
        str mname.60,wname.80,partname.80 
        str zparxx.120(25)
        str temp_time_stamp.80 
        str trecords.120(20) 

        int time_stamp_loc 
        int g,m 
        int rc 
        int t1,t2,t3,t4,t5,t6
        int kk,ii 
        int f1,f2,f3,f4 
        int aa3,aa4,aa5,aa6,aa7,aa8,aa10 
        int sugg_flg,sugg_flg2 
        int mrest 
        int repeater_flag 
        int font_changes(10,2),changecnt 
        int fize,ficnt,read_state 
        int restplace 
        int cfactor 
        int wrest 
        int restoff 
        int text_flag 
        int text_loc 
        str LL.1 
        int irest_flag 
        int mreport_flag 
        int barnum2 

        int sys_data(32,4) 
&dA 
&dA &d@  initialization of parameters 
&dA &d@  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ 
&dA 
        notesize = Notesize 
        mtfont = 31 
        tword_height = 6 
        twfont = 34 
        cfactor = Cfactor 
        sizenum = revsizes(notesize) 

        bvpar(16) = 3 * notesize 
        bvpar(17) = notesize / 2 
        bvpar(18) = 30 * notesize / 16 
        bvpar(20) = notesize / 2 + 1 / 2 
        bvpar(22) = 6 * notesize / 16 
        bvpar(23) = 9 * notesize / 16 
        bvpar(24) = 7 * notesize / 16 
        bvpar(25) = 22 * notesize / 16 
        bvpar(26) = 27 * notesize / 16 
        bvpar(29) = 38 * notesize / 16 
        bvpar(30) = 3 * notesize - 8 / 16 
        bvpar(31) = notesize / 2 + 1 
        bvpar(32) = notesize * 8 + 4 / 10 
        bvpar(33) = notesize * 12 + 10 / 14 
        bvpar(34) = notesize - 3 / 9 
        bvpar(35) = notesize / 3 

        curfont = 0
        zcnt = 0 
&dA 
&dA &d@  initialization 
&dA &d@  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍ 
&dA 
&dA &d@    Vertical and horizontal parameters 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
 
&dA &d@   for notesize = 6 
        zparxx(1)  = "-0369<?BEH+,9,5.,-,24+B9******/*4**.*I/<3399ZBf3T003633233333763.f-,32+*-,3124+*218,..-,----,,-*****"
        zparxx(2)  = "V***************************************************************************************************"
        zparxx(3)  = "0116,87@03/1+>73.6-3.-55S..+-7374*:+30H0-2.--1/5+*10/,*H+1*452/101004/5431./32+--246-:61++05++,-3/*2"
        zparxx(4)  = "1.+.1,+231///../---**/3.0-6-6/6.4.3-1/11,938********************************************************"
        zparxx(5)  = "ªÆ­¹©¶ª«¬-&--&-'.'.'." 

&dA &d@   for notesize = 14 
        zparxx(6)  = "18?FMT[bip-0N0D5/10=A-bM******6*A**4,s7T??MMšb¶?Œ88?F??<?????IF?5¶2/?<,+0/?;=B,+=;K/220/1101-./*****"
        zparxx(7)  = "***************************************************************************************************"
        zparxx(8)  = "8<9G/KH^9?7:-ZH?3F1?42DDŠ54.1I?JC+P.?9p82=40/;6D.*:85.*H-:*AC=6<9977@5@@>845?<,01=BF0PE9-,7C,..1?5+<"
        zparxx(9)  = ";4,3;-+<?9466225001**5?271G2E4E3A3?1949;/H?I********************************************************"
        zparxx(10) = "ªÆ­¹©¶ª«¬-&--&-'.'.'." 

&dA &d@   for notesize = 16 
        zparxx(11) = "2:BJRZbjrz.1T1H7031@E.jR******8*D**6,~9ZBBRRªjÊBš::BJBB?BBBBBNJB7Ê30B?,+10B>@E,+@>O033101112-/0*****"
        zparxx(12) = "***************************************************************************************************"
        zparxx(13) = ";><H0PMf:B9=.aMC5K2B64HH˜76/3NBOG,V0C<z;4@610>8H/*<:7.*H-<*DG@8>;;99D7DCB;46B?-12@EJ1UI;.,9F-/.2A6+?"
        zparxx(14) = ">5,4>.+?B<6:9337112**6B392K3I6I5D5B2;5;=/LCN********************************************************"
        zparxx(15) = "ªÆ­¹©¶ª«¬-&--&-'.'.'." 

&dA &d@   for notesize = 18 
        zparxx(16) = "3<ENW`ir{„.1Y1K8041BH.rW******:*H**7,ˆ:`EEWWºrŞE¨<<ENEEBEEEEERNE8Ş41EA,+21E@BI,+B@U144212223.01*****"
        zparxx(17) = "­***************************************************************************************************"
        zparxx(18) = "=@>J0TQm<E:?.gQF6O3E75KK¥87/4RESJ,[2F>„=5B710@9K/*><8/*H.>*GKD9@>=::F9FFD=58EB.24DJP2[M>.-;J.//4C8,B"
        zparxx(19) = "A7-6@/,AE=8;:449223**8E4;3O4M7M6H6E3=6=@0QEQ********************************************************"
        zparxx(20) = "ªÆ­¹©¶ª«¬-&--&-'.'.'." 

&dA &d@   for notesize = 21 
        zparxx(21) = "4?IT^is~ˆ“/3a3Q;153FM/~^******<*M**:-˜=iII^^Ò~üI½??ITIIFIIIIIYTI9ü62JE-,32JDGN-,GD\266324435/12*****"
        zparxx(22) = "Á***************************************************************************************************"
        zparxx(23) = "@CAM1[Wx?I=B/rWJ8U4I97QQº;905YIZP,c0JA“@7F931D<Q0*B?;0*H/B*LQH<CB@<<K<KKH@7;IF.36GMU3cSA.->O.006F;,E"
        zparxx(24) = "D9-8D1,EI@9<<66;334**;I6>5U6R9R8M8J4@8@C1YJY********************************************************"
        zparxx(25) = "ªÆ­¹©¶ª«¬-&--&-'.'.'." 

        if notesize = 6 
          line = "06" 
        else 
          line = chs(notesize) 
        end 
        if "   06   14   16   18   21" con line 
          t3 = mpt - 4      /* 0,5,10,15,20 
        end 
        g = 0                          /* index into vpar and hpar 
        loop for t1 = 1 to 2 
          t5 = t1 + t3                  /* index into vpar strings 
          t2 = t1 + t3 + 2              /* index into hpar strings 
          loop for t4 = 1 to 100 
            ++g 
            t6 = ors(zparxx(t5){t4}) 
            vpar(g) = t6 - 42 
            t6 = ors(zparxx(t2){t4}) 
            hpar(g) = t6 - 42 
          repeat 
        repeat 

        vpar20 = 2 * vpar(10) 

#if CUSTOM_PAR 
        if notesize = 14 
          vpar(101) = 111 
        end 
        if notesize = 16 
          vpar(101) = 126 
        end 
        if notesize = 18            /* size-18 added &dA12/18/04&d@ 
          vpar(101) = 141 
        end 
        if notesize = 21 
          vpar(101) = 171 
        end 
#endif 

&dA 
&dA &d@    Other parameters and variables 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        t3 += 5                    /* t3 -> last relevant string 
        g = 0 
        loop for t1 = 1 to 9 
          ++g 
          t6 = ors(zparxx(t3){g}) 
          wak(t1) = t6 - 42 
        repeat 
        loop for t1 = 1 to 2 
          loop for t2 = 1 to 6 
            ++g 
            t6 = ors(zparxx(t3){g}) 
            zak(t1,t2) = t6 - 42 
          repeat 
        repeat 

        slurstr = "FpmFjoiOlpmFooiOphpFokoiffnFggnHFfFFIgGJcceBdddQBaAPEdQQcbeedddM"
        slurstr = slurstr // "KaNKddNMBaAAECCDlpmFIGGOlpmFOGOOphpFoiGHffnFggNH"
        slurstr = slurstr // "FfFFIgGJcceBECQQcdeAECQQcbeeddLMKaNKMdNMAaAAECCD"
        slurunder = "FHHFIGOOFHHFIGOOFNFFINGGFFNFIGNHFFFFIGGJBBBBECCQ" 
        slurunder = slurunder // "BBBBECCQKCKKQNLMKKNKMLNMBKAAECCD" 
        slurover  = "lpppjoiolpppjoiophppokoiffnrggngffsngggncceedddd" 
        slurover  = slurover  // "cceeddddcbeeddddcanaddndcaendddn" 
&dA 
&dA &d@   Meaning of curvedata:  Curvedata is meant to describe the  
&dA &d@   approximate shape of slurs for various situations.  The slurs 
&dA &d@   begin described are (flat) tips down.  The end points are         
&dA &d@   assumed to be 0 and are therefore not included.  A slur between 
&dA &d@   two notes need not be described, so that the first relevant 
&dA &d@   description is a slur between three notes.     
&dA 
&dA &d@   The first dimension of curvedata contains the number of notes  
&dA &d@   under the slur (not counting the end points).  The second 
&dA &d@   dimension contains a number representing the curvature of the 
&dA &d@   slur (from 1 to 4).  The third dimension contains the specific 
&dA &d@   note number for the height data.  This number will range from 
&dA &d@   1 to the number of notes under the slur (not counting the end 
&dA &d@   points).  
&dA 


&dA 
&dA &d@   Curvedata for notesize = 14 
&dA 
        curvedata(1,1,1) = 10 
        curvedata(1,2,1) = 14 
        curvedata(1,3,1) = 18 
        curvedata(1,4,1) = 22 

        curvedata(2,1,1) =  8 
        curvedata(2,2,1) = 12 
        curvedata(2,3,1) = 16 
        curvedata(2,4,1) = 20 

        curvedata(3,1,1) = 10 
        curvedata(3,1,2) = 12 
        curvedata(3,2,1) = 12 
        curvedata(3,2,2) = 16 
        curvedata(3,3,1) = 14 
        curvedata(3,3,2) = 20 
        curvedata(3,4,1) = 17 
        curvedata(3,4,2) = 24 

        curvedata(4,1,1) =  9 
        curvedata(4,1,2) = 12 
        curvedata(4,2,1) = 11 
        curvedata(4,2,2) = 16 
        curvedata(4,3,1) = 13 
        curvedata(4,3,2) = 20 
        curvedata(4,4,1) = 16 
        curvedata(4,4,2) = 24 

        curvedata(5,1,1) =  8 
        curvedata(5,1,2) = 13 
        curvedata(5,1,3) = 14 
        curvedata(5,2,1) = 11 
        curvedata(5,2,2) = 16 
        curvedata(5,2,3) = 18 
        curvedata(5,3,1) = 13 
        curvedata(5,3,2) = 19 
        curvedata(5,3,3) = 21 
        curvedata(5,4,1) = 16 
        curvedata(5,4,2) = 24 
        curvedata(5,4,3) = 25 

        curvedata(6,1,1) =  8 
        curvedata(6,1,2) = 12 
        curvedata(6,1,3) = 14 
        curvedata(6,2,1) = 11 
        curvedata(6,2,2) = 16 
        curvedata(6,2,3) = 18 
        curvedata(6,3,1) = 13 
        curvedata(6,3,2) = 20 
        curvedata(6,3,3) = 22 
        curvedata(6,4,1) = 16 
        curvedata(6,4,2) = 24 
        curvedata(6,4,3) = 25 

        curvedata(7,1,1) =  7 
        curvedata(7,1,2) = 11 
        curvedata(7,1,3) = 14 
        curvedata(7,1,4) = 15 
        curvedata(7,2,1) = 11 
        curvedata(7,2,2) = 16 
        curvedata(7,2,3) = 18 
        curvedata(7,2,4) = 19 
        curvedata(7,3,1) = 14 
        curvedata(7,3,2) = 20 
        curvedata(7,3,3) = 22 
        curvedata(7,3,4) = 23 
        curvedata(7,4,1) = 16 
        curvedata(7,4,2) = 24 
        curvedata(7,4,3) = 26 
        curvedata(7,4,4) = 27 

        curvedata(8,1,1) =  7 
        curvedata(8,1,2) = 11 
        curvedata(8,1,3) = 14 
        curvedata(8,1,4) = 15 
        curvedata(8,2,1) = 11 
        curvedata(8,2,2) = 16 
        curvedata(8,2,3) = 18 
        curvedata(8,2,4) = 19 
        curvedata(8,3,1) = 14 
        curvedata(8,3,2) = 20 
        curvedata(8,3,3) = 22 
        curvedata(8,3,4) = 23 
        curvedata(8,4,1) = 16 
        curvedata(8,4,2) = 24 
        curvedata(8,4,3) = 26 
        curvedata(8,4,4) = 27 

        loop for c1 = 2 to 8 
          loop for c2 = 1 to 4 
            c4 = c1 + 1 / 2 + 1 
            c5 = 1 
            loop for c3 = c1 to c4 step -1 
              curvedata(c1,c2,c3) = curvedata(c1,c2,c5) 
              ++c5 
            repeat 
          repeat 
        repeat 
&dA 
&dA &d@   Scale for notesize = 6 
&dA 
        if notesize = 6 
          loop for c1 = 1 to 8 
            loop for c2 = 1 to 4 
              loop for c3 = 1 to 8 
                curvedata(c1,c2,c3) = curvedata(c1,c2,c3) * 3 + 3 / 7 
              repeat 
            repeat 
          repeat 
        end 
&dA 
&dA &d@   Scale for notesize = 21 
&dA 
        if notesize = 21 
          loop for c1 = 1 to 8 
            loop for c2 = 1 to 4 
              loop for c3 = 1 to 8 
                curvedata(c1,c2,c3) = curvedata(c1,c2,c3) * 21 + 7 / 14 
              repeat 
            repeat 
          repeat 
        end 
&dA 
&dA &d@   Scale for notesize = 18        &dA12/18/04&d@ 
&dA 
        if notesize = 18 
          loop for c1 = 1 to 8 
            loop for c2 = 1 to 4 
              loop for c3 = 1 to 8 
                curvedata(c1,c2,c3) = curvedata(c1,c2,c3) * 18 + 7 / 14 
              repeat 
            repeat 
          repeat 
        end 
&dA 
&dA &d@   Scale for notesize = 16        &dA12/31/08&d@ 
&dA 
        if notesize = 16 
          loop for c1 = 1 to 8 
            loop for c2 = 1 to 4 
              loop for c3 = 1 to 8 
                curvedata(c1,c2,c3) = curvedata(c1,c2,c3) * 16 + 7 / 14 
              repeat 
            repeat 
          repeat 
        end 

&dA*   End of Initialization of parameters     
        psfile_header(4) = "" 
        pgroup = "" 
        read_state = 0 
        ficnt = 0 
        finums = 0 
        t3 = 0         /* t3 contains the valid part counter 
        ii = 0         /* ii is the counter in the source 

NEXT_FTEST: 
&dA 
&dA &d@    You are (supposedly) at the top of a MuseData file 
&dA 
&dA &d@    Step 1: Determine (1) Are the first 11 lines in the proper format?  
&dA &d@                      (2) To how many groups does this file belong?  
&dA &d@                      (3) Does this file belong to the target group "Group"?
&dA 
        t1 = 1         /* This is the counter for trecords 
        ++ii 
        if ii > urcnt 
          goto EOS 
        end 
        tget [UR,ii] line 
        line = line // pad(2) 

        if line{1} = "&" 
          t1 = 0 
          loop 
            ++ii 
            if ii > urcnt 
              goto EOS 
            end 
            tget [UR,ii] line 
            line = line // pad(2) 
          repeat while line{1} <> "&" 
          t1 = 1 
          ++ii 
          if ii > urcnt 
            goto EOS 
          end 
          tget [UR,ii] line 
          line = line // pad(2) 
        end 
        if line{1,2} = "//" 
          goto EOS 
        end 
        if line{1} = "/" 
          tmess = 13 
          pute Top record = ~line 
          perform dtalk (tmess) 
        end 
        line = trm(line) 
        if line <> "" 
          if psfile_header(4) = "" 
            line = line // pad(100) 
            line = line{1,100} 
            line = trm(line) 
            psfile_header(4) = "%%Copyright: " // line 
          end 
        end 
        trecords(t1) = line 
&dA 
&dA &d@    Now read records 2 to 11 
&dA 
        loop for t1 = 2 to 11 
          ++ii 
          if ii > urcnt 
            tmess = 13 
            perform dtalk (tmess) 
          end 
          tget [UR,ii] line 
          line = line // pad(2) 
          if line{1} = "/" 
            tmess = 13 
            perform dtalk (tmess) 
          end 
          if t1 = 3 
            if line{1,6} = "TIMEST" 
              line = line // pad(80) 
              line = line{1,80} 
              temp_time_stamp = trm(line) 
            end 
          end 
          if t1 = 5 
            if line{1,3} <> "WK#" 
              pute Record 5 should, but does not, begin with "WK#" 
              pute Record 5 = ~line 
              tmess = 13 
              perform dtalk (tmess) 
            end 
          end 
          if t1 = 11 
            if line{1,18} = "Group memberships:" 
              line = line{19..} 
              line = mrt(line) 
              line = trm(line) 
              line = lcs(line) 
              line = line // " " 
&dA &d@              
&dA &d@       Determine here the number of groups (t5) 
&dA &d@              
              t4 = 1                          /* pointer into "line" 
              t5 = 0                          /* this will be the number of groups
              loop 
                t2 = t4                       /* this serves as just a local pointer
                loop while line{t4} in ['a'..'z'] 
                  ++t4 
                repeat 
                if t4 > t2 
                  ++t5                        /* increment the number of groups
                end 
                ++t4 
              repeat while t4 < len(line) 
              if line con Group 
                pgroup = Group 
                ++t3                          /* increment the valid part counter
              else 
&dA 
&dA &d@        Go wild.  Get all records until you reach 
&dA &d@          "/END" or "/eof", depending on the flag 
&dA 
                read_state = 1 
                loop 
                  ++ii 
                  if ii > urcnt 
                    goto EOS 
                  end 
                  tget [UR,ii] line 
                  line = line // pad(4) 
                  if line{1} = "/" 
                    if eof_flag = 0 
                      if line{1,4} = "/eof" 
                        read_state = 0 
                        goto NEXT_FTEST 
                      end 
                    else 
                      if line{1,4} = "/END" 
                        read_state = 0 
                        goto NEXT_FTEST 
                      end 
                    end 
                  end 
                repeat 
              end 
            else 
              pute Record 11 should, but does not, begin with "Group memberships:"
              pute Record 11 = ~line 
              tmess = 13 
              perform dtalk (tmess) 
            end 
          end 
          trecords(t1) = line 
        repeat 
&dA 
&dA &d@    Your data has passed the first test 
&dA 
&dA &d@    Step 2: Begin build (adding onto) the source table 
&dA 
        loop for t1 = 1 to 4 
          ++ficnt 
          tput [FI,ficnt] ~trecords(t1) 
        repeat 
        fioffs(t3) = ficnt + 1 
        loop for t1 = 5 to 10 
          ++ficnt 
          tput [FI,ficnt] ~trecords(t1) 
        repeat 
        ++ficnt 
        tput [FI,ficnt] Group memberships: ~pgroup 

        read_state = 2
        loop for t4 = 1 to t5 
          ++ii 
          if ii > urcnt 
            goto EOS 
          end 
          tget [UR,ii] line 
          if line con ":" 
            if line{1,mpt-1} = pgroup 
              ++ficnt 
              tput [FI,ficnt] ~line 
              line = line{mpt..}         /* need this because of group name "parts"
              if line con "part" 
                line = line{mpt+5..} 
                part_order(t3) = int(line) 
                if line con "of" 
                  line = line{mpt+3..} 
                  t6 = int(line) 
                  if finums = 0 
                    finums = t6 
                  else 
                    if finums <> t6 
                      tmess = 17 
                      perform dtalk (tmess) 
                    end 
                  end 
                else 
                  tmess = 17 
                  perform dtalk (tmess) 
                end 
                time_stamp_loc = part_order(t3) 
                if temp_time_stamp <> "" 
                  time_stamps(time_stamp_loc) = temp_time_stamp 
                else 
                  time_stamps(time_stamp_loc) = "TIMESTAMP: <none>" 
                end 
              else 
                tmess = 15 
                perform dtalk (tmess) 
              end 
            end 
          else 
            tmess = 15 
            perform dtalk (tmess) 
          end 
        repeat 

        read_state = 3 
        loop 
          ++ii 
          if ii > urcnt 
            goto EOS 
          end 
          tget [UR,ii] line 
          ++ficnt 
          tput [FI,ficnt] ~line 

          if line{1} = "/" 
            if eof_flag = 0 
              if line{1,4} = "/eof" 
                read_state = 0 
                goto NEXT_FTEST 
              end 
            else 
              if line{1,4} = "/END" 
                read_state = 0 
                goto NEXT_FTEST 
              end 
            end 
          end 
        repeat 
EOS: 
        if read_state = 0 
          if t1 <> 1 
&dA 
&dA &d@      This is an error, because you ran out of records 
&dA &d@      while reading the 11 header records of a MuseData file 
&dA 
            putc Last record = ~line 
            tmess = 13 
            perform dtalk (tmess) 
          end 
        end 

        if read_state = 1 
&dA 
&dA &d@      This is an error, because you ran out of records 
&dA &d@      while reading a non-group file 
&dA 
          tmess = 14 
          perform dtalk (tmess) 
        end 

        if read_state = 2 
&dA 
&dA &d@      This is an error, because the group part records 
&dA &d@      doesn't match the group membership set 
&dA 
          tmess = 15 
          perform dtalk (tmess) 
        end 

        if read_state = 3 
&dA 
&dA &d@      This is an error, because you ran out of records 
&dA &d@      before finding a MuseDate module termination record 
&dA 
          tmess = 16 
          perform dtalk (tmess) 
        end 

        fize = ficnt 
        if t3 <> finums 
          tmess = 17 
          perform dtalk (tmess) 
        end 
&dA 
&dA &d@   Set job_type for selective print suggestions 
&dA 
        if "sound^short^parts^score^skore^data^" con pgroup 
          t4 = mpt / 6 + 1 
          job_type = ".tpskd"{t4}    /* &dA03/10/09&d@ Expanding job_type to include
        end                          /*          k = skore (conductor's score)

        if job_type = "p"            /* setting multirest_flag  &dA03/04/06&d@ 
          multirest_flag = 1 
        else 
          multirest_flag = 0 
        end 

        f1 = 1 
        f2 = finums 
        f3 = f1 
        Nparts = finums 
&dA 
&dA &d@   Check for a complete set of tracks 
&dA 
        t3 = 0 
        loop for t1 = f1 to f2 
          if part_order(t1) > t3 
            t3 = part_order(t1) 
          end 
        repeat 
        if t3 <> f2 
          if t3 < f2 
            tmess = 18 
            perform dtalk (tmess) 
          else 
            tmess = 19 
            perform dtalk (tmess)
          end 
        end 
BIG:  
        m_number = 0 
        tuflag = 0 
        loop for t1 = 1 to MAX_STAFF 
          c8flag(t1) = 0 
          transflag(t1) = 0 
        repeat 

        loop for t1 = 1 to MAX_PASS     /* ctrflag(.) is an array as of &dA12/08/07
          ctrflag(t1) = 0 
        repeat 

        loop for t1 = 1 to 4 
          loop for t2 = 1 to MAX_PASS 
            loop for t3 = 1 to BM_SZ    /* New size parameter &dA05/14/03&d@ 
              beampar(t1,t2,t3) = 0 
            repeat 
          repeat 
        repeat 
        outslurs = "00000000"          /* clear all pending slur flags 
        snum = 0 
        esnum = 0 
        loop for t2 = 1 to MAX_PASS 
          tsnum(t2) = 0 
          pre_tsnum(t2) = 0 
        repeat 
        measnum = 0 
        sct = 0                 /* necessary so that ts(.,.) will be completely cleared
        maxsct = 0 
        oldsct = 0 
        supcnt = 0 
        inctype = 0 
        vflag = 1 
        granddist = Granddist * notesize + 5 / 10 
        global_tpflag = 0 
        tpflag = 0 
        textconflag = OFF 
        restplace = 0 
        fix_next_inctype = 0 
        mdirfont = DEFAULT_MDIRFONT 
        dtivfont = DEFAULT_DTIVFONT 
&dA 
&dA &d@       Code added &dA09/22/03&d@ for more complete initialization of variables 
&dA 
        key = 0 
        loop for t1 = 1 to 50 
          claveax(t1) = 0 
          loop for t2 = 1 to 4          /* &dA06/04/08&d@ was 3 
            measax(t2,t1) = claveax(t1) 
          repeat 
        repeat 

        restoff = 0 
        text_flag = 0 
        text_loc = vpar(101) 
        art_flag = 0 
        single_line = 0 
        stem_change_flag = 0 
        dot_difference_flag = 0 
        irest_flag = 0 
        mreport_flag = 0 
        key_reprint_flag = 0 
        mixed_note_head_flag = 0 
        suppress_key     = 0 
        min_space = hpar(29) * Min_space / 100 
        slur_adjust = 0 
        in_line_edslur = 0 
        large_clef_flag = 0 
        rest_collapse = TRUE 

*********** Transfer file to Data Table ***********
 
        t3 = 0 
        loop for t1 = 1 to finums 
          if part_order(t1) = f3 
            t3 = t1 
            t1 = finums 
          end 
        repeat 
        if t3 = 0 
          if (Debugg & 0x01) > 0 
            pute Unable to locate part ~f3  in the data set 
          end 
          tmess = 11 
          perform dtalk (tmess) 
        end 

        kk = fioffs(t3)      

&dK &d@       putc 
&dK &d@       putc &dEListing for part ~t3  
&dK &d@       putc 
&dK 
&dK &d@       t2 = 0 
&dK &d@       loop for t1 = kk to 1000000 
&dK &d@         tget [FI,t1] line 
&dK &d@         putc .w6 ~t1   ~line 
&dK &d@         ++t2 
&dK &d@         if t2 = 20 
&dK &d@           t1 = 1000000 
&dK &d@         end 
&dK &d@         if line{1} = "/" 
&dK &d@           getc 
&dK &d@           if eof_flag = 0 
&dK &d@             if line{1,4} = "/eof" 
&dK &d@               goto STTT 
&dK &d@             end 
&dK &d@           else 
&dK &d@             if line{1,4} = "/END" 
&dK &d@               goto STTT 
&dK &d@             end 
&dK &d@           end 
&dK &d@         end 
&dK &d@       repeat 
&dKS&d@TTT: 
&dK &d@       getc 
&dK &d@       ++f3 
&dK &d@       if f3 > f2 
&dK &d@         stop 
&dK &d@       end 
&dK &d@       goto BIG 
                 
&dA 
&dA &d@   Put in first "relevant" six lines; then skip two lines 
&dA 
        loop for t1 = 1 to 6 
          tget [FI,kk] line 
          ++kk 
          tput [X,t1] ~line 
        repeat 
        kk += 2                               /* Skip group membership information

        loop 
          tget [FI,kk] line 
          ++kk 
          line = line // pad(6) 
          loop while line{1} = "&"            /* skipping comments bracketed by & records
            loop 
              tget [FI,kk] line 
              ++kk 
              line = line // pad(1) 
            repeat while line{1} <> "&" 
            tget [FI,kk] line 
            ++kk 
            line = line // pad(4) 
          repeat 
          if "Std" not_con line{1}          /* skipping Sound records, deleted records, and tags
            if line{1} = "a"                /* continuation records 
              if len(line) > 15 
                temp = line{16..} 
                tget [X,t1] line 
                line = line // temp 
                tput [X,t1] ~line 
              end 
            else 
              if line{1,2} = "Px" or line{1,2} = "Pv" 
                if line{3,3} con "m" 
                  mreport_flag = 1 
                end 
              else 
                ++t1 
                tput [X,t1] ~line 
              end 
            end 
          end 
          if line{1} = "/" 
            line = line // pad(5) 
            if line{1,5} = "/FINE" 
              loop 
                tget [FI,kk] line 
                ++kk 
                line = line // pad(4) 
              repeat while line{1,4} <> "/END" and kk <= fize 
            end 
            if line{1,4} = "/END" 
              goto LOADED 
            end 
            tmess = 20 
            perform dtalk (tmess) 
          end 
        repeat while kk <= fize 
        tmess = 21 
        perform dtalk (tmess) 

&dAÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dA³           Start Processing Data               ³&d@ 
&dAÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

LOADED:

        barnum2 = 1 
        ttext = "" 
        firstoff = 0 
        sigflag = 0 
        key = 0 
        loop for t1 = 1 to 50 
          claveax(t1) = 0 
        repeat 
        repeater_flag = 0 

        nstaves = 1 
* 
        tget [X,1] line 
        line = trm(line) // " " 
        if line con "MV#:" 
          temp = trm(line{mpt+4..}) 
          line = line{1,mpt-1} 
        end 
        if line con "WK#:" 
          line = trm(line{mpt+4..}) 
        end 
        tget [X,3] wname 
        tget [X,4] mname 
        tget [X,5] partname 

        if (Debugg & 0x06) > 0 
          pute Work #: ~line     .t30 Work name: ~wname 
          pute Movement: ~temp   .t30 Movement name: ~mname 
          pute Part name: ~partname 
        end 
 
        tget [X,6] out 
        out = trm(out) 
        t5 = 0 
        loop for t1 = 1 to len(out) 
          if "SATB" con out{t1} 
            t5 = text_loc                      /* New &dA01/30/05&d@ 
            text_flag = 1                      /* New &dA01/30/05&d@ 
          end 
        repeat 

        scnt = 7 
        p = 0 

        tput [Y,1] ~t5 
        tput [Y,2] J D 4 500 -120 1 6913 0 0 
        tput [Y,3] W 0 0 44 ~mname 
        outpnt = 3 

&dA                                                                              
&dA 
&dA &d@   Special case code added &dA01/06/04&d@.  Look for print suggestion tags 
&dA &d@   placed at the beginning of the file.  This &dEmust&d@ be done here for 
&dA &d@   the case of tag Y U 1.  The others follow along, but are not critical.  
&dA 
&dA &d@   Please note: &dEThis is &dANOT&dE the top of the stage2 data processing loop.&d@  
&dA 
        aa10 = scnt 
PRA: 
        tget [X,aa10] line 
        ++aa10 
        line = line // pad(80) 
        if line{1} = "P" 
          if line{2} = " " 
            sub = 2 
            goto MORE_SUGG_A 
          end 
          if line con " " 
            aa4 = sub 
            temp4 = line{2..sub} 
&dA 
&dA &d@      This notesize filter removes all P suggestions 
&dA &d@        that do not meet notesize restrictions 
&dA 
            loop for t1 = 1 to len(temp4) 
              if temp4{t1} = "#" 
                if temp4{t1,2} = "#<" 
                  a1 = int(temp4{t1+2..})      /* sets sub 
                  if notesize >= a1 
                    goto PRA                  /* This suggestion does not apply
                  end 
                  t1 = sub - 1                /* prepare t1 for next code 
                else 
                  if temp4{t1,2} = "#>" 
                    a1 = int(temp4{t1+2..})   /* sets sub 
                    if notesize <= a1 
                      goto PRA                /* This suggestion does not apply
                    end 
                    t1 = sub - 1              /* prepare t1 for next code 
                  else 
                    a1 = int(temp4{t1+1..})   /* sets sub 
                    if notesize <> a1 
                      goto PRA                /* This suggestion does not apply
                    end 
                    t1 = sub - 1              /* prepare t1 for next code 
                  end 
                end 
              end 
            repeat 

            if temp4 con job_type 
              sub = aa4 
              goto MORE_SUGG_A 
            end 
            if temp4 con "a" 
              sub = aa4 
              goto MORE_SUGG_A 
            end 
          end 
          goto PRA 

MORE_SUGG_A: 
          if line{sub..} con "C" 
            ++sub 
            rc = int(line{sub..})          /* column number 
            if line{sub} = ":" 
              ++sub                        /* skip ":" 
              g = sub 
            else 
              temp5 = "" 
              loop while line{sub} <> ":" and sub < len(line) 
                temp5 = temp5 // line{sub} 
                ++sub 
              repeat 
              if line{sub} <> ":" 
                if (Debugg & 0x01) > 0 
                  pute Incomplete print suggestion 
                  pute line = ~line 
                end 
                tmess = 11 
                perform dtalk (tmess) 
              end 
              ++sub                        /* skip ":" 
              g = sub 
              temp5 = temp5 // " " 
&dA 
&dA &d@      This notesize filter removes all P suggestions 
&dA &d@        that do not meet notesize restrictions 
&dA 
              loop for t1 = 1 to len(temp5) 
                if temp5{t1} = "#" 
                  if temp5{t1,2} = "#<" 
                    a1 = int(temp5{t1+2..})     /* sets sub 
                    if notesize >= a1 
                      loop while line{g} <> " " and g < len(line) 
                        ++g 
                      repeat 
                      sub = g                   /* skipping this suggestion 
                      goto MORE_SUGG_A 
                    end 
                    t1 = sub - 1                /* prepare t1 for next code 
                  else 
                    if temp5{t1,2} = "#>" 
                      a1 = int(temp5{t1+2..})   /* sets sub 
                      if notesize <= a1 
                        loop while line{g} <> " " and g < len(line) 
                          ++g 
                        repeat 
                        sub = g                 /* skipping this suggestion 
                        goto MORE_SUGG_A 
                      end 
                      t1 = sub - 1              /* prepare t1 for next code 
                    else 
                      a1 = int(temp5{t1+1..})   /* sets sub 
                      if notesize <> a1 
                        loop while line{g} <> " " and g < len(line) 
                          ++g 
                        repeat 
                        sub = g                 /* skipping this suggestion 
                        goto MORE_SUGG_A 
                      end 
                      t1 = sub - 1              /* prepare t1 for next code 
                    end 
                  end 
                end 
              repeat 

              if temp5 con job_type or temp5 con "a" 
              else 
                loop while line{g} <> " " and g < len(line) 
                  ++g 
                repeat 
                sub = g 
                goto MORE_SUGG_A 
              end 
            end 
&dA 
&dA &d@       Column 0: general suggestions                               
&dA 
            if rc = 0                    /* general suggestion 
              temp = "" 
              loop for a2 = g to len(line) 
                temp = temp // line{g} 
                ++g 
              repeat while line{g} <> " " 
              temp = temp // " " 
              if temp con "y" 
                a2 = mpt + 1 
                if temp{a2} in ['0'..'9'] 
                  aa3 = int(temp{a2..}) 
                  ++outpnt 
                  tput [Y,outpnt] Y U ~aa3 
                end 
              end 
            else 
              loop for a2 = g to len(line) 
                ++g 
              repeat while line{g} <> " " 
            end 
            sub = g 
            goto MORE_SUGG_A 
          end 
          goto PRA 
        end 
        if line{1} = "$" 
          goto PRA 
        end 
&dA 
&dA &d@   End of special case code &dA01/06/04&d@ 
&dA &d@   
&dA                                                             

&dA 
&dA &d@   Set movement word (if present) 
&dA 
        out = mname
        partname = trm(partname) 
&dA 
&dA &d@    New code to implement // feature in partnames &dA12/21/05&d@ 
&dA 
        if partname con "//" 
          temp3 = partname{mpt+2..} 
          partname = partname{1,mpt-1} // pad(17) 
          partname = partname // temp3 
        end 

        if partname <> "" 
          out = out // ":  " // partname 
        end 
        if out <> "" 
          oby = 0 - vpar(33) - notesize 
          obx = p + hpar(39) + hpar(5) 
          ++outpnt 
          tput [Y,outpnt] J D 1 ~obx  ~oby  1 6913 0 0 
          spn = 6913 
          ++outpnt 
          tput [Y,outpnt] W 0 -~vpar(8)  44 ~out 
        end 
        mrest = 0 
        wrest = 0 
        @n = 0 
        old@n = 0 
        xmindist = hpar(4) * cfactor                 /* New &dA12/16/03&d@ 
        mindist  = xmindist / 100                    /* New &dA12/16/03&d@ 
        minshort = Minshort 
        goto PR 

&dA                                                                       
&dA &d@                                                                     &dA 
&dA &d@                 &dAÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@                   &dA 
&dA &d@                 &dA³    Process the data file      ³&d@                   &dA 
&dA &d@                 &dAÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@                   &dA 
&dA &d@                                                                     &dA 
&dA                                                                       

PR: 
        tget [X,scnt] line 
        ++scnt 
        line = line // pad(80) 
        if line{1} = "@" 
          goto PR 
        end 
        rc = int(line{6,3})          /* possible duration 
        g = int(line{9,4})           /* possible measure number 
        if line{1} = "$" 
          if mrest > 0               /* this code &dAadded 1-27-93&d@ 
            perform setmrest (mrest, wrest) 
            mrest = 0 
          end 
          perform process_section (f4) 
          goto PR 
        end 

#if NO_EDIT 
        if " ABCDEFGgcri" con line{1} 
          if line{32..43} con "&" 
            temp = line{44..} 
            line = line{1..sub-1} // pad(43) 
            line = line // temp 
          end 
        end 
#endif 

&dA                                                                  
&dA  
&dA  &d@    MAIN CODE FOR PRINT SUGGESTIONS  (ends around line 4800) 
&dA  &d@  =================================== 
&dA  

        if line{1} = "P" 
&dA 
&dA &d@   Re-coding this section &dA12/16/03&d@ to add notesize select feature 
&dA &d@     and to fix the problem of consecutive suggestion records 
&dA &d@ 
          sugg_flg = 0                               /* &dA05/02/03&d@ 
          sugg_flg2 = 0                              /* &dA05/02/03&d@ 

          a1 = 1 
          loop while a1 < 10 
            ++a1 
            tget [X,scnt-a1] temp3 
          repeat while temp3{1} = "P" 

                                     /* This code added &dA02/23/97&d@ 
          if line{2} = " " 
            sub = 2 
            goto MORE_SUGG 
          end 
          if line con " " 
            aa4 = sub 
            temp4 = line{2..sub} 
&dA 
&dA &d@      This notesize filter removes all P suggestions 
&dA &d@        that do not meet notesize restrictions 
&dA 
            loop for t1 = 1 to len(temp4) 
              if temp4{t1} = "#" 
                if temp4{t1,2} = "#<" 
                  a1 = int(temp4{t1+2..})     /* sets sub 
                  if notesize >= a1 
                    goto PR                   /* This suggestion does not apply
                  end 
                  t1 = sub - 1                /* prepare t1 for next code 
                else 
                  if temp4{t1,2} = "#>" 
                    a1 = int(temp4{t1+2..})   /* sets sub 
                    if notesize <= a1 
                      goto PR                 /* This suggestion does not apply
                    end 
                    t1 = sub - 1              /* prepare t1 for next code 
                  else 
                    a1 = int(temp4{t1+1..})   /* sets sub 
                    if notesize <> a1 
                      goto PR                 /* This suggestion does not apply
                    end 
                    t1 = sub - 1              /* prepare t1 for next code 
                  end 
                end 
              end 
            repeat 

            if temp4 con job_type 
              sub = aa4 
              goto MORE_SUGG 
            end 
            if temp4 con "a" 
              sub = aa4 
              goto MORE_SUGG 
            end 
          end 
          goto PR                    /* end of &dA02/23/97&d@ addition 
&dA    


MORE_SUGG: 
          if line{sub..} con "C" 
            ++sub
            rc = int(line{sub..})        /* column number 
&dA 
&dA &d@     Code added &dA11/04/03&d@ to allow for job-specific print suggestions to 
&dA &d@     be specified by column number.  
&dA 
            if line{sub} = ":" 
              ++sub                        /* skip ":" 
              g = sub 
            else 
              temp5 = "" 
              g = sub 
              loop while line{sub} <> ":" and sub < len(line) and sub < g + 20
                temp5 = temp5 // line{sub} 
                ++sub 
              repeat 
              if line{sub} <> ":" 
                if (Debugg & 0x01) > 0 
                  pute Incomplete print suggestion.  This fault should be fixed.
                  pute index = ~(scnt+5)   line = ~line 
                end 
                tmess = 11 
                perform dtalk (tmess) 
              end 
              ++sub                        /* skip ":" 
              g = sub 
&dA 
&dA &d@   Re-coding this section &dA12/16/03&d@ to add notesize select feature 
&dA &d@ 
              temp5 = temp5 // " " 
&dA 
&dA &d@      This notesize filter removes all P suggestions 
&dA &d@        that do not meet notesize restrictions 
&dA 
              loop for t1 = 1 to len(temp5) 
                if temp5{t1} = "#" 
                  if temp5{t1,2} = "#<" 
                    a1 = int(temp5{t1+2..})     /* sets sub 
                    if notesize >= a1 
                      loop while line{g} <> " " and g < len(line) 
                        ++g 
                      repeat 
                      sub = g                   /* skipping this suggestion 
                      goto MORE_SUGG 
                    end 
                    t1 = sub - 1                /* prepare t1 for next code 
                  else 
                    if temp5{t1,2} = "#>" 
                      a1 = int(temp5{t1+2..})   /* sets sub 
                      if notesize <= a1 
                        loop while line{g} <> " " and g < len(line) 
                          ++g 
                        repeat 
                        sub = g                 /* skipping this suggestion 
                        goto MORE_SUGG 
                      end 
                      t1 = sub - 1              /* prepare t1 for next code 
                    else 
                      a1 = int(temp5{t1+1..})   /* sets sub 
                      if notesize <> a1 
                        loop while line{g} <> " " and g < len(line) 
                          ++g 
                        repeat 
                        sub = g                 /* skipping this suggestion 
                        goto MORE_SUGG 
                      end 
                      t1 = sub - 1              /* prepare t1 for next code 
                    end 
                  end 
                end 
              repeat 

              if temp5 con job_type or temp5 con "a" 
              else 
                loop while line{g} <> " " and g < len(line) 
                  ++g 
                repeat 
                sub = g 
                goto MORE_SUGG 
              end 
            end 

&dA 
&dA &d@       Column 0: general suggestions                               
&dA 
            if rc = 0                    /* general suggestion 
PQST: 
              if "acdFfghjkmnpqrstvxyz" con line{g} 
                goto PSUG(mpt) 

PSUG(1):                                               /* line{g} = "a"  (New &dA05/26/05&d@)
                art_flag = int(line{g+1..}) 
                g = sub 
                goto PQST 
PSUG(2):                                               /* line{g} = "c"  (New &dA05/12/04&d@)
                restoff = int(line{g+1..}) 
                g = sub 
                if restoff <> 0 
                  restoff = 1 
                end 
                goto PQST 
PSUG(3):                                               /* line{g} = "d"  (Modified &dA01/06/06&d@)
                aa6 = int(line{g+1..}) 
                tword_height = aa6 
                vpar(40) = vpar(2) * aa6 / 2            /* New &dA01/06/06&d@ 
                g = sub 
                goto PQST 
PSUG(4):                                               /* line{g} = "F" 
                dtivfont = int(line{g+1..}) 
                g = sub 
                goto PQST 
PSUG(5):                                               /* line{g} = "f" 
                mdirfont = int(line{g+1..}) 
                g = sub 
                goto PQST 
PSUG(6):                                               /* line{g} = "g"  (New &dA05/01/08&d@)
                slur_adjust = int(line{g+1..}) 
                g = sub 
                goto PQST 
PSUG(7):                                               /* line{g} = "h"  (New &dA11/19/07&d@)
                aa6 = int(line{g+1..}) 
                min_space = hpar(29) * aa6 / 100 
                g = sub 
                goto PQST 
PSUG(8):                                               /* line{g} = "j"  (New &dA12/20/05&d@)
                stem_change_flag = int(line{g+1..}) 
                g = sub 
                goto PQST 
PSUG(9):                                               /* line{g} = "k"  (New &dA12/24/05&d@)
                aa6 = int(line{g+1..}) 
                dot_difference_flag   = aa6 & 0x01 
                key_reprint_flag      = aa6 & 0x02      /* added &dA11/26/06&d@ 
                mixed_note_head_flag  = aa6 & 0x04      /* added &dA11/26/06&d@ 
                suppress_key          = aa6 & 0x08      /* added &dA11/02/07&d@ 
                in_line_edslur        = aa6 & 0x10      /* added &dA01/12/09&d@ 
                large_clef_flag       = aa6 & 0x20      /* added &dA02/02/09&d@ 
                g = sub 
                goto PQST 
PSUG(10):                                              /* line{g} = "m"  (New &dA03/04/06&d@)
                aa6 = int(line{g+1..}) 
                if aa6 = 1 
                  multirest_flag = 1 
                else 
                  multirest_flag = 0 
                end 
                g = sub 
                goto PQST 
PSUG(11):                                              /* line{g} = "n" 
                m_number = int(line{g+1..}) 
                g = sub 
                goto PQST 
PSUG(12):                                              /* line{g} = "p" 
                xmindist = int(line{g+1..}) * hpar(4) * cfactor / 100      /* New &dA12/16/03
                mindist  = xmindist / 100                                  /* New &dA12/16/03
                g = sub 
                perform newnsp 
                goto PQST 
PSUG(13):                                              /* line{g} = "q" 
                minshort = int(line{g+1..}) 
                g = sub 
                perform newnsp 
                goto PQST 
PSUG(14):                                              /* line{g} = "r" (New treatment &dA03/15/09&d@)
                aa6 = int(line{g+1..}) 
                restplace = aa6 & 0x01 
                irest_flag = (aa6 & 0x02) >> 1 
                rest_collapse = (aa6 & 0x04) >> 2       /* New &dA03/15/09&d@: 0 = TRUE; 1 = FALSE
                g = sub 
                goto PQST 
PSUG(15):                                              /* line{g} = "s" 
                granddist = int(line{g+1..}) 
                g = sub 
                granddist = granddist * vpar(2) + 5 / 10 
                goto PQST 
PSUG(16):                                              /* line{g} = "t" 
                global_tpflag = int(line{g+1..}) 
                g = sub 
                if global_tpflag > 4 
                  global_tpflag = 4 
                end 
                if global_tpflag < 0 
                  global_tpflag = 0 
                end 
                tpflag = global_tpflag 
                goto PQST 
&dA 
&dA &d@     This option added &dA01/30/05
&dA 
PSUG(17):                                            /* line{g} = "v" 
                aa6 = int(line{g+1..}) 
                g = sub 
                text_loc = aa6 * notesize / 20 
                tget [Y,1] temp4 
                aa6 = int(temp4) 
                temp4 = temp4 // "  " 
                temp4 = temp4{sub..} 
                temp4 = mrt(temp4) 
                tput [Y,1] ~text_loc  ~temp4 
                goto PQST 
&dA 
&dA &d@     This option added &dA01/03/04&d@; modified &dA01/06/04&d@ 
&dA 
PSUG(18):                                            /* line{g} = "x" 
                aa6 = int(line{g+1..}) 
                if (Defeat_flag & 0x01) = 0 
                  if aa6 = 1 and mrest > 0 
                    perform setmrest (mrest, wrest) 
                    mrest = 0 
                  end 
                  wrest = aa6 
                  if wrest <> 1 
                    wrest = 0 
                  end 
                end 
                g = sub 
                goto PQST 
&dA   

&dA 
&dA &d@     These options added &dA01/06/04&d@ 
&dA 
PSUG(19):                                            /* line{g} = "y" 
                aa6 = int(line{g+1..}) 
                if (Defeat_flag & 0x02) = 0 
                  ++outpnt 
                  tput [Y,outpnt] Y U ~aa6 
                end 
                g = sub 
                goto PQST 
PSUG(20):                                              /* line{g} = "z" 
                aa6 = int(line{g+1..}) 
                ++outpnt 
                if aa6 = 0 
                  tput [Y,outpnt] Y P 0 
                  g = sub 
                else 
                  g = sub 
                  temp = "" 
                  loop while line{g} <> " " and g < 80 
                    temp = temp // line{g} 
                    ++g 
                  repeat 
                  tput [Y,outpnt] Y P ~aa6  ~temp 
                end 
                goto PQST 
&dA   
              end 
              sub = g 
              goto MORE_SUGG 
            end 
&dA 
&dA &d@     Deal with record that contains: notes, grace notes, cue notes, rests, figures
&dA 
            if " ABCDEFGgcrif" con temp3{1}    /* &dA04/24/03&d@ allowing print sugg for chords
              aa3 = mpt 
&dA 
&dA &d@       Column 1: The Object itself.  NOTES, GRACE NOTES, CUE NOTES, RESTS, FIGURES
&dA 
              if rc = 1 
                if "spxXyY" con line{g}        /* "X" added &dA05/02/03&d@   "s" added &dA02/19/06
                  ++@n 
                  tcode(@n) = zpd(4) 
                  tcode(@n){1} = chr(1) 
                  tv1(@n) = P_SUGGESTION 
                  tv2(@n) = 0x0300 
                end 
ABCL: 
                if line{g} = "p" 
                  t1 = int(line{g+1..}) 
                  g = sub 
                  if t1 < 0 
                    t1 = 0 
                  end 
                  if t1 > 7 
                    t1 = 7 
                  end 
                  if t1 > 0 
                    t1 = t1 << 1 + 1 
                  end 
                  tcode(@n){1} = chr(t1) 
                  goto ABCL 
                end 
&dA 
&dA &d@        This code added &dA02/19/06&d@ to implement different shapes of note heads
&dA 
                if line{g} = "s" 
                  t1 = int(line{g+1..}) 
                  g = sub 
                  if t1 < 0 
                    t1 = 0 
                  end 
                  if t1 > 15 
                    t1 = 15 
                  end 
                  t1 <<= 4                          /* use upper part of first byte
                  aa3 = ors(tcode(@n){1}) 
                  aa3 |= t1                         /* add to what is already there
                  aa3 |= 0x01                       /* turn on "active" bit 
                  tcode(@n){1} = chr(aa3) 
                  goto ABCL 
                end 
&dA 
&dA       &d@  End of &dA02/19/06&d@ addition 

                if "xXyY" con line{g}                          /* &dA05/02/03&d@ code revised
                  aa3 = mpt 
                  if line{g+1} = "+" 
                    ++g 
                  end 
                  a2 = int(line{g+1..}) 
                  g = sub 
                  a2 += 128 
                  if a2 <= 0 
                    a2 = 1 
                  end 
                  if a2 > 255 
                    a2 = 255 
                  end 
                  aa4 = ors(tcode(@n){2})                      /* &dA05/02/03&d@ code revised
                  if aa3 < 3 
                    tcode(@n){3} = chr(a2) 
                    if aa3 = 1 
                      aa4 |= 0x01                              /* set position as "relative"
                    else 
                      aa4 |= 0x03                              /* set position as "absolute"
                    end 
                  else 
                    tcode(@n){4} = chr(a2) 
                    if aa3 = 3 
                      aa4 |= 0x01                              /* set position as "relative"
                    else 
                      aa4 |= 0x05                              /* set position as "absolute"
                    end 
                  end 
                  tcode(@n){2} = chr(aa4) 
                  goto ABCL 
                end 
                sub = g 
                goto MORE_SUGG 
              end 
&dA 
&dA &d@       Columns 18 and 19: dots and accidentals on NOTES, GRACE NOTES, CUE NOTES, and RESTS
&dA 
              if (rc = 18 or rc = 19) and aa3 < 12              /* &dA05/02/03&d@ 
                t1 = rc                         /* 18 = dots, 19 = accs 
                if "xXyY" con line{g} 
                  aa3 = mpt 
                  ++@n 
                  tcode(@n) = zpd(4) 
                  tv1(@n) = P_SUGGESTION 
                  tv2(@n) = 0x0200 + t1              /* t1 is index into position string
NXYP2: 
                  if line{g+1} = "+" 
                    ++g 
                  end 
                  a2 = int(line{g+1..}) 
                  g = sub 
                  a2 += 128 
                  if a2 <= 0 
                    a2 = 1 
                  end 
                  if a2 > 255 
                    a2 = 255 
                  end 
                  aa4 = ors(tcode(@n){2}) 
                  if aa3 < 3 
                    tcode(@n){3} = chr(a2) 
                    if aa3 = 1 
                      aa4 |= 0x01                              /* set position as "relative"
                    else 
                      aa4 |= 0x03                              /* set position as "absolute"
                    end 
                  else 
                    tcode(@n){4} = chr(a2) 
                    if aa3 = 3 
                      aa4 |= 0x01                              /* set position as "relative"
                    else 
                      aa4 |= 0x05                              /* set position as "absolute"
                    end 
                  end 
                  tcode(@n){2} = chr(aa4) 
                  if "xXyY" con line{g} 
                    aa3 = mpt 
                    goto NXYP2 
                  end 
                end 
                sub = g 
                goto MORE_SUGG 
              end 
&dA 
&dA &d@       Columns 26 to 30: beams 
&dA &d@                         
              if (rc = 26 or rc = 27) and aa3 < 11 
                if "baAc" con line{g}                  /* "c" option added &dA01/01/08
                  repeater_flag = mpt - 1 
                  if rc = 27 and repeater_flag > 0 
                    repeater_flag += 4 
                  end 
                  sub = g 
                  goto MORE_SUGG 
                end 

                if rc = 26                             /* New code &dA05/14/03&d@ 
                  t1 = 28                              /* 28 = beam stem length code
                  if line{g} = "y" 
                    ++@n 
                    tcode(@n) = zpd(4) 
                    tv1(@n) = P_SUGGESTION 
                    tv2(@n) = 0x0200 + t1              /* t1 is index into position string

                    ++g 
                    sub = g 
                    if line{sub} = "+" 
                      ++sub 
                    end 
                    a2 = int(line{sub..}) 
                    g = sub 
                    a2 += 128 
                    if a2 < 1 
                      a2 = 1 
                    end 
                    if a2 > 255 
                      a2 = 255 
                    end 
                    tcode(@n){2} = chr(a2) 
                  end 
                end 

                sub = g 
                goto MORE_SUGG 
              end 
&dA 
&dA &d@       Columns 32 to 43: ties, articulations, ornaments, dynamics, 
&dA &d@                           fermatas, technical suggestions (fingerings, etc.)
&dA 
              if rc >= 32 and rc <= 43 and aa3 < 12             /* &dA04/24/03&d@ 11 changed to 12
&dA 
&dA &d@       Slur suggestions.  Additions and modifications to code on &dA05/06/03&d@ 
&dA 
                if "([{z" con temp3{rc}                        /* start slur 1,2,3,4
                  aa5 = mpt 
                  if "ou" con line{g}    /* this is a forced slur suggestion
                    t1 = aa5 - 1 << 1 - 1 + mpt 
                    ++@n 
                    tv1(@n) = P_SUGGESTION 
                    tv2(@n) = t1 
                    sub = g 
                    goto MORE_SUGG 
                  end 
                  t1 = aa5 + 19           /* 20, 21, 22, 23 
&dA 
&dA &d@    New code &dA04/26/05&d@ for print suggestion suppressing the printing of a slur
&dA 
                  if line{g} = "*" 
                    ++@n 
                    tcode(@n) = ch4(-1)                /* 0xffffffff = suppress slur
                    tv1(@n) = P_SUGGESTION 
                    tv2(@n) = 0x0200 + t1              /* t1 is index into position string
                    sub = g 
                    goto MORE_SUGG 
                  end 
&dA         
                  if "xyXY" con line{g} 
                    aa3 = mpt 
                    ++@n 
                    tcode(@n) = zpd(4) 
                    tv1(@n) = P_SUGGESTION 
                    tv2(@n) = 0x0200 + t1              /* t1 is index into position string
NXYH: 
                    ++g 
                    sub = g 
                    if line{sub} = "+" 
                      ++sub 
                    end 
                    a2 = int(line{sub..}) 
                    g = sub 
                    a2 += 128 
                    if a2 < 1 
                      a2 = 1 
                    end 
                    if a2 > 255 
                      a2 = 255 
                    end 
                    tcode(@n){aa3} = chr(a2) 

                    if "xyXY" con line{g} 
                      aa3 = mpt 
                      goto NXYH 
                    end 
                  end 
                  sub = g 
                  goto MORE_SUGG 
                end 
&dA 
&dA &d@       More slur suggestions 
&dA 
                if ")]}x" con temp3{rc}                        /* end slur 1,2,3,4
                  t1 = mpt + 23          /* 24, 25, 26, 27 
                  if "xyh" con line{g} 
                    aa3 = mpt 
                    ++@n 
                    tcode(@n) = zpd(4) 
                    tv1(@n) = P_SUGGESTION 
                    tv2(@n) = 0x0200 + t1              /* t1 is index into position string
NXYH2: 
                    ++g 
                    sub = g 
                    if line{sub} = "+" 
                      ++sub 
                    end 
                    a2 = int(line{sub..}) 
                    g = sub 
                    a2 += 128 
                    if a2 < 1 
                      a2 = 1 
                    end 
                    if a2 > 255 
                      a2 = 255 
                    end 
                    tcode(@n){aa3} = chr(a2) 

                    if "xyh" con line{g} 
                      aa3 = mpt 
                      goto NXYH2 
                    end 
                  end 
                  sub = g 
                  goto MORE_SUGG 
                end 
&dA 
&dA &d@       End of &dA05/06/03&d@ Addition 
&dA 
                if temp3{rc} = "-" 
                  if "ou" con line{g}    /* this is a specified tie 
                    ++@n 
                    tv1(@n) = P_SUGGESTION 
                    tv2(@n) = mpt + 7 
                  end 
                end 
                if "_.=i>VArt~wMkTJKvnoQ012345mpfZRFE-" con temp3{rc}  /* Back ties added &dA04/22/08
                  t1 = mpt - 1 << 1 + 1 
                  t1 = int("01010102030303040404040404040404060607080809090909091414141414151617"{t1,2})
&dA 
&dA &d@   Explanation: We need to have a code which indicates the type of element to which
&dA &d@                the suggestions is applied.  So for, we have the following codes:
&dA 
&dA &d@                1 = legato, staccato, or legato-staccate &dEarticulation&d@ 
&dA &d@                2 = spiccato &dEarticulation&d@ 
&dA &d@                3 = horizontal, vertical, or inverted vertical &dEaccent&d@ 
&dA &d@                4 = turn, trill, wavy line, shake, mordant, or delayed turn &dEornament
&dA &d@                                               tremulo added &dA01/07/06&d@ 
&dA &d@                                               back ties added &dA04/22/08&d@ 
&dA &d@                5 = (same thing, I think) 
&dA &d@                6 = up bow, or down bow &dEbowing&d@ 
&dA &d@                7 = &dEharmonic&d@ 
&dA &d@                8 = open string, or thumb position 
&dA &d@             9-13 = &dEfingering&d@ (five suggestions possible) 
&dA &d@               14 = &dEdynamics&d@ 
&dA &d@               15 = upright &dEfermata&d@ 
&dA &d@               16 = inverted &dEfermata&d@ 
&dA &d@               17 = &dEtie&d@ 
&dA &d@               18 = &dEdots&d@ 
&dA &d@               19 = &dEaccidentals&d@ 
&dA &d@           (20-23 = start slur) 
&dA &d@           (24-27 = stop slur) 
&dA 
                  if t1 = 4                            /* ornament 
                    if sugg_flg2 < 2 
                      ++sugg_flg2 
                      t1 = sugg_flg2 + 3 
                    end 
                  end 
                  if t1 = 9                            /* fingering 
                    if rc > 32 and temp3{rc-1} = ":" 
                      t1 = 1000                        /* t1 = 1000 means "do nothing"
                    else 
                      if sugg_flg < 5 
                        ++sugg_flg 
                        t1 = sugg_flg + 8 
                      end 
                    end 
                  end 
                  if line{g} = "L" and t1 <> 17        /* &dA05/02/03&d@ "L" applies only to ties
                    t1 = 1000 
                  end 

                  if t1 < 1000 and "xXyYabL" con line{g}  /* modifications to code &dA05/02/03
                    aa3 = mpt 
                    ++@n 
                    tcode(@n) = zpd(4) 
                    tv1(@n) = P_SUGGESTION 
                    tv2(@n) = 0x0200 + t1              /* t1 is index into position string
NXYP: 
                    if aa3 < 5 
                      ++g 
                      sub = g 
                      if line{sub} = "+" 
                        ++sub 
                      end 
                      a2 = int(line{sub..}) 
                      g = sub 
                      a2 += 128 
                      if a2 < 1 
                        a2 = 1 
                      end 
                      if a2 > 255 
                        a2 = 255 
                      end 
                      aa4 = ors(tcode(@n){2}) 
                      if aa3 < 3 
                        tcode(@n){3} = chr(a2) 
                        if aa3 = 1 
                          aa4 |= 0x01                          /* set position as "relative"
                        else 
                          aa4 |= 0x03                          /* set position as "absolute"
                        end 
                      else 
                        tcode(@n){4} = chr(a2) 
                        if aa3 = 3 
                          aa4 |= 0x01                          /* set position as "relative"
                        else 
                          aa4 |= 0x05                          /* set position as "absolute"
                        end 
                      end 
                      tcode(@n){2} = chr(aa4) 
                      if t1 <> 17 
                        a2 = ors(tcode(@n){1}) | 0x01          /* added &dA11/10/07&d@   Major oversight, check results
                        tcode(@n){1} = chr(a2) 
                      end 
                    end 

                    if aa3 = 5 or aa3 = 6 
                      aa4 = aa3 - 5 * 4 + 3           /* 5 -> 3,  6 -> 7 
                      a2 = ors(tcode(@n){1}) | aa4 
                      tcode(@n){1} = chr(a2) 
                      ++g 
                    end 

                    if aa3 = 7                          /* &dA05/02/03&d@ "L" changes length of tie
                      ++g 
                      sub = g 
                      if line{sub} = "+" 
                        ++sub 
                      end 
                      a2 = int(line{sub..}) 
                      g = sub 
                      a2 += 128 
                      if a2 < 1 
                        a2 = 1 
                      end 
                      if a2 > 255 
                        a2 = 255 
                      end 
                      tcode(@n){1} = chr(a2) 
                    end 

                    if "xXyYabL" con line{g} 
                      aa3 = mpt 
                      if aa3 < 7 or t1 = 17             /* &dA05/02/03&d@ "L" applies only to ties
                        goto NXYP 
                      end 
                    end 
                  end 
                  sub = g 
                  goto MORE_SUGG 
                end 
&dA 
&dA &d@        Suggestions for tuples 
&dA 
                if temp3{rc} = "*"               /* &dA03-21-97&d@ 
                  if "[(:;i" con line{g} 
                    aa3 = mpt 
                    ++@n 
                    tv1(@n) = P_SUGGESTION 
                    tv2(@n) = 0x10               /* tuplet suggestion 
MOTUP: 
                    if aa3 = 2 or aa3 = 4 
                      tv2(@n) |= 0x01            /* round tuplet 
                    end 
                    if aa3 = 1 or aa3 = 2 or aa3 = 5 
                      tv2(@n) |= 0x02            /* continuous tuplet 
                    end 
                    if aa3 = 3 
                      tv2(@n) = 0x10             /* square, broken tuplet (default)
                    end 
                    if aa3 = 5 
                      tv2(@n) |= 0x04            /* tuplet number inside bracket
                    end 
                    if "[(:;i" con line{g+1} 
                      ++g 
                      aa3 = mpt 
                      goto MOTUP 
                    end 
                  end 
                end 
                if temp3{rc} = "!"               /* &dA11/05/05&d@ 
&dA 
&dA &d@         New code &dA11/05/05&d@ implementing post adjustment to tuple position 
&dA 
MOTUP2: 
                  if line{g} = "x" 
                    a2 = int(line{g+1..}) 
                    a2 *= vpar(2) 
                    a2 /= 10 
                    g = sub 
                    if abs(a2) < 128 
                      ++@n 
                      tv1(@n) = P_SUGGESTION 
                      tv2(@n) = 0x500            /* x adjustment to tuplet 
                      a2 += 128 
                      tv2(@n) += a2 
                    end 
                    goto MOTUP2 
                  end 
                  if line{g} = "y" 
                    a2 = int(line{g+1..}) 
                    a2 *= vpar(2) 
                    a2 /= 10 
                    g = sub 
                    if abs(a2) < 128 
                      ++@n 
                      tv1(@n) = P_SUGGESTION 
                      tv2(@n) = 0x600            /* x adjustment to tuplet 
                      a2 += 128 
                      tv2(@n) += a2 
                    end 
                    goto MOTUP2 
                  end 
                end 
&dA                      &d@ End of &dA11/05/05&d@ addition 

                sub = g  
                goto MORE_SUGG 
              end 
            end 
&dA 
&dA &d@      Print suggestions applied to musical directions  (not modified as of &dA05/02/03&d@)
&dA 
            if temp3{1} = "*" 
              if rc >= 17 and rc <= 18 
                if "fxypY" con line{g} 
                  ++@n 
                  tcode(@n) = zpd(4) 
                  tv1(@n) = P_SUGGESTION 
                  if "ABCDGPQR" con temp3{rc}      /* New &dA02/03/08&d@ 
                    tv2(@n) = 0x0100 
                  else 
                    tv2(@n) = 0x0101 
                  end 
                end 
NXFP: 
                if line{g} = "f" 
                  t1 = int(line{g+1..}) 
                  g = sub 
                  if "ABCDGR" con temp3{rc} /* this is a designated font number  New &dA02/03/08
                    tcode(@n){1} = chr(t1) 
                  end 
                  goto NXFP 
                end 

                if "xyYp" con line{g} 
                  aa3 = mpt + 1 
                  if aa3 = 5 
                    aa3 -= 2 
                  end 
                  if line{g+1} = "+" 
                    ++g 
                  end 
                  t1 = int(line{g+1..}) 
                  t1 += 0x80 
                  if t1 <= 0 
                    t1 = 1 
                  end 
                  if t1 > 255 
                    t1 = 255 
                  end 
                  g = sub 
                  if "ABCDEFGHPQRUV" con temp3{rc} /* this is a position shift  New &dA02/03/08
                    tcode(@n){aa3} = chr(t1) 
                  end 
                  goto NXFP 
                end 
                sub = g 
                goto MORE_SUGG 
              end 
              if rc >= 25 and line{g} = "f" and temp3{17,2} con ['B'..'D','R']  /* New &dA02/03/08
                t1 = int(line{g+1..}) 
                g = sub 
                temp3 = temp3 // pad(100) 
&dA 
&dA &d@         De-construct temp3 into ASCII and font changes 
&dA 
                loop for a1 = 1 to 10 
                  font_changes(a1,1) = 0 
                  font_changes(a1,2) = 0 
                repeat 
                changecnt = 0 
                sub = 25 
NXFNUM: 
                if temp3{sub..} con "!" and temp3{sub+1} in ['0'..'9'] 
                  a1 = sub 
                  a2 = int(temp3{a1+1..}) 
                  ++changecnt 
                  font_changes(changecnt,1) = a1 
                  font_changes(changecnt,2) = a2 
&dA 
&dA &d@       Code change &dA01/17/04&d@ to keep font changes from interferring with the text
&dA 
                  if temp3{sub} = "|" 
                    ++sub 
                  end 
&dA   
                  temp3 = temp3{1,a1-1} // temp3{sub..} 
                  sub = a1 
                  goto NXFNUM 
                end 
&dA 
&dA &d@         Add new font change and re-order in ascending order of location 
&dA 
                ++changecnt 
                font_changes(changecnt,1) = rc 
                font_changes(changecnt,2) = t1 
                loop for a1 = changecnt to 2 step -1 
                  a2 = a1 - 1 
                  if font_changes(a1,1) < font_changes(a2,1) 
                    aa3 = font_changes(a1,1) 
                    font_changes(a1,1) = font_changes(a2,1) 
                    font_changes(a2,1) = aa3 
                    aa3 = font_changes(a1,2) 
                    font_changes(a1,2) = font_changes(a2,2) 
                    font_changes(a2,2) = aa3 
                  end 
                repeat 
&dA 
&dA &d@         Merge ASCII and font changes into new temp3 
&dA 
                temp4 = temp3{1,24} 
                a2 = 25 
                loop for a1 = 1 to changecnt 
                  aa3 = font_changes(a1,1) 
                  if aa3 > a2 
                    temp4 = temp4 // temp3{a2..aa3-1} 
                  end 
                  a2 = aa3 
                  temp4 = temp4 // "!" // chs(font_changes(a1,2)) // "|" 
                repeat 
                temp4 = temp4 // temp3{a2..} 
                temp3 = temp4 
                loop for a1 = @n to 1 step -1 
                  if tv1(a1) = MUSICAL_DIR 
                    tdata(a1,1) = temp3{17..96} 
                    a1 = 0 
                  end 
                repeat 
                sub = g 
                goto MORE_SUGG 
              end 
            end 
&dA 
&dA &d@      Print suggestions applied to measures and barlines: New code &dA05/25/03
&dA 
            if temp3{1} = "m" 
              if rc = 1 

&dA          &d@  
&dA 
&dA &d@       New suggestion &dA10/24/08&d@ to breakup a multi-rest measure (for parts) 
&dA 
                if line{g} = "f" and mrest > 0 
                  perform setmrest (mrest, wrest) 
                  mrest = 0 
                end 
&dA 
&dA          

                if line{g} = "n" 
                  ++@n 
                  tcode(@n) = zpd(4) 
                  tv1(@n) = P_SUGGESTION 
                  tv2(@n) = 0x0400 
                end 
&dA 
&dA &d@       New suggestion &dA05/28/05&d@ to implement &dEmid-movement&d@ right justification
&dA 
&dA &d@       NOTE: This code contains a giant cludge.  If the print suggestion follows
&dA &d@             directly after a measure record, and "]" is the only suggestion, then 
&dA &d@             this code reaches directly into the output and changes it.  
&dA &d@                                                                       
                if line{g} = "]" 
                  if @n = 0 
                    loop for t1 = outpnt to (outpnt - 10) step -1 
                      tget [Y,t1] temp4 
                      if len(temp4) > 5 and temp4{1,3} = "J B" 
                        sub = 5 
                        aa6 = int(temp4{sub..}) 
                        aa7 = int(temp4{sub..}) 
                        aa8 = int(temp4{sub..}) 
                        aa8 += 10000000 
                        temp4 = "J B " // chs(aa6) // " " // chs(aa7) // " " // chs(aa8) // temp4{sub..}
                        tput [Y,t1] ~temp4 
                        goto PR 
                      end 
                    repeat 
                  end 
                  ++@n 
                  tcode(@n) = zpd(4) 
                  tv1(@n) = P_SUGGESTION 
                  tv2(@n) = 0x0401 
                end 
                sub = g 
                goto MORE_SUGG 
              end 
            end 

            sub = g 
            goto MORE_SUGG 
          end 
          goto PR 
        end 
&dA  
&dA  &d@    END OF MAIN CODE FOR PRINT SUGGESTIONS 
&dA  &d@  ========================================== 
&dA  
&dA                                                                  


        if line{8} = " " 
          rc = 0 
        end 
        if mrest > 0 
          out = trm(line) 
          if len(out) > 15       /* this is a normal stage2 data line 
            perform setmrest (mrest, wrest) 
            mrest = 0 
          else 
&dA 
&dA &d@    &dA03/07/06&d@ allowing only mheavy4 of all measure codes 
&dA &d@               to slip through here.  
&dA 
            if "mrib" not_con line{1} or line{1,7} = "mheavy4" 
              perform setmrest (mrest, wrest) 
              mrest = 0 
            end 
          end 
        end 
        if "ABCDEFGri" con line{1} 
          ++@n 
          t1 = NOTE 
          if line{1} = "r" 
            t1 = REST 
          end 
          if line{1} = "i" 
            t1 = IREST 
          end 
          tv1(@n) = t1 
          tv2(@n) = rc 
          if " 123" con line{24}               /* staff number goes in tv3(.) & 0x0000000f
            if mpt = 1 
              tv3(@n) = 0 
            else 
              tv3(@n) = mpt - 2 
            end 
          else 
            if (Debugg & 0x01) > 0 
              pute Illegal character in staff number column (col. 24).  Please fix.
              pute Record = ~line 
            end 
            tmess = 11 
            perform dtalk (tmess) 
          end 
&dA 
&dA &d@       Code added &dA01/30/05&d@ for text under notes 
&dA 
          temp4 = trm(line) 
          if len(temp4) > 43 
            text_flag = 1 
          end 
&dA                                

          if " 123456789" con line{15}         /* track number goes in tv3(.) & 0x000000f0
            if mpt = 1                         /* track number = 0 means no information
            else 
              --mpt 
              a1 = mpt << 4 
              tv3(@n) += a1 
            end 
          else 
            if (Debugg & 0x01) > 0 
              pute Illegal character in track number column (col. 15).  Please fix.
              pute Record = ~line 
            end 
            tmess = 11 
            perform dtalk (tmess) 
          end 
&dA 
&dA &d@       Code added &dA01/30/05&d@ for text under notes 
&dA 
          temp4 = trm(line) 
          if len(temp4) > 43 
            text_flag = 1 
          end 
&dA                                

          if line{1} = "i" 
            tcode(@n) = "ires"                 /* redundant, but do it to be on the safe side
          else 
            tcode(@n) = line{1,4} 
          end 
          tdata(@n,1) = line{17..80} 
&dA 
&dA &d@    Code added &dA01/03/04&d@ to deal with optional rests (whole and otherwise) 
&dA 
          if "WHQESTXYZ " con line{17} 
            a1 = mpt 
            if line{1} = "r" and wrest = 1 
              if line{17} = " " 
                tdata(@n,1){1} = "o" 
              else 
                tdata(@n,1){1} = line{17} 
              end 
&dK &d@           else                           /* remove this &dA01/08/11&d@ to implement square notes
&dK &d@             tdata(@n,1){1} = "whqestxyz "{a1} 
            end 
          end 

          if "ri" con line{1}                  /* restplace flag goes in tv3(.) & 0x0000ff00
            if mpt = 1 
              tv3(@n) += restplace << 8 
            end 
          else 
            if repeater_flag > 0               /* repeater flag goes in tv3(.) & 0x0000ff00
              tv3(@n) += repeater_flag << 8 
              if bit(0,repeater_flag) = 1 and line{26} = "]" 
                repeater_flag = 0 
              end 
            end 
          end 
&dA 
&dA &d@   Code added &dA12/20/10&d@ to implement "color" to noteheads, etc.  
&dA 
          if "rgb RGB" con line{14} 
            if mpt <> 4 
              tv3(@n) += mpt << 16             /* color flag goes in tv3(.) & 0x000f0000
            end 
          end 
&dA 
&dA &d@   Code added &dA05/12/04&d@ to implement global suggestion to turn off 
&dA &d@   the printing of rests (used for blank continuo parts).  Note that 
&dA &d@   no other print suggestions for rest can be inforce when this 
&dA &d@   feature is used.  
&dA 
          if restoff = 1 or (irest_flag = 1 and tv1(@n) = IREST) 
            ++@n 
            tcode(@n) = zpd(4) 
            tv1(@n) = P_SUGGESTION 
            tv2(@n) = 0x0300 
            tcode(@n){1} = chr(3) 
          end 
&dA     

&dA 
&dA &d@   Code added &dA01/10/06&d@  to expand the operation of art_flag 
&dA 
          if art_flag >= 16 and "ri" not_con line{1} 
            a2 = art_flag >> 4 
            if a2 = 1 or a2 = 3 or a2 = 4 or a2 = 8 
              ++@n 
              tcode(@n) = zpd(4) 
              tcode(@n){1} = chr(1) 
              tv1(@n) = P_SUGGESTION 
              if a2 < 4 
                tv2(@n) = 0x0201 
              else 
                if a2 = 4 
                  tv2(@n) = 0x0202 
                else 
                  if a2 = 8 
                    tv2(@n) = 0x0203 
                  end 
                end 
              end 
              tcode(@n){1} = chr(3) 
            end 
          end 
&dA     
          goto PR 
        end 
        if line{1} = "/" 
          perform action 
          ++outpnt 
          tput [Y,outpnt] J M 0 ~obx  0 0 10000 0 0 
          if (Debugg & 0x06) > 0 
            pute END 
          end 
          goto NEXT 
        end 
        if " cgf*b" con line{1} 
          a2 = mpt 
          t6 = int(line{8}) 
          if line{8} in ['A'..'E','X']                    /* Implementing arpeggios &dA01/13/06
            t6 = ors(line{8}) - 55       /* A = 10, etc.       X = 33 (ARPEGGIO)
          end 
&dA 
&dA &d@     New code 01/13/06 implementing arpeggios; delete extraneous data 
&dA 
          if t6 = ARPEGGIO 
            line = line{1,24} 
            line = line // pad(80) 
          end 
&dA    
          ++@n 
          tdata(@n,1) = line{17..80} 
          if line{1} = "f" 
            tv3(@n) = 0 
          else 
            if " 123" con line{24}             /* staff number goes in tv3(.) & 0x0000000f
              if mpt = 1 
                tv3(@n) = 0 
              else 
                tv3(@n) = mpt - 2 
              end 
            else 
              if (Debugg & 0x01) > 0 
                pute Illegal character in staff number column (col. 24).  Please fix.
                pute Record = ~line 
              end 
              tmess = 11 
              perform dtalk (tmess) 
            end 
            if a2 < 4         /* chords, grace, and cue notes 
              if " 123456789" con line{15}     /* track number goes in tv3(.) & 0x000000f0
                if mpt = 1                     /* track number = 0 means no information
                else 
                  --mpt 
                  a1 = mpt << 4 
                  tv3(@n) += a1 
                end 
              else 
                if (Debugg & 0x01) > 0 
                  pute Illegal character in track number column (col. 15).  Please fix.
                  pute Record = ~line 
                end 
                tmess = 11 
                perform dtalk (tmess) 
              end 
            end 
          end 
          goto TT(a2)                    /* a2 = mpt from ~20 lines above 
TT(1):
          tv1(@n) = XNOTE 
          tv2(@n) = 0 
          tcode(@n) = line{2,4} 
          goto PR 
TT(2):
          t1 = CUE_NOTE 
          if line{2} = " " 
            t1 = XCUE_NOTE 
            tcode(@n) = line{3,4} 
            t6 = 0 
          else 
            tcode(@n) = line{2,4} 
          end 
          if line{2} = "r" 
            t1 = CUE_REST 
          end 
          tv1(@n) = t1 
          tv2(@n) = t6 
          if line{2} = "r"                     /* restplace flag goes in tv3(.) & 0x0000ff00
            tv3(@n) += restplace << 8 
          else 
            if repeater_flag > 0               /* repeater flag goes in tv3(.) & 0x0000ff00
              tv3(@n) += repeater_flag << 8 
              if bit(0,repeater_flag) = 1 and line{26} = "]" 
                repeater_flag = 0 
              end 
            end 
          end 
          goto PR 
TT(3):
          t1 = GR_NOTE 
          if line{2} = " " 
            t1 = XGR_NOTE 
            tcode(@n) = line{3,4} 
            t6 = 0 
          else 
            tcode(@n) = line{2,4} 
          end 
          tv1(@n) = t1 
          tv2(@n) = t6 
          if repeater_flag > 0                 /* repeater flag goes in tv3(.) & 0x0000ff00
            tv3(@n) += repeater_flag << 8 
            if bit(0,repeater_flag) = 1 and line{26} = "]" 
              repeater_flag = 0 
            end 
          end 
          goto PR 
TT(4):
          tv1(@n) = FIGURES 
          tv2(@n) = rc 
          tv3(@n) = 0 
          tcode(@n) = line{2,4} 
          goto PR 
TT(5): 
          tv1(@n) = MUSICAL_DIR 
          if "12345" con line{15} 
            tv2(@n) = mpt 
          else 
            tv2(@n) = 1 
          end 
          if rc > 0 
            tv3(@n) += rc << 8 
          end 

          tcode(@n) = line{17,4} 
&dA 
&dA &d@    Code added &dA01/07/06&d@ to give format warning 
&dA 
          if line{17,2} = "  " 
            if (Debugg & 0x01) > 0 
              temp4 = trm(line) 
              pute WARNING: Bad format in a musical direction record 
              pute    Rec #~(scnt+5)  -> ~temp4 
            end 
          end 
&dA     
          goto PR 
TT(6): 
          tv1(@n) = BACKSPACE 
          tv2(@n) = rc 
          tv3(@n) = 0 
          tcode(@n) = line{1,4} 
          goto PR 
        end 
        if line{1} = "m" 

          ++barnum2 

          if f4 = 0 and line{2,6} <> "heavy4" 
&dA 
&dA &d@    &dA03/07/06&d@  Allowing other measure types (except "mheavy4") here, but 
&dA &d@                clearing mrest below for all cases other than "measure" 
&dA 
            out = trm(line) 
&dA 
&dA &d@    New &dA03/13/06&d@ Don't process for "multi-rests" unless multirest_flag = 1 
&dA &d@                 Normally, this will apply to Parts only.  
&dA 
            if len(out) < 16 and multirest_flag = 1 
              if @n = 1 
                if "ir" con tcode(1){1} 
                  out = trm(tdata(1,1)) 
                  if out = "" 
                    ++mrest 
                    if mrest = 1 
                      how_much_mrest(1) = divspq 
                      how_much_mrest(2) = tv2(1) 
                    else 
                      if tv2(1) <> how_much_mrest(2) 
                        if (Debugg & 0x01) > 0 
                          pute Stage 2 file format error at approx rec ~scnt
                        end 
                        tmess = 22 
                        perform dtalk (tmess) 
                      end 
                    end 

                    mrest_line = line 
                    measnum = g 
                    if wrest = 1 or multirest_flag = 0    /* New code &dA01/03/04&d@ and &dA03/04/06
                      perform setmrest (mrest, wrest) 
                      mrest = 0 
                    else 
                      if line{2,4} <> "easu" 
                        perform setmrest (mrest, wrest) 
                        mrest = 0 
                      end 
                    end 
                    @n = 0 
                    out = trm(line) 
                    if len(out) > 7 
                      if len(out) > 12 
                        out = line{1,8} // chs(g-1) // pad(12) 
                        out = out // line{13..} 
                        out = trm(out) 
                      else 
                        out = line{1,8} // chs(g-1) 
                        out = trm(out) 
                      end 
                    end 
                    if (Debugg & 0x06) > 0 
                      if mreport_flag = 1 or (Debugg & 0x08) > 0 
                        pute ~out 
                      end 
                    end 
                    goto PR 
                  end 
                end 
              else 
                if @n = vflag * 2 - 1 and nstaves = 1 
                  loop for t1 = 1 to vflag * 2 step 2 
                    out = trm(tdata(t1,1)) 
                    if "ir" not_con tcode(t1){1} or out <> "" 
                      t1 = 10000 
                    else 
                      if t1 < @n 
                        out = trm(tdata(t1+1,1)) 
                        if tcode(t1+1) <> "back" or out <> "" 
                          t1 = 10000 
                        end 
                      end 
                    end 
                  repeat 
                  if t1 < 10000 
                    ++mrest 

                    if mrest = 1 
                      how_much_mrest(1) = divspq 
                      how_much_mrest(2) = tv2(1) 
                    else 
                      if tv2(1) <> how_much_mrest(2) 
                        if (Debugg & 0x01) > 0 
                          pute Stage 2 file format error at approx rec ~scnt
                        end 
                        tmess = 22 
                        perform dtalk (tmess) 
                      end 
                    end 

                    mrest_line = line 
                    measnum = g 
                    if wrest = 1 or multirest_flag = 0    /* New code &dA01/03/04&d@ and &dA03/04/06
                      perform setmrest (mrest, wrest) 
                      mrest = 0 
                    else 
                      if line{2,4} <> "easu" 
                        perform setmrest (mrest, wrest) 
                        mrest = 0 
                      end 
                    end 
                    @n = 0 
                    out = trm(line) 
                    goto PR 
                    if (Debugg & 0x06) > 0 
                      if mreport_flag = 1 or (Debugg & 0x08) > 0 
                        pute ~out 
                      end 
                    end 
                  end 
                end 
              end 
            end 
          end 
          f4 = 0 
          ++@n 
          tv1(@n) = BAR_LINE 
          tv2(@n) = g 
          tv3(@n) = nstaves 
          measnum = g 
          tcode(@n) = line{4,4} 
          tdata(@n,1) = line{17..80} 
          tdata(@n,2) = chs(barnum2) // "+" 

          if tdata(@n,1) not_con "*" and tdata(@n,1) not_con "&"  /* 2nd condition added &dA01/30/05
            out = trm(line) 
            if len(out) > 7 
              if len(out) > 12 
                out = line{1,8} // chs(g-1) // pad(12) 
                out = out // line{13..} 
                out = trm(out) 
              else 
                out = line{1,8} // chs(g-1) 
                out = trm(out) 
              end 
            end 
            if (Debugg & 0x06) > 0 
              if mreport_flag = 1 or (Debugg & 0x08) > 0 
                pute ~out 
              end 
            end 
            perform action 
            @n = 0 
          end 
          goto PR 
        end 
        if (Debugg & 0x01) > 0 
          pute ~line 
        end 
        tmess = 7 
        perform dtalk (tmess) 
*          
NEXT: 
        tget [Y,1] t5 .t1 temp3 
&dA 
&dA &d@       Adding this code &dA01/30/05&d@ to make sure text is set at the right height
&dA 
        if text_flag = 1 
          t5 = text_loc 
        end 
        if single_line = 0 
          LL = "L" 
        else 
          LL = "l" 
        end 
&dA 
&dA &d@    If Syscode = "", collect data for constructing a default Syscode 
&dA 
        if Syscode = "" 
          if t5 = 0 
&dA 
&dA &d@     String Section 
&dA 
            partname = partname // " " 
            if partname con "iolin" 
              sys_data(f3,1) = 1 
              sys_data(f3,2) = 1 
              goto SYSC 
            end 
            if partname con "iola" 
              sys_data(f3,1) = 1 
              sys_data(f3,2) = 2 
              goto SYSC 
            end 
            if partname con "iolon" and partname not_con "cello" 
              sys_data(f3,1) = 1 
              sys_data(f3,2) = 3 
              goto SYSC 
            end 
            if partname con "Cello" or partname con "cello" 
              sys_data(f3,1) = 1 
              sys_data(f3,2) = 4 
              goto SYSC 
            end 
            if partname con "Basso" or partname con "basso" or partname con "Bass "
              if partname not_con "larinet" and partname not_con "orn" and partname not_con "rombon"
                sys_data(f3,1) = 1 
                sys_data(f3,2) = 5 
                goto SYSC 
              end 
            end 
&dA 
&dA &d@     Woodwind Section 
&dA 
            if (partname con "Flute" or partname con "flute") and partname not_con "icco"
              sys_data(f3,1) = 2 
              sys_data(f3,2) = 6 
              goto SYSC 
            end 
            if (partname con "Flaut" or partname con "flaut") and partname not_con "icco"
              sys_data(f3,1) = 2 
              sys_data(f3,2) = 7 
              goto SYSC 
            end 
            if partname con "Obo" or partname con "obo" 
              sys_data(f3,1) = 2 
              sys_data(f3,2) = 8 
              goto SYSC 
            end 
            if partname con "larinet"
              if partname con "Basso" or partname con "basso" or partname con "Bass "
                sys_data(f3,1) = 2 
                sys_data(f3,2) = 10 
              else 
                sys_data(f3,1) = 2 
                sys_data(f3,2) = 9 
              end 
              goto SYSC 
            end 
            if partname con "assoon" or partname con "agot" 
              if partname con "ontra" 
                sys_data(f3,1) = 2 
                sys_data(f3,2) = 12 
              else 
                sys_data(f3,1) = 2 
                sys_data(f3,2) = 11 
              end 
              goto SYSC 
            end 
            if partname con "enlish" 
              sys_data(f3,1) = 2 
              sys_data(f3,2) = 13 
              goto SYSC 
            end 
            if partname con "iccolo" and partname not_con "r" 
              sys_data(f3,1) = 2 
              sys_data(f3,2) = 14 
              goto SYSC 
            end 
&dA 
&dA &d@     Brass Section 
&dA 
            if partname con "rump" 
              sys_data(f3,1) = 3 
              sys_data(f3,2) = 15 
              goto SYSC 
            end 
            if partname con "romb" and partname not_con "rombo" 
              sys_data(f3,1) = 3 
              sys_data(f3,2) = 16 
              goto SYSC 
            end 
            if partname con "larino" 
              sys_data(f3,1) = 3 
              sys_data(f3,2) = 17 
              goto SYSC 
            end 
            if partname con "rombon" 
              sys_data(f3,1) = 3 
              sys_data(f3,2) = 18 
              goto SYSC 
            end 
            if partname con "uba" 
              sys_data(f3,1) = 3 
              sys_data(f3,2) = 19 
              goto SYSC 
            end 
            if partname con "orn" and partname not_con "nglish" 
              sys_data(f3,1) = 3 
              sys_data(f3,2) = 20 
              goto SYSC 
            end 
&dA 
&dA &d@     Percussions Section 
&dA 
            if partname con "imp" 
              sys_data(f3,1) = 4 
              sys_data(f3,2) = 21 
              goto SYSC 
            end 
            if partname con "iatt" 
              sys_data(f3,1) = 4 
              sys_data(f3,2) = 22 
              goto SYSC 
            end 
            if partname con "ymbal" 
              sys_data(f3,1) = 1 
              sys_data(f3,2) = 23 
              goto SYSC 
            end 
&dA 
&dA &d@     Two Staves            
&dA 
            if nstaves = 2 
              sys_data(f3,1) = 5 
              sys_data(f3,2) = 24 
              goto SYSC 
            end 
&dA 
&dA &d@     Unknown      
&dA 
            sys_data(f3,1) = 6 
            sys_data(f3,2) = 100 
            goto SYSC 
          else          
&dA 
&dA &d@     Singers 
&dA 
            sys_data(f3,1) = 7 
            if "SsAaTtBb" con partname{1} 
              t1 = mpt - 1 / 2 
            end 
            sys_data(f3,2) = 96 + t1 
            goto SYSC 
          end 
SYSC: 
          sys_data(f3,3) = 0 
          sys_data(f3,4) = 0 
        end 

        partname = trm(partname) 

        ++zcnt 
        tput [Z,zcnt] ******************************************** 

        if nstaves = 2 
          ++zcnt 
          tput [Z,zcnt] L ~granddist  ~t5  ~notesize  !39~partname 
        else 
          ++zcnt 
          tput [Z,zcnt] ~LL  0 ~t5  ~notesize  !39~partname 
        end 

        loop for t1 = 2 to outpnt 
          tget [Y,t1] line 
          ++zcnt 
          tput [Z,zcnt] ~line 
        repeat 
        treset [X] 
        treset [Y] 
* 
        ++f3 
        if f3 > f2 
&dA 
&dA &d@    If Syscode = "", analyse and construct a default Syscode 
&dA 
          if Syscode = "" 
            t2 = 0 
            loop for t1 = 1 to f2 
              if t2 = 0 
                if t1 < f2 
                  if sys_data(t1+1,1) = sys_data(t1,1) 
                    sys_data(t1,3) = 1 
                    t2 = 1 
                  end 
                end 
              else 
                if t1 = f2 
                  sys_data(t1,3) = 2 
                  t2 = 0 
                else 
                  if sys_data(t1+1,1) <> sys_data(t1,1) 
                    sys_data(t1,3) = 2 
                    t2 = 0 
                  end 
                end 
              end 
            repeat 

            t2 = 0 
            loop for t1 = 1 to f2 
              if t2 = 0 
                if sys_data(t1,1) = 5 
                  sys_data(t1,4) = 3 
                else 
                  if t1 < f2 
                    if sys_data(t1+1,2) = sys_data(t1,2) 
                      sys_data(t1,4) = 1 
                      t2 = 1 
                    end 
                  end 
                end 
              else 
                if t1 = f2 
                  sys_data(t1,4) = 2 
                  t2 = 0 
                else 
                  if sys_data(t1+1,2) <> sys_data(t1,2)
                    sys_data(t1,4) = 2 
                    t2 = 0 
                  end 
                end 
              end 
            repeat 

            t2 = 0 
            loop for t1 = 1 to f2 
              if t2 = 0 
                if sys_data(t1,3) = 1 
                  Syscode = Syscode // "[" 
                  t2 = 1 
                else 
                  Syscode = Syscode // "(" 
                  t2 = 2 
                end 
                if sys_data(t1,4) = 1 or sys_data(t1,4) = 3 
                  Syscode = Syscode // "{" 
                end 
                if sys_data(t1,1) = 5 
                  Syscode = Syscode // ":" 
                else 
                  Syscode = Syscode // "." 
                end 
                if sys_data(t1,4) = 3 
                  Syscode = Syscode // "}" 
                end 
              else 
                if sys_data(t1,4) = 1 or sys_data(t1,4) = 3 
                  Syscode = Syscode // "{" 
                end 
                if sys_data(t1,1) = 5 
                  Syscode = Syscode // ":" 
                else 
                  Syscode = Syscode // "." 
                end 
                if sys_data(t1,4) = 3 or sys_data(t1,4) = 2 
                  Syscode = Syscode // "}" 
                end 
                if t2 = 1 
                  if sys_data(t1,3) = 2 
                    Syscode = Syscode // "]" 
                    t2 = 0 
                  end 
                end 
              end 
              if t2 = 2 
                Syscode = Syscode // ")" 
                t2 = 0 
              end 
            repeat 
          end 

          return 
        end 
        goto BIG 
*  
      return 

&dA 
&dA &d@                &dAÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dA &d@                &dA³ End of processing music data    ³&d@ 
&dA &d@                &dAÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 
&dA 
&dA                                                                       

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P*  2. decodeax (t1,t2)                                         ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Input: t1  = pointer into ts array                          ³ 
&dA &d@³           t2  = index into measax array                        ³ 
&dA &d@³           bit(18,ts(t1,SUBFLAG_1)) = cautionary accidental flag³ 
&dA &d@³            (has effect only when no accidental would           ³ 
&dA &d@³             otherwise be printed)                              ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Output: correct accidental in ts(.,AX)                      ³ 
&dA &d@³                                                                ³ 
&dA &d@³             0000 = no accidental                               ³ 
&dA &d@³             0001 = natural                                     ³ 
&dA &d@³             0010 = sharp                                       ³ 
&dA &d@³             0011 = flat                                        ³ 
&dA &d@³             0110 = natural sharp                               ³ 
&dA &d@³             0111 = natural flat                                ³ 
&dA &d@³             1010 = sharp sharp                                 ³ 
&dA &d@³             1111 = flat flat                                   ³ 
&dA &d@³                                                                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure decodeax (t1,t2) 
        int t1,t2,t3,t4,ax 
        getvalue t1,t2   

        t3 = ts(t1,CLAVE)     
        if t3 > 99    
          ts(t1,AX) = 0 
          return 
        end
&dA 
&dA &d@   adjust accident to reflect key and measure   
&dA 
        t4 = ts(t1,AX) 
        ax = t4 

        if ax = measax(t2,t3) 
          if bit(18,ts(t1,SUBFLAG_1)) = 0 
            t4 = 0 
          else 
            if t4 = 0  
              t4 = 1        /* natural 
            end  
          end      
        else   
          if ax = 0      
            t4 = 1   
          else   
            if measax(t2,t3) > 7 
              if ax < 4      
                t4 = t4 | 4   
              end  
            end  
          end  
          measax(t2,t3) = ax 
        end  
        ts(t1,AX) = t4 
      return   

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P*  3. action                                                       ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Purpose:  Action is basically a continuation of the music       ³ 
&dA &d@³              processing program.  It is called when the data       ³ 
&dA &d@³              for a measure is complete.                            ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Inputs:  @n = number of elements in data arrays                 ³ 
&dA &d@³             tv1(.) = element type                                  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                type   element                                      ³ 
&dA &d@³                ----   -------                                      ³ 
&dA &d@³                  1    regular note                                 ³ 
&dA &d@³                  2    extra regular note in chord                  ³ 
&dA &d@³                  3    regular rest                                 ³ 
&dA &d@³                  4    cue note                                     ³ 
&dA &d@³                  5    extra cue note in chord                      ³ 
&dA &d@³                  6    cue rest                                     ³ 
&dA &d@³                  7    grace note or grace rest                     ³ 
&dA &d@³                  8    extra grace note in chord                    ³ 
&dA &d@³                  9    figured harmony                              ³ 
&dA &d@³                 10    bar line                                     ³ 
&dA &d@³                 11    musical direction                            ³ 
&dA &d@³                 12    invisable rest                               ³ 
&dA &d@³                 13    backspace                                    ³ 
&dA &d@³                 14    clef change                                  ³ 
&dA &d@³                 15    time designation or other directive          ³ 
&dA &d@³                 16    time change                                  ³ 
&dA &d@³                 17    change in divspq                             ³ 
&dA &d@³                 18    key change                                   ³ 
&dA &d@³                 19    print suggestion                             ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                tv2(.) = duration for types 1--9, 12,13             ³ 
&dA &d@³                       = measure number for type 10                 ³ 
&dA &d@³                       = track number for type 11 (1 = default)     ³ 
&dA &d@³                       = new clef number for type 14                ³ 
&dA &d@³                       = 0 for type 15                              ³ 
&dA &d@³                       = new time flag for type 16                  ³ 
&dA &d@³                       = new divspq for type 17                     ³ 
&dA &d@³                       = new key for type 18                        ³ 
&dA &d@³                       = type of suggestion for type 19             ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                           if between 0 and 7                       ³ 
&dA &d@³                             0 = force slur 1 over                  ³ 
&dA &d@³                             1 = force slur 1 under                 ³ 
&dA &d@³                             2 = force slur 2 over                  ³ 
&dA &d@³                             3 = force slur 2 under                 ³ 
&dA &d@³                             4 = force slur 3 over                  ³ 
&dA &d@³                             5 = force slur 3 under                 ³ 
&dA &d@³                             6 = force slur 4 over                  ³ 
&dA &d@³                             7 = force slur 4 under                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                           if between 8 and 9                       ³ 
&dA &d@³                             8 = overhanded tie (tips down)         ³ 
&dA &d@³                             9 = underhanded tie (tips up)          ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                           if between 16 and 31 (&dA03-21-97&d@)          ³ 
&dA &d@³                             bit 0: clear = square tuplet           ³ 
&dA &d@³                                    set   = round tuplet            ³ 
&dA &d@³                             bit 1: clear = broken tuplet           ³ 
&dA &d@³                                    set   = continuous tuplet       ³ 
&dA &d@³                             bit 2: clear = number outside tuplet   ³ 
&dA &d@³                                    set   = number inside tuplet    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                           if between 128 and 255                   ³ 
&dA &d@³                             font = type - 128                      ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                           if between 0x100 and 0x1ff               ³ 
&dA &d@³                             vert and/or horz adj to musical dir    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                           if between 0x200 and 0x2ff               ³ 
&dA &d@³                             vert and/or horz adj to sub-obj        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                           if between 0x300 and 0x3ff               ³ 
&dA &d@³                             vert and/or horz adj to note/rest/fig  ³ 
&dA &d@³                               objects.                             ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                           if between 0x400 and 0x4ff               ³ 
&dA &d@³                             suggestion for barline or measure      ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                           if between 0x500 and 0x5ff  New &dA11/05/05&d@ ³ 
&dA &d@³                             x adjustment to tuple                  ³ 
&dA &d@³                               (range -127 to +127)                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                           if between 0x600 and 0x6ff  New &dA11/05/05&d@ ³ 
&dA &d@³                             y adjustment to tuple                  ³ 
&dA &d@³                               (range -127 to +127)                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                tv3(.) & 0x000f = staff number  (0 or 1)            ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                       For notes, rests and irests                  ³ 
&dA &d@³                       & 0x00f0 = track number (0 to 9) 0=unknown   ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                       For notes,                                   ³ 
&dA &d@³                       & 0xff00 = value of repeater_flag            ³ 
&dA &d@³                       & 0xf0000 = value of color_flag              ³ (New &dA12/20/10&d@)
&dA &d@³                       For rests,                                   ³ 
&dA &d@³                       & 0xff00 = value of restplace                ³ 
&dA &d@³                       & 0xf0000 = value of color_flag              ³ (New &dA12/20/10&d@)
&dA &d@³                       For musical directions                       ³ 
&dA &d@³                       & 0xff00 = value of optional forward         ³ 
&dA &d@³                                    offset for division counter     ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                tv5(.) used for flagging $ data that occurs         ³ (New &dA01/17/04&d@)
&dA &d@³                         at the beginning of a measure, but         ³ 
&dA &d@³                         is not typeset immediately                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³              tcode(.) = pitch (rest) for types 1--8                ³ 
&dA &d@³                       = number of figure fields for type 9         ³ 
&dA &d@³                           (figured harmony)                        ³ 
&dA &d@³                       = bar type for type 10                       ³ 
&dA &d@³                       = musical direction code and position        ³ 
&dA &d@³                           for type 11                              ³ 
&dA &d@³                       = "ires" for type 12                         ³ 
&dA &d@³                       = "back" for type 13                         ³ 
&dA &d@³                       = "0" or "128" for type 14 (clef change)     ³ 
&dA &d@³                       = "" for types 15--18                        ³ 
&dA &d@³                       = for type 19 (print suggestions)            ³          
&dA &d@³                           a 4 byte code                            ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                         byte 1: 0x01: active flag (0 = inactive)   ³ 
&dA &d@³                                 0xfe: various meanings             ³ 
&dA &d@³                         (for ties only)                            ³ 
&dA &d@³                                 length modification (+128)         ³ 
&dA &d@³                                   (0 = no data)                    ³ 
&dA &d@³                         (for start slurs &dE([{z&d@ only)                ³ 
&dA &d@³                                 curvature modification (+128)      ³ 
&dA &d@³                                   (0 = no data)                    ³ 
&dA &d@³                                  (-1 = suppress slur) &dA04/26/05&d@     ³ 
&dA &d@³                         (for notes, etc.)                          ³ 
&dA &d@³                                 upper four bits used to designate  ³ 
&dA &d@³                                 note head shape.                   ³ 
&dA &d@³                                    0 = regular                     ³ 
&dA &d@³                                    1 = x (cymbal crash) &dA02/19/06&d@   ³ 
&dA &d@³                                   (2 = diamond)                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                         byte 2: x-y active flags                   ³ 
&dA &d@³                                 0x01: active flag (0 = inactive)   ³ 
&dA &d@³                                 0x02: 0 = x position is relative   ³ 
&dA &d@³                                       1 = x position is absolute   ³ 
&dA &d@³                                 0x04: 0 = y position is relative   ³ 
&dA &d@³                                       1 = y position is absolute   ³ 
&dA &d@³                         byte 3: x position data (+128) (0=no data) ³ 
&dA &d@³                         byte 4: y position data (+128) (0=no data) ³ 
&dA &d@³                                                                    ³ 
&dA &d@³            tdata(.,.) = additional data for types 1--11, 19        ³ tdata(.,.) for type 10
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Output:  ts(.,.)                                                ³ 
&dA &d@³                          Description of ts                         ³ 
&dA &d@³                     --------------------------                     ³ 
&dA &d@³                                                                    ³ 
&dA &d@³     Case I:  Notes, Rests, Grace Notes, Cue Notes, Cue Rests       ³ 
&dA &d@³                 Extra Regular, Grace, and Cue notes in Chords      ³ 
&dA &d@³                     (types  1--8)                                  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(1) = type:   1 = note                                    ³ 
&dA &d@³                        2 = extra regular note in chord             ³ 
&dA &d@³                        3 = rest                                    ³ 
&dA &d@³                        4 = cue note                                ³ 
&dA &d@³                        5 = extra cue note in chord                 ³ 
&dA &d@³                        6 = cue rest                                ³ 
&dA &d@³                        7 = grace note or grace rest                ³ 
&dA &d@³                        8 = extra grace note in chord               ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(2) = division number (starting with 1)                   ³ 
&dA &d@³        ts(3) = clave    <100 = clave number                        ³ 
&dA &d@³                          100 = rest                                ³ 
&dA &d@³                          101 = movable rest                        ³ 
&dA &d@³                          200 = irest <--                           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(4) (used initially to store pointer to tcode(.) )        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(4) = accidental flag                                     ³ 
&dA &d@³                                                                    ³ 
&dA &d@³           bits 0x0f: 0 = none        6 = natural-sharp             ³ 
&dA &d@³                      1 = natural     7 = natural-flat              ³ 
&dA &d@³                      2 = sharp      10 = double sharp              ³ 
&dA &d@³                      3 = flat       15 = double flat               ³ 
&dA &d@³                                                                    ³ 
&dA &d@³           bit  0x10: 0 = regular   1 = "silent"                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³           bits 0xff00: left shift (positioning)                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(5) = note type                                           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                    0 = eighth with slash                           ³ 
&dA &d@³                    1 = 256th note      7 = quarter note            ³ 
&dA &d@³                    2 = 128th note      8 = half note               ³ 
&dA &d@³                    3 = 64th note       9 = whole note              ³ 
&dA &d@³                    4 = 32nd note      10 = breve                   ³ 
&dA &d@³                    5 = 16th note      11 = longa                   ³ 
&dA &d@³                    6 = 8th note       12 = maxima                  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(6) = dot flag   0 = no dot,  1 = dot,  2 = double dot    ³ 
&dA &d@³        ts(7) = tuplet flag   0 = no tuplet, # = tuplet             ³ 
&dA &d@³                      0xff    first number                          ³ 
&dA &d@³                    0xff00    second number                         ³ 
&dA &d@³                  0xff0000    x adjustment (128 centered)           ³ 
&dA &d@³                0xff000000    y adjustment (128 centered)           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(8) = location on staff                                   ³ 
&dA &d@³        ts(9) = spacing number                                      ³ 
&dA &d@³       ts(10) = stem/chord flag    bit      clear        set        ³ 
&dA &d@³                                  -----    -------    ---------     ³ 
&dA &d@³                                    0      no stem      stem        ³ 
&dA &d@³                                    1      step up    stem down     ³ 
&dA &d@³                                    2    single note    chord       ³ 
&dA &d@³                                    3    first note   extra note    ³ 
&dA &d@³                                  4-7    (note number in chord)     ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(11) = beam flag   0 = no beam                             ³ 
&dA &d@³                            1 = end beam                            ³ 
&dA &d@³                            2 = start beam                          ³ 
&dA &d@³                            3 = continue beam                       ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(12) = beam code (up to six digits)                        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                 This is an integer less than 1000000.  The one's   ³ 
&dA &d@³                 digit is the code for the eighth beam; the         ³ 
&dA &d@³                 tens digit is the code for the sixteenth beam,     ³ 
&dA &d@³                 etc.                                               ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                        digit    char    meaning                    ³ 
&dA &d@³                       -------   ----   ---------                   ³ 
&dA &d@³                          0     blank   no beam                     ³ 
&dA &d@³                          1       =     continued beam              ³ 
&dA &d@³                          2       [     begin beam                  ³ 
&dA &d@³                          3       ]     end beam                    ³ 
&dA &d@³                          4       /     forward hook                ³ 
&dA &d@³                          5       \     backward hook               ³ 
&dA &d@³                          6             simple repeater             ³ 
&dA &d@³                          7             begin repeated beam         ³ 
&dA &d@³                          8             end repeated beam           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(13) = local x-offset (for chords)                         ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(14) = superflag     bit        set                        ³ 
&dA &d@³                              -----     --------                    ³ 
&dA &d@³                               0        tie                         ³ 
&dA &d@³                               1        begin ~~~~~ without tr.     ³ 
&dA &d@³                               2        begin ~~~~~ with tr.        ³ 
&dA &d@³                               3        end ~~~~~                   ³ 
&dA &d@³                               4        begin tuplet                ³ 
&dA &d@³                               5        end tuplet                  ³ 
&dA &d@³                               6        tuple has a bracket         ³ 
&dA &d@³                               7        bracket is continuous       ³ 
&dA &d@³                                           (0 = broken)             ³ 
&dA &d@³                               8        number is inside            ³ 
&dA &d@³                                           (0 = outside)            ³ 
&dA &d@³                               9        bracket is round            ³ 
&dA &d@³                                           (0 = square)             ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                              16        tie is editorial (dotted)   ³ 
&dA &d@³                              17        ~~~ is editorial            ³ 
&dA &d@³                              18        tuple is editorial          ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(15) = slurflag    bit set  meaning                        ³ 
&dA &d@³                             -------  -------                       ³ 
&dA &d@³                               0      start slur1 (new slur)        ³ 
&dA &d@³                               1      stop slur1 (from prev. note)  ³ 
&dA &d@³                               2      start slur2  (etc.)           ³ 
&dA &d@³                               3      stop slur2                    ³ 
&dA &d@³                               4      start slur3                   ³ 
&dA &d@³                               5      stop slur3                    ³ 
&dA &d@³                               6      start slur4                   ³ 
&dA &d@³                               7      stop slur4                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                 for editorial slurs                ³ 
&dA &d@³                                 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ                ³ 
&dA &d@³                              16      start slur1 (new slur)        ³ 
&dA &d@³                              17      stop slur1 (from prev. note)  ³ 
&dA &d@³                              18      start slur2  (etc.)           ³ 
&dA &d@³                              19      stop slur2                    ³ 
&dA &d@³                              20      start slur3                   ³ 
&dA &d@³                              21      stop slur3                    ³ 
&dA &d@³                              22      start slur4                   ³ 
&dA &d@³                              23      stop slur4                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                 for both kinds of slurs            ³ 
&dA &d@³                                 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ            ³ 
&dA &d@³                               8      force slur1                   ³ 
&dA &d@³                               9      0 = up, 1 = down              ³ 
&dA &d@³                              10      force slur2                   ³ 
&dA &d@³                              11      0 = up, 1 = down              ³ 
&dA &d@³                              12      force slur3                   ³ 
&dA &d@³                              13      0 = up, 1 = down              ³ 
&dA &d@³                              14      force slur4                   ³ 
&dA &d@³                              15      0 = up, 1 = down              ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                 for ties                           ³ 
&dA &d@³                                 ÄÄÄÄÄÄÄÄ                           ³ 
&dA &d@³                              24      specify tie orientation       ³ 
&dA &d@³                              25      0 = overhand; 1 = underhand   ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(16) = subflag 1    bit     item                           ³ 
&dA &d@³                             -----   -------                        ³ 
&dA &d@³                             0-3     ornaments                      ³ 
&dA &d@³                                     ---------                      ³ 
&dA &d@³                                      0 = none                      ³ 
&dA &d@³                                      1 = turn                      ³ 
&dA &d@³                                      2 = trill(tr.)                ³ 
&dA &d@³                                      3 = shake                     ³ 
&dA &d@³                                      4 = mordent                   ³ 
&dA &d@³                                      5 = delayed turn              ³ 
&dA &d@³                                      6 = tremulo  New &dA01/07/06&d@     ³ 
&dA &d@³                                     7-15 (available)               ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                             4-9     accidental combinations        ³ 
&dA &d@³                                        with ornaments              ³ 
&dA &d@³                                     -----------------------        ³ 
&dA &d@³                                     4-6 accidental above ornament  ³ 
&dA &d@³                                     7-9 accidental below ornament  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                     Accidental code                ³ 
&dA &d@³                                     ---------------                ³ 
&dA &d@³                                      0 = none                      ³ 
&dA &d@³                                      1 = sharp-sharp               ³ 
&dA &d@³                                      2 = flat-flat                 ³ 
&dA &d@³                                      3 = sharp                     ³ 
&dA &d@³                                      4 = natural                   ³ 
&dA &d@³                                      5 = flat                      ³ 
&dA &d@³                                      6 = (not used)                ³ 
&dA &d@³                                      7 = (not used)                ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                            10--13   dynamics                       ³ 
&dA &d@³                                     --------                       ³ 
&dA &d@³                                        0 = none                    ³ 
&dA &d@³                                        1 = p                       ³ 
&dA &d@³                                        2 = pp                      ³ 
&dA &d@³                                        3 = ppp                     ³ 
&dA &d@³                                        4 = pppp                    ³ 
&dA &d@³                                        5 = f                       ³ 
&dA &d@³                                        6 = ff                      ³ 
&dA &d@³                                        7 = fff                     ³ 
&dA &d@³                                        8 = ffff                    ³ 
&dA &d@³                                        9 = mp                      ³ 
&dA &d@³                                       10 = mf                      ³ 
&dA &d@³                                       11 = fp                      ³ 
&dA &d@³                                       12 = sfp                     ³ 
&dA &d@³                                       13 = sf                      ³ 
&dA &d@³                                       14 = sfz                     ³ 
&dA &d@³                                       15 = rfz                     ³ 
&dA &d@³                                       16 = ffp                     ³ 
&dA &d@³                                       17 = mfp    (added &dA01/12/09&d@) ³ 
&dA &d@³                                       18 = Zf     (added &dA03/16/09&d@) ³ 
&dA &d@³                                       19--31      (free)           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                            15    print note in square/diamond font ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                            16    print note in cue size            ³ 
&dA &d@³                            17    editorial accidental              ³ 
&dA &d@³                            18    cautionary accidental             ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                            19    accidental follows trill          ³ 
&dA &d@³                                    rather than above or below      ³ 
&dA &d@³                                         (added &dA11/05/05&d@)           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                            20--23   shape of note head             ³ 
&dA &d@³                                     ------------------             ³ 
&dA &d@³                                        0 = regular                 ³ 
&dA &d@³                                        1 = x (cymbal crash)        ³ 
&dA &d@³                                        2 -> (un-assigned)          ³ 
&dA &d@³                                          possibilities include     ³ 
&dA &d@³                                            normal diamond          ³ 
&dA &d@³                                            stem centered diamond   ³ 
&dA &d@³                                            blank (stem only)       ³ 
&dA &d@³                                            18th century            ³ 
&dA &d@³                                        (added &dA02/19/06&d@)            ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                            24    overhand back tie                 ³ 
&dA &d@³                            25    underhand back tie                ³ 
&dA &d@³                                        (added &dA04/22/08&d@)            ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                            26    upright fermata                   ³ 
&dA &d@³                            27    inverted fermata                  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                            28--30   note color                     ³ 
&dA &d@³                                     ----------                     ³ 
&dA &d@³                                       0 = none                     ³ 
&dA &d@³                                       1 = red                      ³ 
&dA &d@³                                       2 = green                    ³ 
&dA &d@³                                       3 = blue                     ³ 
&dA &d@³                                       4 = (unallocated)            ³ 
&dA &d@³                                       5 = RED                      ³ 
&dA &d@³                                       6 = GREEN                    ³ 
&dA &d@³                                       7 = BLUE                     ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(17) = subflag 2    bit     item                           ³ 
&dA &d@³                            -----    -------                        ³ 
&dA &d@³                      n       0      down bow                       ³ 
&dA &d@³                      v       1      up bow                         ³ 
&dA &d@³                      i       2      spiccato                       ³ 
&dA &d@³                      .       3      staccato                       ³ 
&dA &d@³                      =       4      line over dot                  ³ 
&dA &d@³                      _       5      legato                         ³ 
&dA &d@³                      >       6      horizontal accent              ³ 
&dA &d@³                      A       7      vertical sfortzando accent     ³ 
&dA &d@³                      V       8      vertical sfortzando accent     ³ 
&dA &d@³                      o       9      harmonic                       ³ 
&dA &d@³                      Q      10      thumb (*)                      ³ 
&dA &d@³                      0      11      open string (0)                ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                            12-31    fingering (up to 5 numbers)    ³ 
&dA &d@³                                     ----------                     ³ 
&dA &d@³                            12-14    first number                   ³ 
&dA &d@³                                       0 = no number                ³ 
&dA &d@³                                       1 = finger 1                 ³ 
&dA &d@³                                       2 = finger 2                 ³ 
&dA &d@³                                       3 = finger 3                 ³ 
&dA &d@³                                       4 = finger 4                 ³ 
&dA &d@³                                       5 = finger 5                 ³ 
&dA &d@³                              15     substitution bit               ³ 
&dA &d@³                                       0 = no substitution          ³ 
&dA &d@³                                       1 = substitution             ³ 
&dA &d@³                            16-19   (second number, see 12 to 15)   ³       
&dA &d@³                            20-23   (third  number)                 ³ 
&dA &d@³                            24-27   (fourth number)                 ³ 
&dA &d@³                            28-31   (fifth  number)                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(18) = used for sorting, later used to indicate position   ³ 
&dA &d@³                     of virtual note head (for placing slurs and    ³ 
&dA &d@³                     other articulations and signs).  bit 24        ³ 
&dA &d@³                     set if modified                                ³ 
&dA &d@³       ts(19) = used for sorting, later used to indicate global     ³ 
&dA &d@³                     x-offset for chord groups                      ³ 
&dA &d@³       ts(20) = index to ASCII tsdata                               ³ 
&dA &d@³       ts(21) = pass number                                         ³ 
&dA &d@³       ts(22) = backtie flag (for regular, chord and cue notes)     ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                     0 = this note is not backward tied             ³ 
&dA &d@³                     # = this note is backward tied                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                 Actually the BACKTIE flag has multiple uses.       ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                 (1) When the ts array is first being constructed,  ³ 
&dA &d@³                 there may be a tie &dAinto&d@ this group of notes        ³ 
&dA &d@³                 from a previous measure.  In this case, a tiearr   ³ 
&dA &d@³                 ROW element has already been constructed.  The     ³ 
&dA &d@³                 tiearr rows need to be searched and the proper     ³ 
&dA &d@³                 one found.  This index (+ INT10000) is then        ³ 
&dA &d@³                 stored as the backtie flag.                        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                 (2) For all other row elements of the ts array,    ³ 
&dA &d@³                 it is sufficient to store a back pointer to the    ³ 
&dA &d@³                 ts row that originated the tie.                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                 (3) When it comes time to process the ts array,    ³ 
&dA &d@³                 three cases may be encountered.                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                   (a) There is a non-zero backtie flag, and this   ³ 
&dA &d@³                   flag is greater than INT10000.  In this case,    ³ 
&dA &d@³                   the backtie flag (- INT10000) points to a tiearr ³ 
&dA &d@³                   ROW element, and the tie may be processed.       ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                   (b) There is a forward tie from this note.  In   ³ 
&dA &d@³                   this case, the backtie flag has already been     ³ 
&dA &d@³                   used to set a tie and the element is now free    ³ 
&dA &d@³                   for other use.  We can generate a new row element³ 
&dA &d@³                   in tiearr, and place the pointer to this element ³ 
&dA &d@³                   in the backtie flag (the term "backtie" is now   ³ 
&dA &d@³                   a misnomer).                                     ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                   (c) Now when we encounter a non-zero backtie     ³ 
&dA &d@³                   flag in a new ts ROW, we know this points to a   ³ 
&dA &d@³                   previous ts row, from which we can get the       ³ 
&dA &d@³                   pointer to the relevant tiearr ROW in that       ³ 
&dA &d@³                   ts(,.BACKTIE).                                   ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                 For this method to work properly, it is            ³ 
&dA &d@³                 necessary that backward ties be processed before   ³ 
&dA &d@³                 forward ties.  When a backward tie is processed    ³ 
&dA &d@³                 it is important to set the backtie flag to zero.   ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(23) = note duration (in divisions)                        ³ 
&dA &d@³       ts(24) = increment distance flag                             ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                0 -- fixed distance (not to be modified by print)   ³ 
&dA &d@³                # -- variable distance; # = time elaps between      ³ 
&dA &d@³                     this  node and next node.                      ³ 
&dA &d@³                     (576 divisions = quarter note)                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(25) = virtual end of stem (bit 24 set if modified)        ³ 
&dA &d@³       ts(26) = editorial version of ts(16), subflag 1              ³ 
&dA &d@³       ts(27) = editorial version of ts(17), subflag 2              ³ 
&dA &d@³       ts(28) = staff number                                        ³ 
&dA &d@³       ts(29) = multi-track flag << 2 + mcat flag                   ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                multi-track flag                                    ³ 
&dA &d@³                ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ                                    ³ 
&dA &d@³                0 = this note lies on a staff that has notes from   ³ 
&dA &d@³                     only one pass (the simplest and most common    ³ 
&dA &d@³                     situation).                                    ³ 
&dA &d@³                1 = this note belongs to one of multiple passes     ³ 
&dA &d@³                     on this staff and all notes on this pass       ³ 
&dA &d@³                     have stems which point up                      ³ 
&dA &d@³                2 = this note belongs to one of multiple passes     ³ 
&dA &d@³                     on this staff and all notes on this pass       ³ 
&dA &d@³                     have stems which point down                    ³ 
&dA &d@³                3 = this note belongs to one of multiple passes     ³ 
&dA &d@³                     on this staff and the notes for at least one   ³ 
&dA &d@³                     of these passes have stem directions which     ³ 
&dA &d@³                     are both up and down                           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                mcat flag                                           ³ 
&dA &d@³                ÄÄÄÄÄÄÄÄÄ                                           ³ 
&dA &d@³                0 = only one independent instrument represented     ³ 
&dA &d@³                     in this measure (vflag = 1)                    ³ 
&dA &d@³                1 = more than one independent instrument (vflag > 1)³ 
&dA &d@³                     but only one pass and without chords (either   ³ 
&dA &d@³                     unison part, or single part)                   ³ 
&dA &d@³                2 = more than one independent instrument (vflag > 1)³ 
&dA &d@³                     but only one pass but with chords (more than   ³ 
&dA &d@³                     one part, but parts are isorhythmic)           ³ 
&dA &d@³                3 = more than one independent instrument (vflag > 1)³ 
&dA &d@³                     and more than one pass (two or more musically  ³ 
&dA &d@³                     independent parts)                             ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(30) = spacing parameter (1 <= spn <= 6913)                ³ 
&dA &d@³       ts(31) = y position of object (saves time in proc. chords)   ³ 
&dA &d@³       ts(32) = pointer to extra ts() row element for storing data  ³ 
&dA &d@³                  on slurs.  Elements 1-6 of new element are for    ³ 
&dA &d@³                  storing global data on slurs entering and leaving ³ 
&dA &d@³                  the note.  Elements 7-42 are taken in groups of   ³ 
&dA &d@³                  three (expanded from two in &dA05/06/03&d@ code revi-   ³ 
&dA &d@³                  sion), making a total of 12 such groups.  Each    ³ 
&dA &d@³                  group describes a slur entering or leaving this   ³ 
&dA &d@³                  note.  The first element in the group contains    ³ 
&dA &d@³                  general information + the x-offset; the second    ³ 
&dA &d@³                  element in the group contains the y-offset.  The  ³ 
&dA &d@³                  third element in the group contains the integer   ³ 
&dA &d@³                  equivalent of the 4-byte print suggestion for     ³ 
&dA &d@³                  the slur.  See &dATS32&d@ for more information.         ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(33) = node shift flag (positive and negative values)      ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(34) = track number: 0 if not present                      ³ 
&dA &d@³       ts(35) = base-40 pitch                                       ³ 
&dA &d@³       ts(36) = displacement of note head from the definitive       ³ 
&dA &d@³                    node position (related to GLOBAL_XOFF)          ³ 
&dA &d@³                  Value = -100  if the displacement is (approx.)    ³ 
&dA &d@³                                  one notehead to the left <--      ³ 
&dA &d@³                  Value = 100   if the displacement is (approx.)    ³ 
&dA &d@³                                  one notehead to the right -->     ³ 
&dA &d@³                  Otherwise Value = a * INT10000 + b where          ³ 
&dA &d@³                    a = width of notehead in dots                   ³ 
&dA &d@³                    b = displacement (right or left) meas. in dots  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(39) = tsr pointer                                         ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³     Case II:  Figures                                              ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(1) = 9                                                   ³ 
&dA &d@³        ts(2) = division number (starting with 1)                   ³ 
&dA &d@³        ts(3) = number of figures in this chord                     ³ 
&dA &d@³        ts(4) = space parameter                                     ³ 
&dA &d@³        ts(5) = first figure -- position one                        ³ 
&dA &d@³        ts(6) = first figure -- position two                        ³ 
&dA &d@³        ts(7) = first start/stop flag for continuation line         ³ 
&dA &d@³        ts(8) = second figure -- position one                       ³ 
&dA &d@³        ts(9) = second figure -- position two                       ³ 
&dA &d@³       ts(10) = second start/stop flag for continuation line        ³ 
&dA &d@³       ts(11) = third figure -- position one                        ³ 
&dA &d@³       ts(12) = third figure -- position two                        ³ 
&dA &d@³       ts(13) = third start/stop flag for continuation line         ³ 
&dA &d@³       ts(14) = fourth figure -- position one                       ³ 
&dA &d@³       ts(15) = fourth figure -- position two                       ³ 
&dA &d@³       ts(16) = fourth start/stop flag for continuation line        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³              figure field:  0 = blank                              ³ 
&dA &d@³                          1-19 = figure                             ³ 
&dA &d@³                            20 = +                                  ³ 
&dA &d@³                            21 = x                                  ³ 
&dA &d@³                            22 = 2+                                 ³ 
&dA &d@³                            23 = sharp                              ³ 
&dA &d@³                            24 = 4+                                 ³ 
&dA &d@³                            25 = 5+                                 ³ 
&dA &d@³                            26 = 6\                                 ³ 
&dA &d@³                            27 = 7\                                 ³ 
&dA &d@³                            28 = natural                            ³ 
&dA &d@³                            29 = flat                               ³ 
&dA &d@³                            30 = short continuation line (-)        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³              Adding 1000 to figure field (position one) indicates  ³      
&dA &d@³                small parantheses around the field.                 ³ 
&dA &d@³              Adding 2000 to figure field (position one) indicates  ³      
&dA &d@³                large parantheses this figure and the one below it. ³ 
&dA &d@³              Adding 3000 to figure field (position one) indicates  ³      
&dA &d@³                large parantheses this figure and the two below it. ³ 
&dA &d@³                                                (Added &dA11/16/03&d@)    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³              start/stop continuation flag:  0 = none               ³ 
&dA &d@³                                             1 = stop               ³ 
&dA &d@³                                             2 = start              ³ 
&dA &d@³                                             3 = continue           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(20) = minimum space for figure group                      ³ 
&dA &d@³       ts(21) = pass number                                         ³ 
&dA &d@³       ts(23) = figure duration in divisions (0 if not given)       ³ 
&dA &d@³       ts(24) = increment distance flag (see notes)                 ³ 
&dA &d@³       ts(28) = staff number                                        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³     Case III:  Bar Lines                                           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(1) = 10                                                  ³ 
&dA &d@³        ts(2) = division number (starting with 1)                   ³ 
&dA &d@³        ts(3) = bar number (0 = none)                               ³ 
&dA &d@³        ts(4) = bar type                                            ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                    1 = regular      5 = double regular             ³ 
&dA &d@³                    2 = heavy        6 = regular-heavy              ³ 
&dA &d@³                    3 = dotted       9 = heavy-regular              ³ 
&dA &d@³                                    10 = heavy-heavy                ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(5) = repeat flag                                         ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                    0 = no repeats       1 = forward repeat         ³ 
&dA &d@³                    2 = back repeat      3 = both repeats           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(6) = backward ending flag                                ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                    0 = no ending                                   ³ 
&dA &d@³                    # = ending number: positive = stop ending       ³ 
&dA &d@³                                       negative = discontinue       ³ 
&dA &d@³                                                     ending         ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(7) = forward ending flag                                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                    0 = no ending                                   ³ 
&dA &d@³                    # = ending number                               ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(8) = flags                                               ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                  bit         set           clear                   ³ 
&dA &d@³                 -----    ------------     -------                  ³ 
&dA &d@³                   0      continue ~~~      stop ~~~                ³ 
&dA &d@³                   1      segno sign         0                      ³ 
&dA &d@³                   2      fermata over bar   0                      ³ 
&dA &d@³                   3      fermata under bar  0                      ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(9) = space parameter (important for non-contr. bars)     ³ 
&dA &d@³       ts(10) = number over previous measure: 0 = none              ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(20) = index to ASCII tsdata   &dKtaken out&d@,                  ³ 
&dA &d@³                                        &dAthen put back&d@  &dA03/21/03&d@     ³ 
&dA &d@³                   The reason for putting this back is that         ³ 
&dA &d@³                   we need an ASCII string to communicate           ³ 
&dA &d@³                   the NTRACK data that goes with the barline       ³ 
&dA &d@³                   object.                                          ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(21) = pass number                                         ³ 
&dA &d@³       ts(28) = number of staves                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³     Case IV:  Signs, Words, Marks                                  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(1) = type   sign = 11, words = 12, mark = 13             ³ 
&dA &d@³        ts(2) = division number (starting with 1)                   ³ 
&dA &d@³        ts(3) = vertical position flag:  1 = below line             ³ 
&dA &d@³                                         2 = above line             ³ 
&dA &d@³        ts(4) = sign number                                         ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                  0 = no sign                                       ³ 
&dA &d@³                  1 = segno                                         ³ 
&dA &d@³                  2 = ped                                           ³ 
&dA &d@³                  3 = *                                             ³ 
&dA &d@³                  4 = other letter dynamics                         ³ 
&dA &d@³                  5 = D.S or D.C. (right justified string)          ³ 
&dA &d@³                  6 = fine (centered string)                        ³ 
&dA &d@³                  7 = words (left justified string)                 ³ 
&dA &d@³                  8 = tie terminator       (added &dA10-12-96&d@)         ³ 
&dA &d@³                  9 = rehearsal mark (left justified + box)         ³ 
&dA &d@³                                           (added &dA02-03-08&d@)         ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(5) = super flag                                          ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                  0 = no super-object                               ³ 
&dA &d@³                  1 = start wedge                                   ³ 
&dA &d@³                  2 = stop wedge                                    ³ 
&dA &d@³                  3 = start dashes (after words)                    ³ 
&dA &d@³                  4 = stop dashes                                   ³ 
&dA &d@³                  5 = start 8ve up                                  ³ 
&dA &d@³                  6 = stop  8ve up                                  ³ 
&dA &d@³                  7 = start 8ve down                                ³ 
&dA &d@³                  8 = stop  8ve down                                ³ 
&dA &d@³                  9 = start 15 up                                   ³ 
&dA &d@³                 10 = stop  15 up                                   ³ 
&dA &d@³                 11 = start 15 down                                 ³ 
&dA &d@³                 12 = stop  15 down                                 ³ 
&dA &d@³                 13 = normal transposition (temporary flag)         ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(6) = parameter for words:  optional font designation     ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(7) = wedge offset  (for cases where a wedge begins after ³ 
&dA &d@³                                or stops at a letter dynamic)       ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(8) = track number  (useful for multiple wedges, dashes   ³ 
&dA &d@³                                or transpositions of the same type) ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(9) = spacing (for case of isolated mark)                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(10) = parameter for wedges: wedge spread                  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(11) = parameter for musical directions which are          ³ 
&dA &d@³                  objects: position shift                           ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(12) = special flag for case where this element is         ³ 
&dA &d@³                  isolated on a division (possibly with other       ³ 
&dA &d@³                  members of this same group).                      ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(13) = parameter for musical directions which are          ³ 
&dA &d@³                  super-objects: position shift                     ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(20) = index to ASCII tsdata                               ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(21) = pass number                                         ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(22) = backtie flag (for tie terminators) (added &dA10-12-96&d@) ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       ts(28) = staff number                                        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³     Case V:  Clef change in middle of a measure                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(1) = type = 14                                           ³ 
&dA &d@³        ts(2) = division number (starting with 1)                   ³ 
&dA &d@³        ts(3) = clef number                                         ³ 
&dA &d@³        ts(4) = clef font number                                    ³ 
&dA &d@³        ts(5) = transpostion flag:                                  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                   1 = notes written octave higher than sound       ³ 
&dA &d@³                   0 = notes written at sound                       ³ 
&dA &d@³                  -1 = notes written octave lower than sound        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(6) = position on staff                                   ³ 
&dA &d@³        ts(9) = space parameter                                     ³ 
&dA &d@³       ts(20) = index to ASCII tsdata                               ³ 
&dA &d@³       ts(21) = pass number                                         ³ 
&dA &d@³       ts(28) = staff number                                        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³     Case VI:  Time designation in middle of a measure              ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(1) = type = 15                                           ³ 
&dA &d@³        ts(2) = division number (starting with 1)                   ³ 
&dA &d@³        ts(9) = space parameter                                     ³ 
&dA &d@³       ts(20) = index to ASCII tsdata                               ³ 
&dA &d@³       ts(21) = pass number                                         ³ 
&dA &d@³       ts(28) = staff number                                        ³ 
&dA &d@³                                                                    ³ 
&dA &d@³     Case VII:  Meter change in middle of a measure                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(1) = type = 16                                           ³ 
&dA &d@³        ts(2) = division number (starting with 1)                   ³ 
&dA &d@³        ts(3) = time number (100 time numerator + denominator)      ³ 
&dA &d@³        ts(9) = space parameter                                     ³ 
&dA &d@³       ts(20) = index to ASCII tsdata                               ³ 
&dA &d@³       ts(21) = pass number                                         ³ 
&dA &d@³       ts(28) = number of currently active staves                   ³ 
&dA &d@³                                                                    ³ 
&dA &d@³     Case VIII:  Change in number of divisions per quarter          ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(1) = type = 17                                           ³ 
&dA &d@³        ts(2) = division number (starting with 1)                   ³ 
&dA &d@³        ts(3) = divisions per quarter                               ³ 
&dA &d@³        ts(9) = space parameter                                     ³ 
&dA &d@³       ts(20) = index to ASCII tsdata                               ³ 
&dA &d@³       ts(21) = pass number                                         ³ 
&dA &d@³                                                                    ³ 
&dA &d@³       Case IX:  Change in key signature                            ³ 
&dA &d@³                                                                    ³ 
&dA &d@³        ts(1) = type = 18                                           ³ 
&dA &d@³        ts(2) = division number (starting with 1)                   ³ 
&dA &d@³        ts(3) = new key signature                                   ³ 
&dA &d@³        ts(4) = old key signature                                   ³ 
&dA &d@³        ts(9) = space parameter                                     ³ 
&dA &d@³       ts(20) = index to ASCII tsdata                               ³ 
&dA &d@³       ts(21) = pass number                                         ³ 
&dA &d@³       ts(28) = number of currently active staves                   ³ 
&dA &d@³                                                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure action   
        str temp2.160 
        str slurlet.1 
        str xbyte.2,note.4,codes.12 

        int tvar1,tvar2 
        int mf2(120) 
        int multichk(3,MAX_PASS,MAX_STAFF) 
        int tiearr(MAX_TIES,TIE_ARR_SZ) 
        int figarr(MAX_FIG,4)
        int sitf 
        int tclaveax(50) 
        int dv4 
        int beamfont 
        int a3,a4,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16 
        int save_a4 
        int y1,y2,z1 
        int olda1 
        int passpar(MAX_PASS) 
        int firstsp,tfirstsp 
        int divpoint,totdiv,cuediv,mdiv,qflag 
        int figdiv,smusdir(30,4) 
        int ctrarrf(MAX_PASS),try(MAX_PASS) 
        int nodtype 
        int sobx2
        int obx1,obx2,oby1,oby2 
        int chorddur 
        int sflag,mcat 
        int xposi_shift,yposi_shift 
        int save_xposi_shift       
        int repeater_flag2 
        int repeater_dot_flag                         
        int repeater_dot_flag2                        
        int chord_spread,mdir_offset 
        int profile(100,2) 
        int sgroup(13,3),nsgroups 
        int curve       
        int npasses,thispass,passcnt(MAX_PASS,3) 
        int pitchcnt(10) 
        int clashes(10,10) 
        int tgroup(10),ntgroups 
        int ps_passcount(2) 
        int oldgr(2,45) 
        int ttextcnt 
        str ttextarr.80(6) 
        str xbytearr.2(6) 
        str chord_tones.4(10) 
        int chordsize,last_chordsize,chordsize2 
        int checkoff(10) 
        int restplace2 
        int inctype_rem 
        int org_c4 
        int nspace(MAX_M,8) 
        int old_c2 
        int color_flag2         
        bstr tbit1.2000,tbit2.2000 
        real r1,r2,r3
&dA     
        int t1,t2,t3,t4,t5,t6,t7,t8      
        if @n = 0  
          goto ACT_RETURN 
        end  
        passnum = 1  
        yposi_shift = 0 
        xposi_shift = 0 
&dA 
&dA &d@   If there are no pending slurs, then clear the ts array and set sct = 0 
&dA 
        if sct = 0 
          loop for a9 = 1 to MAX_OBJECTS 
            loop for a10 = 1 to TS_SIZE 
              ts(a9,a10) = 0 
            repeat 
            tsr(a9) = zpd(TSR_LENG)             /* &dA05/02/03&d@: was zpd(72)         
            ts(a9,TSR_POINT) = a9 
          repeat 
          outslurs = "00000000" 
        else 
          if outslurs = "00000000" 
            if sct > maxsct 
              maxsct = sct 
            end 
            loop for a9 = 1 to maxsct + 10   
              loop for a10 = 1 to TS_SIZE 
                ts(a9,a10) = 0 
              repeat 
              tsr(a9) = zpd(TSR_LENG)           /* &dA05/02/03&d@: was zpd(72)       
              ts(a9,TSR_POINT) = a9 
            repeat 
            sct = 0 
            old@n = 0 
          else 
            if sct > maxsct 
              maxsct = sct 
            end 
            loop for a9 = sct+1 to maxsct+10 
              loop for a10 = 1 to TS_SIZE 
                ts(a9,a10) = 0 
              repeat 
              tsr(a9) = zpd(TSR_LENG)           /* &dA05/02/03&d@: was zpd(72)     
              ts(a9,TSR_POINT) = a9 
            repeat 
          end 
        end 
        oldsct = sct 
&dA 
&dA &d@   If you are starting a new version of the ts(.) array then 
&dA &d@     copy claveax(.) to tclaveax(.)   &dA12/14/07&d@ 
&dA 
        if sct = 0 
          loop for a9 = 1 to 50 
            tclaveax(a9) = claveax(a9) 
          repeat 
        end 
&dA           

&dA 
&dA &d@   Store original data in set array 
&dA 
        divpoint = 1 
        figdiv = 0
        cuediv = 0 
        totdiv = 1 
        qflag = 0
        divspq = olddivspq

        loop for a9 = 1 to @n    
          tsdata(a9+old@n) = "" 
          line = tdata(a9,1) 
          tvar1 = tv1(a9)    
          tvar2 = tv2(a9)  
&dA 
&dA &d@   New code &dA12/20/10&d@ dealing with (real) color 
&dA 
          if tv3(a9) > 0xffff 
            if tvar1 <= NOTE_OR_REST 
              c5 = tv3(a9) >> 16           /* 1 <= c5 <= 7  (three colors, two modes)
              c5 <<= 28 
              ts(sct+1,SUBFLAG_1) |= c5    /* sct hasn't been incremented yet
            end 
            tv3(a9) &= 0xffff 
          end 
&dA      
          if tv3(a9) > 0xff 
            if tvar1 <= NOTE_OR_REST 
              if tvar1 = REST or tvar1 = CUE_REST 
                restplace2 = tv3(a9) >> 8 
              else 
                repeater_flag2 = tv3(a9) >> 8            /* changed &dA01/01/08
              end 
            else 
              mdir_offset = tv3(a9) >> 8 
            end 
            tv3(a9) &= 0xff 
          else 
            repeater_flag2 = 0 
            restplace2 = 0 
            mdir_offset = 0 
          end 
&dA 
&dA &d@  Deal with situation where there is an irest followed by a 
&dA &d@  print suggestion that it should be allocated space 
&dA 
          if tvar1 = IREST 
            if a9 < @n and tv1(a9+1) = P_SUGGESTION 
              if tv2(a9+1) & 0xff00 = 0x0300 
                pcontrol = ors(tcode(a9+1){1}) 
                if pcontrol = 3 or pcontrol = 5 
                  tvar1 = REST                  /* send it through the system
                  tcode(a9) = "rest"            /* as a "regular" rest 
                end 
              end 
            end 
          end        
&dA &d@              
&dA &d@  Case I:  notes, rests, cue notes, grace notes,  
&dA &d@              extra notes in chords, figures  
&dA 
          if tvar1 <> FIGURES and tvar1 <> P_SUGGESTION 
            figdiv = 0 
          end  
          if tvar1 <= NOTE_OR_REST
            loop for a3 = 1 to 7 step 3  
              a4 = a3 + 1  
              if tvar1 = a4        /* extra chord tone 
                if a9 = 1  
                  tmess = 1 
                  perform dtalk (tmess) 
                end  
                c5 = 1 
                loop while tv1(a9-c5) = P_SUGGESTION and a9 > c5 + 1 
                  ++c5 
                repeat 
                if tv1(a9-c5) <> a3   
                  if tv1(a9-c5) <> a4   
                    tmess = 1 
                    perform dtalk (tmess) 
                  end  
                else 
*  tricky code to set chord bit on first note in chord 
                  ts(sct,STEM_FLAGS) += 4   /* sct -> previous array entry 
                end        
              end  
            repeat 
            ++sct                                 /* &dIincrementing array pointer &dAsct
            ts(sct,TYPE) = tvar1   
&dA 
&dA &d@    &dASet DIV&d@ (for cue notes) 
&dA 
            if chr(tvar1) in [CUE_NOTE,XCUE_NOTE,CUE_REST] 
              if tvar1 <> XCUE_NOTE
                ts(sct,DIV) = divpoint + cuediv 
              else 
                ts(sct,DIV) = divpoint + cuediv - chorddur 
              end 
              goto WWCC 
            end  
&dA 
&dA &d@    &dASet DIV&d@ (for regular and grace notes) 
&dA 
            if tvar1 = XNOTE 
              ts(sct,DIV) = divpoint - chorddur 
            else 
              ts(sct,DIV) = divpoint 
            end 

            cuediv = 0 
&dA 
&dA &d@    In special case of arpeggios &dA01/13/06&d@, get vertical veriables 
&dA 
            if tvar1 = GR_NOTE and tvar2 = ARPEGGIO 
              if line{1} = " " 
                ts(sct,ARPEG_TOP) = int(line{2}) 
              else 
                ts(sct,ARPEG_TOP) = int(line{1,2}) 
              end 
              if line{3} = "x" 
                ts(sct,ARPEG_FLAG) = granddist 
              else 
                ts(sct,ARPEG_FLAG) = 0 
              end 
              if line{4} = " " 
                ts(sct,ARPEG_BOTTOM) = int(line{5}) 
              else 
                ts(sct,ARPEG_BOTTOM) = int(line{4,2}) 
              end 
              line{1,7} = "e      " 
            end 
&dA     

&dA 
&dA &d@     Normally at this point, we would decode the note and get  
&dA &d@     its clave number and accidental.  The reason we cannot safely  
&dA &d@     do this at this time is that the backspace command might 
&dA &d@     cause us to insert some accidentals at earlier points in 
&dA &d@     the measure.  Because of the current order, these notes  
&dA &d@     would not be accidentalized, whereas a later one (from     
&dA &d@     an earlier pass) would be.  Also, we would like to allow 
&dA &d@     the various passes to run through non-controlling bar  
&dA &d@     lines.  In any event, we must put off decoding and other 
&dA &d@     calculations that depend on this data until the entries  
&dA &d@     can be ordered by time.  In the meantime, we will store  
&dA &d@     the a pointer to the proper tcode element in ts(4)  
WWCC: 
            ts(sct,TEMP4) = a9 
            a4 = tvar2                  /* duration field, in this case 
            if tvar1 > REST                  
              a5 = tvar2                /* this will become NTYPE 

              if chr(tvar1) in [CUE_NOTE,CUE_REST] 
&dA 
&dA &d@          We must, in this case, try to assign a length to the 
&dA &d@          cue-type entity in terms of the current value of divspq.  
&dA &d@          The parameter, a4, indicates the note type: 
&dA 
&dA &d@                 1 = 256th note      7 = quarter note 
&dA &d@                 2 = 128th note      8 = half note 
&dA &d@                 3 = 64th note       9 = whole note 
&dA &d@                 4 = 32nd note      10 = breve 
&dA &d@                 5 = 16th note      11 = longa 
&dA &d@                 6 = 8th note 
&dA 
&dA &d@          Columns 4-6 of the variable line contain tuple modifications 
&dA &d@          to the note value 
&dA 
                --a4
                a3 = 1 << a4  
&dA 
&dA &d@           a3 = 64 -->  means quarter note, etc.  
&dA 
                a3 *= divspq 
&dA 
&dA &d@           a3 --> length of notetype as measured in units (64*divspq) 
&dA 
                if line{4} <> " " 
                  a4 = int(line{4}) 
                  if line{4} in ['A'..'Z'] 
                    a4 = ors(line{4}) - 55   /* A = 10, etc 
                  end 
                  a8 = a4 / 3 
               /* default values for "denominator" 
                  if rem = 0 
                    a8 *= 2 
                  else 
                    a8 = a4 - 1 
                  end 
                  if line{6} <> " " 
                    a8 = int(line{6}) 
                    if line{6} in ['A'..'Z'] 
                      a8 = ors(line{6}) - 55   /* A = 10, etc 
                    end 
                  end 
                  a3 *= a8 
                  a3 /= a4 
                  if rem <> 0 
                    tmess = 23 
                    perform dtalk (tmess) 
                  end 
                end 
&dA 
&dA &d@           a3 --> length of note measured in units (64*divspq) 
&dA &d@                    as modified by tuple information 
&dA 
                if ".:;!" con line{2}              /*  code modified &dA12-24-96
                  if mpt = 1 
                    a3 = a3 / 2 * 3 
                  else 
                    if mpt = 2 
                      a3 = a3 / 4 * 7 
                    else 
                      if mpt = 3 
                        a3 = a3 / 8 * 15 
                      else       
                        a3 = a3 / 16 * 31 
                      end 
                    end 
                  end 
                end  
&dA 
&dA &d@           a3 --> length of note measured in units (64*divspq) 
&dA &d@                    as further modified by dot information 
&dA 
                chorddur = a3 / 64 
                if rem <> 0 
                  tmess = 23 
                  perform dtalk (tmess) 
                end 
&dA 
&dA &d@               chorddur --> length of measured in units (divspq) 
&dA 
                cuediv += chorddur 
              end  
            else 
              if tvar1 <> XNOTE
                chorddur = a4  
                divpoint += a4 
                if divpoint > totdiv 
                  totdiv = divpoint  
                end  
              end  
&dA 
&dA &d@   &dA01/08/11&d@ Here is where we separate modern notation from diamond notation
&dA 
&dK &d@             if "zyxtseqhwbL" con line{1} 
&dK &d@               a5 = mpt 
&dK 
              if "zyxtseqhwbLMZYXTSEQHWB" con line{1} 
                a5 = mpt                /* this will become NTYPE 
                if a5 >= 12 
                  ts(sct,SUBFLAG_1) |= 0x008000     /* set square/diamond flag
                  if a5 > 12 
                    a5 -= 12 
                  end 
                end 
&dA     
              else 
                if "123456789AB" con line{1} 
                  a5 = mpt              /* this will become NTYPE 
                  ts(sct,SUBFLAG_1) |= 0x010000     /* set small print flag 
                else 
                  if tvar1 = REST 
&dA                            
&dA 
&dA &d@    New &dA10/15/07&d@ 
&dA 
                    if len(line) > 0 
                      if "ZYXTSEQHWB" con line{1} 
                        a5 = mpt                /* this will become NTYPE with flag
                        a5 += 0x100 
                      else 
&dA 
&dA &d@    Code modified &dA01/03/04&d@ to deal with optional whole rests 
&dA 
                        if line{1} = "o"                         /* o = float New &dA10/15/07
                          ts(sct,CLAVE) = 2   /* temporary floating rest with optionality
                        else 
                          ts(sct,CLAVE) = 1   /* temporary floating rest flag
                        end 
&dA   
                        a5 = WHOLE          /* this will become NTYPE 
                      end 
                    end 
                  else 
                    tmess = 24              /* Note type is missing.  
                    perform dtalk (tmess) 
                  end 
                end 
              end  
            end  
&dA 
&dA &d@    &dASet NTYPE
&dA 
            ts(sct,NTYPE) = a5  
&dA 
&dA &d@    &dASet STAFFLOC (for rests)&d@ 
&dA 
            if tvar1 = REST or tvar1 = CUE_REST 
              ts(sct,STAFFLOC) = restplace2 
            end 
&dA 
&dA &d@    &dASet NOTE_DUR&d@ 
&dA 
            if chr(tvar1) in [GR_NOTE,XGR_NOTE] 
              ts(sct,NOTE_DUR) = 0 
            else 
              ts(sct,NOTE_DUR) = chorddur 
            end 
                
            a8 = int(line{4}) 
            if line{4} in ['A'..'Z'] 
              a8 = ors(line{4}) - 55 
            end 
            if a8 > 0 
&dA 
&dA &d@     Code added to account for complex tuples: 5-11-93 
&dA 
              a3 = int(line{6}) 
              if line{6} in ['A'..'Z'] 
                a3 = ors(line{6}) - 55   /* A = 10, etc 
              end 
              a3 *= 256                     /* New &dA11/05/05&d@ 
&dA 
&dA &d@    &dASet TUPLE
&dA 
              ts(sct,TUPLE) = a8 + a3 
            end 
&dA 
&dA &d@    &dASet DOT&d@            
&dA 
            if ".^:^^^;^^^^^^^!" con line{2}     /*  code modified &dA12-24-96&d@ 
              ts(sct,DOT) = mpt    /* 1 = single dot; 3 = double dot; 7 = triple dot; 15 =
            end 
            if tcode(a9) <> "rest" and tcode(a9) <> "ires" 

&dAÕÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¸&d@ 
&dA³&d@     This calculation must be delayed until after the decoding   &dA³&d@ 
&dA³&d@     ---------------------------------------------------------   &dA³&d@ 
&dA³&d@             a1 = 52 - ts(sct,3) - cline(.) + c8flag(.)          &dA³&d@ 
&dA³&d@             ts(sct,8) = a1 * notesize / 2                       &dA³&d@ 
&dAÔÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¾&d@ 

&dA 
&dA &d@    &dASet STEM_FLAGS&d@   (incomplete) 
&dA 
              a1 = 0 
&dA 
&dA &d@    New code &dA12/20/05&d@ implementing general suggestion for setting stem directions
&dA 
              if stem_change_flag = 0 or stem_change_flag = 3 
                if "u@d" con line{7}     /*  stem direction "u" or "d" 
                  a1 = mpt 
                end 
              else 
                if stem_change_flag = 1
                  a1 = 0 
                else 
                  a1 = 2 
                end 
              end 
&dA       
              if tvar1 = XNOTE   
                a1 += 12 
              end  
              ts(sct,STEM_FLAGS) = a1 
&dA 
&dA &d@    &dASet BEAM_FLAG&d@ 
&dA 
              if "][=" con line{10}  
                ts(sct,BEAM_FLAG) = mpt  
              else 
                ts(sct,BEAM_FLAG) = NO_BEAM 
              end  
&dA 
&dA &d@    &dASet BEAM_CODE&d@ 
&dA 
              a4 = 0 
              if ts(sct,BEAM_FLAG) > NO_BEAM 
                if "[]=" con line{10} 
                  a3 = 1 
                  loop for a1 = 10 to 15 
                    if " =[]/\" con line{a1} 
                      a4 = mpt - 1 * a3 + a4 
                    end 
                    if mpt = 1 
                      a1 = 15 
                    else 
                      a3 *= 10 
                    end 
                  repeat 
                end 
              end 
              ts(sct,BEAM_CODE) = a4 
&dA 
&dA &d@     &dAI think this is the place to alter the ts array, in the case where&d@ 
&dA &d@     &dAa repeater is requested                                           
&dA 
              if repeater_flag2 > 0 and ts(sct,BEAM_FLAG) = END_BEAM 
                repeater_dot_flag = 0 
                a3 = repeater_flag2 & 0x03 
                if a3 = 3                       
                  repeater_dot_flag = 1 
                end 
&dA 
&dA &d@     Decision Point No. 1:  Decide if repeaters are possible 
&dA 
                a3 = 1 
REP2: 
                if a4 / a3 > 9 
                  a3 *= 10 
                  goto REP2 
                end 
                c6 = bit(1,ts(sct,STEM_FLAGS)) 
                c7 = ts(sct,NTYPE) 
&dA 
&dA &d@      For purposes of the code that follows, we need to keep track of the 
&dA &d@      subscripts which point to real data (i.e. not print suggestions) 
&dA &d@      in the data(.), tcode(.), and tv(.) arrays.  We will store these 
&dA &d@      "valid" subscripts in the mf(.) array.  
&dA 
                c10 = a9 
                c2  = 0                            /* counter for primary type 
                c4  = 100                          /* secondary beam break flag
                c14 = 100                          /* secondary beam break flag for threesomes (&dA09/21/08&d@)
                repeater_dot_flag2 = 0             /* added &dA09/21/08&d@ 

                loop for a1 = sct to 1 step -1     /* Two exits from this loop:     
                                                   /*   To REP1 when ts(a1,BEAM_FLAG) = START_BEAM (below)
                                                   /*   to NO_REP whenever a test "fails"
                  loop while tv1(c10) = P_SUGGESTION 
                    --c10 
                  repeat 
                  mf(a1) = c10
                  --c10 

                  if ts(a1,TYPE) < tvar1 or ts(a1,TYPE) > tvar1 + 1 
                    goto NO_REP 
                  end 
                  if ts(a1,TYPE) = tvar1
                    if ts(a1,TUPLE) <> 0 
                      c4 = 100000 + (ts(a1,TUPLE) & 0xffff) 
                    end 
                    a5 = ts(a1,BEAM_CODE) / a3 
                    if a5 > 3 or a5 = 0 
                      goto NO_REP 
                    end 
                    if a1 < sct and a5 = 3 and c4 < 100000  /* secondary beam ends and starts again
                      if c4 = 100 
                        c4 = 16 
                      end 
                      if c14 = 100          /* New &dA09/21/08&d@ 
                        c14 = 6 
                      end 
&dA           
&dA 
&dA &d@    &dA09/21/08&d@ Working on repeaters:  In the case of secondary beam endings, the following (existing)
&dA &d@             code allows endings only in multiples of 2.  Since multiple passes are made
&dA &d@             through this code, c4 becomes the smallest group size.  Specifically, this
&dA &d@             prevents group sizes of 3 and 6, which common enough to consider.            
&dA 
                      loop while c4 > 1 
                        c5 = c2 / c4 
                        if rem <> 0 
                          c4 >>= 1 
                        end 
                      repeat while rem <> 0 
&dA 
&dA &d@    &dA09/21/08&d@ I think the solution is to run twosome and threesome tests in parallel. 
&dA &d@             A jump to NO_REP occurs when both tests fail.  I will use c14 for this
&dA &d@             test.  (New code) 
&dA 
                      loop while c14 > 1 
                        c5 = c2 / c14 
                        if rem <> 0 
                          c14 >>= 1 
                        end 
                      repeat while rem <> 0 
                      if c4 = 1 and c14 = 1      /* c14 test added &dA09/21/08&d@ 
                        goto NO_REP 
                      end 
&dA 
&dA          
                    end 
                    ++c2 
                    mf2(c2) = a1 
                  end 
                  if bit(1,ts(a1,STEM_FLAGS)) <> c6 or ts(a1,NTYPE) <> c7 or ts(a1,DOT) > 0
                    goto NO_REP 
                  end 
                  codes = tdata(mf(a1),1){16,12} 
                  if ts(a1,BEAM_FLAG) = START_BEAM 
                    if codes con ['~',','] 
                      goto NO_REP 
                    end 
                    if codes con ['b','c','h'..'k','n','o','r'..'z','A','M','Q','S','V']
                      goto NO_REP 
                    end 
                    goto REP1 
                  end 
                  if ts(a1,BEAM_FLAG) = END_BEAM 
                    if codes con ['-','(','[','{','~','>','.','_','=',','] 
                      goto NO_REP 
                    end 
                  else 
                    if codes con ['-','(',')','[',']','{','}','~','>','.','_','=','0'..'5',',',':']
                      goto NO_REP 
                    end 
                  end 
                  if codes con ['b','c','f','h'..'z','A','E','F','M','Q'..'S','V','Z']
                    goto NO_REP 
                  end 
                repeat 
&dA 
&dA &d@     Case 1:  Check to see if all chords under the beam are the same 
&dA 
REP1: 
                chordsize = 1 
                chord_tones(1) = tcode(mf(a1)) 
                loop for a2 = a1 + 1 to sct 
                  if ts(a2,TYPE) = tvar1 
                    a2 = sct 
                  else 
                    ++chordsize 
                    chord_tones(chordsize) = tcode(mf(a2)) 
                  end 
                repeat 
&dA 
&dA &d@       In case of chord at end of beam, finish building mf(.) array 
&dA 
                c10 = a9 + 1 
                last_chordsize = 1 
                loop for a2 = sct + 1 to 100000 
                  loop while tv1(c10) = P_SUGGESTION 
                    ++c10 
                  repeat 
                  if tv1(c10) = tvar1 + 1 
                    mf(a2) = c10 
                    if "zyxtseqhwbL" con tdata(c10,1){1} 
                      if mpt <> c7            /* NTYPE of last chord tones 
                        goto NO_REP 
                      end 
                    else 
                      if "123456789AB" con tdata(c10,1){1} 
                        if mpt <> c7          /* NTYPE of last chord tones 
                          goto NO_REP 
                        end 
                      end 
                    end 
                    ++c10 
                    ++last_chordsize 
                  else  
                    a2 = 100000 
                  end 
                repeat 

                if c4 < 100                   /* secondary beams have breaks 
&dA 
&dA &d@    &dA09/21/08&d@  We need to put the correct value in c4 at this point 
&dA 
                  if c4 = 1 
                    c4 = c14 
                  end 
&dA     
                  goto REP3 
                end 

                loop for a2 = a1 + chordsize to sct
                  if ts(a2,TYPE) <> tvar1 
                    goto REP3 
                  end 
                  c5 = 0 
                  loop for c6 = 1 to chordsize 
                    checkoff(c6) = 1 
                  repeat 
REP4: 
                  c14 = 0 
                  loop for c3 = 1 to chordsize 
                    if checkoff(c3) = 1 and chord_tones(c3) = tcode(mf(a2)) 
                      checkoff(c3) = 0 
                      c14 = 1 
                      c3 = chordsize 
                    end 
                  repeat 
                  if c14 = 0 
                    goto REP3 
                  end 
                  ++c5 
                  if c5 < chordsize 
                    ++a2 
                    if a2 <= sct 
                      if ts(a2,TYPE) <> tvar1 + 1 
                        goto REP3 
                      end 
                    else 
                      if tv1(mf(a2)) <> tvar1 + 1 
                        goto REP3 
                      end 
                    end 
                    goto REP4 
                  else 
                    if a2 > sct + chordsize - 1 
                      goto NO_REP 
                    end 
                  end 
                repeat 
&dA &d@                     
&dA &d@        At this point, we have determined that all chords under the 
&dA &d@           beam are the same.  We must compact all of these notes 
&dA &d@           into one note (simplest case).  
&dA &d@                             
                c3 = sct - a1 / chordsize + 1  /* number of notes 
                c5 = ts(a1,NTYPE) 
                c6 = 0 
                c14 = ts(a1,TUPLE) & 0xffff    /* added &dA11/05/05&d@ 
                if c14 > 255                   /* no complex tuples allowed 
                  goto NO_REP 
                end 
                if c14 > 0 
                  if c14 = c3 
                    c7 = 2 
                    loop 
                      c5 += 1 
                      c8 = c3 / c7 
                      if c8 > 1 
                        c7 <<= 1 
                      end 
                    repeat while c8 > 1 
                    goto REP5 
                  else 
                    goto NO_REP                /* if tuple, then # must = group size
                  end 
                else 
                  if chr(c3) not_in [2,3,4,6,7,8,12,14,15,16,24,28,30,31,32] /* modified &dA12-24-96
                    goto NO_REP                /* must be representable with note value + dot(s)
                  end 
                  c7 = 2 
                  loop 
                    c5 += 1 
                    c8 = c3 / c7 
                    if c8 = 1 
                      mpt = rem 
                      if mpt > 0               /* code modified &dA12-24-96&d@ 
                        if mpt = c7 >> 1 
                          c6 = 1 
                        else 
                          if mpt = c7 / 4 * 3 
                            c6 = 3 
                          else 
                            if mpt = c7 / 8 * 7 
                              c6 = 7 
                            else 
                              c6 = 15 
                            end 
                          end     
                        end 
                      end 
                    else 
                      c7 <<= 1 
                    end 
                  repeat while c8 > 1 
                end 
REP5: 
                if chordsize > 1 
                  a9 += chordsize - 1          /* advance a9 over rest of last chord
                end 

                c7 = 6 
                loop for a2 = 1 to QUARTER - ts(a1,NTYPE) - 1 
                  c7 *= 10 
                  c7 += 6 
                repeat 
                ts(a1,BEAM_CODE) = c7                    /* 666... etc 
&dA 
&dA &d@    New code &dA01/01/08&d@.  Deal with special case of the repeater dot.  
&dA 
                if repeater_dot_flag = 1 and c6 = 0 
                  c6 = 1 
                end 
&dA        
                loop for a2 = a1 to a1 + chordsize - 1 
                  ts(a2,NTYPE)    =  c5 
                  ts(a2,DOT)      =  c6 
                  ts(a2,NOTE_DUR) *= c3 
                  ts(a2,BEAM_FLAG) = NO_BEAM 
                  if a2 > a1 
                    ts(a2,BEAM_CODE) = 0          
                  end 
                repeat 
&dA 
&dA &d@     &dA11/20/06&d@ Adding code here that allows a slur over repeated notes with a 
&dA &d@              repeater, provided that the slur covers all notes in the group
&dA &d@              and that chordsize = 1.  
&dA 
&dA &d@              Also, clear the rest of the ts array and reset sct 
&dA 
                a3 = 0 
                if (ts(a1,SLUR_FLAG) & 0xff) <> 0 and chordsize = 1 
                  a2 = ts(a1,SLUR_FLAG) & 0xff 
                  codes = line{16,12} 

                  if codes con ")" and a2 = 1 
                    a3 = 2 
                  end 
                  if codes con "]" and a2 = 3 
                    a3 = 8 
                  end 
                  if codes con "}" and a2 = 5 
                    a3 = 32 
                  end 
                  if codes con "x" and a2 = 7 
                    a3 = 128 
                  end 
                end 
&dA 
&dA &d@          We have already eliminated those cases where slurs start or end 
&dA &d@            within a repeater group. (about 200 lines above) 
&dA 
                if a3 > 0 
                  c5 = ts(sct,DIV) 
                  c6 = ts(sct,AX) 
                  c7 = ts(sct,NOTE_DUR) 
                  ts(a1,NOTE_DUR) -= c7 
                  loop for a2 = a1 + chordsize to sct 
                    loop for c8 = 1 to TS_SIZE 
                      if c8 <> TSR_POINT 
                        ts(a2,c8) = 0 
                      end 
                    repeat 
                  repeat 
                  ++a1 
                  ts(a1,TYPE) = NOTE 
                  ts(a1,DIV) = c5 
                  ts(a1,AX) = c6 
                  ts(a1,NOTE_DUR) = c7 
                  ts(a1,TEXT_INDEX) = c6 
                  ts(a1,PASSNUM) = passnum 
                  ts(a1,SLUR_FLAG) = a3 

&dA                 &d@ End of &dA11/20/06&d@ addition 

                else 
                  loop for a2 = a1 + chordsize to sct 
                    loop for a3 = 1 to TS_SIZE 
                      if a3 <> TSR_POINT 
                        ts(a2,a3) = 0 
                      end 
                    repeat 
                  repeat 
                end 
&dA 
&dA &d@   &dA01/04/06&d@:  There is a problem when a tuple has been started on a repeater.
&dA &d@              First, tuflag has be set to 1, and has not been reset.  Second,
&dA &d@              the SUPER_FLAG has been set to show a tuple starting, but never
&dA &d@              ending.  I can fix these problems here, but this may be symtomatic
&dA &d@              of problems with other super-objects, such as slurs.  I am not
&dA &d@              going to check this out at this point, but be aware!  
&dA 
                loop for a2 = a1 to a1 + chordsize - 1 
                  if ts(a2,SUPER_FLAG) <> 0 
                    if (ts(a2,SUPER_FLAG)) & 0x10 <> 0 
                      tuflag = 0 
                      ts(a2,SUPER_FLAG) &= 0xffef     /* turn off start tuple
                    else 
                      if (Debugg & 0x06) > 0 
                        pute WARNING:  SUPER_FLAG is non-zero at a repeater at
                        pute approximately measure number ~measnum .   Which means
                        pute that repeaters are mixed with ties, slurs, or other
                        pute notations that touch more than one note (in a manner
                        pute not supported by this program).  
                      end 
                    end 
                  else 
                    ts(a2,TUPLE) = 0 
                  end 
                repeat 
&dA       
                sct = a1 + chordsize - 1 
                goto EBL  
REP3: 
&dA 
&dA &d@     Case 2:  Check to see if chords under the beam can be arranged 
&dA &d@                in groups of 2, 4, 8, or 16 
&dA 
&dA &d@                c2 = number of chords 
&dA &d@                mf2(.) = ts subscripts for primary notes of each chord 
&dA &d@                c4 = either: maximum group size    
&dA &d@                         or: 100 (no group size limitation) 
&dA &d@                         or: >= 1000 (tuples are present; no groups allowed)
&dA 
                if c4 >= 100000 
                  goto REP15       /* &dA02/19/97&d@ change accomodates tuples 
                end 
                if c4 = 100 
                  c4 = 32 
                  loop while c4 > c2 / 2 
                    c4 >>= 1 
                  repeat 
                end 
                loop while c4 > 1 
                  c3 = c2 / c4 
                  if rem <> 0 
                    c4 >>= 1 
                  end 
                repeat while rem <> 0 
                c5 = ts(a1,NTYPE)    
                c6 = 1 
                loop while c5 < EIGHTH
                  c6 <<= 1 
                  ++c5 
                repeat 

                repeater_dot_flag2 = 0        /* New &dA09/21/08&d@ 
                if c4 > c6 
                  c11 = c4 / 3 
                  if rem = 0 
                    repeater_dot_flag2 = 1    /* New &dA09/21/08&d@ 
                  else 
                    c4 = c6                   /* Default from old version 
                  end 
                end 
                if c4 = 1 
                  goto REP15 
                end 
&dA 
&dA &d@          c4 is now the largest possible group notes under beam 
&dA &d@          Next we investigate the question of whether c4 is a 
&dA &d@          "legal" group size.  
&dA 
REP11: 
&dA 
&dA &d@          Look for first (actually last) chord prototype 
&dA 
                c1 = 1                      /* index into mf2 
                c3 = mf2(c1)                /* c3 should start as sct 
                chordsize = 1 
                chord_tones(1) = tcode(mf(c3)) 
                ++c3 
                loop while chordsize < last_chordsize   /* 
                  ++chordsize 
                  chord_tones(chordsize) = tcode(mf(c3))    /* accumulate chord tones
                  ++c3 
                repeat 
&dA 
&dA &d@          Look for additional chords to match prototype 
&dA 
REP9: 
                c6 = 1                  /* chord counter 
REP8: 
                ++c1 
                c3 = mf2(c1)            /* ts index to next primary note backward in list
                c5 = 0 
                loop for c11 = 1 to chordsize 
                  checkoff(c11) = 1 
                repeat 
REP6: 
                c11 = 0 
                loop for c12 = 1 to chordsize 
                  if checkoff(c12) = 1 and chord_tones(c12) = tcode(mf(c3)) 
                    checkoff(c12) = 0 
                    c11 = 1 
                    c12 = chordsize 
                  end 
                repeat 
                if c11 = 0 
                  goto REP7                /* this pitch (tcode) was not found in chord
                end 
                ++c5 
                ++c3 
                if c5 < chordsize 
                  if c3 = mf2(c1-1)                              
                    goto REP7              /* this chord is not big enough 
                  end 
                  goto REP6 
                else 
                  if c3 <> mf2(c1-1)         
                    goto REP7              /* this chord is too big 
                  end 
                end 
                ++c6                       /* "valid" chord found 
                if c6 < c4 
                  goto REP8 
                end 
&dA 
&dA &d@          Set up to look for new chord prototype 
&dA 
                if c1 < c2 
                  ++c1                        /* index into mf2 
                  c3 = mf2(c1)                /* c3 should start as sct 
                  chordsize = 1 
                  chord_tones(1) = tcode(mf(c3)) 
                  ++c3 
                  loop while c3 < mf2(c1-1) 
                    ++chordsize 
                    chord_tones(chordsize) = tcode(mf(c3))    /* accumulate chord tones
                    ++c3 
                  repeat 
                  goto REP9 
                end 
                goto REP10                    /* successful pattern match 
REP7: 
                c4 >>= 1 
                if c4 > 1 
                  goto REP11 
                else 
                  goto REP15 
                end 
&dA 
&dA &d@       Repeaters on groups of chords will work, if group size = c4 
&dA 
REP10: 
                c5 = ts(a1,NTYPE) 
                c7 = c4 
                c15 = 0 
                loop 
                  ++c15 
                  ++c5 
                  c7 >>= 1 
                repeat while c7 > 1 

                c1 = c2 
                c6 = mf2(c2)                     /* position for revised data 
REP13:                                           /* loop between groups 
                c3 = mf2(c1) 
REP12:                                           /* loop within chord 
                ts(c3,NTYPE) = c5 
                ts(c3,NOTE_DUR) *= c4 
                ts(c3,DOT) = repeater_dot_flag2      /* New &dA09/21/08&d@ 
                if c3 <> mf2(c1) 
                  c13 = NO_BEAM 
                  ts(c3,BEAM_CODE) = 0
                else 
                  temp3 = chs(ts(c3,BEAM_CODE)) 
                  c14 = len(temp3) 
                  if c1 = c2                     /* beginning of first group 
                    c13 = START_BEAM 
                    temp3 = "222222"{1,c14} 
                  else 
                    if c1 = c4                   /* beginning of last group 
                      c13 = END_BEAM 
                      temp3 = "333333"{1,c14} 
                    else 
                      c13 = CONT_BEAM 
                      temp3 = "111111"{1,c14} 
                    end 
                  end 
                  temp3{1,c15} = "666666"{1,c15} 
                  ts(c3,BEAM_CODE) = int(temp3) 
                end 
                ts(c3,BEAM_FLAG) = c13 
                ++c3                             /* next pitch in chord 
                if c3 < mf2(c1-1) 
                  goto REP12 
                end 
                chordsize = c3 - mf2(c1) 
&dA 
&dA &d@         Move data to revised position 
&dA 
                if c1 <> c2  
                  c7 = mf2(c1)                   /* source location; c6 = destination
                  loop for c8 = 1 to chordsize        
                    loop for c9 = 1 to TS_SIZE 
                      if c9 <> TSR_POINT 
                        ts(c6,c9) = ts(c7,c9) 
                      end 
                    repeat 
                    ++c6 
                    ++c7 
                  repeat 
                else 
                  c6 += chordsize 
                end 
                if c1 > c4 
                  c1 -= c4 
                  goto REP13 
                end 
                if last_chordsize > 1 
                  a9 += last_chordsize - 1    /* advance a9 over rest of last chord
                end 
&dA 
&dA &d@         Clear the rest of the ts array and reset sct 
&dA 
                loop for c8 = c6 to sct 
                  loop for c9 = 1 to TS_SIZE 
                    if c9 <> TSR_POINT 
                      ts(c8,c9) = 0 
                    end 
                  repeat 
                repeat 
                sct = c6 - 1 
                goto EBL  
REP15: 
&dA 
&dA &d@        Alternating case is the only possibility left 
&dA 
&dA &d@     Case 3:  Check to see if chords under the beam alternate             
&dA &d@                in groups of 4, 8, 16, or 32, or a tuple size which is even
&dA 
&dA &d@                c2 = number of chords 
&dA &d@                mf2(.) = ts subscripts for primary notes of each chord 
&dA 

&dA 
&dA &d@           Also allow alternating groups of size 6, 12, and 24 (&dA01/15/06&d@) 
&dA 
                if chr(c2) not_in [4,6,8,12,16,24,32] 
                  if c4 > 100000                      /* &dA02/19/97&d@ change accomodates tuples
                    c4 -= 100000 
                    if c4 & 0x01 = 0 
                      if c4 = c2 and c4 >= 6 
                        goto REP15A 
                      end 
                    end 
                  end 
                  goto REP16 
                end 
&dA 
&dA &d@          Look for first (actually last) chord prototype 
&dA 
REP15A: 
                c1 = 1                      /* index into mf2 
                c3 = mf2(c1)                /* c3 should start as sct 
                chordsize = 1 
                chord_tones(1) = tcode(mf(c3)) 
                ++c3 
                loop while chordsize < last_chordsize   /* 
                  ++chordsize 
                  chord_tones(chordsize) = tcode(mf(c3))    /* accumulate chord tones
                  ++c3 
                repeat 
&dA 
&dA &d@          Check all "odd" chords for a match               
&dA 
                loop for c1 = 3 to c2 - 1 step 2 
                  c3 = mf2(c1)          /* ts index to next "odd" primary note backward in list
                  c5 = 0 
                  loop for c11 = 1 to chordsize 
                    checkoff(c11) = 1 
                  repeat 
REP17: 
                  c11 = 0 
                  loop for c12 = 1 to chordsize 
                    if checkoff(c12) = 1 and chord_tones(c12) = tcode(mf(c3)) 
                      checkoff(c12) = 0 
                      c11 = 1 
                      c12 = chordsize 
                    end 
                  repeat 
                  if c11 = 0 
                    goto NO_REP            /* this pitch (tcode) was not found in chord
                  end 
                  ++c5 
                  ++c3 
                  if c5 < chordsize 
                    if c3 = mf2(c1-1) 
                      goto NO_REP            /* this chord is not big enough 
                    end 
                    goto REP17 
                  else 
                    if c3 <> mf2(c1-1) 
                      goto NO_REP            /* this chord is too big 
                    end 
                  end 
                repeat 
&dA 
&dA &d@          Look for second (actually penultimate) chord prototype 
&dA 
                c1 = 2                      /* index into mf2 
                c3 = mf2(c1)        
                chordsize2 = 1 
                chord_tones(1) = tcode(mf(c3)) 
                ++c3 
                loop while c3 <> mf2(c1-1) 
                  ++chordsize2 
                  chord_tones(chordsize2) = tcode(mf(c3))    /* accumulate chord tones
                  ++c3 
                repeat 
&dA 
&dA &d@          Check all "even" chords for a match 
&dA 
                loop for c1 = 4 to c2 step 2 
                  c3 = mf2(c1)          /* ts index to next "even" primary note backward in list
                  c5 = 0 
                  loop for c11 = 1 to chordsize2 
                    checkoff(c11) = 1 
                  repeat 
REP18: 
                  c11 = 0 
                  loop for c12 = 1 to chordsize2 
                    if checkoff(c12) = 1 and chord_tones(c12) = tcode(mf(c3)) 
                      checkoff(c12) = 0 
                      c11 = 1 
                      c12 = chordsize2 
                    end 
                  repeat 
                  if c11 = 0 
                    goto NO_REP            /* this pitch (tcode) was not found in chord
                  end 
                  ++c5 
                  ++c3 
                  if c5 < chordsize2 
                    if c3 = mf2(c1-1) 
                      goto NO_REP            /* this chord is not big enough 
                    end 
                    goto REP18 
                  else 
                    if c3 <> mf2(c1-1) 
                      goto NO_REP            /* this chord is too big 
                    end 
                  end 
                repeat 
&dA 
&dA &d@       At this point, we have determined that there are c2/2 matching 
&dA &d@       pairs of chords, and that c2 = 4,6,8,12,16,24 or 32, or an even tuple
&dA &d@       of 6 or greater.  In this situation we may reduce these c2 
&dA &d@       entries to two entries.  The duration of each entry is c2/2 
&dA &d@       times the old duration.  The old duration determines the number 
&dA &d@       of beams; the new duration determines the number of through 
&dA &d@       beams.  We are going to have to change the the division number 
&dA &d@       for the second member of the group.  It is the same as the 
&dA &d@       division number of the (c2/2+1)-th member of the group.  
&dA 

&dA 
&dA &d@      &dA01/15/06&d@ Code added to deal with alternating groups of size 6, 12, and 24
&dA 
                c7 = c2 / 3 
                if rem = 0 
                  ts(c3,DOT) = 1 
                  c4 = c2 / 3 
                else 
                  c4 = c2 / 2 
                end 
&dA      
                c5 = ts(a1,NTYPE) 
                c7 = c4 
                loop 
                  ++c5                     /* new duration 
                  c7 >>= 1 
                repeat while c7 > 1 
                if c5 > 6 and c2 < 8       /* don't do a four group of eighths, etc.
                  goto NO_REP 
                end 

                c15 = 7 - ts(a1,NTYPE)     /* total number of beams 
                c14 = 7 - c5               /* number through beams 
                if c14 < 0 
                  c14 = 0 
                end 
#if OLD_REPEATERS 
                if c5 = 7 
                  c5 = 8 
                  c14 = c15 
                end 
#endif 
                c15 -= c14                 /* number of shortened beams 
&dA 
&dA &d@         Code added &dA01/15/06&d@ to allow alternating group sizes of 6, 12, and 24
&dA &d@            with repeaters.  This code gets the DIV variable right 
&dA &d@                   
                if ts(c3,DOT) = 1 
                  c12 = c4 * 3 / 2         /* because we are counting backward in mf2(.)
                  c12 = mf2(c12) 
                else 
                  c12 = mf2(c4) 
                end 
&dA      
                c12 = ts(c12,DIV)          /* division number for second member

                c6 = mf2(c2)                     /* position for revised data 
                c3 = mf2(c2) 
REP19:                                           /* loop within first chord 
                ts(c3,NTYPE) = c5 
                c13 = c2 / 3                     /* &dA02/19/97&d@  added for 6-tuples, 12-tuples
                if rem = 0 
                  ts(c3,DOT) = 1  
                end 
                ts(c3,NOTE_DUR) *= c4 
                if c3 <> mf2(c2) 
                  c13 = NO_BEAM 
                  ts(c3,BEAM_CODE) = 0 
                else 
                  temp3 = "777777"{1,c15} // "222222"{1,c14} 
                  ts(c3,BEAM_CODE) = int(temp3) 
                  c13 = START_BEAM 
                end 
                ts(c3,BEAM_FLAG) = c13 
                ++c3                             /* next pitch in chord 
                if c3 < mf2(c2-1) 
                  goto REP19 
                end 
                chordsize = c3 - mf2(c2) 
                c6 += chordsize 
REP20:                                           /* loop within second chord 
                ts(c3,DIV)   = c12 
                ts(c3,NTYPE) = c5 
                c13 = c2 / 3                     /* &dA02/19/97&d@  added for 6-tuples, 12-tuples
                if rem = 0 
                  ts(c3,DOT) = 1  
                end 
                ts(c3,NOTE_DUR) *= c4 
                if c3 <> mf2(c2-1) 
                  c13 = NO_BEAM 
                  ts(c3,BEAM_CODE) = 0 
                else 
                  temp3 = "888888"{1,c15} // "333333"{1,c14} 
                  ts(c3,BEAM_CODE) = int(temp3) 
                  c13 = END_BEAM 
                end 
                ts(c3,BEAM_FLAG) = c13 
                ++c3                             /* next pitch in chord 
                if c3 < mf2(c2-2) 
                  goto REP20 
                end 
                chordsize = c3 - mf2(c2-1) 
                c6 += chordsize 

                if last_chordsize > 1 
                  a9 += last_chordsize - 1    /* advance a9 over rest of last chord
                end 
&dA 
&dA &d@         Clear the rest of the ts array and reset sct 
&dA 
                loop for c8 = c6 to sct 
                  loop for c9 = 1 to TS_SIZE 
                    if c9 <> TSR_POINT 
                      ts(c8,c9) = 0 
                    end 
                  repeat 
                repeat 
                sct = c6 - 1 
REP16: 
              end 
NO_REP: 
            end  
&dA 
&dA &d@    &dAConstruct SUPER_FLAG&d@ 
&dA 
            a14 = 0                                 /* a14 will become ts(14) 
            codes = line{16,12} 
&dA 
&dA &d@    look for starting tuplet  
&dA 
            if ts(sct,TUPLE) > 0  
              if tuflag = 0 and codes con "*" 
                tuflag = 1 
                a1 = mpt 
                a14 |= 0x10                         /* begin tuplet 
                if codes con "&" and mpt < a1 
                  a14 |= 0x40000                    /* editorial tuplet flag &dA03-21-97
                end                                 
              end  
            end  
&dA 
&dA &d@    look for end of ~~~~~ 
&dA 
            if ctrflag(passnum) > 0                 /* ctrflag changed to array &dA12/08/07
              if codes con "c"   
              else 
                a14 |= 0x08                         /* end ~~~~~ 
                if ctrflag(passnum) >= 0x100 
                  a14 |= 0x20000                    /* editorial ~~~ flag &dA03-21-97
                end  
                ctrflag(passnum) = 0 
              end  
            end  
&dA 
&dA &d@    look for start of ~~~~~ 
&dA 
            if codes con "~"   
              if ctrflag(passnum) = 0               /* New &dA12/08/07&d@ 
                a7 = mpt 
                if codes con "&" and mpt < a7 
                  ctrflag(passnum) = 0x0200         /* editorial start ~~~~~
                  a14 |= 0x20000                    /* editorial ~~~ flag &dA03-21-97
                else 
                  ctrflag(passnum) = 0x02           /* start ~~~~~ 
                end  
                if codes con "t"   
                  ctrflag(passnum) <<= 1 
                  a14 |= 0x04                       /* begin ~~~ with trill 
                else 
                  a14 |= 0x02                       /* begin ~~~ without trill
                end 
              end  
            end  
&dA 
&dA &d@    look for forward tie 
&dA 
            if codes con "-"   
              a7 = mpt 
              a14 |= 0x01                           /* tie flag 
              if codes con "&" and mpt < a7 
                a14 |= 0x10000                      /* editorial tie (dotted) &dA03-21-97
              end  
            end  
&dA 
&dA &d@    look for end of tuplet 
&dA 
            if codes con "!" and tuflag = 1 
              a7 = mpt 
              a14 |= 0x20                           /* end tuplet 
              if codes con "&" and mpt < a7 
                a14 |= 0x40000                      /* editorial tuplet flag &dA03-21-97
              end 
              tuflag = 0 
            end  
&dA 
&dA &d@    &dASet SUPER_FLAG&d@ 
&dA 
            ts(sct,SUPER_FLAG) = a14  

            a14 = 0  
            loop for a1 = 1 to 12 
              if codes{a1} = "@"     /* New &dA12/18/10&d@.  Just to make sure "@" isn't used
                codes{a1} = "?" 
              end 
              if codes{a1} = "&"     /* and codes{a1+1} in ['0'..'9'] 
                a14 = 1  
                if codes{a1+1} in ['0'..'9','X']        /* New &dA05/17/03&d@ 
                  ++a1 
                end 
                goto TLP1      /* skip &# 
              end  
              if "()[]{}zx" con codes{a1} 
                --mpt 
                a7 = 1 << mpt 
                if a14 = 1 
                  a7 <<= 16 
                end 
                ts(sct,SLUR_FLAG) |= a7 
                goto TLP1      
              end 
&dA 
&dA &d@    look for turns, mordents, and their accidentals (trills taken out &dA11/05/05&d@)
&dA &d@                    (T) tremulos added &dA01/07/06&d@ 
&dA 
              if "r@wMkT" con codes{a1}       /* code amended      &dA01/07/06&d@ 
                a7 = mpt 
&dA 
&dA &d@    Special case of tremulo &dA01/07/06&d@; no editorial and no accidentals allowed
&dA 
                if a14 = 0 and a7 = 6 
                  ts(sct,SUBFLAG_1) |= a7
                  goto TLP1 
                end 
&dA    
                if a14 = 0 
                  ts(sct,SUBFLAG_1) |= a7
                else   
                  ts(sct,ED_SUBFLAG_1) |= a7 
                end  

                temp3 = codes // pad(13) 
                loop for a3 = a1 + 1 to 13 
                repeat while "shbu" con temp3{a3} 
                if a3 = a1 + 1 
                  goto TLP1 
                end 
                a7 = 0 
                temp3 = codes{a1+1..a3-1} 
                a1 = a3 - 1 
                if temp3 con "u" 
                  temp4 = temp3{mpt..} // "..." 
                  if mpt = 1 
                    temp3 = "" 
                  else 
                    temp3 = temp3{1,mpt-1} 
                  end 
                  if "uss.ubb.us..uh..ub.." con temp4{1,4} 
                    a7 = mpt + 3 
                    a7 = a7 << 1 
                  end 
                end 
                temp4 = temp3 // "...." 
                if "ss..bb..s...h...b..." con temp4{1,4} 
                  mpt += 3 
                  mpt >>= 2 
                  a7 |= mpt
                end 
                a7 <<= 4 
                if a14 = 0 
                  ts(sct,SUBFLAG_1) |= a7 
                else 
                  ts(sct,ED_SUBFLAG_1) |= a7 
                end 
                goto TLP1      
              end 
&dA 
&dA &d@    New code &dA11/05/05&d@ for trills and their accidentals 
&dA 
              if codes{a1} = "t" 
                a4 = 0                                /* this will be bit 19
                a7 = 2  
                if a14 = 0 
                  ts(sct,SUBFLAG_1) |= a7
                else   
                  ts(sct,ED_SUBFLAG_1) |= a7 
                end  

                temp3 = codes // pad(13) 
                loop for a3 = a1 + 1 to 13 
                repeat while "shbuU" con temp3{a3} 
                if a3 = a1 + 1 
                  goto TLP1 
                end 

                a7 = 0 
                temp3 = codes{a1+1..a3-1} 
                a1 = a3 - 1 

                if temp3 con "u" or temp3 con "U" 
                  temp4 = temp3{mpt..} // "..." 
                  if mpt = 1 
                    temp3 = "" 
                  else 
                    temp3 = temp3{1,mpt-1} 
                  end 
                  if "uss.ubb.us..uh..ub.." con temp4{1,4} 
                    a7 = mpt + 3                          /*  4,8,12,16,20 
                    a7 = a7 << 1                          /*  8,16,24,32,40  = 8 x (1,2,3,4,5)
                  end 
                  if "Uss.Ubb.Us..Uh..Ub.." con temp4{1,4} 
                    a7 = mpt + 3                          /*  4,8,12,16,20 
                    a7 = a7 >> 2                          /*  1,2,3,4,5 
                    a4 = 1 
                  end 
                end 
                temp4 = temp3 // "...." 
                if "ss..bb..s...h...b..." con temp4{1,4} 
                  mpt += 3 
                  mpt >>= 2 
                  a7 |= mpt
                end 
                a7 <<= 4 
                a4 <<= 19 
                if a14 = 0 
                  ts(sct,SUBFLAG_1) |= a7 
                  ts(sct,SUBFLAG_1) |= a4                  /* establish bit 19
                else 
                  ts(sct,ED_SUBFLAG_1) |= a7 
                  ts(sct,ED_SUBFLAG_1) |= a4               /* establish bit 19
                end 
                goto TLP1      
              end 
&dA 
&dA                            &d@ End of &dA11/05/05&d@ New Code 

              if "^+@@@@@@@FE" con codes{a1}       /* Fermatas moved &dA12/18/10
                mpt += 16 
                a7 = 1 << mpt   
                if a14 = 0 
                  ts(sct,SUBFLAG_1) |= a7
                else   
                  ts(sct,ED_SUBFLAG_1) |= a7 
                end  
                goto TLP1      
              end  
&dA 
&dA &d@    look for dynamics   (This section recoded &dA10/08/08&d@ to simplify and add extra dynamic combinations)
&dA 
&dA &d@          New code &dA10/08/08&d@ 
&dA 
              if "mpfZR" con codes{a1} 
                a7 = 0 
                temp4 = codes // pad(13)    /* so we don't run off at the end
                temp3 = temp4{a1} 
                loop while "pf" con temp4{a1+1}   /* add f's and p's to first letter
                  temp3 = temp3 // temp4{a1+1} 
                  ++a1                      /* this will rightsize a1 
                repeat 
                temp3 = temp3 // pad(4) 
                temp3 = temp3{1,4} 
                temp3 = temp3 // "."        /* max data length = 4; full padded length = 5
                if "p   .pp  .ppp .pppp.f   .ff  .fff .ffff.mp  .mf  .fp  .Zp  .fz  .Z   .R   ." con temp3
                  a7 = mpt + 4 / 5          /* values 1 to 15 
                  a7 <<= 10                 /* range in bits 0x3c00 
                end 

                if "ffp .mfp .Zf  ." con temp3 
                  a7 = mpt + 4 / 5 + 15     /* values 16 to 18 New &dA03/16/09&d@; rearranged &dA12/18/10
                  a7 <<= 10                 /* range in bits 0x7c00 
                end 
&dA 
&dA            &d@  End of new code &dA10/08/08&d@ 

                if a14 = 0 
                  if ts(sct,SUBFLAG_1)  & 0x7c00 = 0      /* &dA12/18/10&d@ dynamics in one spot now
                    ts(sct,SUBFLAG_1) |= a7 
                  end 
                else 
                  if ts(sct,ED_SUBFLAG_1) & 0x7c00 = 0        /* &dA12/18/10&d@ (see above)
                    ts(sct,ED_SUBFLAG_1) |= a7 
                  end 
                end 
                goto TLP1 
              end 
&dA 
&dA &d@    look for back ties   New &dA04/22/08&d@ 
&dA 
              if "JK" con codes{a1} 
                a7 = 1 << (mpt + 23) 
                ts(sct,SUBFLAG_1) |= a7 
                goto TLP1 
              end 
&dA 
&dA &d@    other directions connected with notes 
&dA 
              if "nvi.=_>AVoQ0" con codes{a1}    
                --mpt 
                a7 = 1 << mpt 
                if a14 = 0 
                  ts(sct,SUBFLAG_2) |= a7 
                else 
                  ts(sct,ED_SUBFLAG_2) |= a7 
                end 
                goto TLP1 
              end 
&dA 
&dA &d@    fingering connected with notes 
&dA 
              if "12345" con codes{a1} 
                a4 = mpt 
                a7 = 0 
                a3 = 0 
FINNN: 
                if a1 < len(codes) and "12345:" con codes{a1+1} 
                  if mpt = 6 
                    a4 += 8 
                  else 
                    a4 <<= a3 
                    a7 += a4 
                    a4 = mpt 
                    a3 += 4 
                  end 
                  ++a1 
                  goto FINNN 
                end 
                a4 <<= a3 
                a7 += a4 
                a7 <<= 12 
                if a14 = 0 
                  ts(sct,SUBFLAG_2) |= a7 
                else 
                  ts(sct,ED_SUBFLAG_2) |= a7 
                end 
                goto TLP1 
              end 
TLP1: 
            repeat 
            tsdata(a9+old@n) = line{28..} 

            ts(sct,TEXT_INDEX) = a9 + old@n 
            ts(sct,PASSNUM) = passnum  
            ts(sct,STAFF_NUM) = tv3(a9) & 0x000f 
            ts(sct,TRACK_NUM) = tv3(a9) >> 4 & 0x000f 
            goto EBL 
          end  
&dA 
&dA &d@  Case II:  figures 
&dA 
          if tvar1 = FIGURES
            ++sct
            ts(sct,TYPE) = tvar1   
            if figdiv = 0  
              figdiv = divpoint  
            end  
            ts(sct,DIV) = figdiv  
            ts(sct,FIG_DUR) = tvar2  
            figdiv += tvar2 
            a3 = sct - 1 
            a4 = 0 
            loop while a3 > oldsct 
              if ts(a3,TYPE) = FIGURES 
                a4 = a3  
              end  
              --a3
            repeat while a4 = 0  
*   a4 = pointer to previous figure data in measure (or 0) 
            ts(sct,NUMBER_OF_FIG) = int(tcode(a9))  
            if ts(sct,NUMBER_OF_FIG) > 4  
              tmess = 2 
              perform dtalk (tmess) 
            end  
            a7 = FIG_DATA
            loop for a5 = 1 to ts(sct,NUMBER_OF_FIG) 
              line = mrt(line) 
              if line = "" 
                tmess = 2 
                perform dtalk (tmess) 
              end  
&dA 
&dA &d@    Adding new code &dA11/16/03&d@ to allow for parentheses around figure fields 
&dA 
              a13 = 0                           /* initialize parentheses flag to null
              line = line // " " 
              if line{1} = "(" 
                if line con ")" 
                  a6 = mpt - 1 
                  if mpt = 2 
                    tmess = 2 
                    perform dtalk (tmess) 
                  end 
                  a13 = 1 
                  temp = line{2..(mpt-1)}       /* section of line inside ()
                  if temp{1} = " " 
                    tmess = 2 
                    perform dtalk (tmess) 
                  end                           /* section starts with non-blank field
WB1a: 
                  if temp con " " 
                    temp = temp{mpt..}          /* skip over non-blank field
                    temp = mrt(temp)            /* and remove leading blanks to next field
                    if temp = "" 
                      tmess = 2 
                      perform dtalk (tmess) 
                    end 
                    ++a13   
                    goto WB1a 
                  end 
                  if a13 > (ts(sct,NUMBER_OF_FIG) - a5 + 1) 
                    tmess = 2 
                    perform dtalk (tmess) 
                  end 
                  a13 *= 1000 
                  line = line{2..a6}            /* now remove parentheses from line
                else 
                  tmess = 2 
                  perform dtalk (tmess) 
                end 
              end 
&dA   
              if line con " "  
                temp = line{1,mpt-1} 
                line = line{mpt..} 
              end  

              temp = temp // pad(3)  
              if "_-" con temp{1}  
                if mpt = 1 
                  if a4 = 0  
                    tmess = 2 
                    perform dtalk (tmess) 
                  end  
                  if ts(a4,a7+2) = 0  
                    ts(a4,a7+2) = 2 
                  else 
                    ts(a4,a7+2) = 3 
                  end  
                  ts(sct,a7+2) = 1  
                else 
                  ts(sct,a7) = 30                         /* 30 
                end  
              else 
                if "x@#@@@@nf" con temp{1}                /* 21,23,28,29 
                  ts(sct,a7) = mpt + 20 
                  a6 = 2 
                  goto WB1 
                end  
                if "2@45" con temp{1} and temp{2} = "+"   /* 22,24,25 
                  ts(sct,a7) = mpt + 21 
                  a6 = 4 
                  goto WB1 
                end  
                if "/\" con temp{2} and "67" con temp{1}  /* 26,27 
                  ts(sct,a7) = mpt + 25 
                  a6 = 4 
                  goto WB1 
                end  
                a6 = int(temp)                            /* 1..19 
                if a6 < 0 or a6 > 19 
                  tmess = 2 
                  perform dtalk (tmess) 
                end 
                ts(sct,a7) = a6 
                if ts(sct,a7) < 10  
                  a6 = 2 
                else 
                  a6 = 3 
                end  
WB1:            if a6 < 4  
                  temp = temp{a6..}  
                  if "+x@#@@@@nf" con temp{1}  
                    ts(sct,a7+1) = mpt + 19 
                  else 
                    ts(sct,a7+1) = int(temp)  
                  end  
                end  
              end  
              ts(sct,a7) += a13                  /* Adding parentheses flag &dA11/16/03
              a7 += 3 
            repeat 
            ts(sct,PASSNUM) = passnum  
            ts(sct,STAFF_NUM) = nstaves - 1 
            goto EBL 
          end  
&dA 
&dA &d@  Case III:  bar lines  
&dA 
          if tvar1 = BAR_LINE
            ++sct
            ts(sct,TYPE) = tvar1   
            ts(sct,DIV) = divpoint  
            ts(sct,BAR_NUMBER) = tvar2   
            if tcode(a9) = "sure"  
              ts(sct,BAR_TYPE) = REGULAR 
            else 
              if "@1d@e2@@34" con tcode(a9){4} 
                ts(sct,BAR_TYPE) = mpt 
              end  
            end  
            if line con ":|" 
              ts(sct,REPEAT) |= 0x02
            end  
            if line con "|:" 
              ts(sct,REPEAT) |= 0x01
            end  
            if line con "stop-end" 
              ts(sct,BACK_ENDING) = int(line{mpt+8..})  
            end  
            if line con "start-end"  
              ts(sct,FORW_ENDING) = int(line{mpt+9..})  
            end  
            if line con "disc-end" 
              a3 = int(line{mpt+8..})  
              ts(sct,BACK_ENDING) = 0 - a3  
            end  
            if line con "~" 
              loop for a7 = 1 to passnum 
                if ctrflag(a7) > 0 
                  ts(sct,BAR_FLAGS) |= 0x01 
                end 
              repeat 
            end 
            if line con "A"  
              ts(sct,BAR_FLAGS) |= 0x02 
            end  
            if line con "F"  
              ts(sct,BAR_FLAGS) |= 0x04 
            end  
            if line con "E"  
              ts(sct,BAR_FLAGS) |= 0x08 
            end  
            ts(sct,SPACING) = hpar(37) 
            ts(sct,M_NUMBER) = m_number 
            if m_number > 0 
              ++m_number 
            end 

            ts(sct,TEXT_INDEX) = a9 + old@n   
            tsdata(a9+old@n) = tdata(a9,2)    

            ts(sct,PASSNUM) = passnum  
            ts(sct,NUM_STAVES) = tv3(a9) 
            goto EBL 
          end  
&dA 
&dA &d@  Case IV:  signs, words, marks 
&dA 
          if tvar1 = MUSICAL_DIR
            ++sct
            a4 = 0 
            temp = tcode(a9) 
            loop for a3 = 1 to 2 
              if "APQG" con temp{a3} 
                ts(sct,TYPE) = SIGN
                ts(sct,SIGN_TYPE) = mpt 
              end  
              if temp{a3} = "X"                /* (added &dA10/12/96&d@) 
                ts(sct,TYPE) = SIGN
                ts(sct,SIGN_TYPE) = TIE_TERM 
              end  
              if "BCD" con temp{a3}  
                ts(sct,TYPE) = WORDS
                ts(sct,SIGN_TYPE) = mpt + 4 
              end  
              if "R" con temp{a3}              /* (added &dA02/03/08&d@) 
                ts(sct,TYPE) = WORDS
                ts(sct,SIGN_TYPE) = REH_MARK 
              end 
              if "EFHJ" con temp{a3} 
                ts(sct,SUPER_TYPE) = mpt 
                if mpt < 3 
                  a4 = int(line{5..7})   /* get numerical parameter for wedges 
                  ts(sct,WEDGE_SPREAD) = a4 * notesize / 10 
                end 
              end  
              if "UWV" con temp{a3} 
                if mpt = 2 
                  ts(sct,SUPER_TYPE) = NORMAL_TRANS
                else 
                  ts(sct,SUPER_TYPE) = mpt + 4       /* 5 or 7 */ 
                  if int(tdata(a9,1){5,3}) <> 0 
                    ts(sct,SUPER_TYPE) += 4 
                  end 
                end  
              end 
            repeat 
            if ts(sct,TYPE) = 0  
              ts(sct,TYPE) = MARK
            end  
            ts(sct,DIV) = divpoint + cuediv 
            ts(sct,DIV) += mdir_offset 
            if temp{3} = "+" 
              ts(sct,SIGN_POS) = ABOVE
            else 
              ts(sct,SIGN_POS) = BELOW 
            end 
            if a4 = 0 
              a4 = int(line{5..7}) 
              ts(sct,FONT_NUM) = a4    /* get numerical parameter for words, etc.
            end 

            ts(sct,WEDGE_OFFSET) = vpar(1)       
            if ts(sct,SUPER_TYPE) = WEDGES << 1    /* end of wedge 
              if ts(sct,WEDGE_SPREAD) = 0          /* point of wedge 
                ts(sct,WEDGE_OFFSET) = notesize
              end 
            end 

            if ts(sct,SIGN_TYPE) = LETTER_DYNAM 
              if ts(sct,SUPER_TYPE) = 1        /* start wedge
                line = trm(line) 
                line = line // pad(9) 
                temp = line{9..} 
&dA 
&dA &d@    Adjust temp for "Zp", "Z", and "R".  
&dA 
                temp = " " // temp // " " 
                if temp con "Zp" 
                  temp = temp{1..mpt-1} // "sfp" // temp{mpt+2..} 
                end 
                if temp con "Z" 
#if SFZ 
                  temp = temp{1..mpt-1} // "sfz" // temp{mpt+1..} 
#else 
                  temp = temp{1..mpt-1} // "sf" // temp{mpt+1..} 
#endif 
                end 
                if temp con "R" 
#if SFZ 
                  temp = temp{1..mpt-1} // "rfz" // temp{mpt+1..} 
#else 
                  temp = temp{1..mpt-1} // "rf" // temp{mpt+1..} 
#endif 
                end 
                temp = temp{2..} 
                temp = trm(temp) 
                a5 = notesize / 2  

                loop for a4 = 1 to len(temp) 
                  if "pmfszr" con temp{a4} 
                    mpt += 59 
                    a5 += hpar(mpt) 
                  end  
                repeat 
                ts(sct,WEDGE_OFFSET) = a5  
              end  
              if ts(sct,SUPER_TYPE) = 2        /* stop wedge
                ts(sct,WEDGE_OFFSET) = 0 - hpar(46)      
              end  
            end 
            if ts(sct,SIGN_TYPE) = CENTER_STR or ts(sct,SIGN_TYPE) = LEFT_JUST_STR
              if ts(sct,SUPER_TYPE) = 1        /* start wedge                  
                if len(line) > 8 
                  ttext = line{9..} 
                  ttext = trm(ttext) 
                  perform kernttext            
                  c5 = mtfont 
                  perform wordspace 
&dA &d@³    Outputs:    a5 = space taken up by word          
                  if ts(sct,SIGN_TYPE) = CENTER_STR   /* centered word 
                    a5 >>= 1 
                  end 
                  a5 += notesize / 2 
                  ts(sct,WEDGE_OFFSET) = a5 
                end 
              end  
              if ts(sct,SUPER_TYPE) = 2        /* stop wedge
                ts(sct,WEDGE_OFFSET) = 0 - notesize
              end  
            end  
            tsdata(a9+old@n) = line{9..} 
            ts(sct,TEXT_INDEX) = a9 + old@n 
            ts(sct,PASSNUM) = passnum  
            ts(sct,STAFF_NUM) = tv3(a9) 
            ts(sct,S_TRACK_NUM) = tvar2 
            goto EBL 
          end  
&dA 
&dA &d@  Case V, VI, VII and VIII:
&dA &d@     clef change, time designation, meter change, divspq change
&dA 
          if chr(tvar1) in [CLEF_CHG,DESIGNATION,METER_CHG,DIV_CHG]
            ++sct
            ts(sct,TYPE) = tvar1 
            ts(sct,DIV) = divpoint  
            ts(sct,3) = tvar2               /* first parameter
            if tvar1 = CLEF_CHG
              ts(sct,CLEF_FONT) = int(tcode(a9))  
            end  
            tsdata(a9+old@n) = tdata(a9,1) 
            ts(sct,TEXT_INDEX) = a9 + old@n 
            ts(sct,PASSNUM) = passnum  
            ts(sct,STAFF_NUM) = tv3(a9) 
            ts(sct,DOLLAR_SPN) = tv5(a9)    /* added &dA01/17/04&d@ 
&dA &d@       assure proper current value of divspq for this loop  
            if tvar1 = DIV_CHG
              qflag = 1  
              divspq = tvar2 
            end  
            goto EBL 
          end  
&dA 
&dA &d@  Case IX: key change     
&dA 
          if tvar1 = AX_CHG 
            ++sct 
            ts(sct,TYPE) = tvar1 
            ts(sct,DIV) = divpoint  
            ts(sct,3) = tvar2               /* new key        
            ts(sct,4) = key                 /* old key 
            tsdata(a9+old@n) = tdata(a9,1) 
            ts(sct,TEXT_INDEX) = a9 + old@n 
            ts(sct,PASSNUM) = passnum  
            ts(sct,NUM_STAVES) = tv3(a9) 
            ts(sct,DOLLAR_SPN) = tv5(a9)    /* added &dA01/17/04&d@ 

&dA                                                             
&dA 
&dA &d@     New &dA12/14/07&d@:  This code adjusts tclaveax(.) to reflect 
&dA &d@       the current situation 
&dA 
            loop for a6 = 1 to 50 
              tclaveax(a6) = 0 
            repeat 

            a6 = tvar2 
            if a6 > 0 
              a7 = 4 
              loop for a8 = 1 to a6 
                loop for c5 = a7 to 50 step 7 
                  tclaveax(c5) = 2 
                repeat 
                a7 += 4 
                if a7 > 7 
                  a7 -= 7 
                end 
              repeat 
            end 
            if a6 < 0 
              a6 = 0 - a6 
              a7 = 7 
              loop for a8 = 1 to a6 
                loop for c5 = a7 to 50 step 7 
                  tclaveax(c5) = 3 
                repeat 
                a7 -= 4 
                if a7 < 1 
                  a7 += 7 
                end 
              repeat 
            end 

            loop for a6 = 1 to 50 
              loop for a7 = 1 to 4              /* &dA06/04/08&d@ was 3 
                measax(a7,a6) = tclaveax(a6)
              repeat 
            repeat 
&dA 
&dA                  &d@  End of &dA12/14/07&d@ addition &dA              

            goto EBL 
          end 
&dA 
&dA &d@  Case X: irst, backspace 
&dA 
          if tvar1 = IREST
            divpoint += tvar2 
            if divpoint > totdiv 
              totdiv = divpoint 
            end 
            cuediv = 0 
            goto EBL 
          end  
          if tvar1 = BACKSPACE
            ++passnum
            divpoint -= tvar2
            cuediv = 0 
            goto EBL 
          end  
&dA 
&dA &d@  Case XI: print suggestions 
&dA 
          if tvar1 = P_SUGGESTION 
            if tvar2 < 8                    /* forced slur suggestion 
              a3 = tvar2 & 0x06 
              a4 = tvar2 & 0x01 
              a4 <<= 1 
              ++a4                          /* 1 = over; 3 = under 
              a4 <<= a3 + 8 
              ts(sct,SLUR_FLAG) |= a4       /* turn on forced slur flag 
              goto EBL 
            end 
            if tvar2 < 10 
              if tvar2 = 8 
                ts(sct,SLUR_FLAG) |= 0x1000000    /* overhanded tie 
              else 
                ts(sct,SLUR_FLAG) |= 0x3000000    /* underhanded tie 
              end 
              goto EBL 
            end 
            if tvar2 < 32 
              ts(sct,SUPER_FLAG) |= 0x40          /* tuplet has a bracket &dA03-21-97
              if bit(0,tvar2) = 1 
                ts(sct,SUPER_FLAG) |= 0x200       /* bracket is round &dA03-21-97
              end 
              if bit(1,tvar2) = 1 
                ts(sct,SUPER_FLAG) |= 0x80        /* bracket is continuous &dA03-21-97
              end 
              if bit(2,tvar2) = 1 
                ts(sct,SUPER_FLAG) |= 0x100       /* tuplet number is inside &dA03-21-97
              end 
              goto EBL 
            end 
            if tvar2 >= 0x100 and tvar2 < 0x200   /* musical direction 
              a3 = ors(tcode(a9){1}) 
              if a3 > 0 
                ts(sct,FONT_NUM) = a3   
              end 
              a3 = ors(tcode(a9){2}) << 8 + ors(tcode(a9){3}) 
              if tvar2 & 0xff = 0 
                ts(sct,POSI_SHIFT1) = a3 << 8 + ors(tcode(a9){4}) 
              else 
                ts(sct,POSI_SHIFT2) = a3 << 8 + ors(tcode(a9){4}) 
              end 
              goto EBL 
            end 
            if tvar2 & 0xff00 = 0x0200      /* position of ornaments, etc.  
              a3 = tvar2 & 0xff * 4 + 1 
              tsr(sct){a3,4} = tcode(a9){1,4} 
              goto EBL 
            end 
            if tvar2 & 0xff00 = 0x0300      /* printing of actual objects 
              a3 = ors(tcode(a9){1}) 
              if a3 > 6 
                a3 >>= 1
                a3 &= 0x07 
&dA &d@                             3 = print object, no extension dot      
&dA &d@                             4 = print object, include extension dot 
&dA &d@                             5 = double note length, no extension dot 
&dA &d@                             6 = double note length, include extension dot 
&dA &d@                             7 = quadruple note length, no extension dot 
                if a3 > 2 
                  if a3 = 4 or a3 = 6 
                    ts(sct,DOT) = 1 
                  else 
                    ts(sct,DOT) = 0 
                  end 
                  if a3 > 4 
                    ++ts(sct,NTYPE) 
                  end 
                  if a3 > 6 
                    ++ts(sct,NTYPE) 
                  end 
                  ts(sct,SUPER_FLAG) &= 0xfffffffe  /* turn off ties 
                end 
              end 
              tsr(sct){1,4} = tcode(a9){1,4} 
              goto EBL 
            end 
&dA 
&dA &d@       New Code &dA05/25/03&d@ and &dA05/28/05&d@ 
&dA 
            if tvar2 & 0xff00 = 0x0400      /* print suggestion for preceding bar line
              loop for c1 = outpnt to 1 step -1 
                tget [Y,c1] line            
                if line{1,3} = "J B" 
                  sub = 5 
                  c2 = int(line{sub..})           /* bar number 
                  c3 = int(line{sub..})           /* obx        
                  c4 = int(line{sub..})           /* oby 
                  temp = line{sub..} 
                  if tvar2 & 0xffff = 0x0400 
                    c4 += 1000000                 /* 1 million is flag for fixed length
                  else 
                    if tvar2 & 0xffff = 0x0401 
                      c4 += 10000000              /* New &dA05/28/05&d@ 10 million is flag for
                    end                           /* &dEmid-movement&d@ right justification
                  end 
                  line = "J B " // chs(c2) // " " // chs(c3) // " " // chs(c4) // temp
                  tput [Y,c1] ~line 
                  c1 = 1 
                end 
              repeat 
              goto EBL 
            end 
&dA 
&dA &d@       New code &dA11/05/05&d@ for implementing location suggestions for tuples 
&dA 
            if tvar2 & 0xff00 = 0x0500      /* print suggestion for horizontal adjustment
              c2 = tvar2 & 0xff 
              c2 <<= 16 
              ts(sct,TUPLE) |= c2           /* horizontal adjustment 
              goto EBL 
            end 
            if tvar2 & 0xff00 = 0x0600      /* print suggestion for vertical adjustment
              c2 = tvar2 & 0xff 
              c2 <<= 24 
              ts(sct,TUPLE) |= c2           /* vertical adjustment 
              goto EBL 
            end 
&dA 
&dA                 &d@ End of &dA11/05/05&d@ Code 

          end  
EBL:       
        repeat 
        old@n += @n 

&dA   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   
&dA   ³ End of storing original data in set array  ³   
&dA   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   

&dA 
&dA &d@         ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ» 
&dA &d@         º   N E W    S O R T    A L G O R I T H M   º 
&dA &d@         ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼ 
&dA 
&dA &d@                       &dA09/30/93&d@ 
&dA 
&dA &d@   Reorder set array according to location in measure.  Do not 
&dA &d@     separate extra chord notes from their original lead notes.  
&dA &d@     Do not change the order of bar/clef/grace-note.  Do not 
&dA &d@     extract signs, words, or marks when they precede a bar, 
&dA &d@     clef or grace note; otherwise extract them and put them 
&dA &d@     in front of figures, cues and regular notes.  Do not 
&dA &d@     extract time designations when they precede a bar, 
&dA &d@     clef or grace note; otherwise extract them and put them 
&dA &d@     in front of words, signs, marks, figures, cues and regular 
&dA &d@     notes. 
&dA 
&dA &d@   For objects at same location, the order is as follows: 
&dA 
&dA &d@              1. bar, clef, grace note/chord (in original order for each div) 
&dA &d@              2.  
&dA &d@              3.  
&dA &d@              4. change in divisions per quarter 
&dA &d@              5. time designation, meter change, key change 
&dA &d@              6. word, sign, mark 
&dA &d@              7. figure 
&dA &d@              8. cue note/chord, cue rest 
&dA &d@              9. regular note/chord, regular rest   &dANote: this is why we send irests    
&dA &d@                                                    &dA      through the system as rests   
&dA &d@                                                    &dA      and not as marks              
&dA &d@   Summary of algorithm: 
&dA 
&dA &d@      1. For each division, assign parameters as listed above 
&dA &d@      2. bar, clef, and grace note/chord will be assigned numbers 
&dA &d@           1, 2, and 3 in the order in which they first occur 
&dA &d@           in the array on this division 
&dA &d@      3. For time designations, words, signs and marks, if 
&dA &d@           they preceed a type 1,2,or 3, or if they preceed 
&dA &d@           another or this kind which preceeds a 1,2 or 3, 
&dA &d@           then they take this respective type 
&dA &d@      4. order the elments of mf(.) on each division according 
&dA &d@           to the parameter numbers assigned to them.  mf(.) 
&dA &d@           will now contain the indexes for the proper order 
&dA &d@           of ts(.) from oldsct to sct.  
&dA &d@      5. reorder the elements of ts(.) accordingly 
&dA 

        a7 = 0                  /* global counter in measure 

        a3 = ts(sct,DIV)        /* divisions per measure 
        loop for a2 = 1 to a3 
          temp = "999888007066606545"   /* initial "priority" string (with unknowns = 0)
          a6 = 0 
          a8 = a7                       /* local counter on this division 
          loop for a1 = oldsct + 1 to sct 
            if ts(a1,DIV) = a2 
              a4 = ts(a1,TYPE) 
              a5 = int(temp{a4}) 
              if a5 = 0         /* setting "unknowns" in the order they are encountered
                ++a6 
                if a4 = 7 or a4 = 8 
                  temp{7} = chs(a6) 
                  temp{8} = chs(a6) 
                else 
                  temp{a4} = chs(a6) 
                end 
                a5 = a6 
              end 
              ts(a1,SORTPAR1) = a5 
              ++a8 
              mf(a8) = a1 
            end 
          repeat 

          a5 = 20 
          loop for a3 = a8 to a7 + 1 step -1 
            a1 = mf(a3) 
            a4 = ts(a1,SORTPAR1) 
            if a4 = 6         /* time designation,  word, sign, mark 
              if a5 < 4       /* bar, clef, grace note/chord  or  ...  
                ts(a1,SORTPAR1) = a5 
                a4 = a5 
              else 
                if ts(a1,TYPE) = DESIGNATION 
                  ts(a1,SORTPAR1) = 5 
                end 
              end 
            end 
            a5 = a4 
          repeat 

&dA 
&dA &d@       Sort this section of mf(.) according to SORTPAR1, taking care 
&dA &d@         &dAnot&d@ to separate chord tones from their principal tones.  
&dA 

          if a8 > a7 + 1 

    /* (1) transfer relevant portion to mf2 array 

            loop for a3 = a7+1 to a8 
              mf2(a3) = mf(a3) 
            repeat 

    /* (2) move elements back using order of sort priorites &dAonly&d@ 

            a6 = a7 
            loop for a1 = 1 to 9             /* sort priorities 
              loop for a3 = a7+1 to a8 
                a5 = mf2(a3)                 /* a5 is a ts(.) index 
                if a5 <> 1000 
                  a5 = ts(a5,SORTPAR1)       /* a5 is a sort priority (0 to 9) 
                  if a5 = a1 
                    ++a6 
                    mf(a6) = mf2(a3)         /* move element back to mf 
                    mf2(a3) = 1000           /* and disqualify this element 
                  end 
                end 
              repeat 
            repeat 
          end 
&dA 
&dA &d@       End of mf() section sort 
&dA 
          a7 = a8 
        repeat 

     /* now sort the ts(.,.) array according to the mf(.) order 

        a5 = sct + 1            /* address of "hole" 
        a1 = oldsct + 1 
        loop for a2 = 1 to a8 
          a3 = mf(a2) 
          if a3 <> a1 
      /* move ts(a1) to "hole" and  put  ts(a3) in a1 slot 
            loop for a6 = 1 to TS_SIZE 
              ts(a5,a6) = ts(a1,a6) 
              ts(a1,a6) = ts(a3,a6) 
            repeat 
      /* search mf(.) array for reference to a1 element 
      /*   and tell it that this element is now in a5 
            loop for a7 = a2+1 to a8 
              if mf(a7) = a1 
                mf(a7) = a5 
                a7 = a8 
              end 
            repeat 
&dA &d@           mf(a2) = a1 
      /* set a5 to the new "hole", which is a3 
            a5 = a3 
          end 
      /* advance the destination, a1 
          ++a1 
        repeat 
&dA 
&dA &d@    Code added &dA01/07/06&d@ reporting on a possible failure condition 
&dA &d@           brought on by a faulty stage2 file.  
&dA 
        a5 = sct - oldsct 

        if a5 <> a8 
          if a5 <= sct 
            if (Debugg & 0x06) > 0 
              pute WARNING!  There may be a format error in your source file
              pute (possibly having to do with (cue note) durations).  
            end 
            sct = a8 - oldsct 
          end 
        end 
&dA       

&dA 
&dA &d@    Clear work space 
&dA 
        loop for a1 = oldsct + 1 to sct 
          ts(a1,SORTPAR1) = 0 
        repeat 
        loop for a1 = 1 to TS_SIZE 
          ts(sct+1,a1) = 0 
        repeat 
&dA 
&dA &d@   Reorder multiple grace notes 
&dA 
        loop for a3 = 1 to MAX_PASS 
          passpar(a3) = 200           /* reverse order scheme, starting at 200 
        repeat 
        a6 = 200 
        a5 = 0 
        loop for a1 = sct to oldsct step -1 
          if a1 > oldsct and chr(ts(a1,TYPE)) in [GR_NOTE,XGR_NOTE] 
            if a5 = 0 
              a5 = a1 
            end 
            a2 = ts(a1,PASSNUM) 
            ts(a1,SORTPAR1) = passpar(a2) 
            if a6 > passpar(a2) 
              a6 = passpar(a2) 
            end 
            if ts(a1,TYPE) = GR_NOTE 
              --passpar(a2) 
            end 
          else 
            if a5 > 0           /* some grace notes were found 
              a5 -= a1          /* a5 = number of elements 
              a4 = 0 
              loop for a7 = a6 to 200 
                a3 = 0 
                loop for a8 = 1 to a5 
                  if ts(a1+a8,SORTPAR1) = a7 
                    ++a4 
                    mf(a4) = a1 + a8 
                /* here is where we must add space parameter for GRACE notes 
                    if a3 = 0 
                      if ts(a1+a8,BEAM_FLAG) = NO_BEAM 
                        ts(a1+a8,SPACING) = hpar(97)   /*  Removed  * 4 / 3 &dA05-15-95
                      else 
                        ts(a1+a8,SPACING) = hpar(97) 
                      end 
                      a3 = 1 
                    else 
                      ts(a1+a8,SPACING) = 0 
                    end 
                  end 
                repeat 
              repeat 
           /* mf(.) now contains the locations of array elements (in reordered form)

              loop for a8 = 1 to a5 
                a4 = mf(a8) 
                if a1+a8 <> a4        /* what's there now  is not  what goes there
                  loop for a7 = 1 to TS_SIZE 
                    ts(sct+1,a7) = ts(a1+a8,a7)     /* make hole for new element
                    ts(a1+a8,a7) = ts(a4,a7)        /* move in new element 
                    ts(a4,a7)    = ts(sct+1,a7)     /* put old element in vacancy
                  repeat 
                  loop for a7 = 1 to a5 
                    if mf(a7) = a1 + a8             /* this element has been moved
                      mf(a7) = a4                   /*   now give new location 
                      a7 = a5 
                    end 
                  repeat 
                  mf(a8) = a1 + a8 
                end 
              repeat 

           /* re-initialize sorting parameters 
              loop for a3 = 1 to MAX_PASS 
                passpar(a3) = 200 
              repeat 
              a5 = 0 
              a6 = 200 
            end 
          end 
        repeat 
        loop for a1 = oldsct+1 to sct 
          ts(a1,SORTPAR1) = 0 
        repeat 

&dA  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   
&dA  ³ End of reorder process. ³   
&dA  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   

&dA 
&dA &d@       Check for isolated SIGNS, WORDS, or MARKS 
&dA 
        a2 = oldsct + 1 
        a5 = ts(a2,DIV) 
        loop for a1 = oldsct+1 to sct 
          if ts(a1,DIV) <> a5 
            loop for a3 = a2 to a1 - 1 
              nodtype = ts(a3,TYPE) 
              if chr(nodtype) not_in [SIGN,WORDS,MARK] 
                a3 = 1000000 
              end 
            repeat 
            if a3 <> 1000000 
              loop for a3 = a2 to a1 - 1 
                ts(a3,ISOLATED) = 1 
              repeat 
            end 
            a2 = a1 
            a5 = ts(a2,DIV) 
          end 
        repeat 
&dA 
&dA &d@  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@  ³ Before decoding the notes, we must determine if this part      ³ 
&dA &d@  ³ represents more than one independent instrument.  If so then   ³ 
&dA &d@  ³ the rules regarding accidentals are slightly different.  Each  ³ 
&dA &d@  ³ instrumental part must have its own, independent measax array. ³ 
&dA &d@  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
&dA 

&dA 
&dA &d@    For the case where more than one independent instrument is being 
&dA &d@    represented on this measure, (vflag > 1) we need to catagorize 
&dA &d@    the measure into one of three types: 
&dA 
&dA &d@    (1) one pass, no chords.  
&dA 
&dA &d@       This situation arrises when we have an a2 (zu 2) situation, 
&dA &d@       i.e., all instruments are active, but are playing the same 
&dA &d@       music, or a 1. (2. or 3.) situation, i.e., only one 
&dA &d@       instrument is specifically active -- all other instruments 
&dA &d@       have been told not to play.  In this case, the music is 
&dA &d@       easy to typeset.  
&dA 
&dA &d@    (2) one pass, chords.            
&dA 
&dA &d@       This is the situation more than 90% of the time.  Two or 
&dA &d@       more parts (99.99% of the time, it is two parts) are 
&dA &d@       represented in the measure, and the following conditions 
&dA &d@       hold true: 
&dA 
&dA &d@          a) all parts have the same rhythm (including resting 
&dA &d@               at the same time) 
&dA &d@          b) part 1 is at unison or is higher than part 2, etc.  
&dA 
&dA &d@          c) all parts have identical slurs and articulations.  
&dA &d@               This includes slurs entering and leaving the    
&dA &d@               measure.  
&dA 
&dA &d@          d) if there is a unison and it is an eighth note or less, 
&dA &d@               then it is not attached to a beam.  
&dA 
&dA &d@       The parts will be printed as chords.  Slurs and articulations 
&dA &d@       will be attached to the note head at the end of stem.  Unison 
&dA &d@       notes (represented as chords with two or more identical notes) 
&dA &d@       will be printed in one of two ways: 
&dA 
&dA &d@          a) whole notes and larger will be printed side-by-side.  
&dA 
&dA &d@          b) half notes and smaller will be printed with two stems 
&dA &d@               (up and down) regardless of the listed stem direction.  
&dA &d@               (three unisons cannot be handled by this program) 
&dA 
&dA &d@       &dAWith this type, each part (defined by its position in the chord)&d@ 
&dA &d@       &dAwill have its own measax array.  This is because accidentals    
&dA &d@       &dAmust be repeated, if they appear in different parts.            
&dA 
&dA &d@    (3) more than one pass.  
&dA 
&dA &d@       With this type, notes occuring on the same division and having 
&dA &d@       the same duration and same stem direction will be combined into 
&dA &d@       one chord. &dA As with type (2) above, each part (defined in this   
&dA &d@       &dAcase by pass number) will have its own measax array.  Accidentals&d@ 
&dA &d@       &dAmust be repeated, if they appear in different parts.&d@  Unison 
&dA &d@       whole notes and larger will be printed side-by-side.  
&dA 
        if vflag > 1 
          if passnum = 1 
&dA &d@                     
&dA &d@         Must determine if there are chords in this measure 
&dA 
            mcat = 1 
            loop for a1 = 1 to sct 
              if ts(a1,TYPE) = XNOTE 
                mcat = 2 
                a1 = sct 
              end 
            repeat 
          else 
            mcat = 3 
          end 
        else 
          mcat = 0 
        end 
&dA 
&dA &d@   (added &dA10-12-96&d@) 
&dA 
&dA &d@   Determine links between tie terminators and earlier pitches 
&dA 
&dA &d@       Basically, we look backward through the data to find the pitch 
&dA &d@       referred to by the tie terminator.  If the pitch cannot be found, 
&dA &d@       this is an error condition.  We must search on the correct staff 
&dA &d@       number.  Once we have found the pitch, we need to store its  
&dA &d@       index number.  Later we will determine the STAFFLOC parameter.  
&dA &d@       This will be used later to generate the mark object and the tie 
&dA &d@       super object.  
&dA 
        loop for a1 = oldsct+1 to sct 
          if ts(a1,TYPE) = SIGN and ts(a1,SIGN_TYPE) = TIE_TERM 
            tsdata(ts(a1,TEXT_INDEX)) = tsdata(ts(a1,TEXT_INDEX)) // pad(4) 
            note = tsdata(ts(a1,TEXT_INDEX)){1,4} 
            loop for t7 = a1 to oldsct+1 step -1 
              if ts(t7,TYPE) <= NOTE_OR_REST 
                if ts(t7,STAFF_NUM) = ts(a1,STAFF_NUM) 
                  t8 = ts(t7,4) 
                  if note = tcode(t8) 
                    ts(a1,BACKTIE) = t7        /* store ts index of pitch generating tie
                    goto TIE_TERM_FOUND 
                  end 
                end 
              end 
            repeat 
            tmess = 10 
            perform dtalk (tmess) 
          end 
TIE_TERM_FOUND: 
        repeat 
&dA 
&dA &d@   End of &dA10-12-96&d@ addition 
&dA 

&dA 
&dA &d@   Decode pitches, store &dAunmodified&d@ accidentals in ts(.,AX) 
&dA 
        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE) 
          if nodtype <= NOTE_OR_REST 
            a2 = ts(a1,4) 
            note = tcode(a2) 
&dA 
&dA &d@       Putting the decodenote procedure "in line" here, since it 
&dA &d@       is called only once.  
&dA 
            if note = "rest" 
              a7 = 100 
              a8 = 0 
              mf(1) = 0 
              goto DECODE_DONE 
            end 
            if note = "ires" 
              a7 = 200 
              a8 = 0 
              goto DECODE_DONE 
            end 
            if "CDEFGAB" con note{1} 
              t1 = mpt 
            end 
            a8 = 0 
            loop for t2 = 2 to 4 
              if "0123456789" con note{t2} 
                a7 = mpt - 2 * 7 + t1 
                goto DECODE_DONE 
              end 
              a8 <<= 2 
              if " #f" con note{t2} 
                a8 = a8 | mpt 
              end 
            repeat 
            if (Debugg & 0x01) > 0 
              pute note = ~note    ...  
            end 
            tmess = 9 
            perform dtalk (tmess) 
DECODE_DONE: 
            if a7 = 100 
              a7 += ts(a1,CLAVE)       /* see "floating rest flag"
            end 
            ts(a1,CLAVE) = a7          /* &dAHere is where CLAVE is definitively set
            ts(a1,AX) = a8 
            a4 = ts(a1,STAFF_NUM) + 1 
            if a7 < 100  
              ts(a1,STAFFLOC) = 52 - a7 - cline(a4) + c8flag(a4) + 20 * notesize / 2 - vpar20
            end  
&dA 
&dA &d@      We need to capture the note shape data now, because it will figure in on
&dA &d@      whether a passage is iso-rhythmic; i.e., you can't have iso-rhythm with 
&dA &d@      different note shapes.    Code added &dA02/19/06&d@ 
&dA 
            a14 = ts(a1,TSR_POINT) 
            a4 = ors(tsr(a14){1}) 
            if a4 > 16 
              a4 >>= 4           /* upper four bits 
              a4 <<= 20          /*   shifted to space 20-23 
              ts(a1,SUBFLAG_1) |= a4 
            end 
&dA     
          end  
          if chr(nodtype) in [SIGN,WORDS,MARK]
            a4 = ts(a1,STAFF_NUM) + 1    /* staff number 
            a2 = ts(a1,SUPER_TYPE) + 1 / 2
            if chr(a2) in [OCT_UP,OCT_DOWN,DBL_OCT_UP,DBL_OCT_DOWN]
&dA 
&dA &d@         adjust c8flag(.) 
&dA 
              if a2 = OCT_UP 
                c8flag(a4) = -7 
              end 
              if a2 = OCT_DOWN 
                c8flag(a4) = 7 
              end 
              if a2 = DBL_OCT_UP 
                c8flag(a4) = -14 
              end 
              if a2 = DBL_OCT_DOWN 
                c8flag(a4) = 14 
              end 
              transflag(a4) = 2 * a2
            end
            if ts(a1,SUPER_TYPE) = NORMAL_TRANS 
              c8flag(a4) = 0             /* return to normal 
              if transflag(a4) < 2 * OCT_UP 
                if (Debugg & 0x06) > 0 
                  pute Possible Coding error with transpositions 
                end 
              end 
              ts(a1,SUPER_TYPE) = transflag(a4) 
              transflag(a4) = 0
            end 
          end  
          if nodtype = CLEF_CHG
            a4 = ts(a1,STAFF_NUM) + 1    /* staff number 
            clef(a4) = ts(a1,CLEF_NUM) 
            perform zjcline (a4) 
*     this resets clef and cline 
            ts(a1,CLEF_STAFF_POS) = 5 - clef_vpos * notesize     /* &dA  Possibly     
            a3 = hpar(8) * 5 / 6                                 /* &dA  unnecessary  
            if ts(a1,CLEF_FONT) >= 128   /* music font           /* &dA  at this      
              a3 = a3 * 8 / 10                                   /* &dA  point        
            end                                                  /* &dA               
            ts(a1,SPACING) = a3                                  /* &dA               

          end  
        repeat 

&dA 
&dA &d@   If mcat = 3, reorganize notes on the same division.  If two notes 
&dA &d@   with different pass numbers have the same duration and stem directions 
&dA &d@   in the same direction, and these notes do not have beam connections, 
&dA &d@   then these notes can be combined into one chord.  This will save 
&dA &d@   considerable trouble later during the computing of x-offsets (both 
&dA &d@   local and global) and the setting of stems.  
&dA 
&dA &d@   &dA09/22/93&d@  Actually I would like to expand this section.  
&dA 
&dA &d@    (1) I would like to try to combine isorhythmic passages that do connect 
&dA &d@        to beams 
&dA 
&dA &d@    (2) If the entire measure is isorhythmic, then I would like to set 
&dA &d@        mcat to 2 and reduce the number of passes 
&dA 
&dA &d@    (3) Also, if the measure is isorhythmic, I would like to print out 
&dA &d@        rests only one time 
&dA 
&dA &d@    (4) Also, if mcat > 1, accidentals on the same line should NOT be 
&dA &d@        reprinted.  This should be easy to fix, simply by looping though 
&dA &d@        all simultanities on a staff and removing accidentals that 
&dA &d@        occur twice on the same pitch.  
&dA 
&dA &d@   available variables: a1 --> a16 
&dA 
        if mcat = 3               /* %%% add code here for changing ax behavior
&dA 
&dA &d@     First thing: fix accidentals according to pass number 
&dA 
          loop for a1 = oldsct+1 to sct 
            nodtype = ts(a1,TYPE) 
            if nodtype <= NOTE_OR_REST 
              a4 = ts(a1,PASSNUM) 
              if a4 > 3 
                tmess = 25 
                perform dtalk (tmess) 
              end 
              perform decodeax (a1,a4) 
            end 
            if nodtype = BAR_LINE 
              loop for a3 = 1 to 50 
                loop for a4 = 1 to 4                    /* &dA06/04/08&d@ was 3 
                  measax(a4,a3) = tclaveax(a3)          /* New &dA12/14/07&d@ 
                repeat 
              repeat 
            end 
            if nodtype = CLEF_CHG 
              a4 = ts(a1,STAFF_NUM) + 1    /* staff number 
              clef(a4) = ts(a1,CLEF_NUM) 
              perform zjcline (a4) 
*     this resets clef and cline 
              ts(a1,CLEF_FONT) += z        /* music font 
              ts(a1,CLEF_STAFF_POS) = 5 - clef_vpos * notesize 
              a3 = hpar(8) * 5 / 6                           /* Added &dA06-24-94&d@ 
              if ts(a1,CLEF_FONT) > 128     /* music font 
                a3 = a3 * 8 / 10 
              end 
              ts(a1,SPACING) = a3 
              if nstaves > 1     /* Case: assume one part to stave (usual case)
                loop for a3 = 1 to 50 
                  measax(a4,a3) = tclaveax(a3)          /* New &dA12/14/07&d@ 
                repeat 
              else 
                loop for a4 = 1 to 4                    /* &dA06/04/08&d@ was 3 
                  loop for a3 = 1 to 50 
                    measax(a4,a3) = tclaveax(a3)        /* New &dA12/14/07&d@ 
                  repeat 
                repeat 
              end 
            end 
          repeat 
&dA 
&dA &d@     Now you can combine notes into chords  (and alter pass numbers) 
&dA 
&dA &d@     If there are notes of different note shapes in a measure, this is a 
&dA &d@     non-starter for combining any notes into chords.  All notes must have 
&dA &d@     the same note shape (bits 20-23 of SUBFLAG_1).  This information was 
&dA &d@     encoded at the same time as pitch.  (added &dA02/19/06&d@) 
&dA 
          a2 = 0 
          loop for a1 = oldsct+1 to sct 
            nodtype = ts(a1,TYPE) 
            if nodtype <= NOTE_OR_REST 
              if a2 = 0  
                a2 = a1 
              end 
              if (ts(a2,SUBFLAG_1) & 0xf00000) <> (ts(a1,SUBFLAG_1) & 0xf00000) 
                goto ISO_DONE
              end 
            end 
          repeat 
&dA         

&dA 
&dA &d@     First check to see if the entire measure is isorhythmic.  This will 
&dA &d@     save time in the end, and is also necessary in determining whether or 
&dA &d@     not to eliminate duplicate rests.  There are some caviats here: 
&dA 
&dA &d@      (1) Notes with lower pass numbers must always be unison or higher   
&dA &d@            on the staff 
&dA &d@      (2) All stem directions must be the same (for a particular division)
&dA &d@            &dAREMOVED
&dA 
&dA &d@      (3) All beam flags for notes from each pass must be identical.        
&dA 
&dA &d@      (4) Every division must have a representative from each pass.  These 
&dA &d@            must be either all notes or all rests.  
&dA 
          /* %%% add code here for disabling isorhythmic compression 

          loop for a1 = oldsct+1 to sct 
            nodtype = ts(a1,TYPE) 
            if nodtype <= NOTE_OR_REST 
              loop for a2 = a1 + 1 to sct 
                if ts(a2,DIV) <> ts(a1,DIV) or ts(a2,SPACING) <> 0 
                  goto JOL1 
                end 
                if nodtype = REST or nodtype = CUE_REST 
                  if ts(a2,TYPE) <> nodtype 
                    goto JOL1 
                  end 
                else 
                  if ts(a2,TYPE) <> nodtype and ts(a2,TYPE) <> nodtype + 1 
                    goto JOL1 
                  end 
                end 
              repeat        
JOL1: 
              --a2 
              if a2 - a1 + 1 < passnum 
                goto ISO_FAIL 
              end 
              a4 = 0 
              a5 = 0 
              a6 = ts(a1,PASSNUM) 
              a7 = 1000 
              loop for a3 = a1 to a2 
                if ts(a3,CLAVE) < 100 
                  if ts(a3,STAFF_NUM) <> ts(a1,STAFF_NUM) 
                    goto ISO_FAIL 
                  end 
&dA &d@                 if bit(1,ts(a3,STEM_FLAGS)) <> bit(1,ts(a1,STEM_FLAGS)) 
&dA &d@                   goto ISO_FAIL 
&dA &d@                 end 
                  if ts(a3,BEAM_FLAG) <> ts(a1,BEAM_FLAG) 
                    goto ISO_FAIL 
                  end 
                  if bit(0,ts(a3,SUPER_FLAG)) <> bit(0,ts(a1,SUPER_FLAG))    /* ties
                    goto ISO_FAIL 
                  end 
                  if bit(2,ts(a3,STEM_FLAGS)) = 0         /* number of "events"
                    ++a4 
                  end 
                  if ts(a3,PASSNUM) = a6                 /* order of pitches */
                    if ts(a3,CLAVE) < a7 
                      a7 = ts(a3,CLAVE) 
                    end 
                  else 
                    if ts(a3,CLAVE) > a7 
                      goto ISO_FAIL 
                    end 
                    a6 = ts(a3,PASSNUM) 
                    a7 = ts(a3,CLAVE) 
                  end 
                else 
                  ++a5 
                end 
              repeat 
              if a4 = 0 
                if a5 <> passnum 
                  goto ISO_FAIL 
                end 
              else 
                if a4 <> passnum or a5 > 0 
                  goto ISO_FAIL 
                end 
              end 
              a1 = a2 
            end 
          repeat 

&dA 
&dA &d@     The measure meets the conditions of isorhythmic compression.  Here is 
&dA &d@     what we must do: 
&dA 
&dA &d@       (1) Rests:  Delete duplicate rests.  Do this all at one time, 
&dA &d@             since this involves resizing the ts array.  
&dA 
&dA &d@           &dANote on this&d@: I don't think autoscr actually wants to delete 
&dA &d@             rests, but rather to make them "silent."  To do otherwise 
&dA &d@             might remove time from a track.  
&dA 
&dA &d@       (2) Notes--situation 1: Note not connected to a beam 
&dA 
&dA &d@          New condition &dA12/20/05&d@: If stem_change_flag < 3, then do the 
&dA &d@            steps below only if the stem directions are the same.  
&dA 
&dA &d@          &dA &d@ If no unison and no chords in separate parts, then combine all 
&dA &d@          &dA &d@      pitches into one chord 
&dA &d@          &dA &d@   If separate stem directions do not agree, determine 
&dA &d@          &dA &d@     best direction; otherwise use common direction 
&dA &d@          &dA 
&dA &d@          &dA &d@          TYPE: for each note group, make first type 1,4,7 and 
&dA &d@          &dA &d@                  all others 2,5,8 
&dA &d@          &dA &d@    STEM_FLAGS: set all bit2's; set all bit3's for all but first 
&dA &d@          &dA &d@                  member of group 
&dA &d@          &dA &d@     BEAM_FLAG: zero for all but first member of chord group 
&dA &d@          &dA &d@     BEAM_CODE: zero for all but first member of chord group 
&dA &d@          &dA &d@     PASSNUM: equal to PASSNUM for first member of group 
&dA &d@          &dA 
&dA &d@          &dA &d@ Otherwise, set the stem direction for the upper pass 
&dA &d@          &dA &d@   to up and for the lower pass to down.  
&dA 
&dA &d@       (3) Notes--situation 2: Note is connected to a beam 
&dA 
&dA &d@            For all notes on that beam determine if there are any unisons 
&dA &d@               or any chords in separate chords.  
&dA 
&dA &d@              If no unisons and no chords, then combine all pitches into one chord
&dA &d@                If separate stem directions do not agree, determine 
&dA &d@                  best direction; otherwise use common direction 
&dA 
&dA &d@                       TYPE: for each note group, make first type 1,4,7 and 
&dA &d@                               all others 2,5,8 
&dA &d@                 STEM_FLAGS: set all bit2's; set all bit3's for all but first 
&dA &d@                               member of group 
&dA &d@                  BEAM_FLAG: zero for all but first member of chord group 
&dA &d@                  BEAM_CODE: zero for all but first member of chord group 
&dA &d@                  PASSNUM: equal to PASSNUM for first member of group 
&dA 
&dA &d@              If unisons, then set the stem direction for the upper pass 
&dA &d@                to up and for the lower pass to down.  
&dA 
&dA &d@       (4) If all notes in measure were combined into chords, then 
&dA &d@              decrease passnum by amount of largest PASSNUM + 1 / 2 
&dA 

&dA 
&dA &d@   (1) Rests:  Delete duplicate rests 
&dA 

          a1 = oldsct+1 
COMPRESS1: 
          nodtype = ts(a1,TYPE) 
          if (nodtype = REST or nodtype = CUE_REST) and rest_collapse = TRUE
            loop for a2 = a1 + 1 to sct 
              if ts(a2,DIV) <> ts(a1,DIV) or ts(a2,TYPE) <> nodtype 
                goto JOL2 
              end 
            repeat         
JOL2: 
            if a2 > a1 + 1                           /* do this only if another rest is found
              a5 = a1 + 1 
              loop for a3 = a2 to sct 
                loop for a4 = 1 to TS_SIZE 
                  ts(a5,a4) = ts(a3,a4) 
                repeat 
                ++a5 
              repeat 
              loop for a4 = 1 to TS_SIZE            /* &dA1/30/96&d@  clear last ts(.,.) line
                ts(sct,a4) = 0 
              repeat 
              sct -= a2 - a1 - 1 
            end 
          end 
          ++a1 
          if a1 <= sct 
            goto COMPRESS1 
          end 
&dA 
&dA &d@   (2) (3) Notes-- situations 1 and 2      
&dA 
          a16 = 0  /* New &dA12/20/05&d@ and be careful not to modify this in other parts of AUTOSET
          a15 = 0  /* New &dA12/20/05&d@ 
          a10 = 0 
          a5 = 0 
          a6 = 0 
          a7 = 0              
          a8 = 0 

          loop for a1 = oldsct+1 to sct 
            nodtype = ts(a1,TYPE) 
            if nodtype = NOTE or nodtype = CUE_NOTE or nodtype = GR_NOTE 
              loop for a2 = a1 + 1 to sct 
                if ts(a2,DIV) <> ts(a1,DIV) or ts(a2,SPACING) <> 0 
                  goto JOL3 
                end 
              repeat while ts(a2,TYPE) = nodtype or ts(a2,TYPE) = nodtype + 1 
JOL3: 
              --a2 
&dA 
&dA &d@     Remove duplicate fermatas for notes on same division (because it is easy 
&dA &d@         to do at this point) 
&dA 
&dA &d@     New code &dA12/18/10&d@.  Treats up and down fermatas separately, and in new location
&dA 
              a4 = ts(a1,SUBFLAG_1) & 0x04000000      /* 0100 0000 0000 0000 0000 0000 0000
              a7 = ts(a1,ED_SUBFLAG_1) & 0x04000000   /* 0100 0000 0000 0000 0000 0000 0000
              loop for a3 = a1 + 1 to a2                      
                if ts(a3,SUBFLAG_1) & 0x04000000 = a4 
                  ts(a3,SUBFLAG_1) &= 0xfbffffff 
                end 
                if ts(a3,ED_SUBFLAG_1) & 0x04000000 = a7
                  ts(a3,ED_SUBFLAG_1) &= 0xfbffffff 
                end 
              repeat 

              a4 = ts(a1,SUBFLAG_1) & 0x08000000      /* 1000 0000 0000 0000 0000 0000 0000
              a7 = ts(a1,ED_SUBFLAG_1) & 0x08000000   /* 1000 0000 0000 0000 0000 0000 0000
              loop for a3 = a1 + 1 to a2 
                if ts(a3,SUBFLAG_1) & 0x08000000 = a4 
                  ts(a3,SUBFLAG_1) &= 0xf7ffffff 
                end 
                if ts(a3,ED_SUBFLAG_1) & 0x08000000 = a7
                  ts(a3,ED_SUBFLAG_1) &= 0xf7ffffff 
                end 
              repeat 
&dA 
&dA      &d@ End of new code &dA12/18/10&d@ 

              if a2 - a1 + 1 > passnum 
                a7 = 1                      /* chords are present on this division
              end 
&dA 
&dA &d@     Determine if there is a unison in this group 
&dA 
              if a7 = 0 and stem_change_flag = 3      /* New condition &dA12/20/05
                loop for a3 = a1 + 1 to a2 
                  if ts(a3,CLAVE) = ts(a3-1,CLAVE) 
                    a7 = 1 
                  end 
                repeat 
              end 

              if a16 = 0 
                loop for a3 = a1 + 1 to a2 
                  if bit(1,ts(a3,STEM_FLAGS)) <> bit(1,ts(a1,STEM_FLAGS)) 
                    a8 = 1                  /* conflicting stem directions 
                  end 
                repeat 
              end 
              if ts(a1,BEAM_FLAG) <> 0      /* this note is on a beam 
                a15 = 1                     /* New &dA12/20/05&d@ "beam flag" 
                if ts(a1,BEAM_FLAG) = START_BEAM 
                  a16 = a1                  /* index starts (first/top) beam
                end 
                if ts(a1,BEAM_FLAG) = END_BEAM 
                  a16 += INT10000           /* beams end; now use saved value of a1 from above
                end 
              else 
                a16 = a1 + INT10000         /* "no beam" case 
              end 
              if a16 > INT10000             /* process notes here 
                a16 -= INT10000             /* recover value of starting "a1"
&dA 
&dA &d@           New condition &dA12/20/05&d@: If stem_change_flag < 3, then (for 
&dA &d@             non-beam case) do steps below only if the stem directions 
&dA &d@             are the same.  (i.e., when a15 = 0, a8 must be zero, 
&dA &d@             if stem_change_flag < 3) 
&dA 
                if a15 = 0      /* no beam 
                  if stem_change_flag < 3 and a8 = 1 
                    a10 = 1                            /* New condition &dA12/20/05
                    goto NO_STEM_CHANGE 
                  end 
                end 
&dA        
&dA &d@           At this point: either a15 = 1 (this is a beamed group or set of beamed groups)
&dA &d@                 or stem_change_flag = 3 (old code situation) 
&dA &d@                               or a8 = 0 (all stems point the same way) 
&dA 
&dA &d@      Case 1: either a unison between passes or a chord on one of the passes 
&dA &d@              (note: in order for a unison to trigger this case, stem_change_flag must = 3
&dA &d@                     otherwise, unisons will fall into case 2 
&dA 
                if a7 = 1 
&dA 
&dA &d@        New &dA12/20/05&d@ change stem directions only of stem_change_flag = 3 
&dA 
                  if stem_change_flag = 3 
                    loop for a3 = a16 to a2                /* all notes inclusive
                      a7 = ts(a3,TYPE) 
                      if a7 <= NOTE_OR_REST and a7 <> REST and a7 <> CUE_REST
                        if ts(a3,PASSNUM) = ts(a16,PASSNUM) 
                          ts(a3,STEM_FLAGS) &= 0xfffd      /* stem up for upper pass
                        else 
                          ts(a3,STEM_FLAGS) |= 0x0002      /* stem down for lower pass
                        end 
                      end 
                    repeat 
                  end 
                  a10 = 1 
                else 
&dA 
&dA &d@      Old Case 2: no unisons, no chords -- combine passes in one chord                
&dA &d@                    (and stem_change_flag = 3) 
&dA 
&dA &d@      &dA12/20/05&d@ Case 2: no chords -- combine passes in one chord 
&dA &d@                       (note: unisons may fall into this case if stem_change_flag < 3)
&dA 
&dA 
                  if a8 = 1 and stem_change_flag < 3     /* New condition &dA12/20/05
                    a10 = 1 
                    goto NO_STEM_CHANGE 
                  end 

                  if a8 = 1            /* determine stem direction 
                    a8 = 0 
                    loop for a3 = a16 to a2 
                      a7 = ts(a3,TYPE) 
                      if a7 <= NOTE_OR_REST and a7 <> REST and a7 <> CUE_REST 
                        a8 += ts(a3,STAFFLOC) 
                      end 
                    repeat 
                    a8 <<= 1 
                    a8 /= notesize 
                    a9 = a2 - a16 + 1 
                    a8 += a9 + 1 / 2 
                    a8 /= a9             
                    if a8 >= 5 
                      a9 = UP 
                    else 
                      a9 = DOWN 
                    end 
                  else 
                    a9 = bit(1,ts(a16,STEM_FLAGS)) 
                  end 

                  a11 = 0 
                  a12 = 0 
                  loop for a3 = a16 to a2       /* put all notes into chords
                    a7 = ts(a3,TYPE) 
                    if a7 <= NOTE_OR_REST and a7 <> REST and a7 <> CUE_REST 
                      ts(a3,STEM_FLAGS) &= 0xfffd     /* prepare for new stem direction
                      ts(a3,STEM_FLAGS) |= a9 << 1 
&dA   
&dA &d@     Also move all dynamics for notes on same division to first note (This is correct place
&dA &d@       to do this operation &dA12/20/05&d@)   &dEThis code uses a4, a6 and a14 in a temporary manner
&dA   
                      if ts(a3,DIV) <> a11 or ts(a3,SPACING) <> 0 or a12 <> a7 or a3 = a16
                        a12 = a7 
                        a11 = ts(a3,DIV) 
                        ts(a3,STEM_FLAGS) |= 0x04 
                        a8 = a3 
&dA   
&dA &d@     Collect dynamics data for this note (a3) &dA12/20/05&d@ 
&dA   

                        a4 = ts(a3,SUBFLAG_1)    & 0x007c00 
                        a6 = ts(a3,ED_SUBFLAG_1) & 0x007c00 
                      else 
                        ts(a3,TYPE) = ts(a8,TYPE) + 1 
                        ts(a3,STEM_FLAGS) |= 0x0c 
                        ts(a3,BEAM_FLAG) = 0 
                        ts(a3,BEAM_CODE) = 0 
                        if ts(a3,PASSNUM) > a5 
                          a5 = ts(a3,PASSNUM)         /* save max passnum 
                        end 
                        ts(a3,PASSNUM) = ts(a8,PASSNUM) 
&dA    
&dA &d@     Merge dynamics data with data for first (a8) note 
&dA 
                        a4 |= ts(a3,SUBFLAG_1)    & 0x007c00 
                        a6 |= ts(a3,ED_SUBFLAG_1) & 0x007c00 
&dA 
&dA &d@     Turn off dynamics data for this note (a3) 
&dA 
                        ts(a3,SUBFLAG_1) &= 0xffff83ff 
                        ts(a3,ED_SUBFLAG_1) &= 0xffff83ff 
&dA 
&dA &d@     Add in (new) dynamics data to first (a8) note 
&dA 
                        ts(a8,SUBFLAG_1) |= a4 
                        ts(a8,ED_SUBFLAG_1) |= a6 
&dA 
&dA &d@          The following code is untested, and may cause problems.  
&dA &d@          Note: &dA10/28/07&d@ it has!   I will make some changes that fix a definite
&dA &d@            bug, but there may still be other problems.  
&dA 
                        c4 = ts(a3,TSR_POINT) 
                        c5 = ts(a8,TSR_POINT) 
             /* byte 1 
                        c6 = ors(tsr(c4){1}) & 0xff 
                        c7 = ors(tsr(c5){1}) & 0xff 
                        c7 |= c6 
                        tsr(c5){1} = chr(c7) 
             /* byte 2 
                        c6 = ors(tsr(c4){2}) & 0xff 
                        c7 = ors(tsr(c5){2}) & 0xff 
                        c7 |= c6 
                        tsr(c5){2} = chr(c7) 
             /* byte 3 = x offset (modification by suggestion) 
                        c6 = ors(tsr(c4){3}) & 0xff 
                        c7 = ors(tsr(c5){3}) & 0xff 
                        if c6 <> c7 
                          if (Debugg & 0x06) > 0 
                            pute WARNING:  At approximate measure number ~(measnum - 1)
                            pute 
                            pute       You have asked autoset to combine into a chord two pitches
                            pute   which have different x offsets.  This will be done, but the
                            pute   results are unpredictable.  Note combination usually arrises
                            pute   when two instruments occupy the same staff (multi track) and
                            pute   have simultaneous notes with the same stem direction.  If you
                            pute   really want different x offsets, you should make the stem
                            pute   directions on these notes different.  
                            pute 
                          end 
                        end 
                        tsr(c5){3} = chr(c7) 
             /* byte 4 = y offset (modification by suggestion) 
                        c6 = ors(tsr(c4){4}) & 0xff 
                        c7 = ors(tsr(c5){4}) & 0xff 
                        if c6 <> c7 
                          if (Debugg & 0x06) > 0 
                            pute WARNING:  At approximate measure number ~(measnum - 1)
                            pute 
                            pute       You have asked autoset to combine into a chord two pitches
                            pute   which have different x offsets.  This will be done, but the
                            pute   results are unpredictable.  Note combination usually arrises
                            pute   when two instruments occupy the same staff (multi track) and
                            pute   have simultaneous notes with the same stem direction.  If you
                            pute   really want different x offsets, you should make the stem
                            pute   directions on these notes different.  
                            pute 
                          end 
                        end 
                        tsr(c5){4} = chr(c7) 

                        c7 = TSR_LENG 
                        a14 = ts(a3,TSR_POINT)             /* combine tsr strings
                        tbit2 = cbi(tsr(a14){5..}) 
                        a14 = ts(a8,TSR_POINT) 
                        tbit1 = cbi(tsr(a14){5..}) 
                        tbit1 = bor(tbit1,tbit2) 
                        tsr(a14){5..c7} = cby(tbit1) 
&dA 
&dA                     &d@  End of &dA10/28/07&d@ modifications 

&dA 
&dA &d@     End of dynamics merge process (moved here &dA12/20/05&d@) 
&dA    
                      end 
                    end 
                  repeat 

                end 
NO_STEM_CHANGE: 
                a16 = 0 
                a7 = 0             
                a8 = 0 
                a15 = 0                        /* New &dA12/20/05&d@ 
              end 
              a1 = a2 
            end 
          repeat 

&dA 
&dA &d@   (4) If all notes in measure were combined into chords, then 
&dA &d@         Adjust PASSNUM for all nodes and decrease passnum by 
&dA &d@         amount of largest PASSNUM + 1 / 2  (not fully implemented) 
&dA 
          if a10 = 0 
            if a5 > 2 
              if (Debugg & 0x06) > 0 
                pute WARNING:  This program may have problems with more than
                pute   two separate instruments on a staff line 
              end 
            end 
            loop for a1 = oldsct+1 to sct 
              ts(a1,PASSNUM) = 1 
            repeat 
            passnum = 1 
          end 

          goto ISO_DONE 

ISO_FAIL: 

          loop for a1 = oldsct+1 to sct 
            nodtype = ts(a1,TYPE) 
            if nodtype <= NOTE_OR_REST and ts(a1,BEAM_FLAG) = NO_BEAM 
              a4 = ts(a1,DIV)                /* test note 
              a5 = ts(a1,NOTE_DUR) 
              a6 = bit(1,ts(a1,STEM_FLAGS)) 
              a7 = ts(a1,STAFF_NUM) 
              if nodtype = NOTE or nodtype = CUE_NOTE 
                loop for a3 = a1+1 to sct 
                  if ts(a3,DIV) = a4 
                    if ts(a3,TYPE) = nodtype and ts(a3,NOTE_DUR) = a5 
                      if bit(1,ts(a3,STEM_FLAGS)) = a6 and ts(a3,BEAM_FLAG) = NO_BEAM
                        if ts(a3,STAFF_NUM) = a7 
&dA 
&dA &d@           Move this to be part of a chord on test note 
&dA 
                          a9 = a1+1 
                          perform rotate_array (a9,a3) 
                          ts(a9,TYPE) = nodtype + 1    /* chord note 
                          ts(a9,STEM_FLAGS) |= 0x0c 
                          ts(a1,STEM_FLAGS) |= 0x04    /* make note at a1 "first" in chord &dA1/30/96
                          ts(a9,PASSNUM) = ts(a1,PASSNUM) 
                        end 
                      end 
                    end 
                  else 
                    a3 = sct 
                  end 
                repeat 
              end 
              if nodtype = GR_NOTE 
                a8 = ts(a1,NTYPE) 
                loop for a3 = a1+1 to sct 
                  if ts(a3,DIV) = a4 
                    if ts(a3,TYPE) = GR_NOTE and ts(a3,NTYPE) = a8 and ts(a3,SPACING) = 0
                      if bit(1,ts(a3,STEM_FLAGS)) = a6 and ts(a3,BEAM_FLAG) = NO_BEAM
                        if ts(a3,STAFF_NUM) = a7 
&dA 
&dA &d@           Move this to be part of a chord on test note 
&dA 
                          a9 = a1+1 
                          perform rotate_array (a9,a3) 
                          ts(a9,TYPE) = XGR_NOTE 
                          ts(a9,STEM_FLAGS) |= 0x0c 
                          ts(a1,STEM_FLAGS) |= 0x04    /* make note at a1 "first" in chord &dA1/30/96
                          ts(a9,PASSNUM) = ts(a1,PASSNUM) 
                        end 
                      end 
                    end 
                  else 
                    a3 = sct 
                  end 
                repeat 
              end 
            end 
          repeat 

&dA                                                                            
&dA 
&dA &d@     New code &dA10/14/07&d@ 
&dA &d@     Without wrecking what already works with autoset, I will now attempt to
&dA &d@        combine groups of notes under the same beam for the case where there
&dA &d@        is a third "silent" track or other disruptive objects.  
&dA 
          loop for a1 = oldsct+1 to sct 
            nodtype = ts(a1,TYPE) 
            if nodtype = NOTE and ts(a1,BEAM_FLAG) = START_BEAM 
              a4 = ts(a1,DIV)                /* test note 
              a5 = ts(a1,NOTE_DUR) 
              a6 = bit(1,ts(a1,STEM_FLAGS)) 
              a7 = ts(a1,STAFF_NUM) 
              a2 = a1 + 1 
              if ts(a2,TYPE) = NOTE and ts(a2,BEAM_FLAG) = START_BEAM 
                if ts(a2,DIV) = a4 and ts(a2,NOTE_DUR) = a5 
                  if bit(1,ts(a2,STEM_FLAGS)) = a6 and ts(a2,STAFF_NUM) = a7 
                    c1 = a1 + 2 
                    c2 = a2 + 2 
                    loop while ts(c1,BEAM_FLAG) = CONT_BEAM or ts(c1,BEAM_FLAG) = END_BEAM
                      if ts(c2,BEAM_FLAG) <> ts(c1,BEAM_FLAG) 
                        goto NO_BCOM 
                      end 
                      if ts(c1,TYPE) <> NOTE or ts(c2,TYPE) <> NOTE 
                        goto NO_BCOM 
                      end 
                      if ts(c2,DIV) <> ts(c1,DIV) or ts(c2,NOTE_DUR) <> ts(c1,NOTE_DUR)
                        goto NO_BCOM 
                      end 
                      if bit(1,ts(c1,STEM_FLAGS)) <> a6 or bit(1,ts(c2,STEM_FLAGS)) <> a6
                        goto NO_BCOM 
                      end 
                      if ts(c1,STAFF_NUM) <> a7 or ts(c2,STAFF_NUM) <> a7 
                        goto NO_BCOM 
                      end 
&dA 
&dA &d@   New code &dA12/18/10&d@.  Don't combine if there are ornaments, back ties, or fermatas
&dA 
                      c3 = ts(c1,SUBFLAG_1) & 0x0f0803ff      
                      c4 = ts(c1,ED_SUBFLAG_1) & 0x0f0803ff   
                      if c3 <> 0 or c4 <> 0 
                        goto NO_BCOM 
                      end 
&dA     
                      c1 += 2 
                      c2 += 2 
                    repeat 
                    c1 -= 2 
                    c2 -= 2 
                    if ts(c1,BEAM_FLAG) <> END_BEAM or ts(c2,BEAM_FLAG) <> END_BEAM
                      goto NO_BCOM 
                    end 
&dA 
&dA &d@           Move these notes to be part of chords on test notes 
&dA 
                    loop for c3 = a1 to c1 step 2 
                      a9 = c3 + 1 
                      ts(a9,TYPE) = nodtype + 1    /* chord note 
                      ts(a9,STEM_FLAGS) |= 0x0c 
                      ts(c3,STEM_FLAGS) |= 0x04 
                      ts(a9,PASSNUM) = ts(c3,PASSNUM) 
&dA 
&dA &d@   New code &dA12/18/10&d@.  From SUBFLAG_1, combine only the dynamics 
&dA 
                      c4 = ts(a9,SUBFLAG_1) & 0x7c00        /* dynamics only
                      ts(c3,SUBFLAG_1) |= c4                /* add these to main note
                      ts(a9,SUBFLAG_1) &= 0xffff83ff        /* and turn them off here
                      c4 = ts(a9,ED_SUBFLAG_1) & 0x7c00     /* dynamics only
                      ts(c3,ED_SUBFLAG_1) |= c4             /* add these to main note
                      ts(a9,ED_SUBFLAG_1) &= 0xffff83ff     /* and turn them off here
&dA      
                      ts(c3,SUBFLAG_2) |= ts(a9,SUBFLAG_2)        /* New &dA05/17/03
                      ts(a9,SUBFLAG_2) = 0                                                
                      ts(c3,ED_SUBFLAG_2) |= ts(a9,ED_SUBFLAG_2)  /* New &dA05/17/03
                      ts(a9,ED_SUBFLAG_2) = 0 
                    repeat 
                    a1 = a9 
                  end 
                end 
              end 
            end 
NO_BCOM: 
          repeat 
&dA 
&dA &d@     Check to see if the number of passes has been reduced            
&dA &d@        (omitted for the moment; may not be necessary) 
&dA 

ISO_DONE: 

        end 
&dA 
&dA &d@   Make sure at this point that all chords are oriented with the top 
&dA &d@   note first.  Also, for each note (or set of notes = chord), compute 
&dA &d@   the position of the note head at the end of the stem, and also 
&dA &d@   compute the position of the end of the stem.  Later, we will make  
&dA &d@   a "best guess" about what the beam height for those notes belonging 
&dA &d@   to a beam.  Store the note position in VIRT_NOTE (for all notes 
&dA &d@   of the chord) and the stem position in VIRT_STEM (for all notes 
&dA &d@   of the chord) 
&dA 
        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE) 
          if chr(nodtype) in [NOTE,CUE_NOTE,GR_NOTE]
            if bit(2,ts(a1,STEM_FLAGS)) = 1  /* This is a chord 
              a5 = ts(a1,STEM_FLAGS) & 0x03           /* save lower two bits 
              a2 = a1 + 1 
              loop while ts(a2,TYPE) = nodtype + 1 
                ++a2 
              repeat 
              --a2            /* a2 = last note in chord 
&dA 
&dA &d@         Bubble sort 
&dA 
              loop for a3 = a1 to a2-1 
                loop for a4 = a3 to a2 
                  if ts(a3,CLAVE) < ts(a4,CLAVE) 
                    loop for a7 = 2 to TS_SIZE        /* keep primary type on top
                      if a7 <> BEAM_FLAG and a7 <> BEAM_CODE     /* and don't move beam flags, etc.
                        ts(sct+1,a7) = ts(a3,a7)        /* make hole for new element
                        ts(a3,a7)    = ts(a4,a7)        /* move in new element 
                        ts(a4,a7)    = ts(sct+1,a7)     /* put old element in vacancy
                      end 
                    repeat 
                  end 
                repeat 
              repeat 
&dA 
&dA &d@         Rewrite stem flags 
&dA 
              loop for a3 = a1 to a2  
                if a3 = a1 
                  ts(a3,STEM_FLAGS) = a5 + 0x04       /* turn bit 2 
                else 
                  ts(a3,STEM_FLAGS) = a5 + 0x0c       /* turn bits 2 and 3 (&dA01-31-97&d@ added a5)
                end 
                a4 = a3 - a1 + 1 << 4 
                ts(a3,STEM_FLAGS) += a4               /* note number in chord 
              repeat 
            else 
              a2 = a1 
            end 
&dA 
&dA &d@         Put in y location of object, y location of end note head 
&dA &d@           and (tentitive) y location of end of stem.  
&dA 
            if bit(1,ts(a1,STEM_FLAGS)) = UP 
              a4 = ts(a1,STAFFLOC) 
              a5 = ts(a2,STAFFLOC) 
              a6 = ts(a1,STAFFLOC) 
              if a6 >= vpar(5) 
                c3 = vpar(7) 
              else 
                c3 = vpar(6) 
                if ts(a1,NTYPE) > EIGHTH and a6 < 0 - vpar(1) 
                  c3 = vpar(5) 
                end 
              end 
              if nodtype <> NOTE and c3 > vpar(5) 
                if c3 = vpar(6) 
                  c3 = vpar(5) 
                else 
                  c3 = vpar(6) 
                end 
              end 
              a6 -= c3 
              a6 += vpar(1)              /* &dAFUDGE&d@ 
              if a6 > vpar(5) 
                a6 = vpar(5) 
              end 
            else 
              a4 = ts(a2,STAFFLOC) 
              a5 = ts(a1,STAFFLOC) 
              a6 = ts(a2,STAFFLOC) 
              if a6 <= vpar(4)          /* &dA09/22/05&d@ was vpar(3) 
                c3 = vpar(7) 
              else 
                c3 = vpar(6) 
                if ts(a1,NTYPE) > EIGHTH and a6 >= vpar(10) 
                  c3 = vpar(5) 
                end 
              end 
              if nodtype <> NOTE and c3 > vpar(5) 
                if c3 = vpar(6) 
                  c3 = vpar(5) 
                else 
                  c3 = vpar(6) 
                end 
              end 
              a6 += c3 
              a6 -= vpar(1)              /* &dAFUDGE&d@ 
              if a6 < vpar(3) 
                a6 = vpar(3) 
              end 
            end 
            loop for a3 = a1 to a2 
              ts(a3,OBY) = a4 
              ts(a3,VIRT_NOTE) = a5 
              ts(a3,VIRT_STEM) = a6 
            repeat 
            a1 = a2         /* advance index to last note of chord 
          end 
        repeat 
&dA 
&dA &d@   Now we can make a "best guess" about what the beam height for those 
&dA &d@   notes (chords) belonging to a beam.  Store the modified height 
&dA &d@   (for all notes of the chord) in VIRT_STEM. 
&dA 
        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE) 
          if chr(nodtype) in [NOTE,CUE_NOTE,GR_NOTE]
            c5 = ts(a1,BEAM_FLAG) 
            if c5 <> NO_BEAM 
              c3 = ts(a1,PASSNUM) 
              c4 = nodtype + 2 / 3      /* 1, 2, or 3 
              if c5 = START_BEAM 
                passcnt(c3,c4) = 0 
              end 
              ++passcnt(c3,c4) 
              c6 = passcnt(c3,c4) 
              beamdata(c4,c3,c6) = a1       /* index to this note 

              if c5 = END_BEAM 
                stem = bit(1,ts(a1,STEM_FLAGS)) 
                if c4 = 1 
                  c5 = 0 
                else 
                  c5 = 1 
                end 
                loop for c7 = 1 to c6 
                  c1 = beamdata(c4,c3,c7) 
                  mf(c7) = ts(c1,OBY)            /*  vpar(7) * c8 + ts(c1,VIRT_STEM)
                  beamcode(c7) = ts(c1,BEAM_CODE) 
                repeat 
                perform guessbeam (c10, c11) 
&dA 
&dA &d@          Put in "new" values for virtual stem position 
&dA 
                loop for c7 = 1 to c6 
                  c9 = c7 - 1 * vpar(6) * c10 / BHPAR1 
                  c1 = beamdata(c4,c3,c7) 
                  ts(c1,VIRT_STEM) = c11 + c9 
                repeat 
              end 
            end 
          end 
        repeat 

        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE) 
          if chr(nodtype) in [XNOTE,XCUE_NOTE,XGR_NOTE]
            ts(a1,VIRT_STEM) = ts(a1-1,VIRT_STEM) 
          end 
        repeat 
&dA 
&dA &d@   If mcat = 2, decode all accidentals using a measax array which depends 
&dA &d@   on the note position in a chord.  
&dA 
        if mcat = 2                /* %%% add code here for changing ax behavior
          loop for a1 = oldsct+1 to sct 
            nodtype = ts(a1,TYPE) 
            if nodtype <= NOTE_OR_REST 
              a4 = ts(a1,STEM_FLAGS) >> 4     /* Note number in chord 
              if a4 = 0 
                a4 = 1 
              end 
              if a4 > 4                                 /* &dA06/04/08&d@ was 3 
                tmess = 26 
                perform dtalk (tmess) 
              end 
              perform decodeax (a1,a4) 
            end 
            if nodtype = BAR_LINE 
              loop for a3 = 1 to 50 
                loop for a4 = 1 to 4                    /* &dA06/04/08&d@ was 3 
                  measax(a4,a3) = tclaveax(a3)          /* New &dA12/14/07&d@ 
                repeat 
              repeat 
            end 
            if nodtype = CLEF_CHG 
              a4 = ts(a1,STAFF_NUM) + 1    /* staff number 
              clef(a4) = ts(a1,CLEF_NUM) 
              perform zjcline (a4) 
*     this resets clef and cline 
              ts(a1,CLEF_FONT) += z        /* music font 
              ts(a1,CLEF_STAFF_POS) = 5 - clef_vpos * notesize 
              a3 = hpar(8) * 5 / 6                           /* Added &dA06-24-94&d@ 
              if ts(a1,CLEF_FONT) > 128     /* music font 
                a3 = a3 * 8 / 10 
              end 
              ts(a1,SPACING) = a3 
              if nstaves > 1     /* Case: assume one part to stave (usual case)
                loop for a3 = 1 to 50 
                  measax(a4,a3) = tclaveax(a3)          /* New &dA12/14/07&d@ 
                repeat 
              else 
                loop for a4 = 1 to 4                    /* &dA06/04/08&d@ was 3 
                  loop for a3 = 1 to 50 
                    measax(a4,a3) = tclaveax(a3)        /* New &dA12/14/07&d@ 
                  repeat 
                repeat 
              end 
            end 
          repeat 
        end 
&dA 
&dA &d@   Decode all accidentals for all other cases               
&dA 
        if mcat < 2 
          loop for a1 = oldsct+1 to sct 
            nodtype = ts(a1,TYPE) 
            if nodtype <= NOTE_OR_REST 
              a4 = ts(a1,STAFF_NUM) + 1    /* staff number 
              perform decodeax (a1,a4) 
            end 
            if nodtype = BAR_LINE 
              loop for a3 = 1 to 50 
                loop for a4 = 1 to 4                    /* &dA06/04/08&d@ was 3 
                  measax(a4,a3) = tclaveax(a3)          /* New &dA12/14/07&d@ 
                repeat 
              repeat 
            end 
            if nodtype = CLEF_CHG 
              a4 = ts(a1,STAFF_NUM) + 1    /* staff number 
              clef(a4) = ts(a1,CLEF_NUM) 
              perform zjcline (a4) 
*     this resets clef and cline 
              ts(a1,CLEF_FONT) += z         /* music font 
              ts(a1,CLEF_STAFF_POS) = 5 - clef_vpos * notesize 
              a3 = hpar(8) * 5 / 6                           /* Added &dA06-24-94&d@ 
              if ts(a1,CLEF_FONT) > 128     /* music font 
                a3 = a3 * 8 / 10 
              else 
                a3 = a3 * 6 / 5                              /* Added &dA12/09/03&d@ as a cludge
              end 
              ts(a1,SPACING) = a3 
              loop for a3 = 1 to 50 
                measax(a4,a3) = tclaveax(a3)            /* New &dA12/14/07&d@ 
              repeat 
            end 
          repeat 
        end 
&dA 
&dA &d@   Now remove all places where accidentals have been placed twice on 
&dA &d@   the same line as a result of multiple parts playing the same 
&dA &d@   altered note.  This code added &dA09/22/93&d@ 
&dA 
        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE) 
          if nodtype <= NOTE_OR_REST               
            loop for a2 = a1 + 1 to sct 
            repeat while ts(a2,SPACING) = 0 and ts(a2,DIV) = ts(a1,DIV) and ts(a2,TYPE) <= NOTE_OR_REST
            --a2 
            if a2 > a1 
              loop for a3 = a1 to a2 
                if ts(a3,AX) > 0 
                  loop for a4 = a3 + 1 to a2 
                    if ts(a4,STAFF_NUM) = ts(a3,STAFF_NUM) 
                      if ts(a4,CLAVE) = ts(a3,CLAVE) 
                        if ts(a4,AX) = ts(a3,AX) 
                          ts(a4,AX) = 0 
                        end 
                      end 
                    end 
                  repeat 
                end 
              repeat 
            end 
            a1 = a2 
          end 
        repeat 
&dA 
&dA &d@   Set backtie for division 1 elements in the ts() array.  
&dA &d@   
&dA &d@     If this is the measure in a group of measures, then 
&dA &d@     BACKTIE for division 1 will point to a ROW element of tiearr, 
&dA &d@     otherwise (2) BACKTIE for division 1 will point to the ts() ROW 
&dA &d@     element that originated the tie.  
&dA &d@   
        loop for a1 = 1 to MAX_TIES
          if tiearr(a1,TIE_SNUM) > 0 and tiearr(a1,TIE_FOUND) = 0 
&dA 
&dA &d@     Case 1:  division 1 of first measure in group 
&dA 
            if oldsct = 0 
              loop for a2 = 1 to sct 
                if ts(a2,DIV) = 1 
                  a3 = tiearr(a1,TIE_NTYPE) 
                  a4 = ts(a2,TYPE) 
                  xbyte = chr(a3) // chr(a4) 
                  if ts(a2,STAFFLOC) = tiearr(a1,TIE_VLOC) 
                    if ts(a2,STAFF_NUM) = tiearr(a1,TIE_STAFF) 
                      if ts(a2,BACKTIE) = 0 
                        if xbyte in [NOTE,XNOTE]    /* i.e., both a3 and a4 are in set
                          ts(a2,BACKTIE) = a1 + INT10000   /* backtie = tie number
                          goto TS1 
                        end 
                        if xbyte in [CUE_NOTE,XCUE_NOTE] 
                          ts(a2,BACKTIE) = a1 + INT10000   /* backtie = tie number
                          goto TS1 
                        end 
                      end 
                    end 
                  end 
                end 
              repeat 
              tmess = 3 
              perform dtalk (tmess) 
            else 
&dA 
&dA &d@     Case 2:  division 1 for subsequent measures in group 
&dA 
              loop for a2 = oldsct+1 to sct 
                if ts(a2,DIV) = 1 
                  a3 = tiearr(a1,TIE_NTYPE) 
                  a4 = ts(a2,TYPE) 
                  xbyte = chr(a3) // chr(a4) 
                  if ts(a2,STAFFLOC) = tiearr(a1,TIE_VLOC) 
                    if ts(a2,STAFF_NUM) = tiearr(a1,TIE_STAFF) 
                      if xbyte in [NOTE,XNOTE]    /* i.e., both a3 and a4 are in set
                        ts(a2,BACKTIE) = tiearr(a1,TIE_NDX)   /* backtie = ts index
                        tiearr(a1,TIE_SNUM) = 0   /* free-up this ROW element of tiearr
                        goto TS1 
                      end 
                      if xbyte in [CUE_NOTE,XCUE_NOTE] 
                        ts(a2,BACKTIE) = tiearr(a1,TIE_NDX)   /* backtie = ts index
                        tiearr(a1,TIE_SNUM) = 0   /* free-up this ROW element of tiearr
                        goto TS1 
                      end 
                    end 
                  end 
                end 
              repeat 
              tmess = 3 
              perform dtalk (tmess) 
            end 
TS1: 
            tiearr(a1,TIE_FOUND) = 1 
          end  
        repeat 
&dA 
&dA &d@   Set backtie for all non-division-1 elements in the ts() array.  
&dA &d@   
        loop for a1 = oldsct+1 to sct 
&dA 
&dA &d@     Special case: Grace note tied to a regular note on the same division &dA11/02/05
&dA 
          if chr(ts(a1,TYPE)) in [GR_NOTE,XGR_NOTE] 
            if bit(0,ts(a1,SUPER_FLAG)) = 1 and a1 < sct      /* tie present 
              a4 = ts(a1,DIV)
              loop for a2 = a1+1 to sct 
                if ts(a2,DIV) = a4    
                  if ts(a1,STAFF_NUM) = ts(a2,STAFF_NUM) 
                    if ts(a1,STAFFLOC) = ts(a2,STAFFLOC) 
                      if chr(ts(a2,TYPE)) in [NOTE,XNOTE] 
                        ts(a2,BACKTIE) = a1     /* Case: backtie = ts index to first note
                        goto SEARCH_DONE 
                      end 
                    end 
                  end 
                else 
                  a2 = 1000000 
                end 
              repeat 
            end 
          end 
&dA 
&dA &d@     End of &dA11/02/05&d@ special case 
&dA 
          if chr(ts(a1,TYPE)) in [NOTE,XNOTE,CUE_NOTE,XCUE_NOTE]
            if bit(0,ts(a1,SUPER_FLAG)) = 1 and a1 < sct      /* tie present 
              a4 = ts(a1,DIV) + ts(a1,NOTE_DUR) 
&dA 
&dA &d@        Try it first where pass numbers must be the same (usual case) 
&dA 
              loop for a2 = a1+1 to sct 
                if ts(a2,DIV) = a4 and ts(a1,PASSNUM) = ts(a2,PASSNUM) 
                  if ts(a1,STAFFLOC) = ts(a2,STAFFLOC) 
                    if chr(ts(a1,TYPE)) in [NOTE,XNOTE] 
                      if chr(ts(a2,TYPE)) in [NOTE,XNOTE] 
                        ts(a2,BACKTIE) = a1     /* Case: backtie = ts index to first note
                        goto SEARCH_DONE 
                      end 
                    else 
                      if chr(ts(a2,TYPE)) in [CUE_NOTE,XCUE_NOTE] 
                        ts(a2,BACKTIE) = a1     /* Case: backtie = ts index to first note
                        goto SEARCH_DONE 
                      end 
                    end 
                  end 
                end 
              repeat 
&dA 
&dA &d@        Now try it where pass numbers need not be the same (unusual case) 
&dA 
              loop for a2 = a1+1 to sct 
                if ts(a2,DIV) = a4 
                  if ts(a1,STAFFLOC) = ts(a2,STAFFLOC) 
                    if chr(ts(a1,TYPE)) in [NOTE,XNOTE] 
                      if chr(ts(a2,TYPE)) in [NOTE,XNOTE] 
                        ts(a2,BACKTIE) = a1     /* Case: backtie = ts index to first note
                        goto SEARCH_DONE 
                      end 
                    else 
                      if chr(ts(a2,TYPE)) in [CUE_NOTE,XCUE_NOTE] 
                        ts(a2,BACKTIE) = a1     /* Case: backtie = ts index to first note
                        goto SEARCH_DONE 
                      end 
                    end 
                  end 
                end 
              repeat 
&dA 
&dA &d@    If you reach this point (i.e., you have not found a terminating 
&dA &d@    note), then you must use the tiearr to temporarily store the 
&dA &d@    information about this note for future reference.  This info must  
&dA &d@    be discarded before the final processing of the ts() array.       
&dA 
&dA &d@        Identify a free slice of tiearr 
&dA 
              loop for c7 = 1 to MAX_TIES 
                if tiearr(c7,TIE_SNUM) = 0 
                  goto XXX2 
                end 
              repeat 
&dA 
&dA &d@          Here is where the pseudo tiearr is built 
&dA 
XXX2:         tiearr(c7,TIE_SNUM)  = INT1000000       /* pseudo super number 
              tiearr(c7,TIE_NTYPE) = ts(a1,TYPE) 
              tiearr(c7,TIE_VLOC)  = ts(a1,STAFFLOC) 
              tiearr(c7,TIE_NDX)   = a1 
              tiearr(c7,TIE_STAFF) = ts(a1,STAFF_NUM) 
              tiearr(c7,TIE_FOUND) = 0 
              tiearr(c7,TIE_FORCE) = ts(a1,SLUR_FLAG) >> 24 
       /* &dA04/20/03&d@: New code 
              c6 = ts(a1,TSR_POINT) 
              tiearr(c7,TIE_SUGG)  = ors(tsr(c6){69,4}) 
              tiearr(c7,TIE_COLOR) = ts(a1,SUBFLAG_1) >> 28   /* New &dA12/21/10
            end  
          end  
SEARCH_DONE: 
        repeat 
&dA 
&dA &d@  Determine space parameter for notes and figures (and isolated signs, words and marks)
&dA 
        loop for a1 = 1 to 120 
          mf(a1) = 0 
        repeat 
        a9 = 0 
        divspq = olddivspq
        inctype_rem = 0                            /* Code added &dA02/24/97&d@ 
        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE)  
          if nodtype = DIV_CHG
            mdiv = ts(a1,DIV)
            divspq = ts(a1,DIVSPQ)
          end
          if nodtype = METER_CHG
            perform newnsp
          end
          if nodtype > NOTE_OR_REST and nodtype <> FIGURES
            if chr(nodtype) in [SIGN,WORDS,MARK] and ts(a1,ISOLATED) = 1 
            else 
              goto TS3 
            end 
          end  
          if chr(nodtype) not_in [XNOTE,XCUE_NOTE,XGR_NOTE]
            if nodtype = GR_NOTE
              goto TS3       /* grace note spacing has already been computed. see GRACE
            end  
&dA 
&dA &d@     determine space and duration for this note/figure 
&dA 
            if nodtype <= NOTE_OR_REST
              a5 = a1  
              perform getspace 
              a7 = a6  
              a8 = ts(a1,NOTE_DUR)  
&dA 
&dA &d@     Code added &dA05-29-94&d@   We cannot allow a8 to be less than time    
&dA &d@                           distance to the next division.  
&dA 
&dA &d@     Code added &dA06-18-94&d@   We also cannot allow a8 to be more than the 
&dA &d@                           time distance to the next division, if the 
&dA &d@                           next division contains an isolated sign, 
&dA &d@                           words, or mark. 
&dA 
              loop for a2 = a1+1 to sct 
                a3 = ts(a2,DIV) - ts(a1,DIV) 
                if a3 > 0
                  if a3 > a8 
                    a8 = a3 
                  end 
                  if chr(ts(a2,TYPE)) in [SIGN,WORDS,MARK] and ts(a2,ISOLATED) = 1
                    if a3 < a8 
                      a8 = a3 
                    end 
                  end 
                  a2 = sct 
                end 
              repeat 
            else 
&dA 
&dA &d@   case 2: figures (and isolated signs, words, and marks) 
&dA 
&dA &d@     1) determine duration (given or implied) 
&dA 
              if nodtype = FIGURES and ts(a1,FIG_DUR) > 0 
                a8 = ts(a1,FIG_DUR)  
              else 
&dA &d@       if figure is not isolated, adopt a duration, else
&dA &d@         impute duration
                if a1 <> sct 
                  loop for a11 = a1+1 to sct 
                    if ts(a11,DIV) = ts(a1,DIV)  
                      if ts(a11,TYPE) <= NOTE_OR_REST
                        a8 = ts(a11,NOTE_DUR) 
                        goto TS4 
                      end  
                    else 
&dA &d@             isolated figure in middle of data  
                      a8 = ts(a11,DIV) - ts(a1,DIV)  
                      goto TS4 
                    end  
                  repeat 
                end  
&dA &d@             isolated figure at end of data 
                a8 = divspq  
              end  
&dA 
&dA &d@     2) compute space for this duration 
&dA 

TS4:          a10 = a8 

&dA &d@        a) adjust duration for triplet  
              a12 = 0  
              a11 = divspq / 3 
              if rem = 0 
                a11 = a10 / 3  
                if rem > 0 
                  a10 = a10 * 3 / 2  
                  a12 = 1  
                end  
              end  
&dA &d@        b) find index into space parameter array  
              a11 = 35 - a12 
              a12 = divspq * 16  
              loop 
                a13 = a10 / a12  
                a12 >>= 1 
                a11 -= 3 
              repeat while a13 = 0 
              if rem > 0 
                ++a11
              end  
              a7 = nsp(a11)  
            end  
            a14 = a7 
&dA 
&dA &d@    notes and figures re-unified at this point in program 
&dA 
&dA &d@   a7 = space for first note/figure in node 
&dA &d@   a8 = duration for first note/figure in node  
&dA &d@  a14 = largest space for shortest full duration on this division (initially a14 = a7)
&dA 
            ++a9
            ts(oldsct+a9,TEMP1) = a7 
            ts(oldsct+a9,TEMP2) = a8 
            mf(a9) = a8  
&dA 
&dA &d@    proceeding from this point, we have only regular and cue notes, 
&dA &d@                     rests and chords on this division  
&dA 
            if a1 < sct 
              loop for a2 = a1+1 to sct  
                if ts(a2,DIV) <> ts(a1,DIV)  
                  --a2
                  goto TS2 
                else 
                  a11 = ts(a2,TYPE)
                  if a11 <> XNOTE and a11 <> XCUE_NOTE 
                    a5 = a2  
                    perform getspace 
                    a15 = ts(a2,NOTE_DUR) 
&dA 
&dA &d@     &dA12/04/05&d@  This code moved from below (before modifying a15) 
&dA &d@      
                    ++a9
                    mf(a9) = a15 
&dA      &d@         
                    if a15 < a8                        /* modified &dA3/20/94&d@ 
                      a7 = a6 
                      a14 = a7 
&dA 
&dA &d@       Code added &dA05-29-94&d@   We cannot allow the "time-space increment" 
&dA &d@                             to be less than the time distance to the 
&dA &d@                             next division. 
&dA 
                      loop for a3 = a2+1 to sct 
                        if ts(a3,DIV) <> ts(a1,DIV) 
                          a15 = ts(a3,DIV) - ts(a1,DIV) 
                          a8 = a15 
                          a3 = sct 
                        end 
                      repeat 
                    else 
                      if a15 = a8 
                        if a6 < a7 
                          a7 = a6 
                        end 
                        if a6 > a7 
                          a14 = a6 
                        end 
                      end 
                    end  
                    ts(oldsct+a9,TEMP1) = a6 
                    ts(oldsct+a9,TEMP2) = a15 
                  end  
                end  
              repeat 
              a2 = sct 
            else   
              a2 = a1  
            end  
&dA 
&dA &d@   a2 = pointer into set for last figure/note/rest/cue
&dA &d@                on this division
&dA &d@   a7 = smallest space for notes for shortest duration on this division 
&dA &d@   a8 = duration of notes of shortest duration on this division 
&dA &d@   a9 = total size of mf array (notes longer than smallest) 
&dA &d@  a14 = largest space for shortest full duration on this division 
&dA 
TS2: 
            a4 = 10000 
            a5 = 10000 
            a6 = a7  
            loop for a3 = 1 to a9 
              if mf(a3) > 0  
                if mf(a3) < a4 
                  a4 = mf(a3)  
                end  
&dA 
&dA &d@          &dA07/01/03&d@:  Fixing this to account for irests with &dEnull&d@ space 
&dA 
                if ts(oldsct+a3,TEMP2) <= a5 
                  a5 = ts(oldsct+a3,TEMP2) 
                  if ts(oldsct+a3,TEMP1) > 0 
                    a6 = ts(oldsct+a3,TEMP1) 
                  end 
                end  
              end  
            repeat 
&dA 
&dA &d@   a4 = smallest number of divisions from left over notes 
&dA &d@   a5 = duration of shortest note sounding at this point  
&dA &d@   a6 = space parameter for this shortest note  
&dA &d@   a4 < a8 means syncopation  
&dA &d@   here also is where we set the increment distance flag.
&dA &d@      Since we are going to increment the distance, we 
&dA &d@      know at this point what technique we will be using.
&dA &d@      ts(24) describes this technique.
&dA 
            if a4 < a8   
              a7 = a6 * a4 / a5    
              a8 = a4  
            else 
              a7 = a14 
            end 
&dA 
&dA &d@   a7 = space parameter for this node 
&dA &d@   a8 = real duration of this node  
&dA 
            dv4 = 576 * a8 / divspq  
            inctype_rem += rem                     /* Code added &dA02/24/97&d@ 
            if inctype_rem > (divspq / 2) 
              inctype_rem -= divspq 
              ++dv4 
            end                                    /* End of &dA02/24/97&d@ addition
            ts(a1,DINC_FLAG) = dv4
            loop for a3 = 1 to a9  
              mf(a3) -= a8 
              if mf(a3) < 0  
                mf(a3) = 0 
              end  
            repeat 
            if chr(nodtype) in [SIGN,WORDS,MARK]
              ts(a1,SPACING) = a7                  /* must be small, but non-zero
            else 
              if nodtype <= NOTE_OR_REST 
                ts(a1,SPACING) = a7 
              else 
                if a1 = a2 
                  ts(a1,FIG_SPACE) = a7 
                  ts(a1,MIN_FIG_SPAC) = a7 
                else 
                  a6 = a1 + 1 
                  if ts(a6,TYPE) <= NOTE_OR_REST 
                    ts(a6,SPACING) = a7 
                  else 
                    tmess = 8 
                    perform dtalk (tmess) 
                  end 
                end 
              end 
            end 
            a1 = a2  
          end  
TS3: 
        repeat 
&dA 
&dA &d@   Update olddivspq
&dA 
        olddivspq = divspq
        if mdiv = totdiv  /*  &dAadded 1-27-93    This code is necessary&d@ 
          qflag = 0       /*  &dAto cope with the situation where the   
        end               /*  &dAdivisions-per-quarter is changed at the&d@ 
                          /*  &dAend of the measure                     
        loop for a1 = 1 to a9  
          ts(oldsct+a1,TEMP1) = 0 
          ts(oldsct+a1,TEMP2) = 0 
        repeat 
&dA 
&dA &d@   Space parameter is initialized 
&dA 
&dA 
&dA &d@   We have computed ts(24), the distance increment flag, for all 
&dA &d@   regular/cue/figure nodes.  This parameter is the time elaps 
&dA &d@   between this node and the next node in the measure.  It is 
&dA &d@   measured in divisions, with 576 divisions being the equivalent 
&dA &d@   of a quarter note.  In the example below the notes are triplet 
&dA &d@   eights and regular sixteenths respectively.  The distances are 
&dA &d@   listed by letter.  
&dA 
&dA &d@                   :=======:=======: 
&dA &d@      triplet 8ths |       |       |       |    a =  144 (reg 16th) 
&dA &d@                   @       @       @       O    b =   48 
&dA &d@                   /  a  /b/ c / d /e/  f  /    c =   96 
&dA &d@                   @     @     @     @     O    d =   96 
&dA &d@      sixteenths   |     |     |     |     |    e =   48 
&dA &d@                   |_____|_____|_____|          f =  144 (reg 16th) 
&dA &d@                   *=====*=====*=====* 
&dA 
&dA &d@   These parameters will be assigned to the first object in the 
&dA &d@   node FOLLOWING THE DISTANCE, whatever it is.  It might, for 
&dA &d@   example, be a grace note, or some kind of sign.  The first 
&dA &d@   object in the node is the one where we can best describe the 
&dA &d@   distance that has been traversed.  In order to accomplish this, 
&dA &d@   we do not set the inctype parameter until after the object 
&dA &d@   containing the ts(24) parameter is processed.  When spn rolls 
&dA &d@   over to a new value, the object in question will be assigned 
&dA &d@   the prior ts(24) parameter.  
&dA 
        tfirstsp = 0  
&dA 
&dA &d@   Adjust accidentals for case where tie crosses bar line 
&dA 
        a10 = 1  
        loop for a1 = oldsct+1 to sct   
          nodtype = ts(a1,TYPE)  
          if ts(a1,DIV) = a10 and ts(a1,BACKTIE) > 0 
            if chr(nodtype) in [NOTE,XNOTE,CUE_NOTE,XCUE_NOTE] 
              loop for a3 = a1+1 to sct 
                if ts(a3,DIV) > a10 and ts(a3,TYPE) <= NOTE_OR_REST 
                  if ts(a3,CLAVE) = ts(a1,CLAVE) 
                    if ts(a3,STAFF_NUM) = ts(a1,STAFF_NUM)    /* added &dA3-23-94&d@ 
                      if ts(a3,AX) = 0 
                        ts(a3,AX) = ts(a1,AX) 
                      end 
&dA 
&dA &d@                   Now remove any similar accidentals which might have 
&dA &d@                   existed previously on this <pitch, staff, division> 
&dA &d@                   combination.  
&dA 
                      loop for a4 = a3 + 1 to sct 
                      repeat while ts(a4,SPACING) = 0 and ts(a4,DIV) = ts(a3,DIV) and ts(a4,TYPE) <= NOTE_OR_REST
                      --a4 
                      loop for a5 = a3 + 1 to a4 
                        if ts(a5,STAFF_NUM) = ts(a3,STAFF_NUM) 
                          if ts(a5,CLAVE) = ts(a3,CLAVE) 
                            if ts(a5,AX) = ts(a3,AX) 
                              ts(a5,AX) = 0 
                            end 
                          end 
                        end 
                      repeat 
                      goto XD 
                    end 
                  end 
                end 
              repeat 
XD: 
              if ts(a1,AX) > 0 and (ts(a1,SUBFLAG_1) & 0x040000) = 0 /* condition added &dA11/05/05
                ts(a1,AX) |= 0x10       /* Code added &dA02/25/97&d@.  This is the "silent" flag
              end
            end  
          end  
          if nodtype = BAR_LINE       /* non-controlling case 
            a10 = ts(a1,DIV)  
          end  
        repeat       

&dA 
&dA &d@    We have a tiny chore to do here.  In the case where we have 
&dA &d@    a down-up pattern of stems on the same beam, we need to be 
&dA &d@    sure the spacing between these notes is at least some minimum 
&dA &d@    distance.  (This code will work most of the time). 
&dA 
        a5 = hpar(4) * 4 / 5 + hpar(82) 
        a4 = 0 
        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE) 
          if nodtype <= NOTE_OR_REST 
            a3 = nodtype + 1 / 3        /* &dAThis code assumes               
            if rem <> 0                 /* &dAXNOTE=2  XCUE_NOTE=5  XGR_NOTE=8&d@ 
              if ts(a1,SPACING) > 0 
                a4 = a1                 /* save index to spacing number 
              end 
            end 
            if nodtype = NOTE or nodtype = GR_NOTE or nodtype = CUE_NOTE 
              if bit(1,ts(a1,STEM_FLAGS)) = UP 
                c12 = ts(a1,BEAM_FLAG) 
                if c12 = CONT_BEAM or c12 = START_BEAM 
                  a3 = 0 
                  loop for a2 = a1 + 1 to sct 
                    if ts(a2,SPACING) > 0 
                      ++a3 
                      if a3 > 1 
                        goto NEXTNOTE 
                      end 
                    end 
                    if ts(a2,TYPE) = nodtype 
                      if ts(a2,PASSNUM) = ts(a1,PASSNUM) 
                        if bit(1,ts(a2,STEM_FLAGS)) = DOWN 
                          if ts(a4,SPACING) < a5 
                            ts(a4,SPACING) = a5 
                          end 
                        end 
                        goto NEXTNOTE 
                      end 
                    end 
                  repeat 
                end 
              end 
            end 
          end 
NEXTNOTE: 
        repeat 
&dA 
&dA &d@    Make space for text                
&dA 
&dA &d@    This is not an easy task to perform.  I have tried a couple of 
&dA &d@    methods already and am not too happy with them.  Let me start 
&dA &d@    by summarizing the objectives.  
&dA 
&dA &d@    1) We want to underlay the text in as compact a way as possible 
&dA &d@         The reason for this is that in the later stages of typesetting 
&dA &d@         we almost always &dAexpand&d@ the music, so we want to start with 
&dA &d@         as compact a version as possible.  
&dA 
&dA &d@    2) We want the notes to be as true to their rythmic values as 
&dA &d@         possible.  
&dA 
&dA &d@    3) We need to preserve spacings attached to grace notes, clef  
&dA &d@         signs, key changes, etc.  
&dA 
        a2 = firstoff  
        a3 = hpar(37) + tfirstsp 
        a11 = 0  
        c11 = 0                             /* added &dA12/09/03&d@ 
        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE)  
          if nodtype = NOTE
            a8 = ts(a1,TEXT_INDEX)  
            temp2 = trm(tsdata(a8)) 
            temp2 = temp2 // pad(1) 
&dA 
&dA &d@        New test for text data &dA09/01/03&d@ 
&dA 
            c6 = 0 
            if temp2{1} in ['A'..'Z','a'..'z','!'..'(','\','='] 
              c6 = 1 
            else 
              temp2 = temp2 // " " 
              loop for c7 = 1 to len(temp2) 
                if temp2{c7} = "|" and temp2{c7+1} in ['A'..'Z','a'..'z','!'..'(','\','=']
                  c6 = 1 
                  c7 = len(temp2) 
                end 
              repeat 
              temp2 = trm(temp2) 
            end 
            if c6 = 1 
&dA 
&dA &d@        End of test &dA09/01/03&d@ 
&dA 
              c11 = 1                       /* added &dA12/09/03&d@ 
              textconflag = OFF 
&dA 
&dA &d@    Look for case of multiple text 
&dA 
              c6 = 0 
              c7 = 0 
              temp2 = temp2 // "| " 
CCCB: 
              if temp2 con "|" 
                ttext = temp2{1,mpt-1} 
                temp2 = temp2{mpt+1..} 
                c5 = mtfont 
                perform wordspace 
                a6 = len(ttext) 
                if "-_" con ttext{a6} 
                  if mpt = 1 
                    a5 -= spc(45) 
                  else 
                    a5 -= spc(95) 
                  end 
                else 
                  c7 = 1 
                end 
                if c6 < a5 
                  c6 = a5 
                end 
                goto CCCB 
              end 
              a5 = c6 
              if c7 = 0    /* all words end in "_" or "-" 
                if a1 <> sct and ts(a1+1,TYPE) = NOTE 
                  c8 = ts(a1+1,TEXT_INDEX) 
                  temp2 = trm(tsdata(c8)) 
                  temp2 = temp2 // pad(1) 
                  if "-_" con temp2{1} 
                    a4 = a5 - ts(a1,SPACING) - hpar(51) / 3 
                    if a4 < 0 
                      a4 = 0 
                    end 
                    goto CCCC 
                  end 
                end 
                if bit(0,ts(a1,SUPER_FLAG)) = 1 
                  a4 = a5 - ts(a1,SPACING) - hpar(51) / 3 
                  if a4 < 0 
                    a4 = 0 
                  end 
                  goto CCCC 
                end 
              end 
              a4 = a5 / 3 - (spc(45) >> 1) 

CCCC:         a6 = a3 - a4 
              a7 = a2 - a6 
&dA 
&dA &d@  a5       = projected space taken up by syllable 
&dA &d@  a4       = amount by which a syllable is backed up from the note 
&dA &d@                 position 
&dA &d@  tfirstsp = amount by which first note is shifted forward to make 
&dA &d@                 space for text 
&dA &d@  a3       = projected position of current note from bar line 
&dA &d@  a6       = projected position of beginning of current syllable 
&dA &d@  firstoff = amount by which last syllable from previous measure 
&dA &d@                 overhangs the space allowed for the last note 
&dA &d@  a2       = smallest value of a6 allowed 
&dA &d@  a7       = difference between smallest allowed a6 and current a6 
&dA 

              if a7 > 0  
                if a11 = 0   
                  tfirstsp += a7 
&dA &d@                 a3 += a7 
                else 
                  if ts(a10,TYPE) = NOTE 
                    c8 = ts(a10,TEXT_INDEX) 
                    temp2 = trm(tsdata(c8)) 
                    temp2 = temp2 // pad(1) 
                    if "-_" con temp2{1} 
                      c9 = 0 
                      loop for c10 = a10 - 1 to oldsct + 1 step -1 
                        if ts(c10,SPACING) > 0 and ts(c10,TYPE) < GR_NOTE 
                          c9 = c10 
                          c10 = 0 
                        end 
                      repeat 
                      if c9 > 0 
                        ts(c9,SPACING) += a7 >> 1 
                        ts(a10,SPACING) += a7 >> 1                    
                        goto CCCA 
                      end 
                    end 
                  end 
                  ts(a10,SPACING) += a7     /* a10 set later 
                end  
              end  
CCCA: 
              tsdata(a8) = trm(tsdata(a8)) // "$$$$" // chs(a4) 

              a5 -= a4 
              a2 = a3 + a5 + hpar(58)       /* hpar(58) = space between words        
            end  
            if temp2{1} = "_"  
              a5 = a3 + spc(95)  
              if a5 > a2 
                a2 = a5  
              end  
            end  

            temp2 = trm(tsdata(a8)) 
            temp2 = temp2 // pad(1) 
            if temp2{1} = "_" 
              textconflag = ON 
            end 

            sub = 1 
            a11 = 1 
            loop while temp2{sub..} con "|" 
              a11 <<= 1 
              ++sub 
              if temp2{sub} = "_" 
                textconflag += a11 
              end 
            repeat 

            if temp2 = " " and textconflag > OFF     /* code added &dA02-23-95&d@ 
              tsdata(a8) = pad(10) 
              loop for a11 = 0 to 9 
                if bit(a11,textconflag) = ON 
                  tsdata(a8){a11+1} = "~" 
                end 
              repeat 
              tsdata(a8) = trm(tsdata(a8)) 
              textconflag = OFF 
            end 
            a11 = 1  
          end  
          if nodtype = REST and ts(a1,CLAVE) < 200   /* code added &dA02-23-95&d@ 
            textconflag = OFF 
          end 
          if nodtype = BAR_LINE 
            if a2 - hpar(36) > a3 
              ts(a10,SPACING) += a2 - hpar(36) - a3 
              a3 = a2 - hpar(36) 
            end 
          end 
&dA 
&dA &d@   a10 = backpointer to prior space for note/rest object set  
&dA 
          if ts(a1,SPACING) > 0 and ts(a1,TYPE) < GR_NOTE 
            a10 = a1 
          end  
          firstoff = 0 
          if a1 = sct  
            a4 = a2 - hpar(36) 
            if a4 > a3 
              firstoff = a4 - a3 
            end  
          else 
            a3 += ts(a1,SPACING) 
          end  
        repeat 
&dA 
&dA &d@    Adding a new section of code (&dA12/09/03&d@) which attempts to midigate somewhat
&dA &d@    the unevenness in note spacing introduced by the addition of text.  Code
&dA &d@    uses c11 to c17 as temporary variables, as well as a new array variable nspace(.,.)
&dA 
        if c11 = 1 
          c12 = 0 
          loop for a1 = oldsct+1 to sct 
            nodtype = ts(a1,TYPE) 
            if nodtype = NOTE or nodtype = REST 
              a8 = ts(a1,TEXT_INDEX) 
              temp2 = trm(tsdata(a8)) 
              ++c12 
              nspace(c12,1) = a1 
              nspace(c12,2) = ts(a1,NTYPE) & 0xff           /* new &dA10/15/07&d@ 
              nspace(c12,3) = ts(a1,SPACING) 
              nspace(c12,4) = ts(a1,TYPE)      
              if temp2 con "$$$$" 
                nspace(c12,5) = int(temp2{mpt+4..}) 
              else 
                nspace(c12,5) = 0 
              end 
              nspace(c12,6) = 0 
              nspace(c12,7) = 0 
              nspace(c12,8) = 0 

            end 
          repeat 
&dA 
&dA &d@ Algorithm.  
&dA 
&dA &d@ (1) examine all pairs of notes.  Find the pair for which 
&dA &d@     (a) same duration 
&dA &d@     (b) if d1 = distance after 1st note, and d2 = distance after 2nd note 
&dA &d@           and both d1 and d2 are non-zero                     (added &dA04/10/05&d@)
&dA &d@           and abs(d1 - d2) > 1 
&dA &d@     (c) smallest distance in this set 
&dA 
&dA &d@ (2) try moving 2nd note one unit either towards (d1 > d2) or away from (d2 > d1) first note.
&dA &d@     (a) resulting total shift of 2nd note cannot more than 1/2 nspace(.,5) to the right
&dA &d@           or more than nspace(.,5) to the left 
&dA &d@     (b) if note cannot be moved, goto (1) and consider next pair 
&dA 
&dA &d@ (3) if (1)+(2) fail, look for situations where                               
&dA &d@     (a) a note of longer duration follows a note of shorter duration, and 
&dA &d@           the shorter note is allowed more space.  Try moving the 2nd note
&dA &d@           closer to the first, then goto (1).  
&dA &d@     (b) a note of shorter duration follows a note of longer duration, and 
&dA &d@           the shorter note is allowed more space.  Try moving the 2nd note
&dA &d@           away from the first, then goto (1).  
&dA &d@     (c) in all cases under (3), principal (2)(a) must be followed, 
&dA &d@           and both notes in question must have non-zero following distances (added &dA04/10/05&d@)
&dA 
&dA 
NXPAIR: 
          c15 = 1000 
          c16 = 0 
          loop for c13 = 1 to c12 - 1 
            if nspace(c13,2) = nspace(c13+1,2) and nspace(c13+1,3) <> 0 and nspace(c13,3) <> 0
              c14 = abs(nspace(c13,3) - nspace(c13+1,3)) 
              if c14 > 1 
                if c14 < c15 
                  if nspace(c13+1,5) = 0                     /* next node is a rest, etc.
                    if nspace(c13+1,6) > -6                  /* max incroachment is 6
                      c15 = c14 
                      c16 = c13 
                    end 
                  else 
                    if nspace(c13,3) > nspace(c13+1,3)       /* move 2nd note to the left
                      if nspace(c13+1,6) < 0 
                        if abs(nspace(c13+1,6)) < nspace(c13+1,5) 
                          c15 = c14 
                          c16 = c13 
                        end 
                      else 
                        c15 = c14 
                        c16 = c13 
                      end 
                    else                                     /* move 2nd note to the right
                      if nspace(c13+1,6) < (nspace(c13+1,5) + 1 >> 1) 
                        c15 = c14 
                        c16 = c13 
                      end 
                    end 
                  end 
                end 
              end 
            end 
          repeat 
          if c16 > 0 
            loop for c13 = 1 to c12 
              nspace(c13,7) = 0 
            repeat 
          end 

          if c16 = 0 
            loop for c13 = 1 to c12 - 1 
              if nspace(c13,2) = nspace(c13+1,2) and nspace(c13+1,3) <> 0 and nspace(c13,3) <> 0
                c14 = abs(nspace(c13,3) - nspace(c13+1,3)) 
                if c14 = 1 and nspace(c13,7) = 0 
                  if nspace(c13+1,5) = 0                     /* next node is a rest, etc.
                    if nspace(c13+1,6) > -6                  /* max incroachment is 6
                      c16 = c13 
                      c13 = c12 
                    end 
                  else 
                    if nspace(c13,3) > nspace(c13+1,3)       /* move 2nd note to the left
                      if nspace(c13+1,6) < 0 
                        if abs(nspace(c13+1,6)) < nspace(c13+1,5) 
                          c16 = c13 
                          c13 = c12 
                        end 
                      else 
                        c16 = c13 
                        c13 = c12 
                      end 
                    else                                     /* move 2nd note to the right
                      if nspace(c13+1,6) < (nspace(c13+1,5) + 1 >> 1) 
                        c16 = c13 
                        c13 = c12 
                      end 
                    end 
                  end 
                end 
              end 
            repeat 
            if c16 > 0 
              nspace(c16,7) = 1 
            end 
          end 

          if c16 > 0           /* note pair found 
            if nspace(c16,3) > nspace(c16+1,3) 
              if c16 > 1 and nspace(c16-1,2) > nspace(c16,2) and nspace(c16,6) < nspace(c16,5)
                --nspace(c16,3) 
                ++nspace(c16-1,3) 
                ++nspace(c16,6) 
              else 
                --nspace(c16,3) 
                ++nspace(c16+1,3) 
                --nspace(c16+1,6) 
              end 
            else 
              ++nspace(c16,3) 
              --nspace(c16+1,3) 
              ++nspace(c16+1,6) 
            end 
            goto NXPAIR 
          end 

          loop for c13 = 1 to c12 - 1 
            if nspace(c13,3) <> 0 and nspace(c13+1,3) <> 0   /* this condition added &dA04/10/05
              if nspace(c13,2) > nspace(c13+1,2) 
                if nspace(c13,3) < nspace(c13+1,3) 
                  if nspace(c13+1,6) < nspace(c13+1,5) or (nspace(c13+1,4) = 3 and nspace(c13+1,6) < 6)
                    ++nspace(c13,3) 
                    --nspace(c13+1,3) 
                    ++nspace(c13+1,6) 
                    goto NXPAIR 
                  end 
                end 
              end 
              if nspace(c13,2) < nspace(c13+1,2) 
                if nspace(c13,3) > nspace(c13+1,3) 
                  if abs(nspace(c13+1,6)) < (nspace(c13+1,5) + 1 >> 1) 
                    --nspace(c13,3) 
                    ++nspace(c13+1,3) 
                    --nspace(c13+1,6) 
                    goto NXPAIR 
                  end 
                end 
              end 
            end 
          repeat 
          c12 = 0 
          loop for a1 = oldsct+1 to sct 
            nodtype = ts(a1,TYPE) 
            if nodtype = NOTE or nodtype = REST 
              a8 = ts(a1,TEXT_INDEX) 
              temp2 = trm(tsdata(a8)) 
              ++c12 
              ts(a1,SPACING) = nspace(c12,3) 
              if temp2 con "$$$$" 
                c13 = nspace(c12,5) + nspace(c12,6) 
                temp2 = temp2{1,mpt+3} // chs(c13) // "," // chs(nspace(c12,5))
                tsdata(a8) = trm(temp2) 
              end 
            end 
          repeat 

        end 
&dA     &d@  End of &dA12/09/03&d@ addition 

&dA 
&dA &d@    If there is more that one pass in this measure, one of the 
&dA &d@    things we need to know is the number of passes per staff.  
&dA &d@    If this number is greater than one for a particular staff, 
&dA &d@    then we are going to need to know (1) whether ties have tips 
&dA &d@    up or down for each pass, and (2) whether slurs should connect 
&dA &d@    to note heads or to stems.  
&dA 
&dA &d@    I propose the following rule:  If there is more than one track 
&dA &d@    on a particular staff and if stem directions are consistant 
&dA &d@    for each track on that particular staff, then 
&dA 
&dA &d@      (1) tie tips will always go the opposite direction of the 
&dA &d@            stem direction 
&dA &d@      (2) slurs should connect to stems rather than to note heads 
&dA 
&dA &d@    Before beginning the processing loop, I need to determine the 
&dA &d@    situation, since it is dependent on what happens in the entire 
&dA &d@    measure.  I propose (6-4-93) to add a new element to the ts(.) 
&dA &d@    array, in this case, element 29 = MULTI_TRACK flag.  The meaning 
&dA &d@    of this flag will be as follows: 
&dA 
&dA &d@        0 = this note lies on a staff that has notes from only one 
&dA &d@              pass.  
&dA 
&dA &d@              In this situation, mcat can be 0, 1 or 2              
&dA 
&dA &d@              (1) mcat = 0 or mcat = 1.   Any tie or slur 
&dA &d@              starting or ending on this note will follow the 
&dA &d@              rules for a single part on a staff.  
&dA 
&dA &d@              (2) mcat = 2   There is only one pass, but notes 
&dA &d@              will occur in chords.  In this case, slurs and 
&dA &d@              articulations will mainly fall on the note head at 
&dA &d@              the end of the stem.  In the case where both stem 
&dA &d@              directions are involved, slurs are generally put 
&dA &d@              above the notes (tips down) 
&dA 
&dA 
&dA &d@        1 = this note belongs to one of multiple passes on this 
&dA &d@              staff and all notes on this pass have stems which 
&dA &d@              point up.  
&dA 
&dA &d@              In this situation, mcat can be either 0 or 3, depending 
&dA &d@              on the value of vflag.  Whatever the case, slurs 
&dA &d@              will go above the notes (tips down).  
&dA 
&dA 
&dA &d@        2 = this note belongs to one of multiple passes on this 
&dA &d@              staff and all notes on this pass have stems which 
&dA &d@              point down.  
&dA 
&dA &d@              In this situation, mcat can be either 0 or 3, depending 
&dA &d@              on the value of vflag.  Whatever the case, slurs 
&dA &d@              will go below the notes (tips up).  
&dA 
&dA &d@        3 = this note belongs to one of multiple passes on this 
&dA &d@              staff and the stem directions for the note of at least 
&dA &d@              one of these passes on this staff are inconsistant 
&dA &d@              (both up and down).  
&dA 
&dA &d@              In this situation, mcat can be either 0 or 3, depending 
&dA &d@              on the value of vflag.  In either case, the placement of 
&dA &d@              slurs cannot be inferred from this parameter.  The note 
&dA &d@              in question might belong to a track that is "well behaved", 
&dA &d@              i.e., not the "rogue track".  In this case, determining 
&dA &d@              the type and placement of the slur will be straight- 
&dA &d@              forward.  In the case where mcat = 0 (i.e. vflag = 1), 
&dA &d@              it is likely that the rules for a single part may work 
&dA &d@              fairly well.  In the case where mcat = 3 (i.e. vflag > 1), 
&dA &d@              a number of difficult situations can arrise, such as a 
&dA &d@              slur from a stem-up chord note (pass one) to a stem down 
&dA &d@              note (pass two).  Such situation will have to be handled 
&dA &d@              in a way that seems best under the particular circumstances.  
&dA 
&dA 
&dA &d@    The MULTI_TRACK parameter will actually be combination of the 
&dA &d@    multi-track flag and the value of mcat, according to the 
&dA &d@    formula below: 
&dA 
&dA &d@        ts(.,MULTI_TRACK) = multi-track << 2 + mcat 
&dA 

        loop for a2 = 1 to 3             
          loop for a3 = 1 to passnum         /* assume passnum = total # of passes
            loop for a4 = 1 to MAX_STAFF 
              multichk(a2,a3,a4) = 0 
            repeat 
          repeat 
        repeat 
        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE) 
          if nodtype <= NOTE_OR_REST 
            a2 = nodtype + 2 / 3 
            a3 = ts(a1,PASSNUM) 
            a4 = ts(a1,STAFF_NUM) + 1        /* staff number 
            a6 = multichk(a2,a3,a4) 
            if rem <> 2 
              a5 = bit(1,ts(a1,STEM_FLAGS)) + 1 
              if a6 = 0 or a6 = 4 
                multichk(a2,a3,a4) = a5 
              else 
                if a6 <> a5 
                  multichk(a2,a3,a4) = 3 
                end 
              end 
            else 
              if a6 = 0 
                multichk(a2,a3,a4) = 4        /* rest (stem direction unspecified)
              end 
            end 
          end 
        repeat 

        loop for a2 = 1 to 3               /* loop through note types i.e. reg,cue,grace
          loop for a4 = 1 to MAX_STAFF 
            a5 = 0 
            a6 = 0 
            loop for a3 = 1 to passnum 
              a7 = multichk(a2,a3,a4) 
              if a7 = 3                    /* Case: multiple stem directions 
                a6 = 100 
              end 
              if a7 > 0 
                ++a5 
                if a7 = 4 
                  a8 = a3 + 1 / 2               /* set multichk to 1 for odd passnums, 2 for even
                  multichk(a2,a3,a4) = rem + 1  /*   for parts with only rests 
                end 
              end 
            repeat 
            if a6 = 100 and a5 > 1         /* Case: mult passes on staff and ambiguous stem dirs
              loop for a3 = 1 to passnum 
                multichk(a2,a3,a4) = 3     /* all notes (for this type) on this staff have mt = 3
              repeat 
            end 
            if a5 = 1                      /* Case: single pass on this staff (for this note type)
              loop for a3 = 1 to passnum 
                multichk(a2,a3,a4) = 0     /* all notes (for this type) on this staff have mt = 0
              repeat 
            end 
          repeat 
        repeat 

        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE) 
          if nodtype <= NOTE_OR_REST 
            a2 = nodtype + 2 / 3 
            a3 = ts(a1,PASSNUM) 
            a4 = ts(a1,STAFF_NUM) + 1      /* staff number 
            a5 = multichk(a2,a3,a4) << 2 
            ts(a1,MULTI_TRACK) = a5 + mcat 
          end 
        repeat 
        if oldsct = 0 
          firstsp = tfirstsp 
        else 
&dA 
&dA &d@     Include tfirstsp in the spacing after previous completed bar 
&dA 
          if ts(oldsct,TYPE) <> BAR_LINE 
            ts(oldsct,SPACING) += tfirstsp 
          else 
            ts(oldsct,SPACING) += tfirstsp 
          end 
        end 
&dA 
&dA &d@     Compute the spn (spacing) parameter 
&dA 
        loop for a1 = oldsct+1 to sct   
          if ts(a1,TYPE) = DIV_CHG and qflag = 1 
            qflag = 2 
          end  
          if qflag = 0 
            a5 = totdiv - 1  
            a4 = ts(a1,DIV) - 1   
            if a5 = a4 
              spn = 6913 
            else 
              spn = 6912 / a5 * a4 + 1   
            end  
          else   
            if qflag = 1   
              a5 = mdiv - 1  
              a4 = ts(a1,DIV) - 1 
              if a5 = a4 
                spn = 3457                                           
              else 
                spn = 3456 / a5 * a4 + 1 
              end  
            else 
              a5 = totdiv - mdiv 
              a4 = ts(a1,DIV) - mdiv  
              if a5 = a4 
                spn = 6913 
              else 
                spn = 3456 / a5 * a4 + 3457  
              end  
            end  
          end  
          ts(a1,SPN_NUM) = spn 
        repeat 
&dA 
&dA &d@     We have a choice at this point whether to do extra calculations on 
&dA &d@     the placement of notes, note-dots, and note-accidentals, or to wait 
&dA &d@     to do this until the point when we process the entire array.  I think 
&dA &d@     now is a good time to do this, because (1) I prefer to do work I think 
&dA &d@     I know how to do earlier rather than later (you never know just what 
&dA &d@     kinds of tasks you may have to do later, so why not get this one out 
&dA &d@     of the way), and (2) the information gained in the this process might 
&dA &d@     help us in the placement of slurs (which we will need to do first 
&dA &d@     thing when we begin processing the entire array).  
&dA 
&dA &d@     Basically we are going to try to compute the following information for 
&dA &d@     each "musical node".  The definition of a "musical node" is the set of 
&dA &d@     one or more objects (chords + dots + accidentals) occuring on the same 
&dA &d@     division number and &dAwhich would, if possible, be placed in the same&d@ 
&dA &d@     &dAx-position on the staff&d@.  
&dA 
&dA &d@       (1) the global x-offset.  This is the amount by which each &dAobject&d@ 
&dA &d@             is displaced from the 0 x-position of all objects on this 
&dA &d@             musical node.  I believe the global x-offset is always >= 0.  
&dA &d@                                   
&dA &d@       (2) the local x-offset for note heads.  This is the amount by which 
&dA &d@             each note head of a particular object is displaced from the 
&dA &d@             x position of the object.  
&dA 
&dA &d@       (3) the location of rests on the staff (based on the position of 
&dA &d@             other objects at this location).  
&dA 
&dA &d@       (4) the x and y offsets for any dot(s) which might follow each 
&dA &d@             note head of a particular object. &dA Note: the y-position of 
&dA &d@             &dAan object which has more than one note head (chord) is     
&dA &d@             &dAthe y position of the note head furthest from the note-end 
&dA &d@             &dAof the stem (i.e., therefore nearest to the beam end of    
&dA &d@             &dAthe stem, if there is a beam).     
&dA 
&dA &d@       (5) the x offset (as measured to the left) of any accidental(s) 
&dA &d@             which might precede each note head.  
&dA 
&dA 
&dA &d@     I. How to store this information.  
&dA 
&dA &d@     (0) The grouping of elements in the ts(.,.) array into "musical 
&dA &d@         nodes" can be determined by the space parameter "&dLSPACING&d@".  
&dA &d@         The first array element of a "musical node" will have a 
&dA &d@         non-zero space parameter, and any other element in the node 
&dA &d@         will have a space parameter = 0.  
&dA 
&dA &d@     (1) The global x-offset can be stored in the GLOBAL_XOFF element 
&dA &d@         of the ts(.,.) array.  If we further specify that the GLOBAL_XOFF 
&dA &d@         element will be set to INT10000 * a1 (index of first note in the 
&dA &d@         chord) + a2 (index of last note in chord), this will give us an 
&dA &d@         easy way to determine the number of array elements (note heads) 
&dA &d@         in the object (chord).  
&dA 
&dA &d@     (2) The local x-offset for note heads can be stored in the 
&dA &d@         LOCAL_XOFF element of the ts(.,.) array.  
&dA 
&dA &d@     (3) The location of rests on the staff can be stored in the 
&dA &d@         STAFFLOC element of the ts(.,.) array.  
&dA 
&dA &d@     (4) For the x and y offsets for any dots(s), we can use the DOT    (modified &dA12-24-96&d@)
&dA &d@         element of the ts(.,.) array.  Up to this point, the DOT element 
&dA &d@         could have five values: 0 = no dot; 1 = single dot; 3 = double dot;
&dA &d@         7 = triple dot; 15 = quadruple dot.  We need to preserve this          
&dA &d@         information, which uses bits 0 through 3 of the integer.  Since 
&dA &d@         the x offset is always positive, and the y offset may be positive 
&dA &d@         or negative, we can construct a number which is x * INT10000 + y, 
&dA &d@         shift it over 4 and &dAOR&d@ it with the current value of DOT.  
&dA 
&dA &d@     (5) For the x offset of any accidental(s), we can use the AX 
&dA &d@         element of the ts(.,.) array.  Up to this point, the AX element 
&dA &d@         could have sixteen values: 0 to 15.  There is also the "silent" 
&dA &d@         flag in bit 4 (value 16) which we need to preserve.  Altogether  (added &dA02/25/97&d@)
&dA &d@         we need to preserve bits 0 through 4 of the integer.  Since 
&dA &d@         the x offset (measured to the left) is always positive, we can 
&dA &d@         simply shift this offset over 8 and &dAOR&d@ with the current value 
&dA &d@         of AX.  
&dA 
&dA &d@    II. Method of computation.  
&dA 
&dA &d@         The first task will be to compute the global and local x-offset 
&dA &d@         for the note heads in each musical node.  We have a way of doing 
&dA &d@         this, which we call pseudo-typesetting.  A concurrent task will 
&dA &d@         be to compute the y location of rests in each musical node.  
&dA 
&dA &d@         The second task will be to compute the x and y offsets for any 
&dA &d@         dots(s).  The method will be as follows (for each staff): 
&dA 
&dA &d@           (1) If there is only one note head on the staff, use the 
&dA &d@               single note method for determining dot position.  
&dA 
&dA &d@               Otherwise, determine the x position for a "row of dots".  
&dA &d@               This position will be to the right of the right-most 
&dA &d@               note head on the stave.  (Note that the x-offset for 
&dA &d@               each dot is the x position minus the global x-offset 
&dA &d@               for each object).  
&dA 
&dA &d@           (2) Starting with the left-most objects in the "musical node" 
&dA &d@               and moving to the right, set dot positions according to 
&dA &d@               the following algorithm (keeping track of all previous 
&dA &d@               dots for this stave): 
&dA 
&dA &d@                  Start with the note head furtherest from note-end of stem 
&dA &d@                  If note on line, 
&dA &d@                    if space above is free, put dot there 
&dA &d@                    else put dot in first free space below 
&dA &d@                  else 
&dA &d@                    if space is free, put dot there 
&dA &d@                    else put dot in first free space in reverse direction 
&dA &d@                  end 
&dA 
&dA &d@         The third task will be to compute the x offsets for any 
&dA &d@         accidental(s) for each note head.  The method will be as 
&dA &d@         follows (for each staff): 
&dA 
&dA &d@           (1) Check the left-hand border from the typesetting operation. 
&dA &d@               If there are any accidentals that could be set on right- 
&dA &d@               shifted note heads, set these first, starting from the 
&dA &d@               top down.  This defines column 1 of the accidentals.  
&dA 
&dA &d@               Otherwise, column one is the first free location to the 
&dA &d@               left of the left-most note head.  
&dA 
&dA &d@           (2) For all remaining accidentals to set, start at the top 
&dA &d@               of the group.  Make successive passes until all accidentals 
&dA &d@               are set.  
&dA 
&dA &d@               (a) moving down, put in as many accidentals as possible 
&dA &d@                   where the distance between eligible notes (delta) >= 
&dA &d@                   vpar(6), with the caviat that you do not put an 
&dA &d@                   accidental on the lower half of a second before the 
&dA &d@                   upper half of a second (as you move down).  
&dA 
&dA &d@               (b) move to the left by the largest thickness of accidentals 
&dA &d@                   just placed.  Decide on the direction to move for the 
&dA &d@                   next pass and goto (a).  The new direction will be 
&dA &d@                   down (again) if the previous pass hit the lowest remaining 
&dA &d@                   accidental; otherwise, the new direction will be up.  
&dA 
&dA 
&dA &d@         Good Luck with all of this!  If you get it right, you will have 
&dA &d@         accomplished a good deal of the task of setting simultaneous 
&dA &d@         notes!  
&dA 
&dA &d@         &dA3-23-94&d@: 
&dA 
&dA &d@         I am going to add another element to this process.  It turns out that
&dA &d@         this is the best time to determine whatever extra space is required 
&dA &d@         for each object, based on the items previously typeset.  (We had been
&dA &d@         doing this later, but without the detailed information available in this
&dA &d@         part of the process, i.e. global-right boundaries, etc.).  
&dA 
&dA &d@         We start with the fact that the process below begins either after the
&dA &d@         initial setting of the clef, key and time, or after a controlling bar
&dA &d@         line.  In either case, we know the profile of "emptyspace" relative 
&dA &d@         to the position we are about to put something.  
&dA 
&dA &d@         After processing each object, we need to be sure two things are done.
&dA 
&dA &d@         (1) If there will be a need to shift the position of a node, the 
&dA &d@         value of this shift (positive or negative) needs to be stored in the 
&dA &d@         array element: NODE_SHIFT.  
&dA 
&dA &d@         (2) The values of emptyspace need to be updated.  
&dA 
        olda1 = 0      

        loop for a1 = oldsct+1 to sct   
          nodtype = ts(a1,TYPE)  
          if nodtype > NOTE_OR_REST 
&dA 
&dA &d@       A. Figure out space for Bar Line 
&dA 
            if nodtype = BAR_LINE 
              a5 = 1000000 
              loop for a3 = 1 to MAX_STAFF 
                loop for a4 = 1 to 45 
                  if emptyspace(a3,a4) < a5 
                    a5 = emptyspace(a3,a4) 
                  end 
                repeat 
              repeat 
              a6 = mindist - hpar(82) - a5 
&dA &d@   Task (1) 
              if a6 > 0 
                ts(a1,NODE_SHIFT) = a6 
              end 
&dA &d@   Task (2) 
              a5 = ts(a1,SPACING) - hpar(93) 
              loop for a4 = 1 to MAX_STAFF 
                loop for a3 = 1 to 45 
                  emptyspace(a4,a3) = a5 
                repeat 
              repeat 
              goto WWWW 
            end 
&dA 
&dA &d@       B. Figure out space for Clef change
&dA 
            if nodtype = CLEF_CHG 
              a3 = ts(a1,STAFF_NUM) + 1         /* staff number 
&dA 
&dA &d@      Check to see if we can "backup" the node position        
&dA 
              a5 = 1000000 
              loop for a4 = 1 to 45 
                if emptyspace(a3,a4) < a5 
                  a5 = emptyspace(a3,a4)        /* minimum emptyspace on this staff
                end 
              repeat 
&dA &d@   Task (1) 
              if a5 > ts(a1,SPACING) >> 1 
                a4 = a5 * 2 / 3 
                a7 = ts(a1,SPACING) 
                c2 = 0 
                loop for c1 = a1+1 to sct          /* check if following note has accidentals
                  if ts(c1,DIV) <> ts(a1,DIV) 
                    goto HJKO 
                  end 
                  a6 = ts(c1,TYPE) 
                  if a6 > FIGURES 
                    goto HJKO 
                  end 
                  if a6 <> REST and a6 <> CUE_REST and a6 <> FIGURES 
                    if ts(c1,STAFF_NUM) = ts(a1,STAFF_NUM) 
                      a6 = ts(c1,AX) & 0x1f 
                      if a6 < 0x10 and a6 > 0 and hpar(a6) > c2   /* Code modified &dA02/25/97
                        c2 = hpar(a6) 
                      end 
                    end   
                  end 
                repeat 
HJKO: 
                a7 += c2 
                if a4 > a7
                  a4 = a7
                end 
                ts(a1,NODE_SHIFT) = 0 - a4    /* negative shift 
              else 
                a6 = mindist - hpar(82) - a5 
                if a6 > 0 
                  ts(a1,NODE_SHIFT) = a6 
                end 
              end 
&dA &d@   Task (2) 
              a5 = ts(a1,SPACING) - a4          /* amount by position really advanced
              a7 = hpar(86) 
              if z > 128 
                a7 = a7 * 7 / 10                /* use to be 8 / 10 
              end 
              a7 = ts(a1,SPACING) - a7          /* empty space after clef sign 
              loop for a4 = 1 to MAX_STAFF 
                if a4 = a3 
                  loop for a6 = 1 to 45 
                    emptyspace(a4,a6) = a7 
                  repeat 
                else 
                  loop for a6 = 1 to 45 
                    emptyspace(a4,a6) += a5 
                  repeat 
                end 
              repeat 
              goto WWWW 
            end 
&dA 
&dA &d@       C. Figure out space for Time change
&dA 
            if nodtype = METER_CHG 
              a5 = 1000000 
              loop for a3 = 1 to MAX_STAFF 
                loop for a4 = 1 to 45 
                  if emptyspace(a3,a4) < a5 
                    a5 = emptyspace(a3,a4) 
                  end 
                repeat 
              repeat 
              a6 = hpar(12) - a5 
&dA &d@   Task (1) 
              if a6 > 0 
                ts(a1,NODE_SHIFT) = a6 
              end 
&dA &d@   Task (2) 
              loop for a4 = 1 to MAX_STAFF 
                loop for a3 = 1 to 45 
                  emptyspace(a4,a3) = min_space            /* replaces hpar(29)   &dA11/19/07
                repeat 
              repeat 
              goto WWWW 
            end 
&dA 
&dA &d@       D. Figure out space for Key change 
&dA 
            if nodtype = AX_CHG 
              a5 = 1000000 
              loop for a3 = 1 to MAX_STAFF 
                loop for a4 = 1 to 45 
                  if emptyspace(a3,a4) < a5 
                    a5 = emptyspace(a3,a4) 
                  end 
                repeat 
              repeat 
              a6 = hpar(37) - hpar(93) - a5 
&dA &d@   Task (1) 
              if a6 > 0 
                ts(a1,NODE_SHIFT) = a6 
              end 
&dA &d@   Task (2) 
              loop for a4 = 1 to MAX_STAFF 
                loop for a3 = 1 to 45 
                  emptyspace(a4,a3) = hpar(12) 
                repeat 
              repeat 
              goto WWWW 
            end 
&dA 
&dA &d@       E. Figure out space for Signs, Words and Marks which are Objects 
&dA &d@                    
            if nodtype = SIGN or nodtype = WORDS or nodtype = MARK 
              ts(a1,NODE_SHIFT) = 0  
              goto WWWW 
            end 
&dA 
&dA &d@       F. Figure out space for Figures 
&dA &d@                    
            if nodtype = FIGURES 
              c3  = FIG_DATA 
              c11 = 0 
              c14 = 0                         /* Flag for preceding accidentals on figures
              loop for c2 = 1 to ts(a1,NUMBER_OF_FIG) 
                c12 = 0 
&dA 
&dA &d@    Code added &dA11/16/03&d@ to deal with parentheses around figures 
&dA 
                c6 = ts(a1,c3) 
                c13 = 0                       /* Flag for parentheses around figures
                if c6 > 1000 
                  c6 -= 1000 
                  if c6 > 1000                /* large parentheses 
                    c6 = c6 / 1000 
                    c6 = rem 
                    c13 = hpar(138) + hpar(139) 
                  else                        /* small parentheses 
                    c13 = hpar(136) + hpar(137) 
                  end 
                end 
&dA   

&dA 
&dA &d@    And this code rewritten &dA11/16/03&d@ 
&dA 
                if c6 > 0 
                  temp = chr(c6+28) 
                  if "1389" con temp          /* case: accidental x,#,f,n 
                    c4 = ts(a1,c3+1) 
                    if c4 > 0                 /* sub-case: accidental followed by figure
                      c14 = hpar(c4+47)       /* result: set flag for preceding accidental
                      if c4 < 20                    /* figure 
                        if c4 < 10 
                          c12 = hpar(66) 
                        else 
                          c12 = hpar(66) << 1 
                        end 
                      else 
                        c12 = hpar(c4+67) 
                      end 
                    else 
                      c12 = hpar(c6+47)       /* 20 <= c6 <= 30 --> hpar(67) to hpar(77)
                    end 
                  else 
                    if c6 < 20                /* case: figure 
                      if c6 < 10 
                        c12 = hpar(66) 
                      else 
                        c12 = hpar(66) << 1 
                      end 
                      c4 = ts(a1,c3+1) 
                      if c4 > 0               /* accidental following number
                        temp = chr(c4+28) 
                        if "01389" con temp 
                          c12 += hpar(c4+47) 
                        end 
                      end 
                    else                      /* cases: isolated +,2+,4+,5+,6\,7\,-
                      c12 += hpar(c6+47) 
                    end 
                  end 
                end 
&dA   
                c12 += c13                    /* Adding space for parentheses &dA11/16/03
                if c12 > c11 
                  c11 = c12 
                end 
                c3 += 3 
              repeat 

              c11 += c14                      /* Adding space for pre-accidentals &dA11/16/03
              c11 += hpar(75)                 /* free space = width of natural 

              if ts(a1,MIN_FIG_SPAC) < c11 
                ts(a1,MIN_FIG_SPAC) = c11 
              end 
              if ts(a1,FIG_SPACE) > 0 and ts(a1,FIG_SPACE) < c11 
                ts(a1,FIG_SPACE) = c11 
              end 
              a4 = ts(a1,FIG_SPACE) 
              ts(a1,NODE_SHIFT) = 0  
              if a4 > 0 
                loop for a3 = 1 to MAX_STAFF 
                  loop for a2 = 1 to 45 
                    emptyspace(a3,a2) += a4 
                  repeat 
                repeat 
              end 
              goto WWWW 
            end 
            goto WWWW 
          end 
&dA 
&dA &d@    &dA PROCESSING NOTES AND RESTS NOW 
&dA 
          npasses = 1 
          a3 = 1 
          if a1 = sct              /* added &dA01-31-97&d@ 
            a2 = a1 
            pitchcnt(1) = 1 
            goto X1 
          end 
          loop for a2 = a1+1 to sct  
            if ts(a2,SPACING) <> 0 
              --a2 
              pitchcnt(npasses) = a3 
              goto X1 
            end 
            if ts(a2,TYPE) > NOTE_OR_REST 
              --a2 
              pitchcnt(npasses) = a3 
              goto X1 
            end 
            if nodtype = GR_NOTE
              if ts(a2,TYPE) = XGR_NOTE 
                ++a3 
              else 
                pitchcnt(npasses) = a3 
                a3 = 1 
                ++npasses 
              end 
            else 
              if ts(a2,TYPE) = XNOTE or ts(a2,TYPE) = XCUE_NOTE 
                ++a3 
              else 
                pitchcnt(npasses) = a3 
                a3 = 1 
                ++npasses 
              end 
            end 
          repeat 
X1:  
&dA 
&dA &d@    a2          = index to last element in node 
&dA &d@    npasses     = number of passes 
&dA &d@    pitchcnt(.) = size of chord for each pass
&dA 
&dA &d@         if a1 = a2     /* Simple (and most common) case:  single element, a2 = a1
&dA 
          if ts(a1,MULTI_TRACK) < 4 and a1 = a2 

            a3 = ts(a1,STAFF_NUM) + 1         /* staff number 
            c1 = a1  
            passnum = ts(c1,PASSNUM) 
            ntype = ts(c1,NTYPE) & 0xff           /* new &dA10/15/07&d@ 
            stem = bit(1,ts(c1,STEM_FLAGS)) 
            if nodtype <= REST
              passtype = REG          
              passsize = FULLSIZE 
              if bit(16,ts(c1,SUBFLAG_1)) = 1 
                passsize = CUESIZE                /* EXPERIMENT  &dA06-24-94&d@ 
              end 
            else
              passsize = CUESIZE 
              if nodtype <= CUE_REST
                passtype = CUE
              else
                passtype = GRACE
              end
            end
&dA 
&dA &d@     a) rests 
&dA 
            if nodtype = REST or nodtype = CUE_REST
              if nodtype = REST 
                c8 = vpar(4) 
              else 
                c8 = vpar(2) 
              end 
              if ts(c1,STAFFLOC) = 1 
                c8 = vpar(4) 
              end 
              ts(c1,STAFFLOC) = c8 
              ts(c1,OBY) = c8
              if ts(c1,DOT) > 0 
                c4 = 0            /* additions to "eighth rest" 
                c2 = 0            /* y shift down for starting rests 
                c6 = 0            /* extra height of dot  (negative shift) 
                if ntype <= SIXTEENTH 
                  c6 = notesize 
                  c4 = EIGHTH - ntype 
                  c2 = notesize 
                  if ntype < THIRTY_SECOND 
                    c2 = THIRTY_SECOND - ntype * notesize + c2 
                  end 
                end 
                if ntype > QUARTER 
                  c3 = hpar(30) 
                else 
                  c3 = c4 * hpar(54) + hpar(31) 
                  c6 *= c4 
                end 
                if passsize = CUESIZE 
                  c3 = c3 * 8 / 10 
                end 
                c7 = c3 
&dA 
&dA &d@    Minor code modification &dA04/19/08&d@ 
&dA 
                if ntype <= SIXTEENTH 
                  c3 -= hpar(54) 
                end 
&dA    
                c6 += vpar(1) /* shift to space   OK 4-21-95 
             /* c3 is the x shift to the dot(s) 
                c2 -= c6      /* final y offset 
                c9 = c2 
             /* x * INT10000 + y, shift it over 4 and &dAOR&d@ it with DOT   (code modified &dA12-24-96&d@)
                c3 *= INT10000 
                c3 += c2 
                c3 <<= 4                                         /*    (code modified &dA12-24-96&d@)
                ts(c1,DOT) |= c3  
              else 
                c7 = 0 
                c9 = 0 
              end 
&dA &d@   Task (1) 
              a5 = 1000000 
              loop for a4 = 1 to 45 
                if emptyspace(a3,a4) < a5 
                  a5 = emptyspace(a3,a4)        /* minimum emptyspace on this staff
                end 
              repeat 

              a6 = mindist - hpar(82) - a5 
              if a6 > 0 
                ts(a1,NODE_SHIFT) = a6 
              end 
&dA &d@   Task (2) 
              loop for a6 = 1 to 45 
                gr(a3,a6) = -200 
              repeat 

              if ts(c1,CLAVE) < 200
                perform rest_occupy_space (c8,a3)     /* ntype is read directly
              end 

              if ts(c1,DOT) > 0 
                c8 += c9 
                if c8 >= 0 
                  c8 = 2 * c8 + 1 / vpar(2) 
                else 
                  c8 = 2 * c8 - 1 / vpar(2) 
                end 
                c8 = 23 - c8 
                c7 += hpar(80) 
                if ts(c1,DOT) & 0x0e > 0            /* code modified &dA12-24-96
                  if ts(c1,DOT) & 0x02 > 0 
                    c7 += hpar(91)                    /* extra shift to second dot
                  end 
                  if ts(c1,DOT) & 0x04 > 0 
                    c7 += hpar(91)                    /* extra shift to third dot
                  end 
                  if ts(c1,DOT) & 0x08 > 0 
                    c7 += hpar(91)                    /* extra shift to fourth dot
                  end 
                end 
                loop for a6 = c8 - 1 to c8 + 1 
                  gr(a3,a6) += c7  
                repeat 
              end 
              c10 = ts(c1,SPACING) 
              loop for c11 = 1 to MAX_STAFF 
                if c11 = a3 
                  loop for c6 = 1 to 45 
                    if gr(c11,c6) = -200 
                      emptyspace(c11,c6) += c10 
                    else 
                      emptyspace(c11,c6) = c10 - gr(c11,c6) 
                    end 
                  repeat 
                else 
                  loop for c6 = 1 to 45 
                    emptyspace(c11,c6) += c10 
                  repeat 
                end 
              repeat 
            else 
&dA 
&dA &d@     b) notes 
&dA 
              repeater_case      = 0 
              ts(c1,LOCAL_XOFF)  = 0 
              ts(c1,GLOBAL_XOFF) = 0 
&dA 
&dA &d@  Technically, this code must also appear here, although it is highly unlikely 
&dA &d@  that anyone would want to shift a single note on a stave from its primary position.
&dA 
&dA &d@                              All New code &dA05/02/03&d@ 
&dA 
&dA &d@       At this point, we need to see if the note object position has been modified
&dA &d@       "absolutely" by a print suggestion.  If this is the case, we need to make the
&dA &d@       adjustment here, AND, elimate the suggestion from the tsr string.  
&dA 
              c6 = ts(c1,TSR_POINT) 
              c7 = ors(tsr(c6){2}) 
              if bit(0,c7) = 1 
                px = ors(tsr(c6){3}) 
                if px > 0 
                  px = px - 128 * notesize / 10 
                  pxx = c7 & 0x02 >> 1 
                  if pxx = 1 
                    ts(c1,GLOBAL_XOFF) = px 
                    tsr(c6){3} = chr(0)         /* here is where suggestion is zerod out
                  end 
                end 
              end 
&dA 
&dA &d@       End of new code &dA05/02/03&d@ 
&dA 
              c6 = ts(c1,STAFFLOC) + vpar20 * 2 + 1 / vpar(2) - 20 

              if ts(c1,DOT) > 0 
                if (ts(c1,SUBFLAG_1) & 0x8000) = 0   /* modern notation 
                  if ntype > HALF 
                    c3 = hpar(32) 
                  else 
                    c3 = hpar(33) 
                  end 
                else                                 /* New &dA01/08/11&d@ 
                  if ntype > WHOLE 
                    c3 = vpar(2) * 5 / 2 
                  else 
                    if ntype > HALF 
                      c3 = vpar(2) * 9 / 5 
                    else 
                      c3 = vpar(2) * 3 / 2 
                    end 
                  end 
                end 
                c10 = ts(c1,STAFFLOC) / notesize 
                c10 = rem                 /* c10 = 0 means note on line 
                if stem = UP and bit(15,ts(c1,SUBFLAG_1)) = 0 /* modern only
                  if ts(c1,BEAM_FLAG) = NO_BEAM and ts(c1,NTYPE) < QUARTER 
                    c3 += hpar(27) 
                    if c10 <> 0
                      c3 -= hpar(34) 
                    end 
                  end 
                end 
&dA 
&dA &d@    if dot is on staff line, c10 = 0     
&dA 
                if c10 = 0 
                  c2 = 0 - vpar(12) 
           /* lower dot if more than one track and stem is down 
                  if bit(3,ts(c1,MULTI_TRACK)) = 1 
                    if stem = DOWN 
                      c2 = vpar(12) 
                    end 
                  end 
                  c3 -= hpar(34) 
                else 
                  c2 = 0 
                end 
                if passsize = CUESIZE 
                  c3 = c3 * 8 / 10 
                end 
             /* c3 = x shift 
             /* c2 = y offset 

             /* x * INT10000 + y, shift it over 2 and &dAOR&d@ it with DOT   (code modified &dA12-24-96&d@)
                c7 = c3 
                c8 = c2 
                c3 *= INT10000 
                c3 += c2 
                c3 <<= 4                                            /*  code modified &dA12-24-96
                ts(c1,DOT) |= c3  
              end 

&dA &d@   Task (1) 
              loop for c10 = 1 to 45 
                gl(a3,c10) = 200 
                pseudo_gl(a3,c10) = 200 
                gr(a3,c10) = -200 
              repeat 
              c6 = 23 - c6 

              if c6 > 45 or c6 < 1 
                tmess = 27 
                perform dtalk (tmess) 
              end 
        /* Determine thickness of note: c11 
              if (ts(c1,SUBFLAG_1) & 0x8000) = 0 
                if ntype <= HALF or ntype = SLASH8 
                  c11 = hpar(82) 
                else 
                  if ntype = WHOLE 
                    c11 = hpar(83) 
                  else 
                    if ntype = BREVE 
                      c11 = hpar(84) 
                    else 
                      if ntype = LONGA 
                        c11 = vpar(2) * 5 / 4 
                      else 
                        c11 = hpar(144) + 3 
                      end 
                    end 
                  end 
                end 
              else                            /* New  &dA01/08/11&d@ 
                if ntype <= HALF
                  c11 = vpar(2) 
                else 
                  if ntype <= LONGA 
                    c11 = vpar(2) * 5 / 4 
                  else 
                    c11 = hpar(144) + 3 
                  end 
                end 
              end 

              if passsize = CUESIZE 
                c11 = c11 * 8 / 10 
              end 
        /* Put in limits of note head 
              gl(a3,c6+1) = hpar(95) 
              pseudo_gl(a3,c6+1) = 0
              gl(a3,c6)   = 0 
              gr(a3,c6+1) = c11  
              gr(a3,c6)   = c11 - hpar(95) 

              if ntype < WHOLE 
        /* Determine length of stem: c10 
                if ntype > EIGHTH 
                  c10 = 8                          /* length of stem 
                else 
                  c10 = 7 
                  if ntype < EIGHTH 
                    c10 += EIGHTH - ntype
                  end 
                end 
                if passsize = CUESIZE 
                  c10 = c10 * 8 / 10 
                end 
                if ts(c1,BEAM_FLAG) = NO_BEAM and ts(c1,BEAM_CODE) > 0 
                  repeater_case = 1
                  c13 = ts(c1,BEAM_CODE) / 10 
                  loop while c13 > 0 
                    c13 /= 10 
                    c10 += 2 
                  repeat 
                end 
        /* Determine thickness of stem: c12 
                if ts(c1,BEAM_FLAG) = NO_BEAM and ntype < QUARTER 
                  if bit(15,ts(c1,SUBFLAG_1)) = 0 
                    c12 = hpar(26) 
                    if passsize = CUESIZE 
                      c12 = c12 * 8 / 10 
                    end 
                  else                          /* New &dA01/08/11&d@ 
                    c12 = hpar(26) - c11
                  end 
                else 
                  if stem = UP 
                    if bit(15,ts(c1,SUBFLAG_1)) = 0      /* modern notation 
                      c12 = 0 
                    else                                 /* New &dA01/08/11&d@ 
                      c12 = 0 - c11
                    end 
                  else 
                    c12 = hpar(90) 
                  end 
                end 
&dA 
&dA &d@     Put in limits of gl(.,.) and gr(.,.) for stem 
&dA 
&dA &d@     &dA06/04/08&d@  Fixing case where there are no-beam repeaters 
&dA 
                if stem = UP 
                  c13 = c6 + c10 
                  if c13 > 45 
                    c13 = 45 
                  end 
                  gr(a3,c6+1) = c11 + c12 
                                               
                  loop for c14 = c6 + 2 to c6 + 3   /* No repeaters near note head
                    gr(a3,c14) = c11 + c12                  
                    gl(a3,c14) = c11 - hpar(90) 
                  repeat 

                  if repeater_case = 1 
                    c15 = hpar(98) + hpar(90) 
                    if ntype >= QUARTER 
                      c12 += hpar(98) 
                    end 
                  else 
                    c15 = hpar(90) 
                  end 
                  loop for c14 = c6 + 4 to c13      /* &dA06/04/08&d@ changing c6 + 2 to c6 + 4
                    gr(a3,c14) = c11 + c12                  
                    gl(a3,c14) = c11 - c15
                  repeat 
                else 
                  c13 = c6 - c10 
                  if c13 < 1 
                    c13 = 1 
                  end 

                  loop for c14 = c6 - 2 to c6 - 1   /* No repeaters near note head
                    gr(a3,c14) = c12       
                    gl(a3,c14) = 0         
                  repeat 

                  if repeater_case = 1 
                    c11 = hpar(98) 
                  else 
                    c11 = 0 
                  end 
                  loop for c14 = c13 to c6 - 3      /* &dA06/04/08&d@ changing c6 - 1 to c6 - 3
                    gr(a3,c14) = c12       
                    gl(a3,c14) = 0 - c11 
                  repeat 
                end 
              end 
&dA 
&dA &d@          Put in limits of for accidentals 
&dA &d@               and store location of accidental 
&dA 
              if ts(c1,AX) > 0 
                c5 = ts(c1,AX) & 0x0f 
                c7 = passsize 
                perform place_accidental (a3,c6,c5,c7)  /* returns c7 = negative offset
            /* shift the offset over 8 and &dAOR&d@ with AX 
                c7 = 0 - c7                             /* we store positive value
                c7 <<= 8               /* &dA02/25/97&d@ shift changed from 4 to 8
                ts(c1,AX) |= c7               
              end 
&dA 
&dA &d@       Adjust the gr(.,.) array to accommodate space for dots 
&dA &d@           (added &dA04/04/94&d@) 
&dA 
              c8 = ts(a1,STAFF_NUM) + 1                    /* staff number 
              c3 = ts(a1,DOT) 
              if c3 > 0                                    /* code modified &dA12-24-96
                c4 = c3 & 0x0f               /* dot flag   /* &dA12-24-96&d@ 
                c3 >>= 4                                   /* &dA12-24-96&d@ 
                c5 = c3 / INT10000           /* x offset 
                c6 = rem                     /* y offset 
                if c6 > INT10000 >> 1 
                  c6 -= INT10000 
                  ++c5 
                end 
                c6 = c6 + vpar(8) * 2 - 1 / vpar(2) - 7 

                c10 = ts(a1,STAFFLOC) + vpar20 * 2 + 1 / vpar(2) - 20 
                c6 = 23 - c10 - c6 

                c5 += hpar(80) 
                if c4 > 1                                  /* modified &dA12-24-96
                  c5 += hpar(91)                         /* second dot 
                  if c4 > 4 
                    c5 += hpar(91)                         /* third dot 
                  end 
                  if c4 > 8 
                    c5 += hpar(91)                         /* fourth dot 
                  end 
                end 
                if c6 < 46 and c6 > 0 
                  gr(c8,c6) = c5 
                end 
              end 

        /* Calculate NODE_SHIFT 
              c10 = 0
              if c1 = 1 or ts(c1-1,TYPE) < CUE_NOTE 
                c6 = min_space            /* replaces hpar(29)   &dA11/19/07&d@ 
              else 
                c6 = min_space / 2        /* replaces hapr(29) / 2  &dA11/19/07
              end 
              loop for c11 = 1 to 45 
                if gl(a3,c11) > pseudo_gl(a3,c11) 
                  gl(a3,c11) = pseudo_gl(a3,c11) 
                end 
                c12 = c6       - gl(a3,c11) - emptyspace(a3,c11) /* should be negative
                if c12 > c10                                     /* most of the time
                  c10 = c12                     
                end 
              repeat 
              if (ts(c1,AX) & 0x0f) > 0 and ts(c1,SPACING) = mindist and c10 < hpar(94)
                c10 = hpar(94) 
              end 
              if c10 > 0 
                ts(c1,NODE_SHIFT) = c10 
              end 
&dA &d@   Task (2) 
              c10 = ts(c1,SPACING) 
              loop for c11 = 1 to MAX_STAFF 
                if c11 = a3 
                  loop for c6 = 1 to 45 
                    if gr(c11,c6) = -200 
                      emptyspace(c11,c6) += c10 
                    else 
                      emptyspace(c11,c6) = c10 - gr(c11,c6) 
                    end 
                  repeat 
                else 
                  loop for c6 = 1 to 45 
                    emptyspace(c11,c6) += c10 
                  repeat 
                end 
              repeat 
            end 
          else 

&dA &d@ &dAÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»&d@ 
&dA &d@ &dAº&d@                                                                &dAº&d@ 
&dA &d@ &dAº&d@   Here is where you deal with chords and with multiple passes  &dAº&d@ 
&dA &d@ &dAº&d@                                                                &dAº&d@ 
&dA &d@ &dAÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼&d@ 

&dA &d@                       ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@                       ³ D I S C U S S I O N  ³ 
&dA &d@                       ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
&dA 
&dA &d@       To start with, a major difference between the single note version 
&dA &d@   and this multiple note version is the placement of (1) the note heads 
&dA &d@   in chords and (2) the chord groups, themselves.  The major problem is 
&dA &d@   to determine the x-offset for each note in a chord and the x-offset for 
&dA &d@   each chord group.  Once this information is known, it will then be 
&dA &d@   possible to typeset the various entities in a manner somewhat similar 
&dA &d@   to the case of the single note version above.  
&dA 
&dA &d@       The x placement of all of the elements of a multiple note node 
&dA &d@   requires consideration of all of the elements; i.e., they cannot be 
&dA &d@   simply put down in a serial fashion.  Therefore, we must do a pseudo- 
&dA &d@   typesetting of the elements, and from this extract the x-offsets we 
&dA &d@   need to do the real job.  I note that set array elements 13 and 19 
&dA &d@   are free at this point, so we can use them to store local x-offset and 
&dA &d@   global x-offset, respectively (&dDLOCAL_XOFF&d@, &dDGLOBAL_XOFF&d@).  
&dA 
&dA &d@       Also, the vertical placement of rests must be taken into 
&dA &d@   consideration.  There is no definite parameter in the stage2 source 
&dA &d@   file that tells us were to locate rests vertically.  We have two 
&dA &d@   indirect parameters available: (1) the pass number, based on the 
&dA &d@   the order of encoding the material, and (2) the optional track 
&dA &d@   number.  I would favor using the pass number at this point.  Where 
&dA &d@   the maximum pass number is 2, rests could be located "high" and 
&dA &d@   "low" for passes 1 and 2, respectively; where the maximum pass number 
&dA &d@   is 3, rests could be located "high", "medium" and "low", etc.  In the 
&dA &d@   case of the grand staff (two or more staves), these locations could 
&dA &d@   be refined to reflect the staff on which the rests are being put.  
&dA 
&dA 
&dA &d@  &dA ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ» 
&dA &d@  &dA º &d@                                                   &dA º 
&dA &d@  &dA º &d@          (A) pseudo-typeset the notes             &dA º 
&dA &d@  &dA º &d@                                                   &dA º 
&dA &d@  &dA ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼ 
&dA 

&dA &d@               ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@               ³   construct note data   ³ 
&dA &d@               ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
&dA &d@ 
&dA &d@   ndata(1) = pass number (set to 0, after chord is typeset)
&dA &d@   ndata(2) = stem flag: 
&dA &d@                 bit 0: direction    0 = up, 1 = down 
&dA &d@                 bit 1: repeater     0 = none, 1 = present 
&dA &d@              bits 2-4: flag flag    0 = no flag 
&dA &d@                                     1 = eighth flag 
&dA &d@                                     2 = sixteenth flag 
&dA &d@                                     3 = 32nd flag 
&dA &d@                                     4 = 64th flag 
&dA &d@                                     5 = 128th flag 
&dA &d@                                     6 = 256th flag 
&dA 
&dA &d@   ndata(3)  = note_head   0 = black, 1 = half, 2 = whole, 3 = breve 
&dA &d@   ndata(4)  = dot         0 = none, 1 = dot 
&dA &d@   ndata(5)  = pitch 
&dA &d@   ndata(6)  = position in chord (from note end of stem) 
&dA &d@   ndata(7)  = final x-position of this pitch within chord 
&dA &d@   ndata(8)  = pass number 
&dA &d@   ndata(9)  = staff number 
&dA &d@   ndata(10) = note size (full size vs. que size) 
&dA &d@   ndata(11) = ntype
&dA &d@   ndata(12) = note style 
&dA &d@   pcnt     = total number of notes (and rests) 
&dA &d@            
#define  PS_PASS    1 
#define  PS_STEM    2 
#define  PS_HEAD    3 
#define  PS_DOT     4 
#define  PS_PITCH   5 
#define  PS_RANK    6 
#define  PS_XPOS    7 
#define  PS_PASS2   8 
#define  PS_STAFF   9 
#define  PS_NSIZE  10 
#define  PS_NTYPE  11 
#define  PS_NSTYLE 12 

            loop for c1 = 1 to 45     /* initialize right and left boundaries 
              gr(1,c1) = -200 
              gr(2,c1) = -200 
              pseudo_gr(1,c1) = -200 
              pseudo_gr(2,c1) = -200 
              pseudo_gl(1,c1) = 200 
              pseudo_gl(2,c1) = 200 
              gl(1,c1) = 200 
              gl(2,c1) = 200 
            repeat 

            pcnt = 0 
            c1 = a1 
            ps_passcount(1) = 0 
            ps_passcount(2) = 0 

            loop for thispass = 1 to npasses 
              c2 = ts(c1,STAFF_NUM) + 1           /* staff number 
              ++ps_passcount(c2) 
              c2 = 0 
              loop for c3 = 1 to pitchcnt(thispass) 
                ++pcnt 
                ndata(pcnt,PS_PASS2) = thispass 
                ndata(pcnt,PS_PASS)  = thispass 
                ndata(pcnt,PS_STEM)  = bit(1,ts(c1,STEM_FLAGS)) 
                if c3 = 1 and ts(c1,BEAM_FLAG) = NO_BEAM 
                  if ts(c1,BEAM_CODE) > 0 
                    ndata(pcnt,PS_STEM) += 2 
                  end 
                  if ts(c1,NTYPE) < QUARTER 
                    c4 = QUARTER - ts(c1,NTYPE) << 2 
                    ndata(pcnt,PS_STEM) += c4 
                  end 
                end 

                if ts(c1,CLAVE) < 100           /* note 
                  if ts(c1,NTYPE) < HALF 
                    ndata(pcnt, PS_HEAD) = 0 
                  else 
                    ndata(pcnt,PS_HEAD) = ts(c1,NTYPE) - 7 
                  end 
                else 
                  ndata(pcnt,PS_HEAD) = ts(c1,NTYPE) & 0xff    /* new &dA10/15/07
                end 
                ndata(pcnt,PS_NTYPE) = ts(c1,NTYPE) & 0xff      /* new &dA10/15/07
                ndata(pcnt,PS_NSTYLE) = ts(c1,SUBFLAG_1) >> 15  /* new &dA01/08/11
                ndata(pcnt,PS_NSTYLE) &= 0x01                   /* new &dA01/08/11
                if ts(c1,TYPE) <= REST 
                  ndata(pcnt,PS_NSIZE) = bit(16,ts(c1,SUBFLAG_1)) 
                else 
                  ndata(pcnt,PS_NSIZE) = CUESIZE
                end 

                ndata(pcnt,PS_DOT)   = ts(c1,DOT)
                if ts(c1,CLAVE) < 100           /* note 
                  c10 = ts(c1,STAFFLOC) + vpar20 * 2 + 1 / vpar(2) - 20 
                  ndata(pcnt,PS_PITCH) = 23 - c10 
                else 
                  ndata(pcnt,PS_PITCH) = 100    /* rest 
                end 
                ndata(pcnt,PS_XPOS)  = 0 
                ndata(pcnt,PS_STAFF) = ts(c1,STAFF_NUM) 
                ++c1 
&dA &d@     compute horizontal placement of notes for down stems (on the fly) 
                if bit(0,ndata(pcnt,PS_STEM)) = DOWN and c3 > 1 
                  c4 = ndata(pcnt-1,PS_PITCH) - ndata(pcnt,PS_PITCH) 
                  if c4 = 1 
                    if c2 = 0 
                      ndata(pcnt,PS_XPOS) = -1 
                      c2 = 1 
                    else 
                      c2 = 0 
                    end 
                  else 
                    c2 = 0 
                  end 
                end 
&dA &d@     rank the notes in a chord 
                if bit(0,ndata(pcnt,PS_STEM)) = UP 
                  ndata(pcnt,PS_RANK) = pitchcnt(thispass) + 1 - c3 
                else 
                  ndata(pcnt,PS_RANK) = c3 
                end 
              repeat 
&dA &d@     compute horizontal placement of notes for up stems 
              if pcnt > 0 and bit(0,ndata(pcnt,PS_STEM)) = UP and pitchcnt(thispass) > 1
                c5 = pcnt 
                c2 = 0 
                loop for c3 = 2 to pitchcnt(thispass) 
                  c4 = ndata(c5-1,PS_PITCH) - ndata(c5,PS_PITCH) 
                  if c4 = 1 and c2 = 0 
                    ndata(c5-1,PS_XPOS) = 1 
                    c2 = 1 
                  else 
                    c2 = 0 
                  end 
                  --c5 
                repeat 
              end 
              c2 = pcnt - pitchcnt(thispass) + 1 
            repeat 
&dA 
&dA &d@     determine all clashes between chords 
&dA 
            loop for c2 = 1 to npasses 
              loop for c3 = 1 to npasses 
                clashes(c2,c3) = 0 
              repeat 
            repeat 

            loop for c2 = 1 to pcnt - 1 
              loop for c3 = c2+1 to pcnt 
                c4 = ndata(c2,PS_PASS) 
                c5 = ndata(c3,PS_PASS) 
                if c4 <> c5 and ndata(c2,PS_STAFF) = ndata(c3,PS_STAFF) 
                  if ndata(c2,PS_XPOS) = 0 and ndata(c3,PS_XPOS) = 0 
                    if ndata(c2,PS_PITCH) < 100 
                      c6 = ndata(c2,PS_PITCH) - ndata(c3,PS_PITCH) 
                      if c6 = 0                                     /* same pitch
                        if bit(0,ndata(c2,PS_STEM)) = bit(0,ndata(c3,PS_STEM)) 
                          clashes(c4,c5) = 1 
                          clashes(c5,c4) = 1 
                          goto PS_D2 
                        end 
                        if ndata(c2,PS_HEAD) <> ndata(c3,PS_HEAD) 
                          clashes(c4,c5) = 1 
                          clashes(c5,c4) = 1 
                          goto PS_D2 
                        end 
                        if ndata(c2,PS_NSIZE) <> ndata(c3,PS_NSIZE) 
                          clashes(c4,c5) = 1 
                          clashes(c5,c4) = 1 
                          goto PS_D2 
                        end 
&dA 
&dA &d@     &dA12/24/05&d@  This optional code is now controlled by dot_difference_flag 
&dA 
                        if dot_difference_flag = 1 
                          if ndata(c2,PS_DOT) <> ndata(c3,PS_DOT) 
                            clashes(c4,c5) = 1 
                            clashes(c5,c4) = 1 
                            goto PS_D2 
                          end 
                        end 
&dA              
                        if ndata(c2,PS_RANK) * ndata(c3,PS_RANK) <> 1 
                          clashes(c4,c5) = 1 
                          clashes(c5,c4) = 1 
                          goto PS_D2 
                        end 
&dA &d@                           
&dA &d@           We must now ask the question: are all notes of first chord either 
&dA &d@              equal/above all notes of second chord, or equal/below all notes 
&dA &d@              of second chord.  
&dA 
                        c10 = 0 
                        loop for c9 = 1 to pcnt 
                          if ndata(c9,PS_PASS) = ndata(c2,PS_PASS) 
                            if ndata(c9,PS_PITCH) <> ndata(c2,PS_PITCH) 
                              if ndata(c9,PS_PITCH) > ndata(c2,PS_PITCH) 
                                if c10 = -1 
                                  c10 = 1000 
                                else 
                                  c10 = 1 
                                end 
                              end 
                              if ndata(c9,PS_PITCH) < ndata(c2,PS_PITCH) 
                                if c10 = 1 
                                  c10 = 1000 
                                else 
                                  c10 = -1 
                                end 
                              end 
                            end 
                          end 
                        repeat 
                        if c10 = 1000 
                          clashes(c4,c5) = 1 
                          clashes(c5,c4) = 1 
                          goto PS_D2 
                        end 
                        loop for c9 = 1 to pcnt 
                          if ndata(c9,PS_PASS) = ndata(c3,PS_PASS) 
                            if ndata(c9,PS_PITCH) <> ndata(c3,PS_PITCH) 
                              if ndata(c9,PS_PITCH) > ndata(c3,PS_PITCH) 
                                if c10 = 0 
                                  c10 = -1   
                                end 
                                if c10 = 1 
                                  c10 = 1000 
                                end 
                              end 
                              if ndata(c9,PS_PITCH) < ndata(c3,PS_PITCH) 
                                if c10 = 0 
                                  c10 = 1 
                                end 
                                if c10 = -1 
                                  c10 = 1000 
                                end 
                              end 
                            end 
                          end 
                        repeat 
                        if c10 = 1000 
                          clashes(c4,c5) = 1 
                          clashes(c5,c4) = 1 
                          goto PS_D2 
                        end 
                        clashes(c4,c5) = 2 
                        clashes(c5,c4) = 2 
                        goto PS_D2 
                      end 
                      if c6 = 1 or c6 = -1 
                        clashes(c4,c5) = 1 
                        clashes(c5,c4) = 1 
                      end 
                    end 
                  end 
                end 
PS_D2: 
              repeat 
            repeat 
&dA 
&dA &d@     typeset all groups of chords for which there are no clashes 
&dA 
            loop for c2 = 1 to npasses 
              tgroup(c2) = 0 
            repeat 
            ntgroups = 0 
            loop for c2 = 1 to npasses 
              c5 = 0 
              loop for c3 = c2+1 to npasses 
                if clashes(c2,c3) <> 1 and tgroup(c3) = 0 
                  if c5 = 0 
                    ++ntgroups 
                    c5 = 1 
                    tgroup(c2) = ntgroups 
                    tgroup(c3) = ntgroups 
                  else 
                    loop for c4 = c2+1 to c3-1 
                      if tgroup(c4) = ntgroups and clashes(c4,c3) = 1 
                        c4 = 1000 
                      end 
                    repeat 
                    if c4 <> 1000 
                      tgroup(c3) = ntgroups 
                    end 
                  end 
                end 
              repeat 
            repeat 
            c10 = 0                        /* initialize right-hand chord boundary

            loop for c3 = 1 to ntgroups    /* number of typeset groups 
&dA 
&dA &d@     typeset chords
&dA 
              loop for c4 = 1 to 2    /* typeset stem down first 
                c5 = 2 - c4 
PS_CC:          c6 = 0 
                c7 = 0 
                c15 = 0 
                loop for c2 = 1 to pcnt 
                  c9 = ndata(c2,PS_PASS) 
                  if c9 > 0 and tgroup(c9) = c3   /* this typeset group 
                    if bit(0,ndata(c2,PS_STEM)) = c5 
                      if ndata(c2,PS_PITCH) > c6           /* typeset highest pitch first
                        if c6 > 0 and c15 > EIGHTH         /* but check first to see if
                          if ndata(c2,PS_NTYPE) < QUARTER  /* type is quarter or greater
                            if ndata(c2,PS_PITCH) - c6 < 3 
                              goto NOSWITCH 
                            end 
                          end 
                        end 
                        c6 = ndata(c2,PS_PITCH) 
                        c7 = ndata(c2,PS_PASS) 
                        c15 = ndata(c2,PS_NTYPE) 
NOSWITCH: 
                      else 
                        if c15 < QUARTER and ndata(c2,PS_NTYPE) > EIGHTH 
                          if c6 - ndata(c2,PS_PITCH) < 3 
                            c6 = ndata(c2,PS_PITCH) 
                            c7 = ndata(c2,PS_PASS) 
                            c15 = ndata(c2,PS_NTYPE) 
                          end 
                        end 
                      end 
                    end 
                  end 
                repeat 
                if c7 > 0 
                  c8 = 100 
                  loop for c2 = 1 to npasses 
                    if clashes(c2,c7) = 2         /* unison 
                      c8 = c2 
                      c2 = 100 
                    end 
                  repeat 
                  perform ps_setchord (c7, c8, c10) 
                  goto PS_CC 
                end 
              repeat 
            repeat 
&dA 
&dA &d@     determine if there are clashes left 
&dA 
PS_B:    
            loop for c2 = 1 to pcnt - 1 
              if ndata(c2,PS_PASS) > 0 and ndata(c2,PS_XPOS) = 0 
                             /* chord(PS_PASS) has not been set 
                loop for c3 = c2+1 to pcnt 
                  if ndata(c3,PS_XPOS) = 0 and ndata(c3,PS_PASS) > 0 
                    if ndata(c2,PS_STAFF) = ndata(c3,PS_STAFF) 
                      if ndata(c2,PS_PITCH) < 100 
                        c4 = ndata(c2,PS_PITCH) - ndata(c3,PS_PITCH) 
                        if c4 = 0 
                          if bit(0,ndata(c2,PS_STEM)) = bit(0,ndata(c3,PS_STEM))
                            goto PS_CL 
                          end 
                          if ndata(c2,PS_HEAD) <> ndata(c3,PS_HEAD) 
                            goto PS_CL 
                          end 
&dA 
&dA &d@     &dA12/24/05&d@  This optional code is now controlled by dot_difference_flag 
&dA 
                          if dot_difference_flag = 1 
                            if ndata(c2,PS_DOT) <> ndata(c3,PS_DOT) 
                              goto PS_CL 
                            end 
                          end 
&dA              
                          if ndata(c2,PS_RANK) * ndata(c3,PS_RANK) <> 1 
                            goto PS_CL 
                          end 
&dA &d@                           
&dA &d@           We must now ask the question: are all notes of first chord either 
&dA &d@              equal/above all notes of second chord, or equal/below all notes 
&dA &d@              of second chord.  
&dA 
                          c10 = 0 
                          loop for c9 = 1 to pcnt 
                            if ndata(c9,PS_PASS) = ndata(c2,PS_PASS) 
                              if ndata(c9,PS_PITCH) <> ndata(c2,PS_PITCH) 
                                if ndata(c9,PS_PITCH) > ndata(c2,PS_PITCH) 
                                  if c10 = -1 
                                    c10 = 1000 
                                  else 
                                    c10 = 1 
                                  end 
                                end 
                                if ndata(c9,PS_PITCH) < ndata(c2,PS_PITCH) 
                                  if c10 = 1 
                                    c10 = 1000 
                                  else 
                                    c10 = -1 
                                  end 
                                end 
                              end 
                            end 
                          repeat 
                          if c10 = 1000 
                            goto PS_CL 
                          end 
                          loop for c9 = 1 to pcnt 
                            if ndata(c9,PS_PASS) = ndata(c3,PS_PASS) 
                              if ndata(c9,PS_PITCH) <> ndata(c3,PS_PITCH) 
                                if ndata(c9,PS_PITCH) > ndata(c3,PS_PITCH) 
                                  if c10 = 0 
                                    c10 = -1 
                                  end 
                                  if c10 = 1 
                                    c10 = 1000 
                                  end 
                                end 
                                if ndata(c9,PS_PITCH) < ndata(c3,PS_PITCH) 
                                  if c10 = 0 
                                    c10 = 1 
                                  end 
                                  if c10 = -1 
                                    c10 = 1000 
                                  end 
                                end 
                              end 
                            end 
                          repeat 
                          if c10 = 1000 
                            goto PS_CL 
                          end 
                          goto PS_UNIS     /*  typeset unison 
                        end 
                        if c4 = 1 or c4 = -1 
                          if ndata(c2,PS_PASS) <> ndata(c3,PS_PASS) 
                            goto PS_CL 
                          end 
                        end 
                      end 
                    end 
                  end 
                repeat 
              end 
            repeat 
&dA 
&dA &d@     no clashes found.  Typeset chords 
&dA 
            loop for c4 = 1 to 2    /* typeset stem down first 
              c5 = 2 - c4 
PS_C:         c6 = 0 
              c7 = 0 
              loop for c2 = 1 to pcnt 
                if ndata(c2,PS_PASS) > 0 and bit(0,ndata(c2,PS_STEM)) = c5 
                  if ndata(c2,PS_PITCH) > c6     /* typeset highest pitch first
                    c6 = ndata(c2,PS_PITCH) 
                    c7 = ndata(c2,PS_PASS) 
                  end 
                end 
              repeat 
              if c7 > 0 
                c8 = 100 
                perform ps_setchord (c7, c8, c10) 
                goto PS_C 
              end 
            repeat 
&dA 
&dA &d@     Note: When you have reached this point in the code, you have determined 
&dA &d@     the local position of all notes (but not rests) in the simultaneity.  The
&dA &d@     arrays gr(.,.) and gl(,.,) have been computed (if there were notes in 
&dA &d@     the simultaneity).  You can now use this information to try to place 
&dA &d@     any rests vertically as best you can.  After this, you need to compute 
&dA &d@     the NODE_SHIFT parameter (from emptyspace(.,.) and gl(,.,) and then 
&dA &d@     the new values for emptyspace(.,.) 
&dA 
&dA &d@     Now store results in set array    (watch out for c9 and c10 in this loop)
&dA 
            c2 = 0 
            c5 = 0 
            pitchcnt(1) = 0 
            pitchcnt(2) = 0 
            loop for c1 = a1 to a2 
              ++c2 
              c4 = ts(c1,STAFF_NUM) + 1      /* staff number 
              thispass = ndata(c2,PS_PASS2)
              if thispass <> c5 
                c5 = thispass 
                ++pitchcnt(c4) 
              end 
              if ndata(c2,PS_PITCH) = 100    /* rest 
                ntype = ndata(c2,PS_HEAD) 
                c6 = ntype << 1 - 1 
                c8 = int("1008060402020402030303"{c6,2}) 
                c7 = int("0505050505030301000101"{c6,2}) 
                if ps_passcount(c4) = 1 
                  c3 = vpar(4) 
                  if ts(c1,MULTI_TRACK) >= 4 
                    c6 = ts(c1,MULTI_TRACK) >> 2 
                    if c6 = 1 
                      c3 -= vpar(2) 
                    end 
                    if c6 = 2 
                      c3 += vpar(4) 
                    end 
                  end 
                else 
                  if ps_passcount(c4) = 2 
                    if pitchcnt(c4) = 1 
                      if chr(ts(c1+1,TYPE)) in [NOTE,CUE_NOTE] 
                        c3 = ts(c1+1,STAFFLOC)
                      else 
&dA 
&dA &d@       &dA05/10/05&d@ Addition to allow a single rest (expressing parallel rests)
&dA &d@                  to be located at vpar(4), the middle staff line.  
&dA &d@                  Note: this work-around may not cover all cases.  
&dA 
                        if ts(c1+1,TYPE) = REST and ts(c1+1,CLAVE) = 200 
                          c3 = vpar(4) 
                          goto RTYY3 
                        else 
                          c3 = vpar(2) 
                          if (ts(c1,NTYPE) & 0xff) < EIGHTH and c3 > 0    /* new &dA10/15/07
                            c3 = 0 
                          end 
                        end 
&dA           
                      end 
                      c11 = c3 + vpar20 * 2 + 1 / vpar(2) - 20 
                      c6 = 23 - c11 

                      c13 = c6 
                      loop while gr(c4,c6) <> -200 
                        c3 -= vpar(1) 
                        c11 = c3 * 2 / vpar(2) 
                        c3 -= rem                 /* tricky code 

                        ++c6      
                      repeat 
                      c6 -= c7                          /* c7 is lower part of rest
                      loop while gr(c4,c6) <> -200 
                        c3 -= vpar(1) 
                        c11 = c3 * 2 / vpar(2) 
                        c3 -= rem                 /* tricky code 

                        ++c6      
                      repeat 
                      if c6 > c13 + 8 
                        c3 += vpar(2) 
                      end 
                      if c3 > vpar(2) 
                        c3 = vpar(2) 
                      end 
                      c6 = c3 / notesize 
                      if rem <> 0 
                        c3 -= vpar(1)     /* OK 4-21-95 
                      end 
                    else 
                      if chr(ts(c1-1,TYPE)) in [REST,CUE_REST] 
                        if ts(c1-1,CLAVE) < 200
                          c3 = vpar(8) 
                        else 
                          c3 = vpar(4) 
                          goto RTYY3 
                        end 
                      else 
                        c3 = ts(c1-1,STAFFLOC) + vpar(2) 
                      end 
                      c11 = c3 + vpar20 * 2 + 1 / vpar(2) - 20 
                      c6 = 23 - c11 

                      c13 = c6 
                      loop while gr(c4,c6) <> -200 
                        c11 = c3 * 2 / vpar(2) 
                        if rem <> 0               /* tricky code 
                          ++c3       
                        end 
                        c3 += vpar(1) 

                        --c6   
                      repeat 
                      c6 += c8                          /* c8 is "clearance" at top of rest
                      loop while gr(c4,c6) <> -200 
                        c11 = c3 * 2 / vpar(2) 
                        if rem <> 0               /* tricky code 
                          ++c3       
                        end 
                        c3 += vpar(1) 

                        --c6   
                      repeat 
                      if c6 < c13 - 8 
                        c3 -= vpar(2) 
                      end 
                      if c3 < vpar(8) 
                        c3 = vpar(8) 
                      end 
                      c6 = c3 / notesize 
                      if rem <> 0 
                        c3 = c6 + 1 * notesize 

                      end 
                    end 
                  else 
                    if pitchcnt(c4) = 1 
                      if chr(ts(c1+1,TYPE)) in [NOTE,CUE_NOTE] 
                        c3 = ts(c1+1,STAFFLOC)           
                      else 
                        c3 = vpar(2) 
                      end 
                      if (ts(c1,NTYPE) & 0xff) < EIGHTH and c3 > 0     /* new &dA10/15/07
                        c3 = 0 
                      end 
                      c11 = c3 + vpar20 * 2 + 1 / vpar(2) - 20 
                      c6 = 23 - c11 

                      c13 = c6 
                      loop while gr(c4,c6) <> -200 
                        c3 -= vpar(1) 
                        c11 = c3 * 2 / vpar(2) 
                        c3 -= rem                 /* tricky code 

                        ++c6      
                      repeat 
                      c6 -= c7                          /* c7 is lower part of rest
                      loop while gr(c4,c6) <> -200 
                        c3 -= vpar(1) 
                        c11 = c3 * 2 / vpar(2) 
                        c3 -= rem                 /* tricky code 

                        ++c6      
                      repeat 
                      if c6 > c13 + 8 
                        c3 += vpar(2) 
                      end 
                      if c3 > vpar(2) 
                        c3 = vpar(2) 
                      end 
                      c6 = c3 / notesize 
                      if rem <> 0 
                        c3 -= vpar(1)      /* OK 4-21-95 
                      end 
                    else 
                      if pitchcnt(c4) = ps_passcount(c4) 
                        if chr(ts(c1-1,TYPE)) in [REST,CUE_REST] 
                          if ts(c1-1,CLAVE) < 200
                            c3 = vpar(10) 
                          else 
                            c3 = vpar(4) 
                          end 
                        else 
                          c3 = ts(c1-1,STAFFLOC) + vpar(2) 
                        end 
                        c11 = c3 + vpar20 * 2 + 1 / vpar(2) - 20 
                        c6 = 23 - c11 

                        c13 = c6 
                        loop while gr(c4,c6) <> -200 
                          c11 = c3 * 2 / vpar(2) 
                          if rem <> 0               /* tricky code 
                            ++c3 
                          end 
                          c3 += vpar(1) 

                          --c6        
                        repeat 
                        c6 += c8                          /* c8 is "clearance" at top of rest
                        loop while gr(c4,c6) <> -200 
                          c11 = c3 * 2 / vpar(2) 
                          if rem <> 0               /* tricky code 
                            ++c3 
                          end 
                          c3 += vpar(1) 

                          --c6        
                        repeat 
                        if c6 < c13 - 8 
                          c3 -= vpar(2) 
                        end 
                        if c3 < vpar(8) 
                          c3 = vpar(8) 
                        end 
                        c6 = c3 / notesize 
                        if rem <> 0 
                          c3 = c6 + 1 * notesize 

                        end 
                      else 
&dA 
&dA &d@               Look for empty space in middle of staff 
&dA 
                        loop for c3 = 45 to 1 step -1 
                        repeat while gr(c4,c3) = -200 
                        if c3 <= 21                      /* suppose there's nothing up there
                          c3 += 3 
                          if c3 < 19 
                            c3 = 19 
                          end 
                          goto RTYY2 
                        end 
                        loop while c3 > 0 
                          --c3 
                        repeat while gr(c4,c3) <> -200
RTYY: 
                        loop for c6 = 1 to 8 
                          --c3 
                        repeat while c3 > 0 and gr(c4,c3) = -200 
                        if c6 = 8 or c3 <= 0 
                          c3 += 3 
                        else 
                          goto RTYY 
                        end 
RTYY2: 
                        c3 = 43 - c3 / 2 * vpar(2) 
                        c3 += rem * vpar(1) 
                        c3 -= vpar20       
                      end 
                    end 
                  end 
                end 
RTYY3: 
                if ts(c1,CLAVE) < 200
                  if ts(c1,STAFFLOC) = 1 
                    c3 = vpar(4) 
                  end 
                  ts(c1,STAFFLOC) = c3 
                  perform rest_occupy_space (c3,c4)   /* ntype is read directly
                  ts(c1,OBY) = ts(c1,STAFFLOC) 
                end 
              else 
                c3 = ndata(c2,PS_HEAD) 
                if ndata(c2,PS_NSTYLE) = 0 
                  if c3 < 3 
                    c4 = hpar(82) 
                  else 
                    if c3 = 3
                      c4 = hpar(83) 
                    else 
                      c4 = hpar(84) 
                    end 
                  end 
                else                            /* New  &dA01/08/11&d@ 
                  if c3 < 3
                    c4 = vpar(2) 
                  else 
                    if c3 = 3
                      c4 = vpar(2) * 5 / 4 
                    else 
                      c4 = hpar(84) 
                    end 
                  end 
                end 

                if ndata(c2,PS_NSIZE) = CUESIZE 
                  c4 = c4 * 8 / 10 
                end 

                c4 -= 1 
&dA 
&dA &d@     Note: LOCAL_XOFF will now be set for this notehead, and will not be changed.
&dA &d@           The value is negative, zero, or positive by the approximate thickness
&dA &d@           of a notehead.  This information can be used in the final computation
&dA &d@           of P10 for this notehead.  
&dA 
                ts(c1,LOCAL_XOFF)  = c4 * ndata(c2,PS_XPOS)     /* uniquely set here
                
&dA 
&dA &d@  &dA NOTE: Do not call procedure get_topbottom before this point in the program 
&dA 

&dA 
&dA &d@     Note: We are about to set GLOBAL_XOFF for all noteheads in a chord 
&dA &d@           to the value in printpos(thispass).  The spacing of simultaneous
&dA &d@           chords in this program is hopelessly complicated.  Therefore 
&dA &d@           we cannot know directly whether a notehead has been shifted 
&dA &d@           exactly one thickness to the right or left, or whether the 
&dA &d@           shift has been built up in several parts.  All we know is that 
&dA &d@           the shift adds up to GLOBAL_XOFF.  In order to set the NOTE_DISP
&dA &d@           parameter properly, we will need to compare GLOBAL_XOFF with autoscr's
&dA &d@           normal shift distance = (width of black note - 2).  If GLOBAL_XOFF
&dA &d@           is within 2 dots either side of +/- (hpar(82) - 2), then we will
&dA &d@           infer that the shift was an integral notehead thickness; otherwise
&dA &d@           we must record the shift measured in dots.  A shift of an 
&dA &d@           integral notehead thickness will be recorded as -100 or +100.  
&dA 
                if chr(ts(c1,TYPE)) in [NOTE,CUE_NOTE,GR_NOTE] 
                  c9 = c1 
                  ts(c1,GLOBAL_XOFF) = printpos(thispass) 
&dA 
&dA &d@                              All New code &dA05/02/03&d@ 
&dA 
&dA &d@       At this point, we need to see if the note object position has been modified
&dA &d@       "absolutely" by a print suggestion.  If this is the case, we need to make the
&dA &d@       adjustment here, AND, elimate the suggestion from the tsr string.  
&dA 
                  c4 = ts(c1,TSR_POINT) 
                  c3 = ors(tsr(c4){2}) 
                  if bit(0,c3) = 1 
                    px = ors(tsr(c4){3}) 
                    if px > 0 
                      px = px - 128 * notesize / 10 
&dA 
&dA &d@     &dA11/24/07&d@  We need to take action in both the relative and 
&dA &d@     absolute cases of x-shift.  Apparently, there is a difference, 
&dA &d@     at least here.  Relative shift ("x") is added to whatever is 
&dA &d@     already in the GLOBAL_XOFF; whereas absolute shift ("X") replaces 
&dA &d@     any value in GLOBAL_XOFF.  This holds for note placement, but 
&dA &d@     I am unclear whether it is true for musical signs, dynamics, etc.  
&dA 
                      pxx = c3 & 0x02 >> 1 
                      if pxx = 1                    /* true when "X" is used
                        ts(c1,GLOBAL_XOFF) = px 
                        tsr(c4){3} = chr(0)         /* here is where suggestion is zeroed out
                      else 
                        ts(c1,GLOBAL_XOFF) += px 
                        tsr(c4){3} = chr(0)         /* here is where suggestion is zeroed out
                      end 
&dA                 
                    end 
                  end 
                  printpos(thispass) = ts(c1,GLOBAL_XOFF) 
&dA 
&dA &d@       End of new code &dA05/02/03&d@ 
&dA 
                  c10 = c1 + 1
                  loop while ts(c10,TYPE) = ts(c1,TYPE) + 1 
                    ++c10 
                  repeat 
                  --c10 
                else 
                  ts(c1,GLOBAL_XOFF) = c9 * INT10000 + c10    /* temporary storage of indexes
                  ts(c1,NOTE_DISP) = ts(c9,NOTE_DISP) 
                end 
              end 
            repeat 
            goto PS_END 

&dA 
&dA &d@     Clashes
&dA 
PS_CL: 
            c4 = ndata(c2,PS_PASS) 
            c5 = ndata(c3,PS_PASS) 
            if ndata(c2,PS_DOT) > 0 and ndata(c3,PS_DOT) = 0 
              c7 = c5 
              goto PS_CLT 
            end 
            if ndata(c2,PS_DOT) = 0 and ndata(c3,PS_DOT) > 0 
              c7 = c4 
              goto PS_CLT 
            end 
            if bit(0,ndata(c2,PS_STEM)) = UP and bit(0,ndata(c3,PS_STEM)) = DOWN
              c7 = c4 
              goto PS_CLT 
            end 
            if bit(0,ndata(c2,PS_STEM)) = DOWN and bit(0,ndata(c3,PS_STEM)) = UP
              c7 = c5 
              goto PS_CLT 
            end 
            if ndata(c2,PS_PITCH) >= ndata(c3,PS_PITCH) 
              c7 = c4 
            else 
              c7 = c5 
            end 
PS_CLT:
            c8 = 100 
            perform ps_setchord (c7, c8, c10) 
            goto PS_B 
*
PS_UNIS:
            c7 = ndata(c2,PS_PASS) 
            c8 = ndata(c3,PS_PASS) 
            perform ps_setchord (c7, c8, c10) 
            goto PS_B 

PS_END: 

&dA 
&dA &d@     At this point you have accomplished tasks (1), (2), and (3) 
&dA &d@     for the case of multiple note heads on a division.  You now 
&dA &d@     need to do the following (for all ts(.,.) elements from a1   
&dA &d@     to a2).  
&dA 
&dA &d@       (4) Compute the x and y offsets for any dot(s) which might 
&dA &d@           follow each note head.     
&dA 
&dA &d@       (5) Compute the x offset (as measured to the left) of any 
&dA &d@             accidental(s) which might precede each note head.
&dA 

&dA 
&dA &d@     (4) X and Y offsets for dots 
&dA 
&dA &d@       (a) determine number and spacing of note heads on each stave 
&dA &d@             to determine method of placement of dots.  Use column 
&dA &d@             method if note heads (with dots) occur on space and line
&dA &d@             on the same staff.  Otherwise use conventional placement.  
&dA &d@             (This code assumes MAX_STAFF <= 3) 
&dA 
&dA &d@             First find all staves where all offsets (global and local) 
&dA &d@             are zero.  In these cases, we can use the absolute method.  
&dA 
            tgroup(1) = 4 
            tgroup(2) = 4 
            tgroup(3) = 4 
            loop for c1 = a1 to a2 
              c8 = ts(c1,STAFF_NUM) + 1        /* staff number 
              if chr(ts(c1,TYPE)) in [NOTE,CUE_NOTE,GR_NOTE] 
                if ts(c1,GLOBAL_XOFF) > 0 
                  tgroup(c8) = 0 
                end 
              end 
              if ts(c1,LOCAL_XOFF) > 0 
                tgroup(c8) = 0 
              end 
            repeat 

            loop for c1 = a1 to a2 
              if ts(c1,DOT) > 0 
                c8 = ts(c1,STAFF_NUM) + 1      /* staff number 
                if tgroup(c8) <> 4 
                  c9 = ts(c1,STAFFLOC) + vpar20 * 2 + 1 / vpar(2) - 20 

                  c9 = bit(0,c9) + 1 
                  if tgroup(c8) = 0 
                    tgroup(c8) = c9 
                  else 
                    if tgroup(c8) <> c9 
                      tgroup(c8) = 3           /* use column method 
                    end 
                  end 
                end 
              end 
            repeat 
&dA 
&dA &d@       (b) for those staves using the column method, determine the 
&dA &d@             x offset of the column.  
&dA 
            c5 = 0 
            loop for c8 = 1 to 3 
              if tgroup(c8) = 3 
                tgroup(c8) = 1 
                c5 = 1 
              else 
                tgroup(c8) = 0 
              end 
            repeat 
            if c5 = 1 
              loop for c1 = a1 to a2 
                if ts(c1,GLOBAL_XOFF) < INT10000   
                  c9 = ts(c1,GLOBAL_XOFF)                    /* global offset 
                end 
                if ts(c1,DOT) > 0 
                  c8 = ts(c1,STAFF_NUM) + 1                  /* staff number 
                  if tgroup(c8) > 0 
                    c7 = c9 + ts(c1,LOCAL_XOFF)              /* note head position
                    c10 = ts(c1,TYPE) / 3 
                    if rem = 0
                      if ts(c1,NTYPE) > QUARTER 
                        c3 = hpar(30) 
                      else 
                        c3 = hpar(31) 
                      end 
                    else 
                      if (ts(c1,SUBFLAG_1) & 0x8000) = 0   /* modern notation
                        if ts(c1,NTYPE) > HALF 
                          c3 = hpar(32) 
                        else 
                          c3 = hpar(33) 
                        end 
                      else                                 /* New &dA01/08/11&d@ 
                        if ts(c1,NTYPE) > WHOLE 
                          c3 = vpar(2) * 5 / 2 
                        else 
                          if ts(c1,NTYPE) > HALF 
                            c3 = vpar(2) * 9 / 5 
                          else 
                            c3 = vpar(2) * 3 / 2 
                          end 
                        end 
                      end 
                    end 
                    if rem = 1 and bit(1,ts(c1,STEM_FLAGS)) = UP and bit(16,ts(c1,SUBFLAG_1)) = 0 /* modern only
                      if ts(c1,BEAM_FLAG) = NO_BEAM and ts(c1,NTYPE) < QUARTER 
                        c3 += hpar(27) 
                      end 
                    end 
                    if ts(c1,TYPE) > REST 
                      c3 = c3 * 8 / 10 
                    end 
                    c7 += c3             /* dot position for this note head 
                    if tgroup(c8) < c7 
                      tgroup(c8) = c7 
                    end 
                  end 
                end 
              repeat 
&dA &d@              
&dA &d@       (c) place dots for all staves which use the column method
&dA &d@             (relative x placement; absolute y placement) 
&dA 
&dA &d@           Starting with the left-most objects in the "musical node" 
&dA &d@           and moving to the right, set dot positions according to 
&dA &d@           the following algorithm (keeping track of all previous 
&dA &d@           dots for this stave): 
&dA 
&dA &d@              Start with the note head furtherest from note-end of stem 
&dA &d@              If note on line, 
&dA &d@                if space above is free, put dot there 
&dA &d@                else put dot in first free space below 
&dA &d@              else 
&dA &d@                if space is free, put dot there 
&dA &d@                else put dot in first free space in reverse direction 
&dA &d@              end 
&dA 
              loop for c13 = 1 to 3       /* loop though staves 
                if tgroup(c13) > 0 
                  c5 = 0 
                  c10 = 0                 /* count up for stems up 
                  c11 = 1000              /* count down for stems down 
&dA 
&dA &d@    Special case: two notes on stave and multi-tracks on this stave 
&dA 
                  if a2 = a1 + 1 
                    if ts(a1,MULTI_TRACK) >= 4 
                      if abs(ts(a1,STAFFLOC) - ts(a2,STAFFLOC)) > notesize 
                        if bit(1,ts(a1,STEM_FLAGS)) <> bit(1,ts(a2,STEM_FLAGS))
                          loop for c1 = a1 to a2 
                            c8 = ts(c1,GLOBAL_XOFF) 
                            if c8 >= INT10000 
                              c8 /= INT10000 
                              c8 = ts(c8,GLOBAL_XOFF) 
                            end 
                            c10 = ts(c1,STAFFLOC) 
                            c9 = c10 / notesize 
                            if rem = 0                 /* note on line 
                              if bit(1,ts(c1,STEM_FLAGS)) = UP 
                                c10 -= vpar(12) 
                              else 
                                c10 += vpar(12)           
                              end 
                            end 
                            c10 -= ts(c1,OBY)          /* convert to relative y offset
                            c9 = tgroup(c13) - c8      /* relative x offset from obx
                            c9 *= INT10000 
                            c9 += c10 
                            c9 <<= 4                   /* code modified &dA12-24-96
                            ts(c1,DOT) |= c9 
                          repeat 
                          goto X_DOT 
                        end 
                      end 
                    end 
                  end                                        /* global offset 

                  loop for c1 = a1 to a2 
                    if ts(c1,GLOBAL_XOFF) < INT10000   
                      c9 = ts(c1,GLOBAL_XOFF)                /* global offset           
                    end 
                    c8 = ts(c1,STAFF_NUM) + 1         /* staff number 
                    if ts(c1,DOT) > 0 and c8 = c13    /* dot on this staff 
                      ++c5 
                      c12 = bit(1,ts(c1,STEM_FLAGS)) 
                      if c12 = UP       /* stem up 
                        ndata(c5,1) = c10 
                        ++c10 
                      else 
                        ndata(c5,1) = c11 
                        --c11 
                      end 
                      ndata(c5,1) += c9 * 10000        /* tricky code (for ordering)
                      ndata(c5,2) = c1 
                      ndata(c5,3) = c12                /* stem direction 
                      ndata(c5,4) = c9                 /* global x offset 
                      ndata(c5,5) = 100 
                    end 
                  repeat 
&dA 
&dA &d@           Sort the ndata array by ndata(.,1) smallest on top 
&dA &d@           first by global offset, then by stem (up first), then by order 
&dA &d@           on stem (up in order, down reverse order) 
&dA 
                  loop for c8 = 1 to c5 
                    c6 = 10000000    
                    loop for c4 = 1 to c5 
                      if ndata(c4,5) = 100 and ndata(c4,1) < c6 
                        c6 = ndata(c4,1) 
                        c7 = c4 
                      end 
                    repeat 
                    ndata(c7,6) = c8 
                    ndata(c7,5) = 0 
                  repeat 
&dA 
&dA &d@           Typeset dots on this staff 
&dA 
                  loop for c8 = 1 to 50 
                    mf(c8) = 0 
                  repeat 
                  loop for c8 = 1 to c5 
                    c7 = ndata(c8,6)                /* typeset this note head 
                    c1 = ndata(c7,2)                /* c1 is the index 
                    c9 = tgroup(c13) - ndata(c7,4)  /* relative x offset from obx
                    c16 = ts(c1,STAFFLOC) + vpar20 * 2 + 1 / vpar(2) - 20 
                    c4 = 23 - c16                            /* 23 = top line of staff

&dA 
&dA &d@              If note on line, 
&dA &d@                if space above is free, put dot there 
&dA &d@                else put dot in first free space below 
&dA &d@              else 
&dA &d@                if space is free, put dot there 
&dA &d@                else put dot in first free space in reverse direction 
&dA &d@              end 
&dA 
                    if bit(0,c4) = 1                /* if note on line 
                      if mf(c4+1) = 0 
                        mf(c4+1) = 1 
                        c10 = c4 + 1                /* absolute y offset (23 = top line)
                      else 
                        c10 = 0 
                        --c4 
                        loop 
                          if mf(c4) = 0 
                            mf(c4) = 1 
                            c10 = c4 
                          else 
                            c4 -= 2 
                          end 
                        repeat while c10 = 0 
                      end 
                    else                            /* else, note on space 
                      if mf(c4) = 0 
                        mf(c4) = 1 
                        c10 = c4 
                      else 
                        if ndata(c7,3) = UP         /* if stem up, look up 
                          c10 = 0 
                          c4 += 2 
                          loop 
                            if mf(c4) = 0 
                              mf(c4) = 1 
                              c10 = c4 
                            else 
                              c4 += 2 
                            end 
                          repeat while c10 = 0 
                        else                        /* else, stem is down; look down
                          c10 = 0 
                          c4 -= 2 
                          loop 
                            if mf(c4) = 0 
                              mf(c4) = 1 
                              c10 = c4 
                            else 
                              c4 -= 2 
                            end 
                          repeat while c10 = 0 
                        end 
                      end 
                    end 
&dA 
&dA &d@             c10 is the absolute y position (23 = top line) for the dot(s) 
&dA 
                    c10 = 43 - c10 / 2 * vpar(2) 
                    c10 += rem * vpar(1) 
                    c10 -= vpar20 
&dA 
&dA &d@           Store relative values of x and y for this note head 
&dA &d@             c9 is the relative x shift to the dot(s) from obx 
&dA &d@             x * INT10000 + y, shift it over 4 and &dAOR&d@ it DOT   (modified &dA12-24-96&d@)
&dA 
                    c9 *= INT10000 
                    c10 -= ts(c1,OBY)          /* convert to relative y offset 
                    c9 += c10 
                    c9 <<= 4                   /* code modified &dA12-24-96&d@ 
                    ts(c1,DOT) |= c9  
                  repeat 
X_DOT: 

                end 
              repeat 
            end 
&dA &d@              
&dA &d@       (d) place dots for all remaining note heads (absolute placement first) 
&dA 
            old_c2 = 10000                    /* added &dA11/26/06&d@ 
            loop for c1 = a1 to a2 
              if ts(c1,DOT) > 0 and ts(c1,DOT) < INT9000      /* dot not yet placed
                ntype = ts(c1,NTYPE) & 0xff                   /* new &dA10/15/07
                c10 = ts(c1,TYPE) / 3 
                if rem = 0                    /* rests 
                  if ntype > QUARTER 
                    c3 = hpar(30) 
                  else 
                    c3 = hpar(31) 
                  end 
                else 
                  if (ts(c1,SUBFLAG_1) & 0x8000) = 0   /* modern notation 
                    if ntype > HALF 
                      c3 = hpar(32) 
                    else 
                      c3 = hpar(33) 
                    end 
                  else                                 /* New &dA01/08/11&d@ 
                    if ntype > WHOLE 
                      c3 = vpar(2) * 5 / 2 
                    else 
                      if ntype > HALF 
                        c3 = vpar(2) * 9 / 5 
                      else 
                        c3 = vpar(2) * 3 / 2 
                      end 
                    end 
                  end 
                end 
                c6 = ts(c1,STAFFLOC) + vpar20 * 2 + 1 / vpar(2) - 20 
                c5 = ts(c1,STAFFLOC) / notesize 
                c5 = rem                           /* c5 = 0 means note on line

                if bit(1,ts(c1,STEM_FLAGS)) = UP and bit(16,ts(c1,SUBFLAG_1)) = 0
                  if ts(c1,BEAM_FLAG) = NO_BEAM and ts(c1,NTYPE) < QUARTER 
                    c10 = ts(c1,TYPE) / 3 
                    if rem = 1 
                      c3 += hpar(27) 
                      if c5 <> 0 
                        c3 -= hpar(34) 
                      end 
                    end 
                  end 
                end 
*    if dot is on staff line, c5 = 0    
                if c5 = 0 
                  c2 = 0 - vpar(12) 
           /* lower dot if more than one track and stem is down 
                  if bit(3,ts(c1,MULTI_TRACK)) = 1 
                    if bit(1,ts(c1,STEM_FLAGS)) = DOWN 
                      c2 = vpar(12) 
                    end 
                  end 
                  c3 -= hpar(34) 
                else 
                  c2 = 0 
                end 
                if ts(c1,TYPE) <= REST 
                  c5 = bit(16,ts(c1,SUBFLAG_1)) 
                else 
                  c5 = CUESIZE 
                end 
                if c5 = 1 
                  c3 = c3 * 8 / 10 
                end 
                c2 += ts(c1,STAFFLOC) 
                c2 -= ts(c1,OBY)       
&dA 
&dA &d@    This code added &dA11/26/06&d@ (as a cludge) to fix a minor bug in the 
&dA &d@      placement extension dots when one is "on top of" another.  
&dA 
                if ts(c1,TYPE) = XNOTE or ts(c1,TYPE) = XCUE_NOTE or ts(c1,TYPE) = XGR_NOTE
                  if abs(old_c2 - c2) < vpar(1) 
                    c2 += vpar(2) 
                  end 
                end 
                old_c2 = c2 
&dA 
&dA                 &d@ End of &dA11/26/06&d@ addition 

             /* c3 = x offset to the dot(s) from obx 
             /* c2 = y offset to the dot(s) from oby 
             /* x * INT10000 + y, shift it over 4 and &dAOR&d@ it with DOT  (modified &dA12-24-96&d@)
                c3 *= INT10000 
                c3 += c2 
                c3 <<= 4                                   /* code modified &dA12-24-96
                ts(c1,DOT) |= c3    
              end 
            repeat 
&dA 
&dA &d@       Adjust the gr(.,.) array to accommodate space for dots 
&dA 
            c17 = 0                                        /* used below 
            loop for c1 = a1 to a2 
              if ts(c1,GLOBAL_XOFF) < INT10000 
                c9 = ts(c1,GLOBAL_XOFF)                    /* global offset 
              end 
              c8 = ts(c1,STAFF_NUM) + 1                    /* staff number 

&dA                       
&dA 
&dA &d@     Special code added to deal with the discrepency in how single vs. multiple
&dA &d@     tracks handle the minimal spacing for dotted rests.   &dA04/19/08&d@ 
&dA &d@     This section computes the value of the right hand border for the dot, c7
&dA &d@     It also sets the exception variable c17 = 1 
&dA 
              c7 = 10000                                 /* "normal" condition

              c3 = ts(c1,DOT) 
              if c3 > 0 

                if c7 = 1

                  ntype = ts(c1,NTYPE) & 0xff 

                  c4 = 0 
                  if ntype <= SIXTEENTH 
                    c4 = EIGHTH - ntype 
                  end 
                  if ntype > QUARTER 
                    c7 = hpar(30) 
                  else 
                    c7 = c4 * hpar(54) + hpar(31) 
                  end 

                  c7 += hpar(80) 

                  if ntype > WHOLE 
                    c4 = hpar(87) * 4 / 3 
                  else 
                    if ntype > QUARTER 
                      c4 = hpar(87) 
                    else 
                      if ntype > EIGHTH 
                        c4 = hpar(88) 
                      else 
                        c4 = EIGHTH - ntype * hpar(54) + hpar(88) 
                      end 
                    end 
                  end 

                  c7 += c4 

                  if ts(c1,DOT) & 0x0e > 0            
                    if ts(c1,DOT) & 0x02 > 0 
                      c7 += hpar(91)                    /* extra shift to second dot
                    end 
                    if ts(c1,DOT) & 0x04 > 0 
                      c7 += hpar(91)                    /* extra shift to third dot
                    end 
                    if ts(c1,DOT) & 0x08 > 0 
                      c7 += hpar(91)                    /* extra shift to fourth dot
                    end 
                  end 
                end 
&dA 
&dA                       

                c4 = c3 & 0x0f               /* dot flag    (modified &dA12-24-96&d@)
                c3 >>= 4                                    /* code modified &dA12-24-96
                c5 = c3 / INT10000           /* x offset 
                c6 = rem                     /* y offset 
                if c6 > INT10000 >> 1 
                  c6 -= INT10000 
                  ++c5 
                end 
                c6 = c6 + vpar(8) * 2 - 1 / vpar(2) - 7 

                c16 = ts(c1,STAFFLOC) + vpar20 * 2 + 1 / vpar(2) - 20 
                c6 = 23 - c16 - c6 

                c5 += c9 + ts(c1,LOCAL_XOFF)               /* final offset for dot
                c5 += hpar(80) 
                if c4 > 1                                  /* code modified &dA12-24-96
                  c5 += hpar(91)              /* second dot 
                  if c4 > 4 
                    c5 += hpar(91)            /* third dot 
                  end 
                  if c4 > 8 
                    c5 += hpar(91)            /* fourth dot 
                  end 
                end 
                if c6 < 46 and c6 > 0 

&dA                       
&dA 
&dA &d@     More code added to deal with the discrepency in how single vs. multiple
&dA &d@     tracks handle the minimal spacing for dotted rests.   &dA04/19/08&d@ 
&dA &d@     This section sets the value of the right hand object "border" gr(.,.) 
&dA 
                  if c7 = 10000                 /* "normal" condition 
                    gr(c8,c6) = c5 
                  else 
                    gr(c8,c6) = c7 
                    if c6 < 44 
                      gr(c8,c6+1) = c7 
                      gr(c8,c6+2) = c7 
                    end 
                  end 
&dA 
&dA                       

                end 
              end 
            repeat 

&dA 
&dA &d@     (5) Compute the x offset (as measured to the left) of any 
&dA &d@             accidental(s) which might precede each note head.
&dA 
&dA &d@       (a) Check the left-hand border from the typesetting operation.  
&dA &d@           If there are any accidentals that could be set on right- 
&dA &d@           shifted note heads, set these first, starting from the 
&dA &d@           top down.  This defines column 1 of the accidentals.  
&dA 
&dA &d@           Otherwise, column one is the first free location to the 
&dA &d@           left of the left-most note head.  
&dA 
&dA &d@       (b) For all remaining accidentals to set, start at the top 
&dA &d@           of the group.  Make successive passes until all accidentals 
&dA &d@           are set.  
&dA 
&dA &d@            1. moving down, put in as many accidentals as possible 
&dA &d@               where the distance between eligible notes (delta) >= 
&dA &d@               vpar(6), with the caviat that you do not put an 
&dA &d@               accidental on the lower half of a second before the 
&dA &d@               upper half of a second (as you move down).  
&dA 
&dA &d@            2. move to the left by the largest thickness of accidentals 
&dA &d@               just placed.  Decide on the direction to move for the 
&dA &d@               next pass and goto (a).  The new direction will be 
&dA &d@               down (again) if the previous pass hit the lowest remaining 
&dA &d@               accidental; otherwise, the new direction will be up.  
&dA 
&dA &d@       (Maximum staves for this code is 2, because this is the size of gl(.,.))
&dA 
            tgroup(1) = 0 
            tgroup(2) = 0 
            tgroup(3) = 0 
            c5 = 0 

            loop for c1 = a1 to a2 
              if ts(c1,AX) > 0 
                c8 = ts(c1,STAFF_NUM) + 1        /* staff number 
                ++tgroup(c8)
                ndata(tgroup(c8),c8) = c1 
                c5 = 1 
              end 
            repeat 
            if c5 = 1                     /* &dADon't change this variable (c5) 
                                          /* &dAuntil task (1) is complete      
              loop for c13 = 1 to 2       /* loop though staves 
                if tgroup(c13) > 0 
                  if a1 = a2              /* simple case (one note group) 
                    c1 = ndata(1,c13)     /* index 
                    c3 = ts(c1,AX) & 0x0f 
                    c16 = ts(c1,STAFFLOC) + vpar20 * 2 + 1 / vpar(2) - 20 
                    c2 = 23 - c16 

                    if ts(c1,TYPE) > REST 
                      c4 = CUESIZE 
                    else 
                      c4 = bit(16,ts(c1,SUBFLAG_1))
                    end 
                    perform place_accidental (c13,c2,c3,c4) /* returns c4 = absolute x

              /* shift offset left 8 and &dAOR&d@ with AX 
                    c4 = 0 - c4 
                    c4 <<= 8             /* &dA02/25/97&d@ shift changed from 4 to 8
                    ts(c1,AX) |= c4       
                  else 
&dA 
&dA &d@        (1) We must re-order elements so that they are in descending 
&dA &d@              order on the staff.  Use bubble sort.  
&dA 
                    loop for c7 = 1 to tgroup(c13) - 1 
                      loop for c8 = c7+1 to tgroup(c13) 
                        c1 = ndata(c7,c13) 
                        c2 = ndata(c8,c13) 
                        if ts(c1,STAFFLOC) > ts(c2,STAFFLOC) 
                          ndata(c7,c13) = c2 
                          ndata(c8,c13) = c1 
                        end 
                      repeat 
                    repeat 
&dA &d@                     
&dA &d@        (2) Try first to set accidentals on "right shifted chords" 
&dA 
                    loop for c8 = 1 to tgroup(c13) 
                      c1 = ndata(c8,c13) 
                      if c8 > 1 
                        c2 = ndata(c8-1,c13) 
                        if c2 < DUMMY_VALUE 
                          c16 = ts(c1,STAFFLOC) - ts(c2,STAFFLOC) 
                          if c16 = vpar(1) or c16 = vpar(1) + 1           /* second
                            if ts(c1,LOCAL_XOFF) < ts(c2,LOCAL_XOFF) 
                              /* don't set accidental in this situation 
                              goto QQQ1 
                            end 
                          end 
                        end 
                      end 
                      c16 = ts(c1,STAFFLOC) + vpar20 * 2 + 1 / vpar(2) - 20 
                      c2 = 23 - c16 

                      c4 = 200 
                      c12 = ts(c1,AX) & 0x0f 
                      c14 = c2 - int("221002200100001"{c12})    /* lower limit 
                      c15 = c2 + int("333003300200003"{c12})    /* upper limit 

                      loop for c3 = c14 to c15 
                        if c3 > 0 and c3 <= 45 
                          if gl(c13,c3) <= 0 
                            c3 = 1000 
                          else 
                            if gl(c13,c3) < c4 
                              c4 = gl(c13,c3) 
                            end 
                          end 
                        end 
                      repeat 
                      if c3 < 1000 
                        c3 = ts(c1,AX) & 0x0f 
                        if ts(c1,TYPE) > REST 
                          c4 = CUESIZE 
                        else 
                          c4 = bit(16,ts(c1,SUBFLAG_1)) 
                        end 
                        perform place_accidental (c13,c2,c3,c4) /* returns c4 = absolute x

                        c3 = ts(c1,GLOBAL_XOFF) 
                        if c3 > INT10000 
                          c3 /= INT10000              /* index of top of chord 
                          c3 = ts(c3,GLOBAL_XOFF) 
                        end 
                        c6 = c3 - c4   /* relative x offset (to the left) 
                  /* shift offset left 8 and &dAOR&d@ with AX 
                        c6 <<= 8                       /* &dA02/25/97&d@ shift changed from 4 to 8
                        ts(c1,AX) |= c6                
                        ndata(c8,c13) = DUMMY_VALUE    /* accidental set 
                      end 
QQQ1: 
                    repeat 
&dA &d@                     
&dA &d@        (3) Now make successive passes until all accidentals are set 
&dA 
                    c10 = DOWN 
                    loop 
                      c6 = 0 
                      loop for c8 = 1 to tgroup(c13) 
                        if ndata(c8,c13) <> DUMMY_VALUE    /* accidental not set
                          c6 = c8 
                        end 
                      repeat 
                      if c6 = 0 
                        goto QQQ2                          /* DONE 
                      end 
                      if c10 = DOWN 
                        c11 = 1 
                        c12 = tgroup(c13) 
                        c9 = 1 
                      else 
                        c11 = tgroup(c13) 
                        c12 = 1 
                        c9 = -1 
                      end 
                      c10 = UP 
                      loop for c8 = c11 to c12 step c9 
                        c1 = ndata(c8,c13) 
                        if c1 = DUMMY_VALUE 
                          goto QQQ3 
                        end 
                        if c8 > 1 
                          c2 = ndata(c8-1,c13) 
                          if c2 < DUMMY_VALUE 
                            c16 = ts(c1,STAFFLOC) - ts(c2,STAFFLOC) 
                            if c16 = vpar(1) or c16 = vpar(1) + 1           /* second
                              if ts(c1,LOCAL_XOFF) < ts(c2,LOCAL_XOFF) 
                                /* don't set accidental in this situation 
                                goto QQQ3 
                              end 
                            end 
                          end 
                        end 
                        if c8 = c6 
                          c10 = DOWN 
                        end 
                        c16 = ts(c1,STAFFLOC) + vpar20 * 2 + 1 / vpar(2) - 20 
                        c2 = 23 - c16 

                        c3 = ts(c1,AX) & 0x0f 
                        if ts(c1,TYPE) > REST 
                          c4 = CUESIZE 
                        else 
                          c4 = bit(16,ts(c1,SUBFLAG_1)) 
                        end 
                        perform place_accidental (c13,c2,c3,c4) /* returns c4 = absolute x

                        c3 = ts(c1,GLOBAL_XOFF) 
                        if c3 > INT10000 
                          c3 /= INT10000              /* index of top of chord 
                          c3 = ts(c3,GLOBAL_XOFF) 
                        end 
                        c15 = c3 - c4   /* relative x offset (to the left) 
                  /* shift offset left 8 and &dAOR&d@ with AX 
                        c15 <<= 8                   /* &dA02/25/97&d@ shift changed from 4 to 8
                        ts(c1,AX) |= c15 
                        ndata(c8,c13) = DUMMY_VALUE    /* accidental set 

QQQ3: 
                      repeat 
                    repeat 
QQQ2: 
                  end 
                end 
              repeat 
            end 
&dA 
&dA &d@   Task (1)         Calculate NODE_SHIFT 
&dA &d@           
            c10 = 0 

            if c17 = 0                       /* set above 

              loop for a3 = 1 to nstaves 
                loop for c11 = 1 to 45 
                  if gl(a3,c11) > pseudo_gl(a3,c11) 
                    gl(a3,c11) = pseudo_gl(a3,c11) 
                  end 
&dA 
&dA &d@              &dA11/19/07&d@ min_space replaces hpar(29) 
&dA 
                  c12 = min_space - gl(a3,c11) - emptyspace(a3,c11) /* should be negative
                  if c12 > c10                                      /* most of the time
                    c10 = c12 
                  end 
                repeat 
              repeat 
              if c5 > 0 and ts(a1,SPACING) = mindist and c10 < hpar(94) 
                c10 = hpar(94) 
              end 

            else 

&dA                          
&dA 
&dA &d@     More code from the &dA04/19/08&d@ cludge 
&dA &d@     This section uses the single-track formula to compute the 
&dA &d@     value of this nodes NODE_SHIFT. 
&dA 
              loop for a3 = 1 to nstaves 
                c7 = 100000 
                loop for c11 = 1 to 45 
                  if emptyspace(a3,c11) < c7 
                    c7 = emptyspace(a3,c11)        /* minimum emptyspace on this staff
                  end 
                repeat 
                c10 = mindist - hpar(82) - c7 
              repeat 
&dA 
&dA                          

            end 
            if c10 > 0 
              ts(a1,NODE_SHIFT) = c10 
            end 
&dA &d@   Task (2) 
            c10 = ts(a1,SPACING) 
            loop for a3 = 1 to nstaves 
              loop for c6 = 1 to 45 
                if pseudo_gr(a3,c6) > gr(a3,c6) 
                  gr(a3,c6) = pseudo_gr(a3,c6) 
                end 
                if gr(a3,c6) = -200 
                  emptyspace(a3,c6) += c10 
                else 
                  emptyspace(a3,c6) = c10 - gr(a3,c6) 
                end 
              repeat 
            repeat 

&dA &d@ &dAÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»&d@ 
&dA &d@ &dAº&d@                                                               &dAº&d@ 
&dA &d@ &dAº&d@   End of where you deal with chords and with multiple passes  &dAº&d@ 
&dA &d@ &dAº&d@                                                               &dAº&d@ 
&dA &d@ &dAÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼&d@ 

          end 
MMMMM: 
&dA 
&dA &d@     We need to check (for now) if the present simultaneity generates 
&dA &d@     a "clash" with the previous simultaneity.  
&dA 
          if olda1 > 0 
            c6 = -1000 
            loop for c3 = 1 to 2 
              loop for c4 = 1 to 45 
                c5 = oldgr(c3,c4) - gl(c3,c4) 
                if c5 > c6 
                  c6 = c5 
                end 
              repeat 
            repeat 
          end 
          loop for c3 = 1 to 2 
            loop for c4 = 1 to 45 
              oldgr(c3,c4) = gr(c3,c4) 
            repeat 
          repeat 
          olda1 = a1 
          a1 = a2  
WWWW: 
        repeat 

&dA 
&dA &d@  &dAÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»&d@ 
&dA &d@  &dAº&d@                                                               &dAº&d@ 
&dA &d@  &dAº&d@   End of calculations on the placement of notes, note-dots,   &dAº&d@ 
&dA &d@  &dAº&d@     and note-accidentals.                                     &dAº&d@ 
&dA &d@  &dAº&d@                                                               &dAº&d@ 
&dA &d@  &dAÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼&d@ 
&dA 

&dA 
&dA &d@  &dAÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»&d@ 
&dA &d@  &dAº &d@                                                                      &dA º&d@ 
&dA &d@  &dAº &d@  At this point, we have a decision to make.  Either we process the   &dA º&d@ 
&dA &d@  &dAº &d@  ts array now (i.e. typeset the music) or we return from this        &dA º&d@ 
&dA &d@  &dAº &d@  procedure and let the ts array continue to grow.  The question that &dA º&d@ 
&dA &d@  &dAº &d@  must be answered is "will all outstanding slurs be processed when   &dA º&d@ 
&dA &d@  &dAº &d@  the ts array is fully processed?"  If "yes", then we can go ahead   &dA º&d@ 
&dA &d@  &dAº &d@  and process the ts array; otherwise, not.                           &dA º&d@ 
&dA &d@  &dAº &d@                                                                      &dA º&d@ 
&dA &d@  &dAº &d@  The information we need is contained in the SLUR_FLAG portion       &dA º&d@ 
&dA &d@  &dAº &d@  of the ts array.  We need to cycle through the array elements we    &dA º&d@ 
&dA &d@  &dAº &d@  have added, taking note of where slurs terminate and where they     &dA º&d@ 
&dA &d@  &dAº &d@  start.  We need a variable to keep track of the state of slur       &dA º&d@ 
&dA &d@  &dAº &d@  completion.  We call this variable bstr "outslurs".  The relevant   &dA º&d@ 
&dA &d@  &dAº &d@  bits will be bits 1 to 8.  When a slur is initiated, the relevant   &dA º&d@ 
&dA &d@  &dAº &d@  bit will be turned on; when a slur is terminated, the relevant      &dA º&d@ 
&dA &d@  &dAº &d@  bit will be turned off.  If at the end of this process,             &dA º&d@ 
&dA &d@  &dAº &d@  outslurs = "00000000", then we can process the array.               &dA º&d@ 
&dA &d@  &dAº &d@                                                                      &dA º&d@ 
&dA &d@  &dAÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼&d@ 
&dA 
        loop for a1 = oldsct+1 to sct 
          nodtype = ts(a1,TYPE)  
          if nodtype <= NOTE_OR_REST
            a2 = ts(a1,SLUR_FLAG) & 0xff 
            a3 = ts(a1,SLUR_FLAG) >> 8 
            a3 &= 0xff00 
            a3 += a2                  /* 16 bits, i.e., stop,start,stop,start etc.
            if a3 > 0 
              a5 = 1 
              loop for a4 = 1 to 8 
                if bit(a5,a3) = 1 
                  if outslurs{a4} = "0"    /* can't stop a non-existant slur 
                    tmess = 28 
                    perform dtalk (tmess) 
                  else 
                    outslurs{a4} = "0" 
                  end 
                end 
                --a5 
                if bit(a5,a3) = 1 
                  if outslurs{a4} = "1"    /* can't start an existing slur 
                    tmess = 29 
                    perform dtalk (tmess) 
                  else 
                    outslurs{a4} = "1" 
                  end 
                end 
                a5 += 3 
              repeat 
            end 
          end 
        repeat 
        if outslurs <> "00000000" 
          goto ACT_RETURN 
        end 
&dA 
&dA &d@   At this point we will be working with the entire ts array.  First 
&dA &d@   thing, we must clear the pseudo tiearr ROWs.  
&dA 
        loop for c7 = 1 to MAX_TIES 
          if tiearr(c7,TIE_SNUM) = INT1000000       /* pseudo super number 
            tiearr(c7,TIE_SNUM) = 0 
          end 
        repeat 
&dA 
&dA &d@    &dASlur Analysis&d@ 
&dA 
&dA &d@    We am now in a position to compile complete information on slurs, 
&dA &d@    so that they can more or less be set properly.  We possess the 
&dA &d@    following information for the notes on which the slur starts and 
&dA &d@    ends: 
&dA &d@                                                                             
&dA &d@      (1) pitch (also whether it is part of a chord, also top or not)        
&dA &d@      (2) stem direction (dist from end of stem, also if beam connects)      
&dA &d@      (3) pass number                                                        
&dA &d@      (4) staff number                                                       
&dA &d@      (5) values of mcat and MULTI                                           
&dA &d@                                                                             
&dA &d@    In addition, we need to compile the following information for each 
&dA &d@    slur: 
&dA &d@                                                                             
&dA &d@      (1) the "high point" and "low point" for all objects on the 
&dA &d@           slur staff between the starting and ending notes.  
&dA &d@                                                                             
&dA &d@    Based on this analysis, it should be possible to state: 
&dA &d@                                                                             
&dA &d@      (1) whether the slur has tips up or down                               
&dA &d@                                                                             
&dA &d@      (2) the x-shift and y-shift for the start of the slur 
&dA &d@                                                                             
&dA &d@      (3) the x-shift and y-shift for the end of the slur 
&dA &d@                                                                             
&dA &d@      (4) any extra curviture that might help the situation                  
&dA &d@                                                                             
&dA &d@    In computing the parameters in (2), (3) and (4), it may be helpful 
&dA &d@    to something about the profile of the desired slur.   For example: 
&dA &d@                                                                             
&dA &d@        *                *               *     * * * * * *     * * * *  
&dA &d@       *    *          *   *         *    *    *         *   *         * 
&dA &d@      *  1.    *    *    2.   *   *    3.  *   *    4.   *   *    5.   * 
&dA &d@      raise start   raise both     raise end    raise both     add to 
&dA &d@                       some                       a lot       curviture 
&dA &d@                                                                             
&dA &d@    &dAStorage of Information&d@ 
&dA &d@                                                                             
&dA &d@    We need to figure out where we are going to store this information.  
&dA &d@    The way this program is constructed, it is possible (in theory at 
&dA &d@    least) for eight slurs to end and for eight slurs to start on the 
&dA &d@    same note.  This could require as many as 32 separate parameters 
&dA &d@    at one ts(.,.) element, to say nothing about the 16 curviture 
&dA &d@    numbers, which must be stored somewhere.  Rather than extend the 
&dA &d@    size of the second dimension of the ts array by this amount, I 
&dA &d@    would rather propose that we add one more element, call it 
&dA &d@    SLUR_X, which would be a pointer to an additional ROW element in the 
&dA &d@    ts array, somewhere below sct (the size of ts, after all, must be 
&dA &d@    much larger than necessary, in order to accommodate 99.99% of all 
&dA &d@    situations).  
&dA 
&dA &d@    While it is possible for eight slurs (four regular and four editorial) 
&dA &d@    to start or end on one chord, I think it is unlikely that more than      
&dA &d@    four would do so.  I would therefore propose that we use a system of 
&dA &d@    flags to define the meaning of a data element within the ROW.  As 
&dA &d@    will be explained below, the first 6 elements of the ROW are reserved 
&dA &d@    for current information about the chord generating the slur, and after 
&dA &d@    this, elements 7 to 32 can be used to hold data on slurs.  We will 
&dA &d@    need to use two elements to contain all of the data.  Let us establish 
&dA &d@    the convention that the first element will contain the key to the 
&dA &d@    meaning of data as well as the type of slur (tips up/down), extra 
&dA &d@    information on curvature, and the x-offset.  Specifically, the key 
&dA &d@    will occupy bits 24-27, with the slur number (1-8) being stored in 
&dA &d@    bits 24-26, and bit 27 being the the start/end flag (0 = start,  
&dA &d@    1 = end).  Bit 16 will be the up/down flag (0 = tips up, 1 = tips 
&dA &d@    down) and bits 17-23 will contain information on extra curvature 
&dA &d@    (this information is necessary only in a slur-end element).  Bits 
&dA &d@    0-15 will contain the x-offset + 1000 (always a positive number).  
&dA &d@    The second element will contain the absolute y-position.  Since 
&dA &d@    there are 26 free elements in the ROW, we can accommodate 13 data 
&dA &d@    groups in this fashion (surely more than necessary).  
&dA 
&dA &d@    Several points to note: 
&dA 
&dA &d@    (1) for purposes of these calculations, and temporary data stroage, 
&dA &d@        it will be simplest to record all y values as absolute y positions 
&dA &d@        (relative to the staff lines).  x values can be stored as offsets.  
&dA 
&dA &d@    (2) In cases where more than one slur starts on a note head, or more 
&dA &d@        than one slur ends on a note head, care must be taken to insure 
&dA &d@        that the "longer" slur stays "on top" (assuming they have tips 
&dA &d@        going in the same direction).  Let's take the situation pictured 
&dA &d@        below: 
&dA 
&dA &d@                    * * * * * * * * slur 1 * * * * * * * * 
&dA &d@                *                                           *          slur 1a
&dA &d@             *                          * * * * slur 2 * * *  *      * 
&dA &d@           *  * slur 4 *             * * slur 3 *             * *  * 
&dA &d@          **             *         **             *             *** 
&dA &d@        note 1         note 2    note 3        note 4          note 5 
&dA &d@                                               
&dA &d@        Slur 1 would be encountered first as we proceeded through the ts 
&dA &d@        array.  If we were to try to process this slur when we first             
&dA &d@        encountered it, we would discover that another slur (slur 2) 
&dA &d@        ended on the same note as slur 1.  Since slur 2 is shorter than   
&dA &d@        slur 1, (and therefore should lie "under" it), we cannot fully    
&dA &d@        process slur 1 until we have processed slur 2.  But in looking back 
&dA &d@        to the beginning of slur 2, we see that another slur (slur 3) also  
&dA &d@        starts on the same note, and that slur 3 (which also we have not     
&dA &d@        seen before) must be processed before we can process slur 2.  
&dA &d@        Clearly we cannot simply follow the rule of "process a slur when 
&dA &d@        you first come to it".  A similar argument can be used to show 
&dA &d@        that you cannot simply work your way through the ts array from 
&dA &d@        end to the start.  
&dA &d@      
&dA &d@        Here is how the process must be conducted:  You proceed forward 
&dA &d@        though the ts array, but do nothing until you encounter the end 
&dA &d@        of a slur (or more than one end, as in the case of note 5 above).  
&dA &d@        If there is more than one slur ending on this note (chord), you can 
&dA &d@        determine which one is shorter by looking backward in the array.  
&dA &d@        The shorter one should be processed first.  In this way, you can 
&dA &d@        always be sure that shorter slurs will be processed before longer 
&dA &d@        ones.  
&dA 
&dA &d@        This method will require extra work in keeping track of what has 
&dA &d@        already been done.  This is the purpose of the first 6 elements of 
&dA &d@        the extra ts ROW element.  In our example above, slur 4 will be the 
&dA &d@        first to be processed.  Since it is the first slur for both note 1 
&dA &d@        and note 2, SLUR_X records must be generated for both of these 
&dA &d@        notes.  In the case of note 2, this is the only slur, but for note 1 
&dA &d@        we will be processing another slur (slur 1) much later.  We need 
&dA &d@        to keep track of what has already transpired as a result of slur 4.  
&dA &d@        The first 6 elements of the SLUR_X ROW element will contain the 
&dA &d@        information listed below: 
&dA &d@        
&dA &d@          (1) current y-position above object for incoming slurs.  
&dA &d@          (2)              "     below   "     "     "       "  .  
&dA &d@          (3)              "     above   "     "  outgoing   "  .  
&dA &d@          (4)              "     below   "     "     "       "  .  
&dA &d@          (5) y-position for staccato, legato, etc.  
&dA &d@          (6) 2 = marks above chord; 1 = marks below chord; 0 = don't use 
&dA 
&dA &d@        Clearly, the information about what has happened at note 1 will 
&dA &d@        be available when it comes time to set slur 1.  
&dA 
&dA &d@        One more thing: in handling this problem, we must deal with a chord 
&dA &d@        as one object.  A chord may be made up of several elements (notes), 
&dA &d@        and slurs coming to or leaving this chord may be coded on separate 
&dA &d@        elements.  Nevertheless, the processing of information requires 
&dA &d@        that all data related to slurs be stored in one place.  Therefore, 
&dA &d@        when a slur ROW element is allocated, the pointer to the element 
&dA &d@        must be put in SLUR_X for &dGall notes in the chord&d@.  
&dA &d@        
&dA &d@    (3) It should be noted that the smallest meaningful resolution of a 
&dA &d@        y-position as far as slurs are concerned is vpar(1), since the 
&dA &d@        printing program treats these shifts as adjusted note positions.  
&dA &d@                       
&dA &d@    (4) The curvature parameter should be a number from 0 to 9 (9 being 
&dA &d@        the most curved).  The printing program actually uses a look-up 
&dA &d@        method to determine which slur to put in a particular position.  
&dA &d@        One of the characterizations of such a slur is its curvature 
&dA &d@        (this is part of the slur number).  It only makes sense to change 
&dA &d@        this number if the new curvature is more than the "look up" 
&dA &d@        value.  Since increasing the curvature will put the "cross part" 
&dA &d@        of the slur at a different height, a new curvature should only 
&dA &d@        be suggested in those cases where it is thought that the slur 
&dA &d@        will not be interfering with staff lines.  One other thing: 
&dA &d@        we do not know the final length of the slur until print time.  
&dA &d@        It turns out that for slurs longer than a certain length 
&dA &d@        (I think about .6 inches) there are varients available which 
&dA &d@        are asymmetric (where the relative high point comes either 
&dA &d@        earlier or later in the slur).  It is possible to "make a 
&dA &d@        suggestion" to the print program that an asymmetric slur 
&dA &d@        be used, if one is available.  Adding 10 to the curvature 
&dA &d@        will suggest that the high point be delayed; and adding 20 
&dA &d@        to the curvature will suggest that the high point come  
&dA &d@        earlier.  Actually, as I remember it, slurs longer about 1.3 
&dA &d@        inches only come in asymmetric versions, so for slurs that 
&dA &d@        appear to be really long (either many notes, or multiple 
&dA &d@        measures), it might actually be helpful to make a recommendation.  
&dA &d@                       
&dA &d@                 S U M M A R Y   O F   I N F O R M A T I O N   (TS32) 
&dA &d@                 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@                       
&dA &d@    1. A slur is processed when its &dGend&d@ is encountered.  If there is more 
&dA &d@       than one slur on a &dGchord&d@, the shortest one is processed first.  If 
&dA &d@       more than one of the same length is encountered, the one on the 
&dA &d@       lowest note is processed first.  
&dA &d@        
&dA &d@    2. The first time a slur is encountered on a chord, a new ts ROW 
&dA &d@       element is allocated and a pointer to it is placed in the SLUR_X 
&dA &d@       element for all notes in the chord.  
&dA &d@                       
&dA &d@    3. The first six elements of a slur ROW element are reserved for the 
&dA &d@       following information: 
&dA &d@                       
&dA &d@          (1) current y-position above object for incoming slurs.  
&dA &d@          (2)              "     below   "     "     "       "  .  
&dA &d@          (3)              "     above   "     "  outgoing   "  .  
&dA &d@          (4)              "     below   "     "     "       "  .  
&dA &d@          (5) y-position for staccato, legato, etc.  
&dA &d@          (6) 2 = marks above chord; 1 = marks below chord; 0 = don't use 
&dA &d@                       
&dA &d@    4. Specific information about slurs coming to or leaving a chord is 
&dA &d@       stored in groups of three (up from two &dA05/06/03&d@) elements, starting 
&dA &d@       with element 7.  The format is as follows: 
&dA &d@                       
&dA &d@       first element 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@          bit 27:     start/end flag (0 = start, 1 = end) 
&dA &d@          bits 24-26: slur number - 1 (0 to 7) 
&dA &d@          bits 17-23: curvature information (end only) 
&dA &d@          bit 16:     up/down flag (0 = tips up, 1 = tips down) (end only) 
&dA &d@          bits 0-15:  x-offset + 1000 (always a positive number) 
&dA &d@       second element 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@          y position relative to the staff 
&dA &d@       third element (added &dA05/06/03&d@) 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@          integer equivalent of 4-byte print suggestion for slur 
&dA &d@                       

&dA 
&dA &d@          &dA  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  
&dA &d@          &dA  ³ &d@                                       &dA ³  
&dA &d@          &dA  ³ &d@   P R O C E S S I N G    S L U R S    &dA ³  
&dA &d@          &dA  ³ &d@                                       &dA ³  
&dA &d@          &dA  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
&dA 

        a14 = sct + 2                   /* SLUR_X pointer 

        loop for a1 = 1 to sct 
          nodtype = ts(a1,TYPE) 
          if nodtype > NOTE_OR_REST 
            goto YYYY 
          end 
          a4 = ts(a1,SLUR_FLAG) & 0x00aa00aa 
          if a4 > 0                     /* a slur ends here 
&dA 
&dA &d@     Compile a list of all slurs that end on this note and on any  
&dA &d@       other (lower) notes in this chord.  
&dA 
            a5 = a4 >> 1 
            a5 &= 0x00ff00ff            /* a list of starts to look for 
            ndata(1,1) = a5 
            ndata(1,2) = a1 
            pcnt = 1 
            perform get_topbottom (a1,c1,c2) 
            loop for a2 = a1+1 to c2 
              a4 = ts(a2,SLUR_FLAG) & 0x00aa00aa 
              if a4 > 0                 /* a slur ends here 
                a5 = a4 >> 1 
                a5 &= 0x00ff00ff        /* a list of starts to look for 
                ++pcnt 
                ndata(pcnt,1) = a5 
                ndata(pcnt,2) = a2 
              end 
            repeat 
            a1 = c2       /* so that we don't look at these notes again 
            nsgroups = 0 
            c9 = pcnt                            /* moved here from +3 lines &dA09/28/93
            loop for c7 = c1-1 to 1 step -1 
              if ts(c7,TYPE) <= NOTE_OR_REST 
                a6 = ts(c7,SLUR_FLAG) & 0x00550055   /* starts on this note 
                loop for c8 = 1 to pcnt 
                  a5 = ndata(c8,1)            /* list of starts for this note of chord
                  a2 = ndata(c8,2)            /* index to this note of chord 
                  a7 = a6 & a5                /* a7 = matches 
                  if a7 > 0 
                    c11 = a7 >> 8 
                    c11 &= 0xff00 
                    c11 += a7 & 0xff                 /* compact a7 into 16 bits

                    a7 = not(a7) 
                    a5 &= a7                         /* remove this slur from a5
                    ndata(c8,1) = a5 

                    c10 = 0                   /* slur number - 1 
                    c6 = a2 
                    loop while c11 > 0 
                      if bit(0,c11) = 1  
                        c4 = c10 & 0x03              /* slur number mod(4)        
                        c5 = 1 << (c4 * 2) 
                        c5 <<= 8 
                        if c5 & ts(c7,SLUR_FLAG) > 0   /* this slur is forced 
                          c5 <<= 1 
                          if c5 & ts(c7,SLUR_FLAG) = 0 
                            c6 |= 0x00010000      /* this is a "force over" slur
                          else 
                            c6 |= 0x00020000      /* this is a "force under" slur
                          end 
                        end 
                        ++nsgroups 
                        sgroup(nsgroups,1) = c7   /* record index starting note
                        sgroup(nsgroups,2) = c6   /* record index ending note (+ flags)
                        sgroup(nsgroups,3) = c10  /* slur number - 1 
                      end 
                      c11 >>= 2 
                      ++c10 
                    repeat 

                    if a5 = 0 
                      --c9 
                      if c9 = 0         /* no more slurs to look for 
                        c7 = 0 
                      end 
                    end 
                  end 
                repeat 
              end 
            repeat 
            if nsgroups = 0 or c9 > 0 
              tmess = 30 
              perform dtalk (tmess) 
            end 
&dA &d@             
&dA &d@     At this point, we have a list of slurs which end on this chord.  
&dA &d@     We need to decide what to do with them.  We certainly can proceed 
&dA &d@     by looping though the group, but we should probably first learn 
&dA &d@     something about the chords we are dealing with.  For example, 
&dA &d@     is the stem up or down?  Where on the chords do the slurs attach?  
&dA &d@     Do the note heads (or chords) have staccato, legato or spiccato 
&dA &d@     marks on them?  (Remember that the notes of a chord have been 
&dA &d@     re-ordered so that the top note comes first; i.e., the top note 
&dA &d@     head may not be at the note end of the stem.)   The purpose of 
&dA &d@     all of this "research" is basically to answer the following 
&dA &d@     two questions: 
&dA 
&dA &d@        (1) should the slur be oriented with tips up or tips down, and 
&dA 
&dA &d@        (2) should the slur take its position from the note head or 
&dA &d@              from the end of the stem?  
&dA 
&dA &d@     I think I have found a system which will at least (1) give an answer         
&dA &d@     to every possible situation, and (2) give "right" answers for most 
&dA &d@     situations.  Essentially, what I will use is "situation based" 
&dA &d@     programming, rather than "rule based" programming.  I have described 
&dA &d@     all possible situations under two conditions: (1) the final note 
&dA &d@     has the multi-track flag = 0, and (2) the final note has the multi-track 
&dA &d@     flag > 0.  These templates are laid out below 
&dA 
&dA &d@ I. Final note multi-track flag = 0 
&dA 
&dA &d@  starting note            ending note        x-shift stem option           overrides
&dA &d@ stem  position         stem   position  tips 1st 2nd 1st 2nd          code over under
&dA &d@ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ         ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂ
&dA &d@ up    single        up     single      ³ up ³H    H ³  no            ³  F ³  l ³  F ³
&dA &d@ (multi-track = 0)   up    top of many  ³down³  no   ³s    s          ³  p ³  p ³  G ³
&dA &d@                     up  middle of many ³down³nr   Y ³  no            ³  m ³  p ³  H ³
&dA &d@                     up  bottom of many ³ up ³H    H ³  no            ³  F ³  p ³  F ³
&dA &d@                    down    single      ³down³nr   H ³s    H (if flag)³  j ³  j ³  I ³
&dA &d@                    down   top of many  ³down³  no   ³s    H          ³  o ³  o ³  G ³
&dA &d@                    down middle of many ³down³nr   H ³                ³  i ³  i ³  O ³
&dA &d@                    down bottom of many ³ up ³  no   ³H    s          ³  O ³  o ³  O ³
&dA &d@                                        ³    ³       ³                ³    ³    ³    ³
&dA &d@ up    single        up     single      ³down³nr   H ³s    s (mid stf)³  l ³  l ³  F ³
&dA &d@ (multi-track > 0)   up    top of many  ³down³  no   ³s    s          ³  p ³  p ³  G ³
&dA &d@                     up  middle of many ³down³nr   Y ³  no            ³  m ³  p ³  H ³
&dA &d@                     up  bottom of many ³ up ³H    H ³  no            ³  F ³  p ³  F ³
&dA &d@                    down    single      ³down³  no   ³s    H          ³  o ³  j ³  I ³
&dA &d@                    down   top of many  ³down³  no   ³s    H          ³  o ³  o ³  G ³
&dA &d@                    down middle of many ³down³nr   H ³                ³  i ³  i ³  O ³
&dA &d@                    down bottom of many ³ up ³  no   ³H    s          ³  O ³  o ³  O ³
&dA &d@                                        ³    ³       ³                ³    ³    ³    ³
&dA &d@ up   top of many    up     single      ³down³  no   ³s    s          ³  p ³  p ³  F ³
&dA &d@ (multi-track = 0)   up    top of many  ³down³nr   n ³s    s (no oths)³  h ³  h ³  N ³
&dA &d@ (multi-track > 0)   up  middle of many ³down³  no   ³s    s          ³  p ³  p ³  F ³
&dA &d@                     up  bottom of many ³ up ³H    H ³  no            ³  F ³  p ³  F ³
&dA &d@                    down    single      ³down³  no   ³s    H          ³  o ³  o ³  I ³
&dA &d@                    down   top of many  ³down³nr   H ³s    H (no oths)³  k ³  k ³  N ³
&dA &d@                    down middle of many ³down³  no   ³s    H          ³  o ³  o ³  G ³
&dA &d@                    down bottom of many ³down³nr   H ³  no            ³  i ³  i ³  G ³
&dA &d@                                        ³    ³       ³                ³    ³    ³    ³
&dA &d@ up middle of many   up     single      ³down³Yr   n ³  no            ³  f ³  f ³  F ³
&dA &d@ (multi-track = 0)   up    top of many  ³down³Yr   n ³  no            ³  f ³  f ³  F ³
&dA &d@ (multi-track > 0)   up  middle of many ³down³nr   nl³  no            ³  n ³  n ³  N ³
&dA &d@                     up  bottom of many ³ up ³H    H ³  no            ³  F ³  r ³  F ³
&dA &d@                    down    single      ³down³Yr   H ³  no            ³  g ³  g ³  I ³
&dA &d@                    down   top of many  ³down³Yr   H ³  no            ³  g ³  g ³  G ³
&dA &d@                    down middle of many ³down³nr   nl³  no            ³  n ³  n ³  N ³
&dA &d@                    down bottom of many ³ up ³H    nl³  no            ³  H ³  g ³  H ³
&dA &d@                                        ³    ³       ³                ³    ³    ³    ³
&dA &d@ up botton of many   up     single      ³ up ³H    H ³  no            ³  F ³  f ³  F ³
&dA &d@ (multi-track = 0)   up    top of many  ³down³Yr   n ³  no            ³  f ³  f ³  F ³
&dA &d@ (multi-track > 0)   up  middle of many ³ up ³H    H ³  no            ³  F ³  s ³  F ³
&dA &d@                     up  bottom of many ³ up ³H    H ³  no            ³  F ³  n ³  F ³
&dA &d@                    down    single      ³ up ³H    nl³H    s (positio)³  I ³  g ³  I ³
&dA &d@                    down   top of many  ³down³Yr   H ³  no            ³  g ³  g ³  G ³
&dA &d@                    down middle of many ³ up ³H    Yl³                ³  G ³  g ³  G ³
&dA &d@                    down bottom of many ³ up ³H    nl³H    s (p n oth)³  J ³  n ³  J ³
&dA &d@                                        ³    ³       ³                ³    ³    ³    ³
&dA &d@ down  single        up     single      ³down³H    n ³H    s (positio)³  c ³  c ³  B ³
&dA &d@ (multi-track = 0)   up    top of many  ³down³H    n ³H    s (positio)³  c ³  c ³  B ³
&dA &d@                     up  middle of many ³down³H    Y ³  no            ³  e ³  e ³  B ³
&dA &d@                     up  bottom of many ³ up ³n    H ³s    H (positio)³  B ³  e ³  B ³
&dA &d@                    down    single      ³down³H    H ³  no            ³  d ³  d ³  E ³
&dA &d@                    down   top of many  ³down³H    H ³  no            ³  d ³  d ³  C ³
&dA &d@                    down middle of many ³down³H    H ³  no            ³  d ³  d ³  C ³
&dA &d@                    down bottom of many ³ up ³  no   ³s    s          ³  Q ³  d ³  Q ³
&dA &d@                                        ³    ³       ³                ³    ³    ³    ³
&dA &d@ down  single        up     single      ³ up ³n    H ³s    H (positio)³  B ³  c ³  B ³
&dA &d@ (multi-track > 0)   up    top of many  ³down³H    n ³  no            ³  a ³  c ³  B ³
&dA &d@                     up  middle of many ³ up ³n    H ³  no            ³  A ³  e ³  B ³
&dA &d@                     up  bottom of many ³ up ³  no   ³s    H          ³  P ³  e ³  B ³
&dA &d@                    down    single      ³ up ³n    nl³s    s (mid stf)³  E ³  d ³  E ³
&dA &d@                    down   top of many  ³down³H    H ³  no            ³  d ³  d ³  C ³
&dA &d@                    down middle of many ³ up ³  no   ³s    s          ³  Q ³  d ³  C ³
&dA &d@                    down bottom of many ³ up ³  no   ³s    s          ³  Q ³  d ³  Q ³
&dA &d@                                        ³    ³       ³                ³    ³    ³    ³
&dA &d@ down  top of many   up     single      ³down³H    n ³H    s (positio)³  c ³  c ³  K ³
&dA &d@ (multi-track = 0)   up    top of many  ³down³H    n ³H    s (p n oth)³  b ³  b ³  C ³
&dA &d@ (multi-track > 0)   up  middle of many ³down³H    Y ³  no            ³  e ³  e ³  K ³
&dA &d@                     up  bottom of many ³down³H    Y ³  no            ³  e ³  e ³  K ³
&dA &d@                    down    single      ³down³H    H ³  no            ³  d ³  d ³  Q ³
&dA &d@                    down   top of many  ³down³H    H ³  no            ³  d ³  d ³  N ³
&dA &d@                    down middle of many ³down³H    H ³  no            ³  d ³  d ³  L ³
&dA &d@                    down bottom of many ³ up ³Y    nl³  no            ³  M ³  d ³  M ³
&dA &d@                                        ³    ³       ³                ³    ³    ³    ³
&dA &d@ down middle of many up     single      ³ up ³Y    H ³  no            ³  K ³  c ³  K ³
&dA &d@ (multi-track = 0)   up    top of many  ³down³H    n ³  no            ³  a ³  a ³  K ³
&dA &d@ (multi-track > 0)   up  middle of many ³ up ³nr   nl³  no            ³  N ³  n ³  N ³
&dA &d@                     up  bottom of many ³ up ³Y    H ³  no            ³  K ³  a ³  K ³
&dA &d@                    down    single      ³down³H    H ³  no            ³  d ³  d ³  M ³
&dA &d@                    down   top of many  ³down³H    H ³  no            ³  d ³  d ³  L ³
&dA &d@                    down middle of many ³ up ³nr   nl³  no            ³  N ³  n ³  N ³
&dA &d@                    down bottom of many ³ up ³Y    nl³  no            ³  M ³  d ³  M ³
&dA &d@                                        ³    ³       ³                ³    ³    ³    ³
&dA &d@ down bottom of many up     single      ³ up ³n    H ³s    H (positio)³  B ³  c ³  B ³
&dA &d@ (multi-track = 0)   up    top of many  ³down³H    n ³  no            ³  a ³  a ³  K ³
&dA &d@ (multi-track > 0)   up  middle of many ³ up ³n    H ³  no            ³  A ³  e ³  A ³
&dA &d@                     up  bottom of many ³ up ³n    H ³  no            ³  A ³  n ³  A ³
&dA &d@                    down    single      ³ up ³n    nl³s    s (mid stf)³  E ³  d ³  E ³
&dA &d@                    down   top of many  ³ up ³n    Yl³  no            ³  C ³  d ³  C ³
&dA &d@                    down middle of many ³ up ³n    Yl³  no            ³  C ³  d ³  C ³
&dA &d@                    down bottom of many ³ up ³n    nl³s    s (no oths)³  D ³  n ³  D ³
&dA 
&dA 
&dA &d@ II. Final note multi-track flag > 0 
&dA 
&dA &d@  starting note            ending note        x-shift stem option              (same)
&dA &d@ stem  position         stem   position  tips 1st 2nd 1st 2nd          code  (overrides)
&dA &d@ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ         ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂ
&dA &d@ up    single        up     single      ³down³nr   H ³s    s (mid stf)³  l ³ 
&dA &d@ (multi-track = 0)   up    top of many  ³down³  no   ³s    s          ³  p ³ 
&dA &d@                     up  middle of many ³down³nr   Y ³  no            ³  m ³ 
&dA &d@                     up  bottom of many ³ up ³H    H ³  no            ³  F ³ 
&dA &d@                    down    single      ³ up ³H    nl³H    s (positio)³  I ³ 
&dA &d@                    down   top of many  ³ up ³H    Yl³  no            ³  G ³ 
&dA &d@                    down middle of many ³ up ³H    Yl³  no            ³  G ³ 
&dA &d@                    down bottom of many ³ up ³  no   ³H    s          ³  O ³ 
&dA &d@                                        ³    ³       ³                ³    ³ 
&dA &d@ up    single        up     single      ³down³nr   H ³s    s (mid stf)³  l ³ 
&dA &d@ (multi-track > 0)   up    top of many  ³down³  no   ³s    s          ³  p ³ 
&dA &d@                     up  middle of many ³down³nr   Y ³  no            ³  m ³ 
&dA &d@                     up  bottom of many ³ up ³H    H ³  no            ³  F ³ 
&dA &d@                    down    single      ³ up ³  no   ³H    s          ³  O ³ 
&dA &d@                    down   top of many  ³ up ³H    Yl³  no            ³  G ³ 
&dA &d@                    down middle of many ³ up ³  no   ³H    s          ³  O ³ 
&dA &d@                    down bottom of many ³ up ³  no   ³H    s          ³  O ³ 
&dA &d@                                        ³    ³       ³                ³    ³ 
&dA &d@ up   top of many    up     single      ³down³  no   ³s    s          ³  p ³ 
&dA &d@ (multi-track = 0)   up    top of many  ³down³nr   n ³s    s (no oths)³  h ³ 
&dA &d@ (multi-track > 0)   up  middle of many ³down³  no   ³s    s          ³  p ³ 
&dA &d@                     up  bottom of many ³ up ³H    H ³  no            ³  F ³ 
&dA &d@                    down    single      ³down³  no   ³s    H          ³  o ³ 
&dA &d@                    down   top of many  ³down³nr   H ³  no            ³  i ³ 
&dA &d@                    down middle of many ³ up ³H    Yl³  no            ³  G ³ 
&dA &d@                    down bottom of many ³ up ³H    nl³  no            ³  H ³ 
&dA &d@                                        ³    ³       ³                ³    ³ 
&dA &d@ up middle of many   up     single      ³down³Yr   n ³  no            ³  f ³ 
&dA &d@ (multi-track = 0)   up    top of many  ³down³Yr   n ³  no            ³  f ³ 
&dA &d@ (multi-track > 0)   up  middle of many ³down³nr   nl³  no            ³  n ³ 
&dA &d@                     up  bottom of many ³ up ³H    H ³  no            ³  F ³ 
&dA &d@                    down    single      ³down³Yr   H ³  no            ³  g ³ 
&dA &d@                    down   top of many  ³down³Yr   H ³  no            ³  g ³ 
&dA &d@                    down middle of many ³ up ³nr   nl³  no            ³  N ³ 
&dA &d@                    down bottom of many ³ up ³H    nl³  no            ³  H ³ 
&dA &d@                                        ³    ³       ³                ³    ³ 
&dA &d@ up botton of many   up     single      ³ up ³H    H ³  no            ³  F ³ 
&dA &d@ (multi-track = 0)   up    top of many  ³down³Yr   n ³  no            ³  f ³ 
&dA &d@ (multi-track > 0)   up  middle of many ³ up ³H    H ³  no            ³  F ³ 
&dA &d@                     up  bottom of many ³ up ³H    H ³  no            ³  F ³ 
&dA &d@                    down    single      ³ up ³H    nl³H    s (positio)³  I ³ 
&dA &d@                    down   top of many  ³down³Yr   H ³  no            ³  g ³ 
&dA &d@                    down middle of many ³ up ³H    Yl³  no            ³  G ³ 
&dA &d@                    down bottom of many ³ up ³H    nl³H    s (p n oth)³  J ³ 
&dA &d@                                        ³    ³       ³                ³    ³ 
&dA &d@ down   single       up     single      ³down³H    n ³H    s (positio)³  c ³ 
&dA &d@ (multi-track = 0)   up    top of many  ³down³H    n ³H    s (positio)³  c ³ 
&dA &d@                     up  middle of many ³down³H    Y ³  no            ³  e ³ 
&dA &d@                     up  bottom of many ³ up ³n    H ³s    H (positio)³  B ³ 
&dA &d@                    down    single      ³ up ³n    nl³s    s (mid stf)³  E ³ 
&dA &d@                    down   top of many  ³ up ³n    Yl³  no            ³  C ³ 
&dA &d@                    down middle of many ³ up ³  no   ³s    s          ³  Q ³ 
&dA &d@                    down bottom of many ³ up ³  no   ³s    s          ³  Q ³ 
&dA &d@                                        ³    ³       ³                ³    ³ 
&dA &d@ down   single       up     single      ³down³H    n ³H    s (positin)³  c ³ 
&dA &d@ (multi-track > 0)   up    top of many  ³down³H    H ³  no            ³  d ³ 
&dA &d@                     up  middle of many ³down³H    Y ³  no            ³  e ³ 
&dA &d@                     up  bottom of many ³ up ³n    H ³  no            ³  A ³ 
&dA &d@                    down    single      ³ up ³n    nl³s    s (mid stf)³  E ³ 
&dA &d@                    down   top of many  ³ up ³n    Yl³  no            ³  C ³ 
&dA &d@                    down middle of many ³ up ³  no   ³s    s          ³  Q ³ 
&dA &d@                    down bottom of many ³ up ³  no   ³s    s          ³  Q ³ 
&dA &d@                                        ³    ³       ³                ³    ³ 
&dA &d@ down  top of many   up     single      ³down³H    n ³H    s (positio)³  c ³ 
&dA &d@ (multi-track = 0)   up    top of many  ³down³H    n ³H    s (p n oth)³  b ³ 
&dA &d@ (multi-track > 0)   up  middle of many ³down³H    Y ³  no            ³  e ³ 
&dA &d@                     up  bottom of many ³down³H    Y ³  no            ³  e ³ 
&dA &d@                    down    single      ³down³H    H ³  no            ³  d ³ 
&dA &d@                    down   top of many  ³down³H    H ³  no            ³  d ³ 
&dA &d@                    down middle of many ³ up ³Y    Yl³  no            ³  L ³ 
&dA &d@                    down bottom of many ³ up ³Y    nl³  no            ³  M ³ 
&dA &d@                                        ³    ³       ³                ³    ³ 
&dA &d@ down middle of many up     single      ³ up ³Y    H ³  no            ³  K ³ 
&dA &d@ (multi-track = 0)   up    top of many  ³down³H    n ³  no            ³  a ³ 
&dA &d@ (multi-track > 0)   up  middle of many ³ up ³nr   nl³  no            ³  N ³ 
&dA &d@                     up  bottom of many ³ up ³Y    H ³  no            ³  K ³ 
&dA &d@                    down    single      ³ up ³Y    nl³  no            ³  M ³ 
&dA &d@                    down   top of many  ³down³H    H ³  no            ³  d ³ 
&dA &d@                    down middle of many ³ up ³nr   nl³  no            ³  N ³ 
&dA &d@                    down bottom of many ³ up ³Y    nl³  no            ³  M ³ 
&dA &d@                                        ³    ³       ³                ³    ³ 
&dA &d@ down bottom of many up     single      ³ up ³n    H ³  no            ³  A ³ 
&dA &d@ (multi-track = 0)   up    top of many  ³down³H    n ³  no            ³  a ³ 
&dA &d@ (multi-track > 0)   up  middle of many ³ up ³n    H ³  no            ³  A ³ 
&dA &d@                     up  bottom of many ³ up ³n    H ³  no            ³  A ³ 
&dA &d@                    down    single      ³ up ³n    nl³s    s (mid stf)³  E ³ 
&dA &d@                    down   top of many  ³ up ³n    Yl³  no            ³  C ³ 
&dA &d@                    down middle of many ³ up ³n    Yl³  no            ³  C ³ 
&dA &d@                    down bottom of many ³ up ³n    nl³s    s (p n oth)³  D ³ 
&dA 
&dA 
&dA &d@                            Meaning of codes 
&dA &d@                ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
&dA &d@                           x-shift    stem option 
&dA &d@            code   tips    1st  2nd    1st  2nd 
&dA &d@            ÄÄÄÄÄ ÄÄÄÄÄÄ  ÄÄÄÄÄÄÄÄÄÄ  ÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@              A     up      n    H        no 
&dA &d@              B     up      n    H      s    H (position) 
&dA &d@              C     up      n    Yl       no 
&dA &d@              D     up      n    nl     s    s (no others) 
&dA &d@              E     up      n    nl     s    s (mid stuff) 
&dA &d@              F     up      H    H        no 
&dA &d@              G     up      H    Yl       no 
&dA &d@              H     up      H    nl       no 
&dA &d@              I     up      H    nl     H    s (position) 
&dA &d@              J     up      H    nl     H    s (pos no oth) 
&dA &d@              K     up      Y    H        no 
&dA &d@              L     up      Y    Yl       no 
&dA &d@              M     up      Y    nl       no 
&dA &d@              N     up      nr   nl       no 
&dA &d@              O     up        no        H    s 
&dA &d@              P     up        no        s    H 
&dA &d@              Q     up        no        s    s 
&dA 
&dA &d@              a    down     H    n        no 
&dA &d@              b    down     H    n      H    s (pos no oth) 
&dA &d@              c    down     H    n      H    s (position) 
&dA &d@              d    down     H    H        no 
&dA &d@              e    down     H    Y        no 
&dA &d@              f    down     Yr   n        no 
&dA &d@              g    down     Yr   H        no 
&dA &d@              h    down     nr   n      s    s (no oths) 
&dA &d@              i    down     nr   H        no 
&dA &d@              j    down     nr   H      s    H (if flag) 
&dA &d@              k    down     nr   H      s    H (no oths) 
&dA &d@              l    down     nr   H      s    s (mid stuff) 
&dA &d@              m    down     nr   Y        no 
&dA &d@              n    down     nr   nl       no 
&dA &d@              o    down       no        s    H 
&dA &d@              p    down       no        s    s 
&dA 
&dA 
&dA &d@                              Extra codes 
&dA &d@                            Meaning of codes 
&dA &d@                ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
&dA &d@                           x-shift     2nd option 
&dA &d@            code   tips    1st  2nd    1st  2nd 
&dA &d@            ÄÄÄÄÄ ÄÄÄÄÄÄ  ÄÄÄÄÄÄÄÄÄÄ  ÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@              R     up      n    nl       no 
&dA 
&dA 
&dA &d@              q    down     nr   n        no 
&dA &d@              r    down     Yr   Yl       no 
&dA &d@              s    down     Yr   Y        no 
&dA &d@              t    down       no        H    s 
&dA 
&dA &d@     This information is combined into a 160 byte string.  By correctly 
&dA &d@     diagnosing the situation, we can therefore determine what actions 
&dA &d@     should be taken.  For both and starting note and the ending note 
&dA &d@     we need to determine:  
&dA 
&dA &d@        (1) multi-track flag? (zero or non-zero) 
&dA &d@        (2) stem direction?   (up or down)   
&dA &d@        (3) note catagory?    (single, top of many, 
&dA &d@                               middle of many, bottom of many) 
&dA &d@          

&dA &d@        &dA  ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»   
&dA &d@        &dA  º   This is the loop which processes slurs   º   
&dA &d@        &dA  ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼   

            loop for a4 = 1 to nsgroups   /* loop through all slurs ending on this chord
              a6 = sgroup(a4,1) 
              a7 = sgroup(a4,2) 
              c7 = a7 >> 16                   /* get forced slur flag 
              a7 &= 0xffff                    /* clean up index 
&dA 
&dA &d@        1a. Get information on starting note 
&dA 
&dA &d@             c1 = multi-track flag for this note 
&dA &d@             c2 = stem direction for this note 
&dA &d@             c3 = note catagory for this note:  0 = single 
&dA &d@                                                1 = top of many 
&dA &d@                                                2 = middle of many 
&dA &d@                                                3 = bottom of many 
&dA &d@             c7 = forced slur flag 
&dA 
              c1 = ts(a6,MULTI_TRACK) >> 2 
              c2 = bit(1,ts(a6,STEM_FLAGS)) 
              c3 = bit(2,ts(a6,STEM_FLAGS)) 
              if c3 = 1 and bit(3,ts(a6,STEM_FLAGS)) = 1 
                ++c3 
                if ts(a6+1,TYPE) <> ts(a6,TYPE) 
                  ++c3 
                end 
              end 
&dA 
&dA &d@        1b. Get information on ending note 
&dA 
&dA &d@             c4 = multi-track flag for this note 
&dA &d@             c5 = stem direction for this note 
&dA &d@             c6 = note catagory for this note:  0 = single 
&dA &d@                                                1 = top of many 
&dA &d@                                                2 = middle of many 
&dA &d@                                                3 = bottom of many 
&dA 
              c4 = ts(a7,MULTI_TRACK) >> 2 
              c5 = bit(1,ts(a7,STEM_FLAGS)) 
              c6 = bit(2,ts(a7,STEM_FLAGS)) 
              if c6 = 1 and bit(3,ts(a7,STEM_FLAGS)) = 1 
                ++c6 
                if ts(a7+1,TYPE) <> ts(a7,TYPE) 
                  ++c6 
                end 
              end 
&dA 
&dA &d@        1c. Modify multi-track flags under certain conditions 
&dA 
              if c1 > 0 and c4 > 0     /* &dACHANGED&d@ from = 3  on 9-10-93 
                if ts(a6,PASSNUM) = ts(a7,PASSNUM) and c2 = c5 
                  if ts(a6,PASSNUM) = 1 and c2 = DOWN 
                    c1 = 0 
                    c4 = 0 
                  end 
                  if ts(a6,PASSNUM) = 2 and c2 = UP  
                    c1 = 0 
                    c4 = 0 
                  end 
                end 
              end 
&dA 
&dA &d@     2. Derive "situation" letter from c1 - c7.  
&dA &d@                 
              c8 = c3 
              if c8 <> 0 or c1 <> 0 
                ++c8 
              end 
              if c2 = DOWN 
                c8 += 5 
              end 
              if c4 > 0 and c7 = 0 
                c8 += 10 
              end 
              c8 *= 8                /* c8 ranges by 8's from 0 to 19*8 
              c8 += c6 
              if c5 = DOWN 
                c8 += 4 
              end 
              ++c8                   /* c8 ranges from 1 to 160 (1 to 80 for forced slurs)
              if c7 = 0 
                slurlet = slurstr{c8} 
                if c1 = 0 and c4 = 0 
                  if chr(ts(a6,TYPE)) in [GR_NOTE,XGR_NOTE] 
                    if chr(ts(a7,TYPE)) in [NOTE,XNOTE] 
                      slurlet = slurunder{c8}   /* force under 
                    end 
                  end 
                end 
              else 
                if c7 = 1 
                  slurlet = slurover{c8}    /* force over 
                else 
                  slurlet = slurunder{c8}   /* force under 
                end 
              end 
&dA 
&dA &d@     2a. Attempt to account for interfering beams 
&dA 
              if ts(a6,TYPE) < GR_NOTE or ts(a7,TYPE) > XNOTE 
                if "abcIJijAB" con slurlet 
                  if mpt < 6 
                    c12 = ts(a7,BEAM_FLAG) 
                    if c12 = CONT_BEAM or c12 = END_BEAM 
                      if mpt < 4           /* down-up; tips down; modify end 
                        slurlet = "t" 
                      else                 /* up-down; tips up; modify end 
                        slurlet = "O" 
                      end 
                    end 
                  else 
                    c12 = ts(a6,BEAM_FLAG) 
                    if c12 = CONT_BEAM or c12 = START_BEAM 
                      if mpt < 8           /* down-up; tips up; modify beginning
                        slurlet = "o" 
                      else                 /* up-down; tips down; modify beginning
                        slurlet = "P" 
                      end 
                    end 
                  end 
                end 
              end 
&dA 
&dA &d@     3. Decompose "compound" situations into separate "simple" situations 
&dA 
&dA &d@        (1) if code in [D,J,b,h,k], are there other slurs between the chords?  
&dA &d@              If yes, then these codes become [R,H,a,q,i] 
&dA 
&dA &d@        (2) if code = I or J, is ending note vpar(6) higher than starting note?
&dA &d@              If yes, then these codes both become O, otherwise they become H 
&dA 
&dA &d@        (3) if code in [B,b,c], is ending note vpar(6) lower than starting note?
&dA &d@              If yes, then codes become [P,t,t]; otherwise they become [A,a,a]
&dA 
&dA &d@        (4) if code = j, does starting note have a flag?  If yes, it becomes 
&dA &d@               an "o".  Otherwise it is an "i" 
&dA 
&dA &d@        (5) if code = l or E, is there anything between the notes (chords) 
&dA &d@               If yes, they become p and Q; otherwise they are i and R.  
&dA 
              if "DJbhk" con slurlet 
                c12 = mpt 
                perform get_topbottom (a6,c1,c2) 
                perform get_topbottom (a7,c4,c5) 

                if c2 > c1 and c5 > c4        /* both chords 
                  loop for c3 = c1 to c2      /* first chord 
                    if c3 <> a6 

                  /* look for other slurs 

                      c8 = ts(c3,SLUR_FLAG) & 0x00550055 
                      if c8 > 0               /* slur(s) start(s) 
                        c8 <<= 1              /* set of end flags for these slurs
                        loop for c9 = c2 + 1 to c5 
                          c10 = ts(c9,TYPE) 
                          if chr(c10) in [NOTE,XNOTE,CUE_NOTE,XCUE_NOTE,GR_NOTE,XGR_NOTE]
                            c11 = ts(c9,SLUR_FLAG) & c8 
                            if c11 > 0    /* slur ends 
                              if c9 >= c4 and c9 <> a7  /* condition met!  
                                slurlet = "RHaqi"{c12} 
                                goto SSEND1 
                              else 
                                c11 = not(c11) 
                                c8 &= c11   /* turn off this possibility 
                              end 
                            end 
                          end 
                        repeat 
                      end 

                  /* now look for ties 

                      if bit(0,ts(c3,SUPER_FLAG)) = 1 
                        loop for c9 = c4 to c5 
                          if c9 <> a7 
                            c10 = ts(c9,BACKTIE) 
                            if c10 = c3                 /* condition met!  (tricky code)
                              slurlet = "RHaqi"{c12} 
                              goto SSEND1 
                            end 
                          end 
                        repeat 
                      end 
                    end 
                  repeat 
                end 
                slurlet = "QJbpo"{c12} 
              end 
SSEND1: 
              c7 = 0              /* option flag 

              if "IJBbcjlE" con slurlet 
                c8 = ts(a6,BEAM_FLAG) 
                c9 = ts(a7,BEAM_FLAG) 
                goto SS(mpt) 
SS(1):                            /* "IJ" 
                if ts(a6,STAFFLOC) - ts(a7,STAFFLOC) > vpar(7) 
                  c7 = 1
                end 
                if ts(a6,TYPE) < GR_NOTE or ts(a7,TYPE) > XNOTE 
                  if c9 = CONT_BEAM or c9 = END_BEAM 
                    c7 = 1 
                  end 
                end 
                goto SSEND 
SS(3):                            /* "Bbc" 
                if ts(a7,STAFFLOC) - ts(a6,STAFFLOC) > vpar(7) 
                  if slurlet = "B" 
                    c7 = 1 
                  else                             /* (New &dA05/17/03&d@) 
                    if ts(a7,SUBFLAG_2) & 0x3c > 0 or ts(a7,ED_SUBFLAG_2) & 0x3c > 0
                      if ts(a7,STAFFLOC) - ts(a6,STAFFLOC) > vpar(9) 
                        c7 = 1 
                      end 
                    else 
                      c7 = 1 
                    end 
                  end 
                end 
                if mpt = 3 
                  if c8 = START_BEAM or c8 = CONT_BEAM 
                    c7 = 1 
                  end 
                else 
                  if c9 = CONT_BEAM or c9 = END_BEAM 
                    c7 = 1 
                  end 
                end 
                goto SSEND 
SS(6):                            /* "j" 
                if c8 = NO_BEAM 
                  if ts(a6,NTYPE) < QUARTER 
                    c7 = 1
                  end 
                else 
                  if c8 = START_BEAM or c8 = CONT_BEAM 
                    c7 = 1                           
                  end 
                end 
                goto SSEND 
SS(7):                            /* "lE"   beams on both notes of slur?  
                if c8 > NO_BEAM and c9 > NO_BEAM 
                  slurlet = "      pQ"{mpt} 
                end 
                goto SSEND2 
&dA 
&dA &d@     At this point in the code, a1,a4,a6,a7 and a14 should not be changed 
&dA 
SSEND: 
&dA 
&dA &d@     Break 'm up 
&dA &d@                               
                if c7 = 1 
                  slurlet = "OOPttopQ"{mpt} 
                else 
                  slurlet = "HHAaaiiR"{mpt} 
                end 
              end 
&dA 
&dA &d@     At this point, you have determined the "situation" letter for the     
&dA &d@     between "a6" and "a7" (with the exception of the cases "l" and "E", 
&dA &d@     which depend on the material between the slurs).  You now need to 
&dA &d@     compile a profile of whatever material might be between the slurs 
&dA &d@     on this staff. (organized by advancing division) 
&dA 
SSEND2: 
              c12 = 0 
              if "lE" con slurlet          /* we do cases "l" and "E" here 
                c12 = mpt 
                c3 = ts(a6,STAFFLOC) 
                c4 = ts(a7,STAFFLOC) 
                if c3 < c4               
                  c3 = c4                
                  c4 = ts(a6,STAFFLOC)   
                end                      
                if mpt = 1               
                  c4 -= vpar(4)          
                else                     
                  c3 += vpar(4) 
                end 
              end 
              c9 = 0 
              c7 = 0 
              c8 = ts(a7,STAFF_NUM) 
              c15 = ts(a6,DIV) 
              c10 = a7  
              loop while chr(ts(c10,TYPE)) in [XNOTE,XCUE_NOTE,XGR_NOTE] 
                --c10 
              repeat 
              --c10       /* c10 will not point to the last chord 
              loop for c1 = a6+1 to c10  
                if ts(c1,STAFF_NUM) = c8 
                  nodtype = ts(c1,TYPE) 
                  if chr(nodtype) in [NOTE,CUE_NOTE,GR_NOTE] 
                    if bit(1,ts(c1,STEM_FLAGS)) = UP 
                      c5 = ts(c1,VIRT_STEM)
                      c6 = ts(c1,VIRT_NOTE) 
                    else 
                      c5 = ts(c1,VIRT_NOTE) 
                      c6 = ts(c1,VIRT_STEM)
                    end 
                  else 
                    if chr(nodtype) in [REST,CUE_REST] 
                      c5 = ts(c1,STAFFLOC) - vpar(3) 
                      c6 = ts(c1,STAFFLOC) + vpar(3) 
                    else 
                      if nodtype = CLEF_CHG 
                        c5 = 0 
                        c6 = vpar(8) 
                      else 
&dA 
&dA &d@         &dA11/26/06&d@  Fixing a minor bug in the placement of slurs 
&dA 
                        if nodtype < METER_CHG 
                          c5 = 1000   
                          c6 = -1000 
                        else 
                          c5 = 10000 
                        end 
&dA             &d@  End of &dA11/26/06&d@ change 
                      end 
                    end 
                  end 
                  if c5 < 10000 
                    if c12 > 0 
                      if c3 > c5 and c4 < c6 
                        c7 = 1 
                      end 
                    end 
                    if ts(c1,DIV) <> c15 
                      ++c9                             /*   Case 1: 
                      profile(c9,1) = c5 - vpar(2)     /*     new division 
                      profile(c9,2) = c6 + vpar(2)     /* 
                    else 
                      if c9 > 0 
                        c5 -= vpar(2)                  /*   Case 2: 
                        c6 += vpar(2)                  /*     more notes 
                        if c5 < profile(c9,1)          /*     on same 
                          profile(c9,1) = c5           /*     division 
                        end                            /* 
                        if c6 > profile(c9,2) 
                          profile(c9,2) = c6 
                        end 
                      end 
                    end 
                  end 
                end 
                if ts(c1,TYPE) = BAR_LINE 
                  c15 = 0 
                else 
                  c15 = ts(c1,DIV) 
                end 
              repeat 
              if c12 > 0 
                if c7 = 1 
                  slurlet = "pQ"{c12}
                else 
                  slurlet = "iR"{c12} 
                end 
              end 
&dA 
&dA &d@     More modifications to slurlet.  If there are staccatos, legatos, 
&dA &d@     or spiccatos connected to the note head, then under certain    
&dA &d@     conditions the slur must start at the stem of the note.  
&dA 
            /* New code rewritten &dA05/17/03&d@ 

              c16 = ts(a6,SUBFLAG_2) | ts(a6,ED_SUBFLAG_2)   /* combination subflag_2 at a6
              c16 &= 0x3c                                    /* staccato, legato, etc.
              c17 = ts(a7,SUBFLAG_2) | ts(a7,ED_SUBFLAG_2)   /* combination subflag_2 at a7
              c17 &= 0x3c                                    /* staccato, legato, etc.

              if slurlet < chr(96)     /* tips up 
                if c16 > 0 
                  if bit(1,ts(a6,STEM_FLAGS)) = DOWN 
                    if "ACRKLM" con slurlet 
                      slurlet = "PQQPQQ"{mpt} 
                    end 
                  end 
                end 
                if ts(a6,TYPE) < GR_NOTE and c17 > 0 
                  if bit(1,ts(a7,STEM_FLAGS)) = DOWN 
                    if "CGHLMR" con slurlet 
                      slurlet = "QOOQQQ"{mpt} 
                    end 
                  end 
                end 
              else                      /* tips down 
                if c16 > 0 
                  if bit(1,ts(a6,STEM_FLAGS)) = UP 
                    if "fgimqrs" con slurlet 
                      slurlet = "poopppp"{mpt} 
                    end 
                  end 
                end 
                if c17 > 0 
                  if bit(1,ts(a7,STEM_FLAGS)) = UP 
                    if slurlet = "o" 
                      slurlet = "p" 
                    end 
                  end 
                end 
              end                         /* End of &dA05/17/03&d@ rewrite 
&dA 
&dA &d@                Updated list of letter codes 
&dA &d@              ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
&dA &d@       tips up           tips down            explanation            
&dA &d@   code   1st  2nd    code   1st  2nd    letter        meaning 
&dA &d@   ÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄ  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@     A     n    H       a     H    n        n     note 
&dA &d@     C     n    Yl      d     H    H        nr    start right of note 
&dA &d@     F     H    H       e     H    Y        nl    end left of note 
&dA &d@     G     H    Yl      f     Yr   n        H     head of chord 
&dA &d@     H     H    nl      g     Yr   H        Y     position of object 
&dA &d@     K     Y    H       i     nr   H              (opposite of H) 
&dA &d@     L     Y    Yl      m     nr   Y        Yr    start right of object 
&dA &d@     M     Y    nl      n     nr   nl       Yl    end left of object 
&dA &d@     N     nr   nl      o     s    H        s     stem 
&dA &d@     O     H    s       p     s    s 
&dA &d@     P     s    H       q     nr   n 
&dA &d@     Q     s    s       r     Yr   Yl 
&dA &d@     R     n    nl      s     Yr   Y 
&dA &d@                        t     H    s 
&dA 

&dA 
&dA &d@     At this point, we need to check to see of this is the first time 
&dA &d@     either chord has been touched by a slur.  When creating the 
&dA &d@     slur element ROW, we need to write in the first four elements: 
&dA 
&dA &d@        (1) current y-position above object for incoming slurs.  
&dA &d@        (2)              "     below   "     "     "       "  .  
&dA &d@        (3)              "     above   "     "  outgoing   "  .  
&dA &d@        (4)              "     below   "     "     "       "  .  
&dA 
              perform get_topbottom (a6,c1,c2) 
              if ts(a6,SLUR_X) = 0 
                ++a14 
                loop for c8 = c1 to c2 
                  ts(c8,SLUR_X) = a14 
                repeat 
                if bit(1,ts(a6,STEM_FLAGS)) = UP 
                  ts(a14,1) = ts(a6,VIRT_STEM) 
                  ts(a14,2) = ts(a6,VIRT_NOTE) 
                  ts(a14,3) = ts(a6,VIRT_STEM) 
                  ts(a14,4) = ts(a6,VIRT_NOTE) 
                else 
                  ts(a14,1) = ts(a6,VIRT_NOTE) 
                  ts(a14,2) = ts(a6,VIRT_STEM) 
                  ts(a14,3) = ts(a6,VIRT_NOTE) 
                  ts(a14,4) = ts(a6,VIRT_STEM) 
                end 
              end 
              if bit(1,ts(a6,STEM_FLAGS)) = UP 
                c3 = c2 
                c2 = c1 
                c1 = c3 
              end 

              perform get_topbottom (a7,c3,c4) 
              if ts(a7,SLUR_X) = 0 
                ++a14 
                loop for c8 = c3 to c4 
                  ts(c8,SLUR_X) = a14 
                repeat 
                if bit(1,ts(a7,STEM_FLAGS)) = UP 
                  ts(a14,1) = ts(a7,VIRT_STEM) 
                  ts(a14,2) = ts(a7,VIRT_NOTE) 
                  ts(a14,3) = ts(a7,VIRT_STEM) 
                  ts(a14,4) = ts(a7,VIRT_NOTE) 
                else 
                  ts(a14,1) = ts(a7,VIRT_NOTE) 
                  ts(a14,2) = ts(a7,VIRT_STEM) 
                  ts(a14,3) = ts(a7,VIRT_NOTE) 
                  ts(a14,4) = ts(a7,VIRT_STEM) 
                end 
              end 
              if bit(1,ts(a7,STEM_FLAGS)) = UP 
                c5 = c4 
                c4 = c3 
                c3 = c5 
              end 
&dA 
&dA &d@       a6 = note we are looking at in first chord 
&dA &d@       c1 = head of first chord 
&dA &d@       c2 = last note (Y) of first chord 
&dA 
&dA &d@       a7 = note we are looking at in second chord 
&dA &d@       c3 = head of second chord 
&dA &d@       c4 = last note (Y) of second chord 
&dA 
&dA &d@     If this slur starts or ends on an element which has either (1) a 
&dA &d@     staccato dot and/or a legato line, or (2) a spiccato indication 
&dA &d@     associated with it, then we need to check to see if this is the 
&dA &d@     first time the element in question has been encountered, i.e., 
&dA &d@     element (5) of the slur element ROW is zero.  If so, this parameter 
&dA &d@     needs to be adjusted to make space for the indication.  This will 
&dA &d@     also shift the position of the slur.  
&dA 

&dA 
&dA &d@     (1) starting 
&dA 
              c5 = ts(a6,SUBFLAG_2) | ts(a6,ED_SUBFLAG_2)   /* New &dA05/17/03&d@ 
                                                            /* At the moment, I am treating 
                                                            /* editorial marks the same way
                                                            /* as regular.  In fact, the 
                                                            /* addition of square brackets
                                                            /* may require additional
                                                            /* vertical space             

              c14 = ts(a6,SLUR_X)        /* index to slur element ROW 
              temp = "FGHOadet"          /* note (changed at bottom of loop) 
              temp2 = "PQop"             /* stem (changed at bottom of loop) 

              loop for c15 = 2 to 0 step -2 /* cases: 2 = start; 0 = end 

                if c5 & 0x3c > 0 
                  if ts(c14,5) = 0 
                    if temp con slurlet     /* if slur starts (ends) on a note 
&dA &d@         
&dA &d@             We need to write elements (5) and (6) and to modify elements 
&dA &d@             (1) and (3), or elements (2) and (4).
&dA &d@         
                      if mpt < 5            /* this works for both cases 
                        stem = UP 
                        t3 = 1 
                        y = ts(c14,c15+2) 
                      else 
                        stem = DOWN 
                        t3 = -1 
                        y = ts(c14,c15+1) 
                      end 

                      if c5 & 0x38 > 0       /* staccato or legato 
                        t2 = notesize 
                        y += t2 * t3 
               /*  check for interference 
                        t4 = 1 
                        if stem = DOWN 
                          if y >= 0 
                            t1 = y / notesize 
                            t4 = rem 
                          else 
                            y = 0 - notesize / 4 + y 
                          end 
                        else 
                          if y <= vpar(8) 
                            t1 = y / notesize 
                            t4 = rem 
                          else 
                            y = notesize / 4 + y 
                          end 
                        end 
               /*  adjust for interference with staff 
                        if t4 = 0                       /* interference 
                          c16 = t2 + vpar20 / vpar(2) 
                          if rem <> 0       
                            ++t2 
                          end 
                          t2 += vpar(1) 
                          c16 = t3 + 20 * vpar(2) / 2 - vpar20 
                          y += c16 
                        end 
                        c10 = t2 
                        if c5 & 0x10 > 0     /* line over dot 
                          y = notesize * t3 + y 
                          c10 += notesize 
                        end 
               /*  write elements 
                        ts(c14,5) = y 
                        if stem = UP 
                          ts(c14,2) += c10 
                          ts(c14,4) += c10 
                          ts(c14,6) = BELOW 
                        else 
                          ts(c14,1) -= c10 
                          ts(c14,3) -= c10 
                          ts(c14,6) = ABOVE 
                        end 
                      end 
                      if c5 & 0x04 > 0       /* spiccato 
                        if stem = DOWN 
                          if y > vpar(1) 
                            y = vpar(1) 
                          end 
                        else 
                          if y < vpar(7) 
                            y = vpar(7) 
                          end 
                        end 
                        y = 5 * notesize / 4 * t3 + y 
                        if stem = UP 
                          y += vpar(50) 
                        end 
               /*  write elements 
                        ts(c14,5) = y 
                        if stem = UP 
                          ts(c14,2) = y 
                          ts(c14,4) = y 
                          ts(c14,6) = BELOW 
                        else 
                          ts(c14,1) = y - vpar(50) 
                          ts(c14,3) = y - vpar(50) 
                          ts(c14,6) = ABOVE 
                        end 
                      end 
                    else 
                      if temp2 con slurlet  /* if slur starts (ends) on the stem
&dA &d@         
&dA &d@             We need to write element (5) and (6) and to modify elements 
&dA &d@             (1) and (3), or elements (2) and (4).
&dA &d@         
                        if mpt > 2           /* works in both cases 
                          stem = UP 
                          t3 = -1 
                          y = ts(c14,c15+1) 
                        else 
                          stem = DOWN 
                          t3 = 1 
                          y = ts(c14,c15+2) 
                        end 
                        if c5 & 0x38 > 0     /* staccato or legato 
                          t2 = vpar(1) 
                          c16 = t3 + 20 * vpar(2) / 2 - vpar20 
                          y += c16 

               /*  check for interference 
                          t4 = 1 
                          if stem = UP 
                            if y >= 0 
                              t1 = y / notesize 
                              t4 = rem 
                            else 
                              y = 0 - notesize / 4 + y 
                            end 
                          else 
                            if y <= vpar(8) 
                              t1 = y / notesize 
                              t4 = rem 
                            else 
                              y = notesize / 4 + y 
                            end 
                          end 
               /*  adjust for interference with staff 
                          if t4 = 0                     /* interference 
                            c16 = t2 + vpar20 / vpar(2) 
                            if rem <> 0 
                              ++t2 
                            end 
                            t2 += vpar(1) 
                            c16 = t3 + 20 * vpar(2) / 2 - vpar20 
                            y += c16 
                          end 
                          c10 = t2 
                          if c5 & 0x10 > 0   /* line over dot 
                            y = notesize * t3 + y 
                            c10 += notesize 
                          end 
               /*  write elements 
                          ts(c14,5) = y 
                          if stem = DOWN 
                            ts(c14,2) += c10 
                            ts(c14,4) += c10 
                            ts(c14,6) = ABOVE 
                          else 
                            ts(c14,1) -= c10 
                            ts(c14,3) -= c10 
                            ts(c14,6) = BELOW 
                          end 
                        end 
                        if c5 & 0x04 > 0     /* spiccato 
                          if stem = DOWN 
                            if y < vpar(8) 
                              y = vpar(8) 
                            end 
                          else 
                            if y > 0 
                              y = 0 
                            end 
                          end 
                          c16 = t3 + 20 * vpar(2) / 2 - vpar20 
                          y += c16 

                          if stem = DOWN 
                            y += vpar(50) 
                          end 
               /*  write elements 
                          ts(c14,5) = y 
                          if stem = DOWN 
                            ts(c14,2) = y 
                            ts(c14,4) = y 
                            ts(c14,6) = ABOVE 
                          else 
                            ts(c14,1) = y - vpar(50) 
                            ts(c14,3) = y - vpar(50) 
                            ts(c14,6) = BELOW 
                          end 
                        end 
                      end 
                    end 
                  end 
                end 
&dA 
&dA &d@     (2) ending 
&dA 
                c5 = ts(a7,SUBFLAG_2) | ts(a7,ED_SUBFLAG_2)   /* New &dA05/17/03&d@; see above.
                c14 = ts(a7,SLUR_X)            /* index to slur element ROW 
                temp = "AFKPdgio" 
                temp2 = "OQpt"   

              repeat 
&dA 
&dA &d@     Now you can affix the position of the slur, and store the results 
&dA &d@     in the appropriate slur element ROWS.  Also, the values of elements 
&dA &d@     (1) (2) (3) or (4) can be updated.  
&dA 

&dA &d@                              T H E   P L A N 
&dA &d@                           ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
&dA &d@     1. Using slurlet and elements (1) to (4), determine tentative start-y 
&dA &d@        and end-y values for slur.  Determine orientation (tips up/down) 
&dA 
&dA &d@     2. If c9 = 0, no adjustments are necessary; proceed with placing slur.  
&dA 
&dA &d@     3. Using curve data, convert actual interior y-values to relative 
&dA &d@        interior y-values.  If all interior y-values fall below (above) the 
&dA &d@        straight line connecting the end points, proceed with placing slur.  
&dA 
&dA &d@     4. Determine interior point with maximum deviation, and raise (lower) 
&dA &d@        the slur end-point on that side to the next multiple of vpar(1). 
&dA &d@        If there is more than one interior point at the maximum, or if the 
&dA &d@        interior point with the maximum is in the center of the slur, 
&dA &d@        raise (lower) both slur end-points to the next multiple of vpar(1).  
&dA 
&dA &d@     5. If all interior y-values now fall below (above) straight line 
&dA &d@        connecting the end points, proceed with placing slur.  
&dA 
&dA &d@     6. Determine interior point(s) with maximum deviation.  If this point 
&dA &d@        (all of these points) fall with the 25%-75% region of the slur, 
&dA &d@        increase the curvature one notch, and goto (3); otherwise goto (4).  
&dA 
&dA &d@     To execute this plan, we will need to set up some temporary variables.  
&dA 
&dA &d@        y1  = starting point of slur 
&dA &d@        y2  = ending point of slur 
&dA &d@        c5  = counting index for interior points 
&dA &d@        c6  = index for maximum on left 
&dA &d@        c7  = index for maximum on right 
&dA &d@        c9  = number of interior points (don't change this) 
&dA 
&dA &d@     I think the easiest way to handle the up/down situation is to convert 
&dA &d@     all down values to 1000 * vpar(1) - down, and treat this as part of the 
&dA &d@     "up" case.  Initial data includes y1, y2 and the profile data.  When we 
&dA &d@     are done, we simply perform the same tranformation to get the final 
&dA &d@     y1 and y2 values.  
&dA 

&dA              
&dA 
&dA &d@     New feature &dA05/01/08&d@.  If slur_adjust flag is non-zero, then this 
&dA &d@     should turn off all automatic post adjustment of slur posiiton.  I 
&dA &d@     think we can do this by setting c9 = 0, which essentially turns off 
&dA &d@     the profile.  
&dA 
              if slur_adjust <> 0 
                c9 = 0 
              end 
&dA 
&dA              

&dA &d@                           A C T I O N 
&dA &d@                          ÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
&dA &d@     1. Using slurlet and elements (1) to (4), determine tentative start-y 
&dA &d@        and end-y values for slur.  Determine orientation (tips up/down) 
&dA 
              if "ACNRimnq"  con slurlet         /* slur starts on note 
                y1 = ts(a6,STAFFLOC) 
              else 
                if "KLMfgrs"   con slurlet       /* slur starts on Y 
                  y1 = ts(a6,OBY) 
                else 
                  c13 = 3 
                  c14 = ts(a6,SLUR_X) 
                  c15 = bit(1,ts(a6,STEM_FLAGS)) 
                  if "FGHOadet"  con slurlet     /* slur starts on H 
                    if c15 = UP 
                      ++c13
                    end  
                  else 
                    if c15 = DOWN 
                      ++c13
                    end  
                  end 
                  y1 = ts(c14,c13) 
                end 
              end 
              if "HMNRafnq"  con slurlet         /* slur ends on note 
                y2 = ts(a7,STAFFLOC) 
              else 
                if "CGLemrs"   con slurlet       /* slur ends on Y 
                  y2 = ts(a7,OBY) 
                else 
                  c13 = 1 
                  c14 = ts(a7,SLUR_X) 
                  c15 = bit(1,ts(a7,STEM_FLAGS)) 
                  if "AFKPdgio"  con slurlet     /* slur ends on H 
                    if c15 = UP 
                      ++c13
                    end  
                  else 
                    if c15 = DOWN 
                      ++c13
                    end  
                  end 
                  y2 = ts(c14,c13) 
                end 
              end 
&dA 
&dA &d@     2. If c9 = 0, no adjustments are necessary; proceed with placing slur.  
&dA 
              if c9 = 0 
                curve = 1 
                goto PLACE_SLUR 
              end 
              c10 = 500 * vpar(2) 
              if slurlet < chr(96)     /* tips up 
                y1 = c10 - y1 
                y2 = c10 - y2 
                loop for c13 = 1 to c9 
                  profile(c13,1) = c10 - profile(c13,2)   /* first cut                 
                repeat 
              else 
                y1 += c10 
                y2 += c10  
                loop for c13 = 1 to c9 
                  profile(c13,1) += c10  
                repeat 
              end 
&dA 
&dA &d@     3. Using curve data, convert actual interior y-values to relative 
&dA &d@        interior y-values.  If all interior y-values fall below (above) the 
&dA &d@        straight line connecting the end points, proceed with placing slur.  
&dA &d@        (see beginning of program for construction of curvedata).  
&dA 
              t1 = 0 
              t2 = 0 
              curve = 1 
              sflag = 1 
              if abs(ts(a6,STAFFLOC) - ts(a7,STAFFLOC)) <= vpar(1) + 1 
                if bit(1,ts(a6,STEM_FLAGS)) = bit(1,ts(a7,STEM_FLAGS)) 
                  sflag = 0 
                end 
              end 
NEW_CURVE: 
              if c9 < 9  
                loop for c10 = 1 to c9 
                  profile(c10,2) = profile(c10,1) + curvedata(c9,curve,c10)
                repeat 
              else 
                loop for c10 = 1 to 4 
                  profile(c10,2) = profile(c10,1) + curvedata(8,curve,c10)
                repeat 
                loop for c10 = 5 to c9 - 4 
                  profile(c10,2) = profile(c10,1) + curvedata(8,curve,4) - 1
                repeat 
                c11 = 1 
                loop for c10 = c9 to c9 - 4 step -1 
                  profile(c10,2) = profile(c10,1) + curvedata(8,curve,c11)
                  ++c11 
                repeat 
              end 

              r1 = flt(y1) + .5 - flt(vpar(2)) 
              r2 = flt(y2 - y1) 
              r3 = flt(c9+1) 
              r2 = r2 / r3 
              c14 = 0 
              c15 = 0 
              c12 = c9 + 1 >> 1 
              c13 = c9 >> 1 + 1 
              t5 = 0 
              t6 = 0 
              loop for c5 = 1 to c9 
                r1 += r2 
                c11 = fix(r1) 
                c11 -= profile(c5,2) 
                if c11 > 0 
                  if c5 <= c12
                    if c11 > c14 
                      c14 = c11 
                      t5 = c5 
                    end 
                  end 
                  if c5 >= c13 
                    if c11 > c15 
                      c15 = c11 
                      t6 = c5 
                    end 
                  end 
                end 
              repeat 
              if c14 = 0 and c15 = 0 
                goto FIX_ENDS 
              end 
&dA 
&dA &d@     4. Determine interior point with maximum deviation, and raise (lower) 
&dA &d@        the slur end-point on that side to the next multiple of vpar(1). 
&dA &d@        If there is more than one interior point at the maximum, or if the 
&dA &d@        interior point with the maximum is in the center of the slur, 
&dA &d@        raise both slur end-points to the next multiple of vpar(1).  
&dA 

              c7 = 0                              
              if c9 > 4 and bit(0,c9) = 0                                 /* 
                c6 = c9 >> 1                                              /*   &dA          
                if t5 = c6 or t6 - 1 = c6                                 /*   &dA  TRIAL   
                  c7 = 1                                                  /*   &dA          
                  if bit(1,ts(a6,STEM_FLAGS)) <> bit(1,ts(a7,STEM_FLAGS)) /* 
                    if abs(ts(a6,STAFFLOC) - ts(a7,STAFFLOC)) <= vpar(10) /* 
                      if curve = 1                                        /* 
                        if c15 > c14                                      /* 
                          t1 = 2                                          /* 
                        else                                              /*   &dA          
                          t2 = 2                                          /*   &dA          
                        end                                               /*   &dA  TRIAL   
                        c7 = 0                                            /*   &dA          
                      end                                                 /* 
                    end                                                   /* 
                  end                                                     /* 
                end 
              end 
NEW_HEIGHT: 
              if c15 = c14 or sflag = 0 or c7 = 1 
                y2 -= vpar(1) 
                c16 = y2 * 2 / vpar(2) 
                y2 -= rem
                y1 -= vpar(1) 
                c16 = y1 * 2 / vpar(2) 
                y1 -= rem
                      
                if sflag = 0 
                  sflag = 1 
                end 
              else 
JKL: 
                if c15 > c14 
                  if t2 > 0 
                    t1 = 0 
                    t2 = 0 
                  end 
                  if t1 = 2            
                    t1 = 0 
                    c14 = c15 + 1 
                  else 
                    ++t1 
                    y2 -= vpar(1) 
                    c16 = y2 * 2 / vpar(2) 
                    y2 -= rem 
                  end 
                end 
                if c14 > c15 
                  if t1 > 0 
                    t1 = 0 
                    t2 = 0 
                  end 
                  if t2 = 2 
                    t2 = 0 
                    c15 = c14 + 1 
                    goto JKL 
                  else 
                    y1 -= vpar(1) 
                    c16 = y1 * 2 / vpar(2) 
                    y1 -= rem 
                  end 
                end 
              end 
&dA 
&dA &d@     5. If all interior y-values now fall below (above) straight line 
&dA &d@        connecting the end points, proceed with placing slur.  
&dA 
              r1 = flt(y1) + .5 - flt(vpar(2)) 
              r2 = flt(y2 - y1) 
              r3 = flt(c9+1) 
              r2 = r2 / r3 
              c14 = 0 
              c15 = 0 
              c6 = 0 
              c7 = 0 
              c12 = c9 + 1 >> 1 
              c13 = c9 >> 1 + 1 
              loop for c5 = 1 to c9 
                r1 += r2 
                c11 = fix(r1) 
                c11 -= profile(c5,2) 
                if c11 > 0 
                  if c5 <= c12
                    if c11 > c14 
                      c6 = c5 
                      c14 = c11 
                    end 
                  end 
                  if c5 >= c13 
                    if c11 > c15 
                      c7 = c5 
                      c15 = c11 
                    end 
                  end 
                end 
              repeat 
              if c6 = 0 and c7 = 0 
                goto FIX_ENDS 
              end 
              t5 = c6 
              t6 = c7 
&dA 
&dA &d@     6. Determine interior point(s) with maximum deviation.  If this point 
&dA &d@        (all of these points) fall with the 25%-75% region of the slur, 
&dA &d@        increase the curvature one notch, and goto (3); otherwise goto (4).  
&dA 
              c5 = 10000 / (c9 + 1) 
              c6 *= c5 
              c7 *= c5 
              if c14 >= c15 and c6 >= 2500 and curve < 4 
                ++curve 
                goto NEW_CURVE 
              end 
              if c14 <= c15 and c7 <= 7500 and curve < 4 
                ++curve 
                goto NEW_CURVE 
              end 
              goto NEW_HEIGHT 
&dA 
&dA &d@     Transform to actual y-values 
&dA 
FIX_ENDS: 
              c10 = 500 * vpar(2) 
              if slurlet < chr(96)     /* tips up 
                y1 = c10 - y1 
                y2 = c10 - y2 
              else 
                y1 -= c10  
                y2 -= c10  
              end 
&dA 
&dA &d@          Adjust slur height if both ends show tuplet 
&dA 
              if bit(4,ts(a6,SUPER_FLAG)) = 1 and bit(5,ts(a7,SUPER_FLAG)) = 1 
                c10 = 0   /* = no 
                goto ADJS(tpflag+1) 
ADJS(1): 
                if ts(a6,BEAM_FLAG) > 0 and ts(a7,BEAM_FLAG) > 0 
                  if ts(a7,MULTI_TRACK) = 0 
                    c10 = 1 
                  end 
                else 
                  c10 = 1 
                end 
                goto ADJSE 
ADJS(2):                       /* always 
                c10 = 1 
                goto ADJSE 
ADJS(3):                       /* never 
                goto ADJSE 
ADJS(4):                       /* only when tips down 
                if slurlet > chr(96)     /* tips down 
                  c10 = 1 
                end 
                goto ADJSE 
ADJS(5):                       /* only when tips up  
                if slurlet < chr(96)     /* tips up 
                  c10 = 1 
                end 
ADJSE:  
                if c10 = 1 
                  if slurlet < chr(96)     /* tips up 
                    if y1 + y2 > vpar(6) << 1 
                      y1 += vpar(2) 
                      y2 += vpar(2) 
                    end 
                  else 
                    if y1 + y2 < vpar(4) 
                      y1 -= vpar(2) 
                      y2 -= vpar(2) 
                    end 
                  end 
                end 
              end 
&dA 
&dA &d@     For both starting and ending chords, (1) find next empty slot in 
&dA &d@     in each SLUR_X row and construct the following information: 
&dA 
&dA &d@       first element 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@          bit 27:     start/end flag (0 = start, 1 = end) 
&dA &d@          bits 24-26: slur number - 1 (0 to 7) 
&dA &d@          bits 17-23: curvature information (end only) 
&dA &d@          bit 16:     up/down flag (0 = tips up, 1 = tips down) (end only) 
&dA &d@          bits 0-15:  x-offset + 1000 (always a positive number) 
&dA &d@       second element 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@          y position relative to the staff 
&dA &d@       third element (&dA05/06/03&d@) 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@          print suggestion for this end of the slur 
&dA 
PLACE_SLUR: 
&dA 
&dA &d@         Starting point 
&dA 
              c10 = 1000           /* x-offset 
              if "ACRNimnq" con slurlet     /* start on "n" 
                if ts(a6,LOCAL_XOFF) > 0 
                  c10 += ts(a6,LOCAL_XOFF) 
                end 
                if mpt > 3 
                  c10 += hpar(82) * 3 / 4 
                end 
              else 
                if "KLMfgrs" con slurlet    /* start on "Y" 
                  if bit(1,ts(a6,STEM_FLAGS)) = UP 
                    if ts(c2,LOCAL_XOFF) > 0 
                      c10 += ts(a6,LOCAL_XOFF) 
                    end 
                    if mpt > 3 
                      c10 += hpar(82) * 3 / 4 
                    end 
                  end 
                else 
                  if "PQop" con slurlet     /* start on "s" 
                    if mpt < 3 
                      c10 -= hpar(82) / 3 
                    else 
                      c10 += hpar(82) / 3 
                    end 
                  end 
                end 
              end 
              c11 = sgroup(a4,3) << 24       /* slur number 
              c11 += c10                     /* odd numbered element 
              c12 = ts(a6,SLUR_X) 
              loop for c13 = 7 to (TS_SIZE - 2) step 3       /* &dA05/06/03&d@ 
                if ts(c12,c13) = 0 
                  goto PLACE_SLUR1 
                end 
              repeat 
PLACE_SLUR1: 
              ts(c12,c13) = c11 
              ++c13 
              ts(c12,c13) = y1 
&dA 
&dA &d@          Fine tuning for special situation 
&dA 
              if slurlet = "i" 
                if ts(a6,STAFFLOC) - ts(a7,STAFFLOC) >= 0 
                  c17 = ts(a7,SUBFLAG_2) | ts(a7,ED_SUBFLAG_2)   /* New &dA05/17/03
                  if c17 & 0x3c > 0                              /* New 
                    ts(c12,c13) -= vpar(2) 
                  end 
                end 
              end 
&dA 
&dA &d@          Code added &dA05/06/03&d@ get print suggestion for this end of slur 
&dA 
              ++c13 
              c11 = sgroup(a4,3)                   /* 0 to 7 
              if c11 > 3 
                c11 -= 4                           /* 0 to 3 = (,[,{,z 
              end 
              c11 *= 4                             /* 0,4,8,12 
              c11 += 81                            /* 81,85,89,93  (97,101,105,109)
              c10 = ts(a6,TSR_POINT)                      
              ts(c12,c13) = ors(tsr(c10){c11,4}) 
&dA 
&dA &d@          End code addition 
&dA 
              if "opadet" con slurlet        /* starting from over (3) 
                ts(c12,3) = y1 - vpar(1) 
                c16 = ts(c12,3) * 2 / vpar(2) 
                ts(c12,3) -= rem 
              end 
              if "FGHOPQ" con slurlet        /* starting from under (4) 
                ts(c12,4) = y1 
                c16 = ts(c12,4) * 2 / vpar(2) 
                if rem <> 0 
                  ++ts(c12,4) 
                end 
                ts(c12,4) += vpar(1) 
              end 
&dA 
&dA &d@         Ending point 
&dA 
              c10 = 1000           /* x-offset 
              if "HMNRnafq" con slurlet     /* end on "n" 
                if ts(a7,LOCAL_XOFF) < 0 
                  c10 += ts(a6,LOCAL_XOFF) 
                end 
                if mpt < 6 
                  c10 -= hpar(82) * 3 / 4 
                end 
              else 
                if "CGLrems" con slurlet    /* end on "Y" 
                  if bit(1,ts(a7,STEM_FLAGS)) = DOWN 
                    if ts(c4,LOCAL_XOFF) < 0 
                      c10 += ts(a6,LOCAL_XOFF) 
                    end 
                    if mpt < 5 
                      c10 -= hpar(82) * 3 / 4 
                    end 
                  end 
                else 
                  if "OQpt" con slurlet     /* end on "s" 
                    if mpt < 3 
                      c10 -= hpar(82) / 3 
                    else 
                      c10 += hpar(82) / 3 
                    end 
                  end 
                end 
              end 
              c11 = sgroup(a4,3)             /* slur number 
              c11 += 16                      /* end flag 
              c11 <<= 8 
              c11 += curve << 1              /* curvature 
              if slurlet > chr(96)     /* tips up 
                ++c11                        /* tips up/down flag 
              end 
              c11 <<= 16 
              c11 += c10                     /* x-offset              
              c12 = ts(a7,SLUR_X) 
              loop for c13 = 7 to (TS_SIZE - 2) step 3       /* &dA05/06/03&d@ 
                if ts(c12,c13) = 0 
                  goto PLACE_SLUR2 
                end 
              repeat 
PLACE_SLUR2: 
              ts(c12,c13) = c11 
              ++c13 
              ts(c12,c13) = y2 
&dA 
&dA &d@          Code added &dA05/06/03&d@ get print suggestion for this end of slur 
&dA 
              ++c13 
              c11 = sgroup(a4,3)                   /* 0 to 7 
              if c11 > 3 
                c11 -= 4                           /* 0 to 3 = (,[,{,z 
              end 
              c11 *= 4                             /* 0,4,8,12 
              c11 += 97                            /* 97,101,105,109 
              c10 = ts(a7,TSR_POINT) 
              ts(c12,c13) = ors(tsr(c10){c11,4}) 
&dA 
&dA &d@          End code addition 
&dA 
              if "ptdgio" con slurlet        /* ending from over (1) 
                ts(c12,1) = y2 - vpar(1) 
                c16 = ts(c12,1) * 2 / vpar(2) 
                ts(c12,1) -= rem 
              end 
              if "AFKPOQ" con slurlet        /* ending from under (2) 
                ts(c12,2) = y2 
                c16 = ts(c12,2) * 2 / vpar(2) 
                if rem <> 0 
                  ++ts(c12,2) 
                end 
                ts(c12,2) += vpar(1) 
              end 
            repeat 

&dA &d@   &dA  ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»  
&dA &d@   &dA  º   This is the end of the loop which processes slurs   º  
&dA &d@   &dA  ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼  

          end 
YYYY: 
        repeat 
        maxsct = a14 
&dA 
&dA &d@***************************************************************** 
&dA &d@    Processing loop (loop ends at ZZZ)   PROCESSING TS ARRAY 
&dA 
&dA &d@    Actions:  
&dA 
&dA &d@       I. Construct text sub-object, if present 
&dA 
&dA &d@      II. Deal with music   
&dA 
&dA &d@          A. Bar Lines  
&dA 
&dA &d@          B. Clef changes, Time changes
&dA 
&dA &d@          C. Signs, Words, Marks  
&dA 
&dA &d@          D. Figures  
&dA 
&dA &d@          E. Notes/Rests  
&dA 
&dA &d@              1. Accidentals  
&dA &d@              2. Note heads, dots   
&dA &d@              3. Leger lines  
&dA &d@              4. Stems and beams  
&dA 
&dA &d@     III. Write object records into intermediate file 
&dA 
        p += firstsp 
        loop for a1 = 1 to sct   
          nodtype = ts(a1,TYPE)  
          a5 = ts(a1,TEXT_INDEX)  
          if a5 > 0 
            ttext = tsdata(a5) // pad(1) 
          else 
            ttext = pad(1) 
          end 
          sobcnt = 0 
          obx = p  
          if nodtype = DIV_CHG
            goto ZZZ 
          end  
&dA 
&dA &d@    Get the spn (spacing) parameter 
&dA 
          spn = ts(a1,SPN_NUM) 
&dA 
&dA &d@   II. Typeset Music  
&dA 
&dA &d@     A. Typeset Bar Line  
&dA 
          if nodtype = BAR_LINE
            a2 = hpar(36)  
            a14 = ts(a1,BAR_TYPE)  
&dA 
&dA &d@    determine location of obx for this object 
&dA 
            if bit(1,ts(a1,REPEAT)) = 1    /* backward repeat
              a2 += hpar(43) 
            end                                                           
            a10 = hpar(43) + hpar(93) - hpar(80) 
&dA 
&dA &d@     hpar(44) = actual white space between two light lines 
&dA &d@     hpar(45) = actual white space between heavy/light, light/heavy and heavy/heavy combinations
&dA &d@     hpar(79) = thickness of light line 
&dA &d@     hpar(81) = thickness of heavy line 
&dA 
&dA &d@                                                                        shift for
&dA &d@                                                                       forward dots(repeats)
&dA &d@   a14   a2+ (add to p)       a4 (1st shft) a5 (2nd shft)  a8 (inc)        a10
&dA &d@  ----  ----                 ----           ---------     ----            -----
&dA &d@    1    0                    0             0               0              a10
&dA &d@    2  { hpar(81) - hpar(79  a2             0               0              a10
&dA &d@              + 1 } 
&dA &d@    3    0                    0             0               0              a10
&dA &d@    5    hpar(44) + hpar(79) a2             0               0              a10
&dA &d@    6  { hpar(45) + hpar(81) a2   - { hpar(81) - hpar(79)   0              a10
&dA &d@              + 1 }                          + 1 } 
&dA &d@    9    0                    0       hpar(81) + hpar(45)   a5           a10 + a5
&dA &d@   10    hpar(81) + hpar(45) a2             0         { hpar(81) -   hpar(43)+hpar(96)-hpar(80)
&dA &d@                                                     hpar(79) + 1 } 
&dA 

            a4 = 0 
            a5 = 0 
            a8 = 0 
            if a14 = HEAVY
              a2 += hpar(81) - hpar(79) + 1 
              a4 = hpar(81) - hpar(79) + 1 
            end  
            if a14 = DOUBLE_REG or a14 = DOUBLE_DOTTED
              a2 += hpar(44) + hpar(79) 
              a4 = hpar(44) + hpar(79) 
            end  
            if a14 = REG_HEAVY
              a2 += hpar(45) + hpar(81) + 1 
              a4 = hpar(45) + hpar(81) + 1 
              a5 = 0 - (hpar(81) - hpar(79) + 1) 
            end  
            if a14 = HEAVY_REG
              a5 = hpar(81) + hpar(45) 
              a8 = a5        
              a10 += a5       
            end  
            if a14 = DOUBLE_HEAVY
              a2 += hpar(81) + hpar(45) 
              a4 =  hpar(81) + hpar(45) 
              a8 =  hpar(81) - hpar(79) + 1 
              a10 = hpar(43) + hpar(96) - hpar(80) 
            end  
            obx = p + a2 
            if ts(a1,NODE_SHIFT) > 0 
              obx += ts(a1,NODE_SHIFT) 
            end 
&dA 
&dA &d@    put out signet signs (if present) 
&dA 
            if bit(1,ts(a1,BAR_FLAGS)) = 1     /* segno sign
              out = "0"  
              jtype = "D"  
              jcode = 8 + sigflag  
              pcode = 106                 /* music font
              oby = vpar(45) 
              if nstaves = 2 
                oby += 1000 
              end 
              putobjpar = 0 
              perform putobj 
              jcode = 5 - sigflag  
              oby = 0 - vpar(43) 
              perform putobj 
              if sigflag = 0 
                sigflag = 1  
              end  
            end  
&dA &d@                 
&dA &d@    put out fermata signs (if present) 
&dA 
            if ts(a1,BAR_FLAGS) & 0x000c > 0 
              putobjpar = 0 
              if bit(2,ts(a1,BAR_FLAGS)) = 1     /* fermata over bar 
                out = "0" 
                jtype = "D" 
                jcode = 5            
                pcode = 101                 /* music font 
                oby = 0 - vpar(3) 
                obx -= vpar(2) 
                perform putobj 
                obx += vpar(2) 
              end 
              if bit(3,ts(a1,BAR_FLAGS)) = 1     /* fermata under bar 
                out = "0" 
                jtype = "D" 
                jcode = 9 
                pcode = 102                 /* music font 
                oby = vpar(3) + vpar(8) 
                if nstaves = 2 
                  oby += 1000 
                end 
                obx -= vpar(2) 
                perform putobj 
                obx += vpar(2) 
              end 
            end 
            oby = 0  
&dA 
&dA &d@    contruct superobject string for bar line  
&dA 
            supcnt = 0 
*    look for termination of ending  
            a9 = ts(a1,BACK_ENDING) 
            if a9 <> 0   
              if esnum > 0 
                ++supcnt
                supnums(supcnt) = esnum  
                a6 = esnum 
              else 
                tmess = 4 
                perform dtalk (tmess) 
              end  
              esnum = 0  
            end  
*    look for termination of long trill ~~~~ 
            if bit(0,ts(a1,BAR_FLAGS)) = 0 
              loop for a3 = 1 to MAX_PASS 
                if tsnum(a3) > 0 
                  ++supcnt                         /* stop trill 
                  supnums(supcnt) = tsnum(a3) 
                end 
              repeat 
            end  
*    look for origination of ending  
            if ts(a1,FORW_ENDING) > 0 
              ++snum
              esnum = snum 
              ++supcnt
              supnums(supcnt) = esnum  
            end  
*    construct supernumber string for object
            out = chs(supcnt)  
            loop for a3 = 1 to supcnt  
              out = out // " " // chs(supnums(a3))   
            repeat 
            supcnt = 0 
&dA 
&dA &d@    Typeset elements of the bar line 
&dA 
*    numbered measure                   /* Code added &dA02-23-97&d@ 
            a3 = ts(a1,M_NUMBER) 
            if a3 > 0 
              c5 = 38
              perform spacepar (c5) 
              c5 = spc(176) >> 1        /* space for small "0" 
              if a3 > 9 
                c5 <<= 1 
              end 
              sobl(1) = "W " // "-" // chs(c5) // " 0 38 " 
              sobcnt = 1 
              if a3 > 9 
                c5 = a3 / 10 
                a3 = rem 
                sobl(1) = sobl(1) // "\0" // chs(c5) 
              end 
              sobl(1) = sobl(1) // "\0" // chs(a3) 
            end 

*    back-repeat 
            if bit(1,ts(a1,REPEAT)) = 1   /* backward repeat 
              x = p + hpar(36) 
              x += ts(a1,NODE_SHIFT)     /* This line added &dA09/22/03&d@ (but not fully checked)
              y = vpar(3) 
              z = 44                      /* music font 
              perform subj 
              y = vpar(5) 
              perform subj 
            end 
*    first of double bar 
            y = 0 
            if a14 > 3 
              a3 = a14 & 0x0c 
              z = a3 / 2 + 80             /* music font 
              x = obx - a4 
              perform subj 
            end 
*    second or single bar  
            a3 = ts(a1,BAR_TYPE) & 0x03 
            z = a3 * 2 + 80               /* music font 
            x = obx + a5 
            perform subj 
*    forward-repeat  
            if bit(0,ts(a1,REPEAT)) = 1   /* forward repeat 
              x = obx + a10 
              a8 += hpar(43) 
              y = vpar(3) 
              z = 44                      /* music font 
              perform subj 
              y = vpar(5) 
              perform subj 
            end 
*    put out object (and sub-objects)  
            jtype = "B" 
            jcode = ts(a1,BAR_NUMBER) 
            if sobcnt = 1 
              pcode = z                   /* music font 
            else 
              pcode = sobcnt 
            end 
            oby = ts(a1,NUM_STAVES) - 1 * 1000 + a14 
            putobjpar = 0 

            perform putobj 
&dA 
&dA 
*    put out ending super-object 
            if a9 <> 0                    /* backward ending
              if ts(a1,FORW_ENDING) > 0 
                out = "-" // chs(hpar(41)) 
              else 
                out = "0"  
              end  
              out = out // " -" // chs(vpar(40)) // " " 
              out = out // chs(vpar(41)) // " "  
              if a9 > 0                   /* ending stops
                out = out // chs(vpar(41)) 
              else                        /* ending discontinues
                a9 = 0 - a9  
                out = out // "0"   
              end  
              ++outpnt 
              tput [Y,outpnt] H ~a6  E ~a9  0 ~out 
            end  
*    put out long trill super-object 
            if bit(0,ts(a1,BAR_FLAGS)) = 0 
              loop for c5 = 1 to MAX_PASS 
                if tsnum(c5) > 0 
                  out = "H " // chs(tsnum(c5)) // " R " // chs(ctrarrf(c5)) 
                  out = out // " 0" 
                  ++outpnt 
                  tput [Y,outpnt] ~out  -~hpar(42)  ~try(c5) 
                  tsnum(c5) = 0 
                  ctrarrf(c5) = 0 
                end 
              repeat 
            end  
*    adjust p
            p = obx + ts(a1,SPACING) + a8   

            goto ZZZ 
          end  
&dA 
&dA &d@     B. Typeset Clef change, Time change, Key change 
&dA 
          if nodtype = CLEF_CHG
&dA 
&dA &d@    Code added &dA01/17/04&d@ to deal with time clef in measure groups 
&dA 
            if ts(a1,DOLLAR_SPN) = 6913             /* 6913 used here as a code, not a value
              spn = 6913 
            end                                     /* otherwise don't change spn
&dA   
            a3 = ts(a1,STAFF_NUM) + 1         /* staff number 

            if ts(a1,NODE_SHIFT) < 0 
              a7 = 0 - ts(a1,NODE_SHIFT) 
              p += ts(a1,NODE_SHIFT) 
            end 

            obx = p  

            clef(a3) = ts(a1,CLEF_NUM) 
            z = ts(a1,CLEF_FONT)              /* music font 
            oby = ts(a1,STAFF_NUM) * 1000     /* added &dA5-28-93&d@ 
            oby += ts(a1,CLEF_STAFF_POS) 
            perform putclef (a3) 
            p += ts(a1,SPACING) 

            goto ZZZ 
          end  
 
          if nodtype = DESIGNATION
&dA 
&dA &d@    Code added &dA01/17/04&d@ to deal with designation in measure groups 
&dA 
            if ts(a1,DOLLAR_SPN) = 6913             /* 6913 used here as a code, not a value
              spn = 6913 
            end                                     /* otherwise don't change spn
&dA   
            c5 = 37 
            perform spacepar (c5) 
&dA 
&dA &d@       Introducing optional conversion to ligitures in designations  &dA04/22/04
&dA 
            perform kernttext                  /* New &dA04/22/04&d@ 
            jtype = "D"  
            jcode = 5  
            obx = p  
            oby = ts(a1,STAFF_NUM) * 1000     /* added &dA5-28-93&d@ 
            oby -= tword_height * vpar(1) 
            out = "0"  
            sobl(1) = "" 
            temp3 = "W 0 0 " // chs(dtivfont) // " " // ttext 
            pcode = 1  
            putobjpar = 0 
            perform putobj 
            goto ZZZ 
          end  
 
          if nodtype = METER_CHG
&dA 
&dA &d@    Code added &dA01/17/04&d@ to deal with meter changes in measure groups 
&dA 
            if ts(a1,DOLLAR_SPN) = 6913             /* 6913 used here as a code, not a value
              spn = 6913 
            end                                     /* otherwise don't change spn
&dA   
            tnum = ts(a1,TIME_NUM) / 100 
            tden = rem 
            oby = 0 
            t1 = p 
            loop for t2 = 1 to ts(a1,NUM_STAVES) 
              p = t1 
              perform settime (a3) 
              oby += 1000 
            repeat 
            if tnum = 1 and tden = 1 
              tnum = 4 
              tden = 4 
            end 
            if tnum = 0 and tden = 0 
              tnum = 2     
              tden = 2 
            end 
            goto ZZZ 
          end  
 
          if nodtype = AX_CHG 
&dA 
&dA &d@    Code added &dA01/17/04&d@ to deal with key changes in measure groups 
&dA 
            if ts(a1,DOLLAR_SPN) = 6913             /* 6913 used here as a code, not a value
              spn = 6913 
            end                                     /* otherwise don't change spn
&dA   
            t1 = ts(a1,3)                              /* new key 
            t2 = ts(a1,4)                              /* old key 
            a3 = ts(a1,NUM_STAVES)                     /* number of staves 
            a4 = 0 
            a5 = 0                                     /* added &dA08/23/06&d@ 
            perform key_change (t1,t2,a3,a4,a5)        /* emptyspace(.,.) not set
            key = t2                               /* &dA08/23/06&d@ 5th variable added to procedure
&dA 
&dA &d@    NOTE: The following instruction was added &dA05/29/05&d@ to fix a minor bug 
&dA &d@          that I have never seen before.  It makes perfect sense that we 
&dA &d@          should go to the next element in the ts(.) array, and I can't see
&dA &d@          how this "bug" has remained hidden for so long.  My worry is that
&dA &d@          there was a good reason why we wanted to "fall through" to the 
&dA &d@          note processing section, although this would be &dEvery poor&d@ programming
&dA &d@          practice.  I do believe, however, in light of the fact that this 
&dA &d@          program has worked properly for so long, that we need to keep an 
&dA &d@          eye on this situation.  This "goto" instruction &dEis&d@ a major change!
&dA 
            goto ZZZ                                  
          end 
&dA 
&dA &d@     C. Typeset Signs, Words and Marks which are Objects  
&dA 
          if nodtype = SIGN or nodtype = WORDS or nodtype = MARK
            putobjpar = 0 
            a4 = ts(a1,TEXT_INDEX)  
            ttext = tsdata(a4)  
            ttext = trm(ttext) 
            out = "0"  
&dA 
&dA &d@     determine vertical positions of object and superobject 
&dA 
            if ts(a1,SIGN_TYPE) = SEGNO 
              oby = 0 - vpar(43) 
            else 
              if ts(a1,SIGN_POS) = ABOVE 
                oby = 0 - vpar(44) 
              else 
                oby = vpar(45) 
              end 
            end 
            oby1 = oby 
            oby2 = oby 
            obx1 = obx 
            obx2 = obx 
&dA 
&dA &d@     Comment: &dA01/07/06&d@ The code here is somewhat convoluted, but I think 
&dA &d@         this addition corrects a problem with the way print suggestions 
&dA &d@         interact with transpositions.  Stay alert!  
&dA 
            if nodtype = MARK
              oby = 0  
            end  
&dA     
            if ts(a1,POSI_SHIFT1) > 0 
              a3 = ts(a1,POSI_SHIFT1) & 0xff 
              if a3 > 0 
                oby1 = a3 - 0x80 * vpar(2) / 10 
                yposi_shift = 0 
              else 
                a3 = ts(a1,POSI_SHIFT1) >> 8  
                yposi_shift = a3 & 0xff 
                if yposi_shift > 0 
                  yposi_shift = yposi_shift - 0x80 * vpar(2) / 10 
                end 
              end 
              xposi_shift = ts(a1,POSI_SHIFT1) >> 16 
              if xposi_shift > 0 
                xposi_shift = xposi_shift - 0x80 * vpar(2) / 10 
              end 
            else 
              yposi_shift = 0 
              xposi_shift = 0 
            end 
            save_xposi_shift = xposi_shift 
            obx1 += xposi_shift 
            oby1 += yposi_shift 

            if ts(a1,POSI_SHIFT2) > 0 
              a3 = ts(a1,POSI_SHIFT2) & 0xff 
              if a3 > 0 
                oby2 = a3 - 0x80 * vpar(2) / 10 
                yposi_shift = 0 
              else 
                a3 = ts(a1,POSI_SHIFT2) >> 8  
                yposi_shift = a3 & 0xff 
                if yposi_shift > 0 
                  yposi_shift = yposi_shift - 0x80 * vpar(2) / 10 
                end 
              end 
              xposi_shift = ts(a1,POSI_SHIFT2) >> 16 
              if xposi_shift > 0 
                xposi_shift = xposi_shift - 0x80 * vpar(2) / 10 
              end 
            else 
              yposi_shift = 0 
              xposi_shift = 0 
            end 
            obx2 = xposi_shift 
            oby2 += yposi_shift 

            temp = " " // chs(oby1) 
            temp2 = " " // chs(oby2) 

            a2 = ts(a1,SUPER_TYPE) 
*     construct superflags for object  
            if a2 > 0  
              a3 = a2 + 1 / 2  
              a8 = 0 
              if a3 = 4  
                a8 = 1 
                a3 = 3 
              end  
              if rem = 0     /* start of super-object 
              
                a4 = a3 - WEDGES * 5 + ts(a1,S_TRACK_NUM) /* row element 
                loop for a5 = 1 to 5 
                  if smusdir(a4,1) = 0                    /* must be zero to use 
                    a5 = 1000 
                  else                                    /* else look at others
                    ++a4 
                    if a4 > a3 * 5 
                      a4 -= 5                             /* in the set 
                    end 
                  end 
                repeat 
                if a5 <> 1000 
                  if a3 = WEDGES 
                    tmess = 31 
                  else 
                    if a3 = DASHES 
                      tmess = 32 
                    else 
                      tmess = 33 
                    end 
                  end 
                  perform dtalk (tmess) 
                end 
                ++snum
                smusdir(a4,1) = snum 
                smusdir(a4,4) = oby2 
                if a3 = WEDGES
                  smusdir(a4,2) = ts(a1,WEDGE_SPREAD)
                  smusdir(a4,3) = ts(a1,WEDGE_OFFSET) + obx2 
                else 
                  if a3 = DASHES 
                    if ts(a1,FONT_NUM) = 0 
                      c5 = mtfont 
                    else 
                      c5 = ts(a1,FONT_NUM) 
                    end 
                    smusdir(a4,3) = c5 
                    perform wordspace 
                    smusdir(a4,2) = a5 + obx2 
                  else 
                    smusdir(a4,3) = obx2 
                    smusdir(a4,4) -= oby    /* tricky code 
                    if a3 = OCT_UP 
                      smusdir(a4,2) = 0 
                    end 
                    if a3 = OCT_DOWN 
                      smusdir(a4,2) = 1 
                    end 
                    if a3 = DBL_OCT_UP 
                      smusdir(a4,2) = 2 
                    end 
                    if a3 = DBL_OCT_DOWN 
                      smusdir(a4,2) = 3 
                    end 
                  end 
                end 

              else                 /* end of super-object 

                a4 = a3 - WEDGES * 5 + ts(a1,S_TRACK_NUM) /* row element 
                loop for a5 = 1 to 5 
                  if smusdir(a4,1) <> 0                   /* must be non zero to use
                    a5 = 1000 
                  else                                    /* else look at others
                    ++a4 
                    if a4 > a3 * 5 
                      a4 -= 5                             /* in the set 
                    end 
                  end 
                repeat 
                if a5 <> 1000 
                  if a3 = WEDGES 
                    tmess = 34 
                  else 
                    if a3 = DASHES 
                      tmess = 35 
                    else 
                      tmess = 36 
                    end 
                  end 
                  perform dtalk (tmess) 
                end 
                save_a4 = a4 
              end 
              out = "1 " // chs(smusdir(a4,1)) 
            end  
&dA 
&dA &d@     if single character, write object  
&dA 
            a3 = ts(a1,SIGN_TYPE) 
            if a3 = PED or a3 = END_PED 
              pcode = 112 + a3           /* music font 
              jtype = "S"  
              jcode = 0  
              obx = obx1 
              oby = ts(a1,STAFF_NUM) * 1000 + oby1 
              if ts(a1,ISOLATED) = 1 
                jtype = "I" 
              end 
              perform putobj 
              goto VT2 
            end  
            if a3 = LETTER_DYNAM          /* one letter dynamics 
              if ttext con "Z" 
#if SFZ 
                ttext{mpt,1} = "sfz" 
#else 
                ttext{mpt,1} = "sf" 
#endif 
              end 
              if len(ttext) = 1 and "pf" con ttext 
                if mpt = 1      
                  pcode = 108             /* music font
                else 
                  pcode = 110             /* music font
                end  
                jtype = "S"  
                jcode = 0  
                obx = obx1 
                oby = ts(a1,STAFF_NUM) * 1000 + oby1 
                if ts(a1,ISOLATED) = 1 
                  jtype = "I" 
                end 
                perform putobj 
                goto VT2 
              end  
            end  
&dA 
&dA &d@    put out segno signs (as directives) 
&dA 
            if a3 = SEGNO    
              pcode = 106                 /* music font 
              jtype = "D" 
              jcode = 8 + sigflag 
              obx = obx1 
              oby = ts(a1,STAFF_NUM) * 1000 + vpar(45)      /* oby reset here 
              if ts(a1,ISOLATED) = 1 
                jtype = "I" 
              end 
              perform putobj 
              jcode = 5 - sigflag 
              oby = ts(a1,STAFF_NUM) * 1000 + oby1     
              if ts(a1,ISOLATED) = 1 
                jtype = "I" 
              end 
              perform putobj 
              if sigflag = 0 
                sigflag = 1  
              end  
              goto VT2 
            end  

&dA                                                                   
&dA 
&dA &d@               This code added &dA10-12-96&d@ 
&dA 

&dA 
&dA &d@    Put out mark for tie terminator
&dA 
            if a3 = TIE_TERM 
              jtype = "M"  
              jcode = 0  
              obx = obx1 + hpar(81) + hpar(45)   /* guarenteed to put you beyond bar line
              oby = 0  
              pcode = 0  
              c7 = ts(a1,BACKTIE) 
              c7 = ts(c7,BACKTIE) 
              out = "1 " // chs(tiearr(c7,TIE_SNUM)) 
              perform putobj 
&dA 
&dA &d@     Now put out the Tie Super-object 
&dA 
&dA &d@        compute sitf (situation flag) 
&dA 
&dA &d@        Description of sitf:   range 1 to 16  
&dA &d@    
&dA &d@        If the range were from 0 to 15, then bits 3 to 0     
&dA &d@          would have the following meanings:  
&dA &d@    
&dA &d@                          zero          |         one 
&dA &d@                   -------------------------------------------- 
&dA &d@          bit 3:        tips down       |       tips up 
&dA &d@          bit 2:      note on space     |     note on line  
&dA &d@          bit 1:   no stem interfenence |   stem interference 
&dA &d@          bit 0:    staff interference  | no staff interference 
&dA 
              c9 = tiearr(c7,TIE_VLOC) 
              c10 = tiearr(c7,TIE_FHDIS)        /* local x-offset for first note
              c11 = 0                           /* local x-offset for second note
              c12 = tiearr(c7,TIE_FORCE)        /* force flag 
              if c12 = 3 
                c12 = 9 
              end 
&dA 
&dA &d@           Rules for single note 
&dA 
              c5 = tiearr(c7,TIE_FSTEM) 
              if c5 = 0 
                sitf = 9                    /* stem up 
              else 
                sitf = 1 
              end 

              if c12 > 0 
                sitf = c12                  /* forced situation 
              end 

              if tiearr(c7,TIE_FSTEM) = UP and sitf < 9 
                sitf += 2                   /* stem interference 
              end 
&dA 
&dA &d@       Note:  you won't know if there is staff interference until 
&dA &d@                   you know the final length of the tie 
&dA 
              c9 += tiearr(c7,TIE_STAFF) * 1000 

          /* New code added &dA04/20/03&d@, modified &dA05/02/03&d@    

              c13 = tiearr(c7,TIE_SUGG) & 0xff000000        /* length data     
              c6 =  tiearr(c7,TIE_SUGG) & 0xff0000          /* position flags
              c4 =  tiearr(c7,TIE_SUGG) & 0xff00            /* x data 
              c5 =  tiearr(c7,TIE_SUGG) & 0xff              /* y data 
              c13 >>= 24 
              c6 >>= 16 
              c4 >>= 8 
              if c4 > 0 
                c4 = c4 - 128 * notesize / 10 
              end 
              if c5 > 0 
                c5 = c5 - 128 * notesize / 10 
              end 
              if bit(2,c6) = 1 
                c5 += 10000 
              end 
              c6 = 0 
              if c13 > 0 
                c6 = c13 - 128 * notesize / 10 
              end 

          /* end New code 

              c8 = tiearr(c7,TIE_SNUM) 

              ++outpnt 
              if tiearr(c7,TIE_COLOR) > 4                /* New &dA12/21/10&d@ 
                if tiearr(c7,TIE_COLOR) = 5 
                  tput [Y,outpnt] P ~c8  T ~c9  ~c10  ~c11  ~c4  ~c5  ~c6  ~sitf  0
                else 
                  if tiearr(c7,TIE_COLOR) = 6 
                    tput [Y,outpnt] P 0x00ff00 ~c8  T ~c9  ~c10  ~c11  ~c4  ~c5  ~c6  ~sitf  0
                  else 
                    tput [Y,outpnt] P 0x0000ff ~c8  T ~c9  ~c10  ~c11  ~c4  ~c5  ~c6  ~sitf  0
                  end 
                end 
              else 
                tput [Y,outpnt] H ~c8  T ~c9  ~c10  ~c11  ~c4  ~c5  ~c6  ~sitf  0
              end 

              tiearr(c7,TIE_SNUM) = 0 
              ts(a1,BACKTIE) = 0 
              goto VT2 
            end 
&dA &d@                    
&dA &d@               End of &dA10-12-96&d@ addition 
&dA 
&dA                                                                      

            if nodtype = MARK
              jtype = "M"  
              jcode = 0  
              obx = obx1 
              oby = 0  
              pcode = 0  
              if ts(a1,ISOLATED) = 1 
                jtype = "I" 
              end 
              perform putobj 
              goto VT2 
            end  
*     words  
            if nodtype = WORDS
              jtype = "D"  
              jcode = 0  

              if ttext = "Fine"  
                jcode = 9  
              end  
              if ttext = "fine"  
                jcode = 9  
              end  
              if ttext = "[fine]"  
                jcode = 9  
              end  
              if ttext con " " 
                if ttext{1,mpt-1} = "da" 
                  jcode = 9  
                end  
                if ttext{1,mpt-1} = "dal"  
                  jcode = 9  
                end  
                if ttext{1,mpt-1} = "Dal"  
                  jcode = 9  
                end  
                if ttext{1,mpt-1} = "Da"  
                  jcode = 9  
                end  
                if ttext con " da " 
                  jcode = 9 
                end 
              end  
              if ttext con "D.C." or ttext con "D. C." 
                jcode = 9 
              end 

              pcode = 1  
              a4 = ts(a1,FONT_NUM) 
              if a4 = 0  
                a4 = mdirfont
              end  

&dA          
&dA &d@      
&dA &d@      This code moved to this location from below, because we need 
&dA &d@      to the operative font number for spacing purposes.  &dA10/08/08&d@ 
&dA 
              ttext = ttext // pad(4) 
              if ttext{1} = "!" 
                a4 = int(ttext{2..}) 
                if ttext{sub} = "|"           /* New &dA01/17/04&d@: skip over "|"
                  ++sub 
                end 
                ttext = ttext{sub..} 
              end 
              ttext = trm(ttext) 
&dA 
&dA          
              if a3 > 4                 /* (a3 = SIGN_TYPE here) 
                c5 = a4 
                if a3 < 7  
&dA 
&dA &d@       Introducing optional conversion to ligitures in words  &dA04/22/04&d@ 
&dA 
                  perform kernttext            /* New &dA04/22/04&d@ 
                  perform wordspace 

&dA                                                       &d@  (reminder) 
&dA &d@³    Inputs:    ttext   = word                       ³ 
&dA &d@³                  c5   = font number                ³ 
&dA &d@³               curfont = currently active font      ³ 
&dA &d@³                                                    ³ 
&dA &d@³    Outputs:   a5 = space taken up by word          ³ 
&dA                                                       

                  if a3 = 6  
                    a5 /= 2 
                  else 
                    a5 += 10 
                  end  
                else 

&dA                                                                    
&dA 
&dA &d@          New code (&dA02/03/08&d@) for determining box size and position 
&dA &d@            for Rehearsal numbers or letters (uses c10,c11,c12,c13,c14,c15,c16,c17)
&dA 
                  if a3 = REH_MARK 
                    perform wordspace 
                    c12 = 2 * font_base + zero_height / 3           /* displacement to top
                    c13 = font_height - font_base * 2 / 3           /* displacement to bottom
                    c14 = spc(48) / 2                               /* displacement to the left
                    c15 = a5 + (spc(48) * 3 / 5)                    /* displacement to the right
                  end 
&dA 
&dA                                                                    

                  a5 = 0 
                end  
              end  
              if a5 > 0  
                temp3 = "W -" // chs(a5) 
              else 
                temp3 = "W 0"  
              end  

&dA                                                           
&dA 
&dA &d@      More code &dA02/03/08&d@ for dealing with boxes 
&dA 
              if a3 = REH_MARK
                sobl(1) = temp3 // temp // " " // chs(a4) // " " // ttext 
                c10 = 1 
                c11 = oby1 - c12              /* actual displacement to top 
                c12 = oby1 + c13              /* actual displacement to bottom
                c13 = 0 - c14                 /* actual displacement to the left
                c14 = c15                     /* actual displacement to the right
&dA 
&dA &d@          First put in horizontal lines of the box 
&dA 
                c17 = 0 
                if notesize = 6 
                  c15 = c13 + 1 
                  loop for c16 = 1 to 8 
                    ++c10 
                    sobl(c10) = "K " // chs(c15) // " " // chs(c11) // " 45"
                    ++c10 
                    sobl(c10) = "K " // chs(c15) // " " // chs(c12) // " 45"
                    c15 += 10 
                    if c17 = 1 
                      c16 = 1000 
                    end 
                    if c15 > (c14 - 9) 
                      c15 = c14 - 9 
                      c17 = 1 
                    end 
                  repeat 
                else 
                  c15 = c13 
                  loop for c16 = 1 to 8 
                    ++c10 
                    sobl(c10) = "K " // chs(c15) // " " // chs(c11) // " 90"
                    ++c10 
                    sobl(c10) = "K " // chs(c15) // " " // chs(c12) // " 90"
                    if c17 = 1 
                      c16 = 1000 
                    end 
                    c15 += 30 
                    if c15 > (c14 - 30) 
                      c15 = c14 - 30 
                      c17 = 1
                    end 
                  repeat 
                end 
&dA 
&dA &d@             for glyph 45                    for glyph 90                         for glyph 89
&dA &d@           ---------------                 ---------------                     -----------------
&dA &d@              notesize 6    -1  0  10        notesize 6       0  0  30            notesize 6         0  0  1  (6)
&dA &d@              notesize 14   -3  0  24        notesize 14      0  1  30            notesize 14        0  1  2  (14)
&dA &d@              notesize 16   -3  0  28        notesize 16      0  1  30            notesize 16        0  1  2  (16)
&dA &d@              notesize 18   -4  0  32        notesize 18      0  1  30            notesize 18        0  1  3  (18)
&dA &d@              notesize 21   -4  0  35        notesize 21      0  2  30            notesize 21        0  1  4  (21)
&dA 

&dA 
&dA &d@          Now put in vertical lines of the box 
&dA 
                c17 = 0 
                c15 = c11 
                --c14 
                if notesize > 6 
                  --c14 
                end 
                if notesize > 16 
                  --c14 
                end 
                if notesize > 18 
                  --c14 
                end 

                loop for c16 = 1 to 8 
                  ++c10 
                  sobl(c10) = "K " // chs(c13) // " " // chs(c15) // " 89" 
                  ++c10 
                  sobl(c10) = "K " // chs(c14) // " " // chs(c15) // " 89" 
                  if c17 = 1 
                    c16 = 1000 
                  end 
                  c15 += notesize 
                  if c15 > (c12 - notesize) 
                    c15 = c12 - notesize 
                    c17 = 1
                  end 
                repeat 
                pcode = c10 
              else 
&dA     
&dA &d@          Need to make a cludge of a modification here &dA01/12/09&d@.  The problem
&dA &d@          is that when the node is isolated, any non-null xposi_shift becomes
&dA &d@          irrelevant, once mskpage takes over.  In this case, if we want the 
&dA &d@          word shifted horizontally, the shift must be in the Word sub-object,
&dA &d@          not in the object position.  We will adjust the obx position because
&dA &d@          it is relevant when printing individual parts 
&dA 
                if ts(a1,ISOLATED) = 1 
                  temp3 = "W " // chs(save_xposi_shift) // temp // " " // chs(a4) // " " // ttext
                  obx1 -= save_xposi_shift 
                else 
                  temp3 = temp3 // temp // " " // chs(a4) // " " // ttext 
                end 
&dA     
                sobl(1) = "" 
              end 

&dA 
&dA          &d@ End of &dA02/03/08&d@ Changes 

              obx = obx1 
              oby = ts(a1,STAFF_NUM) * 1000       
              if ts(a1,ISOLATED) = 1 
                jtype = "I" 
              end 
              perform putobj 
              goto VT2 
            end  
*     multi-letter dynamics  
            jtype = "S"  
            jcode = 0  
            pcode = len(ttext)   
            obx = obx1 
            oby = oby1 
            x = obx 
            y = oby 
            loop for a4 = 1 to pcode 
              if "pmfszr" con ttext{a4}  
                z = mpt + 107             /* music font
                mpt += 59 
                perform subj 
                x += hpar(mpt) 
              end  
            repeat 
            oby = ts(a1,STAFF_NUM) * 1000 + oby 
            if ts(a1,ISOLATED) = 1 
              jtype = "I" 
            end 
            perform putobj 
&dA 
&dA &d@      put out super-objects 
&dA 
VT2:        a2 = ts(a1,SUPER_TYPE) 
            if a2 > 0  
              a2 /= 2 
              if rem = 0 and a2 >= 1 and a2 <= 6 
                a4 = save_a4                              /* this was computed above
                if a2 = WEDGES
*        wedges  
                  line = chs(smusdir(a4,2)) // " " 
                  line = line // chs(ts(a1,WEDGE_SPREAD)) // " " 
                  line = line // chs(smusdir(a4,3)) // " " // chs(smusdir(a4,4)) // " "
                  line = line // chs(ts(a1,WEDGE_OFFSET) + obx2) // " " // chs(smusdir(a4,4))

                  ++outpnt 
                  tput [Y,outpnt] H ~smusdir(a4,1)  W ~line 
                end  
                if a2 = DASHES
*        dashes  
                  if ts(a1,SIGN_TYPE) = LETTER_DYNAM 
                    a6 = obx2 - (2 * hpar(46)) 
                  else 
                    a6 = obx2 
                  end 
                  line = chs(a6) // " " // chs(smusdir(a4,4)) // " 0" 
                  a6 = smusdir(a4,3)  
                  ++outpnt 
                  tput [Y,outpnt] H ~smusdir(a4,1)  D ~smusdir(a4,2)  ~line  ~a6
                end  
*        range shifts                           
                if chr(a2) in [OCT_UP,OCT_DOWN,DBL_OCT_UP,DBL_OCT_DOWN] 
                  if a2 = OCT_UP or a2 = DBL_OCT_UP 
                    a5 = smusdir(a4,4) + vpar(47) 
                  else 
                    a5 = smusdir(a4,4) - vpar(46) 
                  end 
                  line = chs(smusdir(a4,2)) // " " // chs(smusdir(a4,3)) // " "
                  a6 = obx2 - hpar(47) 
                  line = line // chs(a6) // " " // chs(a5) // " " // chs(vpar(41))
                  ++outpnt 
                  tput [Y,outpnt] H ~smusdir(a4,1)  V ~line 
                end 
                smusdir(a4,1) = 0        /* clear the row for next use 
              end  
            end  
            if ts(a1,DINC_FLAG) > 0  
              inctype = ts(a1,DINC_FLAG) 
            end  
            goto ZZZ 
          end  
&dA 
&dA &d@     D. Typeset Figures 
&dA 
          if nodtype = FIGURES 
            obx = p  
&dA 
&dA &d@       We need to run a little check here.  If there is an element 
&dA &d@       in the ts array that has the same division number and is a note or 
&dA &d@       cue-note, then the possibility exist that this object might 
&dA &d@       have to be shifted to the right in order to be placed under 
&dA &d@       the note (and not under some accidental to the note).  
&dA 
            if ts(a1+1,DIV) = ts(a1,DIV) 
              if ts(a1+1,TYPE) = NOTE or ts(a1+1,TYPE) = CUE_NOTE 
                obx += ts(a1+1,NODE_SHIFT) 
                p   += ts(a1+1,NODE_SHIFT) 
                ts(a1+1,NODE_SHIFT) = 0 
                if ts(a1+1,SPACING) < ts(a1,MIN_FIG_SPAC) 
                  ts(a1+1,SPACING) = ts(a1,MIN_FIG_SPAC) 
                end 
              end 
            end 

            a3 = FIG_DATA
            supcnt = 0   
*     determine if accidentals precede any figures in this set 
            loop for a2 = 1 to 4 
              mf(a2) = 0 
            repeat 
            a10 = FIG_DATA
            loop for a2 = 1 to ts(a1,NUMBER_OF_FIG) 
              a4 = ts(a1,a10) + 28  /* tricky code, possible rewrite
&dA 
&dA &d@    Code added &dA11/16/03&d@ to deal with parentheses around figures 
&dA 
              if a4 > 1000 
                a4 = a4 / 1000 
                a4 = rem 
              end 
&dA   
              temp = chr(a4)   
              if "1389" con temp    
                if ts(a1,a10+1) > 0 and ts(a1,a10+1) < 20
                  mf(a2) = a4 - 48 
                end  
              end  
              a10 += 3 
            repeat 
*     construct sub-objects  
            oby = vpar(49) 
            y = vpar(49) 
            loop for a2 = 1 to ts(a1,NUMBER_OF_FIG)
              a6 = ts(a1,a3)  
&dA 
&dA &d@    Code added &dA11/16/03&d@ to deal with parentheses around figures 
&dA 
              a10 = 0 
              if a6 > 1000 
                a10 = a6 / 1000 
                a6 = rem 
                if a6 = 0 
                  a10 = 0 
                else 
                  if a10 = 1 
                    y -= vpar(92) 
                    x = obx - hpar(136) 
                    if mf(a2) > 0 
                      a9 = mf(a2) + 67 
                      a9 = hpar(a9) 
                      x -= a9 
                    end 
                    z = 197                   /* music font 
                    perform subj              /* small left parenthesis 
                    y += vpar(92) 
                  else 
                    if a10 = 3                /* shift down to bracket 3 figures
                      y += (vpar(48) >> 1) 
                    end 
                    y += vpar(93) 
                    x = obx - hpar(138) 
                    if mf(a2) > 0 
                      a9 = mf(a2) + 67 
                      a9 = hpar(a9) 
                      x -= a9 
                    end 
                    z = 69                    /* music font 
                    perform subj              /* large left parenthesis 
                    y -= vpar(93) 
                    if a10 = 3 
                      y -= (vpar(48) >> 1) 
                    end 
                  end 
                end 
              end 
&dA   
              x = obx  
              if a6 > 0    
                if mf(a2) > 0  
                  a9 = mf(a2) + 67 
                  a9 = hpar(a9)  
                  x = obx - a9 
                  z = mf(a2) + 210        /* music font
                else 
                  a9 = hpar(66)  
                  if a6 = 30 
                    z = 220               /* music font
                  else 
                    if a6 < 10 
                      z = a6 + 199 
                    else 
                      if a6 < 20 
                        z = 200 
                        perform subj 
                        x += a9 
                        z = a6 + 189 
                      else 
                        a9 = a6 + 47 
                        a9 = hpar(a9) 
                        z = a6 + 190 
                      end 
                    end 
                  end  
                end  
                perform subj 
                x += a9 
                a6 = ts(a1,a3+1)  
                if a6 > 0  
                  a9 = hpar(66)  
                  if a6 < 10 
                    z = a6 + 199 
                  else 
                    if a6 < 20 
                      z = 200 
                      perform subj 
                      x += a9 
                      z = a6 + 189 
                    else 
                      a9 = a6 + 47 
                      a9 = hpar(a9) 
                      z = a6 + 190 
                    end 
                  end 
                  perform subj 
                  x += a9 
                end  
&dA 
&dA &d@    Code added &dA11/16/03&d@ to deal with parentheses around figures 
&dA 
                if a10 > 0 
                  x -= a9 
                  if a10 = 1 
                    x += hpar(137) 
                    y -= vpar(92) 
                    z = 198                 /* music font 
                    perform subj            /* small right parenthesis 
                    y += vpar(92) 
                  else 
                    if a10 = 3                /* shift down to bracket 3 figures
                      y += (vpar(48) >> 1) 
                    end 
                    x += hpar(139) 
                    y += vpar(93) 
                    z = 70                  /* music font 
                    perform subj            /* large right parenthesis 
                    y -= vpar(93) 
                    if a10 = 3 
                      y -= (vpar(48) >> 1) 
                    end 
                  end 
                  x += a9 
                end 
&dA   
              end  
*       set up for dealing with continuation lines 
              if ts(a1,a3+2) = 2  
                ++snum
                figarr(a2,FIG_SNUM) = snum  
                dv4 = x - obx  
                if a6 > 0  
                  dv4 += (hpar(66) * 3 / 2)     /* &dA11/16/03&d@ Experiment: was simply hpar(66)
                end  
                figarr(a2,FIG_HOFF1) = dv4 
                ++supcnt
                supnums(supcnt) = snum   
              end  
              if ts(a1,a3+2) = 1  
                figarr(a2,FIG_HOFF2) = hpar(77)  
                figarr(a2,FIG_READY) = 1 
                ++supcnt
                supnums(supcnt) = figarr(a2,FIG_SNUM)   
              end  
              a3 += 3 
              y += vpar(48) 
            repeat 
*    put out object and sub-objects  
            out = chs(supcnt)  
            loop for a3 = 1 to supcnt  
              out = out // " " // chs(supnums(a3)) 
            repeat 
            supcnt = 0 
            jtype = "F"  
            jcode = 0  
            pcode = sobcnt 
            oby = ts(a1,STAFF_NUM) * 1000 + oby 
&dA 
&dA &d@       Now look for print suggestions for this figure object 
&dA 
            putobjpar = 0 
            c5 = ts(a1,TSR_POINT) 
            pcontrol = ors(tsr(c5){1})                  /* &dA05/02/03&d@ 
            px = ors(tsr(c5){3}) << 8 
            py = ors(tsr(c5){4}) << 16 
            a2 = ors(tsr(c5){2}) << 24 
            putobjpar = a2 + px + py + pcontrol         /* Note: order of data has been changed

            perform putobj 
*    write out continuation line super-objects 
            loop for a2 = 1 to MAX_FIG
              if figarr(a2,FIG_READY) > 0  
                ++outpnt 
tput [Y,outpnt] H ~figarr(a2,FIG_SNUM)  F ~a2  ~figarr(a2,FIG_HOFF1)  ~figarr(a2,FIG_HOFF2)  0
                loop for a3 = 1 to 4 
                  figarr(a2,a3) = 0  
                repeat 
              end  
            repeat 
            a4 = ts(a1,FIG_SPACE) 
            if a4 > 0  
              p += a4 
            end 
            if ts(a1,DINC_FLAG) > 0  
              inctype = ts(a1,DINC_FLAG) 
            end  
            goto ZZZ 
          end  
&dA 
&dA &d@ ================================================================= 
&dA &d@                  GENERAL SECTION COMMENT 
&dA 
&dA &d@      At this point, we have only notes (grace, regular and cue) 
&dA &d@  and rests (regular and cue) left to typeset.  This is actually 
&dA &d@  where the process becomes interesting and can be quite complex.  
&dA &d@  For music on the grand staff (the most complex situation) 
&dA &d@  there can be as many as &dDten&d@ (&dDMAX_PASS&d@) passes and as many as 
&dA &d@  &dDsix&d@ notes in a single pass (maximum chord size) 
&dA 
&dA &d@      We need to review the way note events are organized in the set 
&dA &d@  array and how this relates to the way they are organized in the 
&dA &d@  i-files.  In the i-files, the basic unit of organization is the 
&dA &d@  object.  An object can contain a note, a set of notes (chord), or a 
&dA &d@  rest.  Items which normally attach to notes such as accidentals, 
&dA &d@  ornaments, articulations, leger lines, etc., are included as 
&dA &d@  sub-objects to the object.  Items which normally connect notes such 
&dA &d@  as beams, ties, and slurs, are represented by superobjects.  Among 
&dA &d@  the parameters associated with an object are (1) &dDhorizontal location&d@, 
&dA &d@  (2) &dDspace node number&d@, and (3) &dDdistance&d@ &dDincrement flag&d@.  
&dA 
&dA &d@      &dDThe first level of organization in the set array is by division&d@.  
&dA &d@  A division is a time-location with a measure.  A division may have 
&dA &d@  several note events belonging to it (as well as other types of events, 
&dA &d@  which, at this point in the program have already been dealt with). 
&dA &d@  &dDAll members of a division will have the same space node number.&d@  
&dA &d@  The first object in a division will have a non-zero distance 
&dA &d@  increment flag.  This feature is handled automatically by the 
&dA &d@  putobj procedure.  
&dA 
&dA &d@      Within a division, we first find all of the grace notes (and 
&dA &d@  grace chord notes).  Since grace notes generally precede regular and 
&dA &d@  cue notes, these notes can have non-zero advance-space parameters 
&dA &d@  associated with them.  This means that grace notes objects can 
&dA &d@  advance the horizontal location pointer.  On the other hand, cue-size 
&dA &d@  and regular objects will generally have the same horizontal location 
&dA &d@  (except for for shifts to accomodate clashes).  
&dA 
&dA &d@      From the above analysis, we can see that &dDthe next level of&d@ 
&dA &d@  &dDorganization in the set array is by general location&d@.  In particular, 
&dA &d@  grace notes will tend fall into one or more groups, each having a 
&dA &d@  separate general location.  All cue-size and regular notes (and 
&dA &d@  rests will have the same general location.  
&dA 
&dA &d@      Finally &dDthe lowest level of organization in the set array is by&d@ 
&dA &d@  &dDactual object&d@.  Only notes of the same chord will share the same 
&dA &d@  object.  
&dA 
&dA &d@      We are currently inside a big loop, which begins under the title 
&dA &d@  "&dLProcessing loop (loop ends at ZZZ)&d@".  The loop itself is initiated 
&dA &d@  by the instruction "&dNloop for a1 = 1 to sct&d@".  The variable "spn", 
&dA &d@  which is the space node number, is retrieved from storage at the top 
&dA &d@  of this loop.  It is based on division number.  We do not need to 
&dA &d@  process all notes and rests on a particular division at one time; we 
&dA &d@  may proceed down to the next level of organization within the set 
&dA &d@  array, which is the general location.  The key variable in 
&dA &d@  determining this grouping is the space parameter "&dLSPACING&d@".  The 
&dA &d@  first ts(.,.) ROW element of a general location group will have a 
&dA &d@  non-zero space parameter, and any other element in such a group will 
&dA &d@  have a space parameter = 0.  
&dA 
&dA &d@      In typesetting a group of notes at a general location, the 
&dA &d@  following information is required.  
&dA 
&dA &d@      (1) The number of passes (chords or single notes) in the group 
&dA &d@      (2) The number of set array elements in each of these passes 
&dA &d@      (3) a4 = the spacing parameter for this group 
&dA &d@      (4) a2 = index to last element in group 
&dA &d@                                                                   
&dA &d@                         END OF COMMENT 
&dA &d@                                                                   
&dA &d@ ================================================================= 
&dA &d@                                                                   
&dA 
&dA &d@     E. Notes/Rests 
&dA 
          a4 = ts(a1,SPACING) 

          if ts(a1,NODE_SHIFT) > 0 
            p += ts(a1,NODE_SHIFT) 
          end 

          npasses = 1 
          a3 = 1 
          loop for a2 = a1+1 to sct  
            if ts(a2,SPACING) <> 0 
              --a2 
              pitchcnt(npasses) = a3 
              goto XX1 
            end 
            if ts(a2,TYPE) > NOTE_OR_REST 
              --a2 
              pitchcnt(npasses) = a3 
              goto XX1 
            end 
            if nodtype = GR_NOTE
              if ts(a2,TYPE) = XGR_NOTE 
                ++a3 
              else 
                pitchcnt(npasses) = a3 
                a3 = 1 
                ++npasses 
              end 
            else 
              if ts(a2,TYPE) = XNOTE or ts(a2,TYPE) = XCUE_NOTE 
                ++a3 
              else 
                pitchcnt(npasses) = a3 
                a3 = 1 
                ++npasses 
              end 
            end 
          repeat 
XX1: 
&dA 
&dA &d@    Create objects for this node  
&dA 
&dA &d@    a1          = index to first element in node 
&dA &d@    a2          = index to last element in node 
&dA &d@    npasses     = number of passes (separate chords) in this node 
&dA &d@    pitchcnt(.) = size of chord for each pass
&dA &d@    a4          = space parameter (space following this node) 
&dA 
&dA &d@    I. Typeset objects in this node 
&dA 

          c2 = a1 - 1 
          loop for a14 = 1 to npasses 
            obx = p 
            c1 = c2 + 1                       /* top of chord 
            c2 = c1 + pitchcnt(a14) - 1       /* bottom of chord 
            a3 = ts(c1,STAFF_NUM) + 1         /* staff number 
            passnum = ts(c1,PASSNUM) 
            oby = ts(c1,OBY) 
            ntype = ts(c1,NTYPE) & 0xff       /* new &dA10/15/07&d@ 
            opt_rest_flag = ts(c1,NTYPE) >> 8 /* new &dA10/15/07&d@ 
            nodtype = ts(c1,TYPE) 

&dA                                                                
&dA 
&dA &d@    I. Construct Text Sub-Object (new to this position  &dA06-26-94&d@ ) 
&dA 
            if nodtype = NOTE 
              c5 = ts(c1,TEXT_INDEX) 
              if c5 > 0 
                ttext = tsdata(c5) // pad(1) 
              else 
                ttext = pad(1) 
              end 
&dA 
&dA &d@        New test for text data &dA09/01/03&d@ 
&dA 
              c5 = 0 
              if ttext{1} in ['A'..'Z','a'..'z','!'..'(','\','='] 
                c5 = 1 
              else 
                ttext = ttext // " " 
                loop for c4 = 1 to len(ttext) 
                  if ttext{c4} = "|" and ttext{c4+1} in ['A'..'Z','a'..'z','!'..'(','\','=']
                    c5 = 1 
                    c4 = len(ttext) 
                  end 
                repeat 
                ttext = trm(ttext) 
              end 
              if c5 = 1 
&dA 
&dA &d@        End of test &dA09/01/03&d@ 
&dA 
                c5 = mtfont 
                perform spacepar (c5) 
                temp2 = ttext 
                if temp2 con "$$$$" 
                  ttext = temp2{1,sub-1} 
                  c4 = int(temp2{sub+4..})        /* x offset (calculated earlier)
                  if sub < len(temp2) 
                    org_c4 = int(temp2{sub+1..})  /* original "unbiased" (pre &dA12/09/03&d@) offset
                  else 
                    org_c4 = c4 
                  end 
                end 
                temp2 = ttext // "| " 
                ttextcnt = 0 
CCCD: 
                if temp2 con "|" 
                  ttext = temp2{1,mpt-1} 

                  if ttext = "_"             /* &dA09/01/03&d@ Must flag isolated "_"
                    ttext = "&" 
                  end 

                  temp2 = temp2{mpt+1..} 
                  ++ttextcnt 
                  ttextarr(ttextcnt) = trm(ttext) 
                  goto CCCD 
                end 
                loop for a7 = 1 to ttextcnt 

                  ttext = ttextarr(a7) 
&dA 
&dA &d@  determine values of xbytearr 
&dA 
                  a6 = len(ttext) 
                  xbytearr(a7) = "* " 
                  if "-_" con ttext{a6} 
                    ttext = ttext{1,a6-1} 
                    xbytearr(a7) = "-_"{mpt} // " " 
                    if mpt = 2 
                      a6 = len(ttext) 
                      if ",.;:!?" con ttext{a6} 
                        ttext = ttext{1,a6-1} 
                        xbytearr(a7) = ",.;:!?"{mpt} // " " 
                      end 
                    end 
                  end 
                  ttextarr(a7) = ttext 
                repeat 
&dA 
&dA &d@   determine relative position of ttext 
&dA 
                x = p - c4 
                sobx = x - obx 
&dA 
&dA &d@          Code added &dA12/09/03&d@ 
&dA 
                if org_c4 <> c4 
                  a8 = p - org_c4 
                  sobx2 = a8 - obx 
                else 
                  sobx2 = 0 
                end 
&dA   
                loop for a8 = 1 to ttextcnt 
                  ttext = ttextarr(a8) 

                  if ttext <> "&"              /* &dA09/01/03&d@  Use flag set above
                    ++sobcnt 
&dA 
&dA &d@          Code modified &dA12/09/03&d@ 
&dA 
                    if sobx2 <> 0 
                      temp3 = "T " // chs(sobx) // "|" // chs(sobx2) // " " // chs(a8) // " "
                    else 
                      temp3 = "T " // chs(sobx) // " " // chs(a8) // " " 
                    end 
&dA   
                    if ttext con "=" 
                      if mpt < 3               /* &dA10/19/03&d@  Fixing corner case error
                        ttext{mpt} = "-" 
                      else 
                        if ttext{mpt-2,3} <> "\0=" 
                          ttext{mpt} = "-" 
                        end 
                      end 
                    end 
&dA 
&dA &d@       Introducing optional conversion to ligitures in text  &dA10/20/03&d@ 
&dA 
                    perform kernttext          /* New &dA04/22/04&d@ 
                    perform wordspace 
                    sobl(sobcnt) = temp3 // ttext // " " // xbytearr(a8) // chs(a5)
                  end 

                repeat 
              else 
                if ttext in [' ','~']             /* code added &dA02-23-95&d@ 
                  loop for c15 = len(ttext) to 1 step -1 
                    if ttext{c15} = "~" 
&dA 
&dA &d@        I'm going to try something risky here, namely to add a text sub-object
&dA &d@          to the previous note: temp variables c13,c14,c15 
&dA 
                      loop for c13 = outpnt to 1 step -1 
                        tget [Y,c13] temp3 
                        if temp3{1,3} = "J N" 
&dA 
&dA &d@                  1. Increment field 6 of record at c13 
&dA 
                          temp3 = temp3{5..} 
                          c14 = int(temp3) 
                          c14 = int(temp3{sub..}) 
                          c14 = int(temp3{sub..}) 
                          temp2 = "J N " // temp3{1..sub} 

                          c14 = int(temp3{sub..}) 
                          ++c14 
                          temp2 = temp2 // chs(c14) // temp3{sub..} 
                          tput [Y,c13] ~temp2 
&dA 
&dA &d@                  2. Create space at c13+1 
&dA 
                          loop for c14 = outpnt to c13 + 1 step -1 
                            tget [Y,c14] temp3 
                            tput [Y,c14+1] ~temp3 
                          repeat 
&dA 
&dA &d@                  3. Add pseudo text record at c13+1 
&dA 
                          temp3 = "T 0 " // chs(c15) // " ~ * 0" 
                          tput [Y,c13+1] ~temp3 
&dA 
&dA &d@                  4. Increment outpnt 
&dA 
                          ++outpnt 
                          c13 = 1        /* end of loop 
                        end 
                      repeat 
                    end 
                  repeat 
                end 
              end 
            end 
&dA 
&dA 
&dA                                                                

            note_dur = ts(c1,NOTE_DUR)            /* Added &dA11-11-93&d@ 

            if nodtype <= REST
              passtype = REG          
              passsize = FULLSIZE 
              if bit(16,ts(c1,SUBFLAG_1)) = 1 
                passsize = CUESIZE                /* EXPERIMENT  &dA06-24-94&d@ 
              end 
            else
              passsize = CUESIZE 
              if nodtype <= CUE_REST
                passtype = CUE
              else
                passtype = GRACE
              end
            end
&dA 
&dA &d@     a) rests 
&dA 
            if nodtype = REST or nodtype = CUE_REST
              color_flag = ts(c1,SUBFLAG_1) >> 28   /* Added &dA12/21/10&d@ 
              c3 = ts(c1,STAFF_NUM) * 1000 
              perform setrest (c9)                          /*  OK 6-23-93 
              goto ZZZZ  
            end  
&dA 
&dA &d@     b) arpeggios  (New code &dA01/13/06&d@) 
&dA 
            if nodtype = GR_NOTE and ntype = ARPEGGIO 
              perform setarpeggio 
              goto ZZZZ 
            end 
&dA 
&dA &d@     c) notes 
&dA 
&dA &d@        leger lines  hpar(82) =  width of black note (for typesetting) 
&dA &d@                     hpar(83) =  width of whole note (for typesetting) 
&dA 
            c7 = c2 
            c8 = c1 
            c9 = 0 
            stem = bit(1,ts(c1,STEM_FLAGS))  
            if stem = UP 
              chord_spread = ts(c2,STAFFLOC) - ts(c1,STAFFLOC) 
            else 
              chord_spread = ts(c1,STAFFLOC) - ts(c2,STAFFLOC) 
            end 
            super_flag = 0 
            slur_flag = 0 
            loop for c3 = c1 to c2 
              super_flag |= ts(c3,SUPER_FLAG) 
              slur_flag  |= ts(c3,SLUR_FLAG) 
            repeat 
            if ntype > HALF
              c9 = hpar(83) - hpar(82) + 1 
            end  
            perform setleger                      /* looks O.K. 6-24-93 
&dA 
&dA &d@        accidentals 
&dA 
            loop for c3 = c1 to c2 
              color_flag = ts(c3,SUBFLAG_1) >> 28   /* New &dA12/21/10&d@ 
              c4 = ts(c3,AX) 
              if c4 > 0 
                y = ts(c3,STAFFLOC) 
                perform setax                     /* looks O.K. 6-24-93 
              end 
            repeat 
&dA 
&dA &d@        note heads and dots  &dA01/08/11&d@  adding square/diamond notation 
&dA 
            if (ts(c1,SUBFLAG_1) & 0x8000) = 0    /* modern notation 
              if ntype > 10 
                z1 = 1015 - ntype 
              else 
                z1 = 50 - ntype             /* music font 
                if z1 > 43                  /* music font 
                  z1 = 43                   /* music font 
                end 
              end 
              if passsize = CUESIZE 
                z1 += 128                   /* music font 
              end 
            else 
              if ntype > 10 
                z1 = 1015 - ntype 
              else 
                z1 = 1014 - ntype 
                if z1 > 1008 
                  z1 = 1008 
                end 
              end 
            end 
&dA 
&dA &d@        Adding code for percussion note heads &dA02/19/06&d@ 
&dA 
            c4 = ts(c1,SUBFLAG_1) & 0xf00000 
            if c4 > 0 
              c4 >>= 20 
              if c4 = 1 
                z1 = 1001                 /* extended music font 
                if passsize = CUESIZE 
                  ++z1                    /* 
                end 
              end 
            end 
&dA     
            color_flag2 = 0                         /* Added &dA12/21/10&d@ 
            loop for c3 = c1 to c2 
              color_flag = ts(c3,SUBFLAG_1) >> 28   /* Added &dA12/21/10&d@ 
              color_flag2 |= color_flag             /* Added &dA12/21/10&d@ 
              if c3 = c1 
                obx = ts(c1,GLOBAL_XOFF) + p 
              end 
              x = obx + ts(c3,LOCAL_XOFF) 
              y = ts(c3,STAFFLOC) 
              z = z1 
&dA 
&dA &d@    Adding code &dA11/26/06&d@ to allow for mixed note_head types in chords 
&dA 
              if mixed_note_head_flag > 0 
                z = 50 - ts(c3,NTYPE) 
                if z > 43                                 /* music font 
                  z = 43                                  /* music font 
                end                                       /* music font 
                if passsize = CUESIZE 
                  z += 128 
                end                                       /* music font 
              end 
&dA 
&dA            &d@ End of &dA11/26/06&d@ Addition 

              if color_flag > 0
                perform subj3 (color_flag)      /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
              c16 = y / notesize 
              if c16 <= 0 
                --c16        /* guarentee c16 is above position for rem <> 0 
              end 

              c10 = rem 
              if y <= 0 - notesize 
                if c10 <> 0 
                  y = c16 + 1 * notesize 
                end 
                perform wideleger         /* looks O.K. 6-24-93 
              end 
              if y >= vpar(10) 
                if c10 <> 0 
                  y = c16 * notesize 
                end 
                perform wideleger 
              end 
              perform setdots             /* looks O.K. 6-24-93 
            repeat 
&dA 
&dA &d@        look for forward tie, slur and tuplet super-objects   
&dA 
            x = obx  
            y = oby  
            color_flag = color_flag2      /* New &dA12/21/10&d@ 
            perform superfor              /* operates on entire chord  
&dA 
&dA &d@        set certain articulations above or below notes or stems 
&dA 
            color_flag = color_flag2      /* New &dA12/21/10&d@ 
            perform setart                /* operates on entire chord 
&dA 
&dA &d@        if there are slurs entering or leaving this chord, adjust virtual 
&dA &d@           endpoints at this time.  
&dA 
            c14 = ts(c1,SLUR_X) 
            c8 = 0                          /* slur present flag 
            if c14 > 0 
              c5 = ts(c14,1) 
              c4 = ts(c14,3) 
              if c4 <> c5 
                c8 = 2                      /* slur present above (usually) 
              end 
              if c4 < c5 
                c5 = c4                     /* above 
              end 
              c4 = ts(c14,2) 
              c6 = ts(c14,4) 
              if c4 <> c6 
                c8 = 1                      /* slur present below (usually) 
              end 
              if c6 > c4 
                c4 = c6                     /* below 
              end 
              if stem = DOWN 
                c6 = c4 
                c4 = c5 
                c5 = c6 
                if c8 <> 0 
                  c8 = 3 - c8 
                end 
              end 
              loop for c6 = c1 to c2 
                ts(c6,VIRT_STEM) = c5 
                ts(c6,VIRT_NOTE) = c4 
              repeat 
            else 
              c5 = ts(c1,VIRT_STEM) 
              c4 = ts(c1,VIRT_NOTE) 
            end 
&dA 
&dA &d@        Set more indications  
&dA 
            color_flag = color_flag2      /* New &dA12/21/10&d@ 
            perform setperf               /* operates on entire chord 
            color_flag = 0                /* New &dA12/21/10&d@ 
&dA 
&dA &d@        Set forte and piano (New code &dA05/17/03&d@) 
&dA 
            c17 = ( ts(c1,SUBFLAG_1) | ts(c1,ED_SUBFLAG_1) ) & 0x00007c00  /* New &dA12/18/10
            if c17 > 0 
              c7 = stem 
              px = 0 
              py = 0 
              pyy = 0 
              pxx = 0 
              c5 = 14                       /* dynamics code = 14 
              perform getpxpy (c5,c1) 

              if bit(0,pcontrol) = 1 
                if bit(1,pcontrol) = 1 
                  if bit(2,pcontrol) = 0 
                    c7 = 1 - stem 
                  else 
                    c7 = stem 
                  end 
                end 
              end 

              c5 = ts(c1,VIRT_STEM) 
              c4 = ts(c1,VIRT_NOTE) 
              c13 = 0  
              perform yadjust 
              if c7 = stem 
                if stem = DOWN 
                  y = c5 + vpar(5) 
                else 
                  y = c4 + vpar(5) 
                end 
              else 
                if stem = UP  
                  y = c5 - vpar(2) 
                else 
                  y = c4 - vpar(2) 
                end 
              end 
              x = obx + px 
              if pyy = 1 
                y = py 
              else 
                y += py 
              end 
              c7 = c17 >> 10                /* potential range 1 to 31 

              c17 = ts(c1,ED_SUBFLAG_1) & 0x00007c00  /* New &dA12/18/10
&dA 
&dA &d@        Case I: regular dynmaics 
&dA 
              if c17 = 0 

&dA            &d@ New code &dA10/08/08&d@ and &dA01/12/09&d@ and &dA03/16/09&d@ 
&dA 
                if c7 = 16 or c7 = 17 or c7 = 18 
                  if c7 = 18             /* sff 
                    z = 111               /* music font 
                    perform subj 
                    x += hpar(63) 
                    z = 110               /* music font 
                    perform subj 
                    x += hpar(62) 
                    z = 110               /* music font 
                    perform subj 
                  else 
                    if c7 = 16 
                      z = 110 
                      perform subj       /* f 
                      x += hpar(140) 
                    else 
                      z = 109 
                      perform subj       /* m 
                      x += hpar(60) 
                      z = 110 
                    end 
                    perform subj 
                    x += hpar(140)       /* f 
                    z = 108 
                    perform subj 
                    x += hpar(62)        /* p 
                  end 
&dA            
                else 
                  if c7 < 5                   /* p, pp, ppp, pppp 
                    z = 108 
                    loop while c7 > 0 
                      perform subj 
                      x += hpar(60) 
                      --c7 
                    repeat 
                  else 
                    if c7 < 9                 /* f, ff, fff, ffff 
                      z = 110 
                      loop while c7 > 4 
                        perform subj 
                        x += hpar(140) 
                        --c7 
                      repeat 
                    else 
                      if c7 < 11              /* mp, mf 
                        z = 109                   /* music font 
                        perform subj 
                        x = obx + hpar(60) + px 
                        z = c7 * 2 + 90           /* music font 
                        perform subj 
                      else 
                        if c7 = 11            /* fp 
                          z = 110                 /* music font 
                          perform subj 
                          x = obx + hpar(140) + px 
                          z = 108                 /* music font 
                          perform subj 
                        else 
                          if c7 = 12          /* sfp 
                            z = 111               /* music font 
                            perform subj 
                            x = obx + hpar(63) + px 
                            z = 110               /* music font 
                            perform subj 
                            x += hpar(140) 
                            z = 108               /* music font 
                            perform subj 
                          else 
                            if c7 > 13          /* sfz, rfz 
                              z = c7 * 2 + 83       /* music font 
                              perform subj 
                              c8 = z - 48 
                              x = obx + hpar(c8) + px 
                            end 
                            z = 110                 /* music font 
                            perform subj 
#if SFZ 
                            x += hpar(62) 
                            z = 112                 /* music font 
                            perform subj 
#endif 
                          end 
                        end 
                      end 
                    end 
                  end 
                end 
              else 
&dA 
&dA &d@        Case II: editorial dynamics 
&dA 

&dA 
&dA &d@      Conditional code added &dA02/04/04&d@ to implement Roman editorial dynamics
&dA 
#if ROMAN_EDIT 
                ++sobcnt 
                sobx = x - obx 
                soby = y - oby 

&dA            &d@ New code &dA10/08/08&d@ 
&dA 
                if c7 = 16 
                  sobl(sobcnt) = "W " // chs(sobx) // " " // chs(soby) // " 31 ffp"
&dA            

                else 
                  if c7 < 5                   /* p, pp, ppp, pppp 
                    sobl(sobcnt) = "W " // chs(sobx) // " " // chs(soby) // " 31 "
                    loop while c7 > 0 
                      sobl(sobcnt) = sobl(sobcnt) // "p" 
                      --c7 
                    repeat 
                  else 
                    if c7 < 9                 /* f, ff, fff, ffff 
                      sobl(sobcnt) = "W " // chs(sobx) // " " // chs(soby) // " 31 "
                      loop while c7 > 4 
                        sobl(sobcnt) = sobl(sobcnt) // "f" 
                        --c7 
                      repeat 
                    else 
                      if c7 < 11              /* mp, mf 
                        sobl(sobcnt) = "W " // chs(sobx) // " " // chs(soby) // " 31 m"
                        if c7 = 9 
                          sobl(sobcnt) = sobl(sobcnt) // "p" 
                        else 
                          sobl(sobcnt) = sobl(sobcnt) // "f" 
                        end 
                      else 
                        if c7 = 11            /* fp 
                          sobl(sobcnt) = "W " // chs(sobx) // " " // chs(soby) // " 31 fp"
                        else 
                          if c7 = 12          /* sfp 
                            sobl(sobcnt) = "W " // chs(sobx) // " " // chs(soby) // " 31 sfp"
                          else 
                            if c7 > 13          /* sfz, rfz 
                              if c7 = 14 
                                sobl(sobcnt) = "W " // chs(sobx) // " " // chs(soby) // " 31 sf"
                              else 
                                sobl(sobcnt) = "W " // chs(sobx) // " " // chs(soby) // " 31 rf"
                              end 
#if SFZ 
                              sobl(sobcnt) = sobl(sobcnt) // "z" 
#endif 
                            end 
                          end 
                        end 
                      end 
                    end 
                  end 
                end 
#else 
&dA 
&dA &d@        Editorial dynamics using square brackets and the music font 
&dA 

&dA            &d@ New code &dA10/08/08&d@ 
&dA 
                if c7 = 16 
                  x -= hpar(116) 
                  y -= vpar(84) 
                  z = 195 
                  perform subj 
                  x += hpar(116) 
                  y += vpar(84) 
                  z = 253                     /* editorial f 
                  perform subj       /* f 
                  x += hpar(110) 
                  perform subj       /* f 
                  x += hpar(110) 
                  perform subj       /* p 
                  x += hpar(108) 
                  x += hpar(120) 
&dA            
                else 

                  if c7 < 5                   /* p, pp, ppp, pppp 
                    x -= hpar(114) 
                    y -= vpar(84) 
                    z = 195 
                    perform subj 
                    x += hpar(114) 
                    y += vpar(84) 
                    z = 251                       /* editorial p 
                    loop while c7 > 0 
                      perform subj 
                      x += hpar(108) 
                      --c7 
                    repeat 
                    x += hpar(120) 
                  else 
                    if c7 < 9                 /* f, ff, fff, ffff 
                      x -= hpar(116) 
                      y -= vpar(84) 
                      z = 195 
                      perform subj 
                      x += hpar(116) 
                      y += vpar(84) 
                      z = 253                     /* editorial f 
                      loop while c7 > 4 
                        perform subj 
                        x += hpar(110) 
                        --c7 
                      repeat 
                      x += hpar(119) 
                    else 
                      if c7 < 11              /* mp, mf 
                        x -= hpar(115) 
                        y -= vpar(84) 
                        z = 195 
                        perform subj 
                        x += hpar(115) 
                        y += vpar(84) 
                        z = 252                   /* editorial m 
                        perform subj 
                        x += hpar(109) 
                        if c7 = 9 
                          z = 251                 /* editorial p 
                          perform subj 
                          x += hpar(108) 
                          x += hpar(120) 
                        else 
                          z = 253                 /* editorial f 
                          perform subj 
                          x += hpar(110) 
                          x += hpar(119) 
                        end 
                      else 
                        if c7 = 11            /* fp 
                          x -= hpar(116) 
                          y -= vpar(84) 
                          z = 195 
                          perform subj 
                          x += hpar(116) 
                          y += vpar(84) 
                          z = 253                 /* editorial f 
                          perform subj 
                          x += hpar(110) 
                          z = 251                 /* editorial p 
                          perform subj 
                          x += hpar(108) 
                          x += hpar(120) 
                        else 
                          if c7 = 12          /* sfp 
                            x -= hpar(117) 
                            y -= vpar(84) 
                            z = 195 
                            perform subj 
                            x += hpar(117) 
                            y += vpar(84) 
                            z = 246               /* editorial s 
                            perform subj 
                            x += hpar(111) 
                            z = 253               /* editorial f 
                            perform subj 
                            x += hpar(110) 
                            z = 251               /* editorial p 
                            perform subj 
                            x += hpar(108) 
                            x += hpar(120) 
                          else 
                            if c7 > 13          /* sfz, rfz 
                              if c7 = 14 
                                x -= hpar(117) 
                                y -= vpar(84) 
                                z = 195 
                                perform subj 
                                x += hpar(117) 
                                y += vpar(84) 
                                z = 246           /* editorial s 
                                perform subj 
                                x += hpar(111) 
                              else 
                                x -= hpar(118) 
                                y -= vpar(84) 
                                z = 195 
                                perform subj 
                                x += hpar(118) 
                                y += vpar(84) 
                                z = 248           /* editorial r 
                                perform subj 
                                x += hpar(113) 
                              end 
                              z = 253             /* editorial f 
                              perform subj 
                              x += hpar(110) 
#if SFZ 
                              z = 247             /* editorial z 
                              perform subj 
                              x += hpar(112) 
#else 
                              x += hpar(119) 
#endif 
                            end 
                          end 
                        end 
                      end 
                    end 
                  end 
                end 
                y -= vpar(84) 
                z = 196 
                perform subj 
#endif 
&dA 
&dA    &d@  End of Conditional compile &dA02/04/04&d@ 
&dA 
              end 
            end 
&dA 
&dA &d@        End of New code &dA05/17/03&d@ 
&dA 
            loop for c3 = c1 to c2 
              ts(c3,VIRT_NOTE) = c4 
              ts(c3,VIRT_STEM) = c5 
            repeat 
&dA 
&dA &d@        set stems and beams for this note 
&dA 
            if stem = UP 
              c3 = c1 
            else 
              c3 = c2 
            end 
            color_flag = color_flag2      /* New &dA12/21/10&d@ 
            perform setstem        /* (revised for multiple notes) 
&dA 
&dA &d@        determine super-objects &dAwhich end&d@ on this note or which 
&dA &d@            contain this note (such as beams) 
&dA 
&dA &d@         1) beams 
&dA 
            if ts(c1,BEAM_FLAG) > 0  
              ++supcnt
              supnums(supcnt) = beampar(passtype,passnum,BM_SNUM)  
            end  
&dA 
&dA &d@         2) ties which end on this note                    
&dA 
            loop for c3 = c1 to c2 
              c7 = ts(c3,BACKTIE) 
              if c7 > 0 
                if c7 < INT10000         /* c7 = index to ts element which starts the tie
                  c7 = ts(c7,BACKTIE)    /* c7 now points to ROW of tiearr 
                else 
                  c7 -= INT10000 
                end 
                ++supcnt 
                supnums(supcnt) = tiearr(c7,TIE_SNUM) 
              end 
              ts(c3,BACKTIE) = c7        /* now set BACKTIE to point directly to ROW of tiearr
            repeat 
&dA 
&dA &d@         3) slurs      (revised for multiple notes)  
&dA 
            loop for c4 = 1 to 4 
              c5 = c4 * 2 - 1
              if bit(c5,slur_flag) = 1 
                ++supcnt
                supnums(supcnt) = slurar(c4,SL_SNUM) 
              end  
              if bit(c5+16,slur_flag) = 1 
                ++supcnt
                supnums(supcnt) = slurar(c4+4,SL_SNUM) 
              end  
            repeat 
&dA 
&dA &d@         4) tuplets    (revised for multiple notes)  
&dA 
            if bit(5,super_flag) = 1 
              ++supcnt
              supnums(supcnt) = tuar(passtype,passnum,TU_SNUM)  
            end  
&dA 
&dA &d@         5) long trills     (revised for multiple notes)  
&dA 
            if tsnum(passnum) > 0 and bit(3,super_flag) = 1    /* long trill ending
              ++supcnt 
              supnums(supcnt) = tsnum(passnum) 
            end  
&dA 
&dA &d@    New code (&dA11-11-93&d@)  Duration attribute of note 
&dA 
            ++sobcnt 
            sobl(sobcnt) = "A D " // chs(note_dur) // " " // chs(divspq*4) 
&dA 
&dA &d@    Write out Object Record and associated Sub-Objects  
&dA 
            out = chs(supcnt)  
            loop for c4 = 1 to supcnt  
              out = out // " " // chs(supnums(c4)) 
            repeat 
            if nodtype = GR_NOTE or nodtype = XGR_NOTE 
              jtype = "G" 
            else 
              jtype = "N" 
            end 
            jcode = ntype  
            pcode = sobcnt 
            c10 = ts(c1,STAFF_NUM) * 1000 
            oby += c10
&dA 
&dA &d@       Now look for print suggestions for this note object 
&dA 
            putobjpar = 0 
            c4 = ts(c1,TSR_POINT) 
            pcontrol = ors(tsr(c4){1})                  /* &dA05/02/03&d@ 
            px = ors(tsr(c4){3}) << 8 
            py = ors(tsr(c4){4}) << 16 
            c8 = ors(tsr(c4){2}) << 24 
            putobjpar = c8 + px + py + pcontrol         /* Note: order of data has been changed

            perform putobj                  
            oby -= c10
&dA 
&dA &d@    Write out completed Super-Objects and set up new ones 
&dA 
&dA &d@      1) Tuples 
&dA 
            if bit(5,super_flag) = 1      /*  (revised for multiple notes) 
&dA 
&dA &d@     Code added &dA05-31-95&d@ to prevent tuplets over "partial" beams from being 
&dA &d@        associated with those beams.  
&dA 
              if beampar(passtype,passnum,BM_TUPLE) > 0 
                if beampar(passtype,passnum,BM_READY) = 0 
                  beampar(passtype,passnum,BM_TUPLE) = 0 
                end 
              end 

              c8 = 1 
              t2 = 0 
              t1 = (tuar(passtype,passnum,TU_FSTEM) & 0xff) + stem 
              c9 = tuar(passtype,passnum,TU_Y1) 
              c11 = 0 
              goto TPF(tpflag+1) 
TPF(1):                                   /* default tuplet placement 
              if beampar(passtype,passnum,BM_TUPLE) > 0 
                c8 |= 0x08 
                t2 = beampar(passtype,passnum,BM_SNUM) 
                t1 = oby 
                if ts(c1,MULTI_TRACK) > 0 
                  c8 |= 0x10 
                else 
                  t1 += chord_spread 
                  c9 = tuar(passtype,passnum,TU_Y2) 
                end 
                c10 = tuar(passtype,passnum,TU_FSTEM) & 0xff00 
                c10 >>= 8 
                if bit(0,c10) = 1       /* bracket present &dA03-21-97&d@ 
                  c10 >>= 1 
                  c10 <<= 5 
                  c10 |= 0x02           /* add bracket 

                  if beampar(passtype,passnum,BM_TUPLE) = 2    /* this code expanded &dA05/06/03
                    if bit(4,c8) = 1 
                      c10 |= 0x04         /* tips up 
                    end 
                  else 
                    if bit(4,c8) = 0 
                      c10 |= 0x04         /* tips up 
                    end 
                  end 
                  c8 |= c10 
                end 
                goto TPFEC 
              else 
                if t1 = 0 
                  goto TPFEA 
                else 
                  goto TPFEB 
                end 
              end 
TPF(2):                                   /* place tuplet near note heads 
              if beampar(passtype,passnum,BM_TUPLE) > 0 
                c8 |= 0x08 
                t2 = beampar(passtype,passnum,BM_SNUM) 
                t1 = oby + chord_spread 
                c9 = tuar(passtype,passnum,TU_Y2) 
                c10 = tuar(passtype,passnum,TU_FSTEM) & 0xff00 
                c10 >>= 8 
                if bit(0,c10) = 1       /* bracket present &dA03-21-97&d@ 
                  c10 >>= 1 
                  c10 <<= 5 
                  c10 |= 0x02           /* add bracket 
                  if beampar(passtype,passnum,BM_TUPLE) = 1 
                    c10 |= 0x04         /* tips up 
                  end 
                  c8 |= c10 
                end 
                goto TPFEC 
              else 
                if t1 = 0 
                  goto TPFEA 
                else 
                  goto TPFEB 
                end 
              end 
TPF(3):                                   /* place tuplet near stems 
              if beampar(passtype,passnum,BM_TUPLE) > 0 
                c8 |= 0x18 
                t2 = beampar(passtype,passnum,BM_SNUM) 
                t1 = oby 
                c10 = tuar(passtype,passnum,TU_FSTEM) & 0xff00 
                c10 >>= 8 
                if bit(0,c10) = 1       /* bracket present &dA03-21-97&d@ 
                  c10 >>= 1 
                  c10 <<= 5 
                  c10 |= 0x02           /* add bracket 
                  if beampar(passtype,passnum,BM_TUPLE) = 2 
                    c10 |= 0x04         /* tips up 
                  end 
                  c8 |= c10 
                end 
                goto TPFEC 
              else 
                if t1 > 0 
                  goto TPFEA 
                else 
                  c11 = hpar(82)          /* shift for stems up 
                  goto TPFEB 
                end 
              end 
TPF(4):                                   /* place all tuplets above notes 
              if beampar(passtype,passnum,BM_TUPLE) > 0 
                t1 = oby 
                if stem = UP 
                  c8 |= 0x18 
                else 
                  c8 |= 0x08 
                  t1 += chord_spread 
                  c9 = tuar(passtype,passnum,TU_Y2) 
                end 
                t2 = beampar(passtype,passnum,BM_SNUM) 
                c10 = tuar(passtype,passnum,TU_FSTEM) & 0xff00 
                c10 >>= 8 
                if bit(0,c10) = 1       /* bracket present &dA03-21-97&d@ 
                  c10 >>= 1 
                  c10 <<= 5 
                  c10 |= 0x02           /* add bracket 
                  c8 |= c10 
                end 
                goto TPFEC 
              else 
                if t1 = 0 
                  c11 = hpar(82)
                end 
                goto TPFEB 
              end 
TPF(5):                                   /* place all tuplets below notes 
              if beampar(passtype,passnum,BM_TUPLE) > 0 
                t1 = oby 
                if stem = UP 
                  c8 |= 0x08 
                  t1 += chord_spread 
                  c9 = tuar(passtype,passnum,TU_Y2) 
                else 
                  c8 |= 0x18 
                end 
                t2 = beampar(passtype,passnum,BM_SNUM) 
                c10 = tuar(passtype,passnum,TU_FSTEM) & 0xff00 
                c10 >>= 8 
                if bit(0,c10) = 1       /* bracket present &dA03-21-97&d@ 
                  c10 >>= 1 
                  c10 <<= 5 
                  c10 |= 0x02           /* add bracket 
                  c10 |= 0x04           /* tips up 
                  c8 |= c10 
                end 
                goto TPFEC 
              else 
                if t1 > 0 
                  c11 = hpar(82)
                end 
                goto TPFEA 
              end 

TPFEA: 
              c9 = tuar(passtype,passnum,TU_Y2) + notesize 
              c9 += vpar(64) 
              if t1 > 0 
                c9 += vpar(7) 
                t1 = vpar(7)                       /* add distance if stem is down
              else 
                t1 = 0 
              end 
              c10 = notesize * 6 
              if c9 < c10 
                c9 = c10 
              end 
              t1 += oby + notesize + vpar(64)      /* t1 set above 
              if t1 < c10 
                t1 = c10 
              end 
              c10 = tuar(passtype,passnum,TU_FSTEM) & 0xff00 
              c10 >>= 8 
              if bit(0,c10) = 1       /* bracket present &dA03-21-97&d@ 
                c10 >>= 1 
                c10 <<= 5 
                c10 |= 0x02           /* add bracket 
                c10 |= 0x04           /* tips up  
                c8 |= c10 
              end 
              goto TPFEC 
TPFEB: 
              c9 = tuar(passtype,passnum,TU_Y2) - notesize 
              c10 = 0 - vpar(1)           /* OK 4-21-95 
              if t1 = 0 
                c9 -= vpar(7) 
                t1 = 0 - vpar(7)                   /* subtract distance if stem is up  
              else 
                t1 = 0 
              end 
              if c9 > c10 
                c9 = c10 
              end 
              t1 += oby - notesize                 /* t1 set above 
              if t1 > c10 
                t1 = c10 
              end 
              c10 = tuar(passtype,passnum,TU_FSTEM) & 0xff00 
              c10 >>= 8 
              if bit(0,c10) = 1       /* bracket present &dA03-21-97&d@ 
                c10 >>= 1 
                c10 <<= 5 
                c10 |= 0x02           /* add bracket 
                c8 |= c10 
              end 
TPFEC:        
              c9 -= tuar(passtype,passnum,TU_Y1) 
              t1 -= oby 
&dA 
&dA &d@       Convert c13 to 1000 * n1 + n2 and get x,y adjustments    New &dA11/05/05
&dA 
              c13 = ts(c1,TUPLE) & 0xffff 
              c17 = c13 >> 8 
              c13 &= 0xff 
              c17 *= 1000 
              c13 += c17 

              c17 = ts(c1,TUPLE) & 0xff0000       /* x adjustment 
              c17 >>= 16 
              if c17 > 0 
                c16 = c17 - 128                   /* center to zero 
              else 
                c16 = 0 
              end 
              c11 += c16 

              c17 = ts(c1,TUPLE) & 0xff000000     /* y adjustment 
              c17 >>= 24 
              if c17 > 0 
                c17 = c17 - 128                   /* center to zero 
              else 
                c17 = 0 
              end 
              c9 += c17 
              t1 += c17 
&dA        
              t3  = tuar(passtype,passnum,TU_SNUM)  
              ++outpnt 
              tput [Y,outpnt] H ~t3  X ~c8  ~c13  ~c16  ~c9  ~c11  ~t1  ~t2 
              tuar(passtype,passnum,TU_SNUM) = 0       /* &dA05/05/03&d@ adding this (from s2ed)     
              tpflag = global_tpflag 
            end  
&dA 
&dA &d@      2) Beams           (O.K. for multiple notes) 
&dA 
            if beampar(passtype,passnum,BM_READY) > 0 
              if notesize = 6 
                if beampar(passtype,passnum,BM_SIZE) = CUESIZE 
                  beamfont = 102                
                else 
                  beamfont = 103                 
                end 
              end 
              if notesize = 14 
                if beampar(passtype,passnum,BM_SIZE) = CUESIZE 
                  beamfont = 106                 
                else 
                  beamfont = 108                 
                end 
              end 
              if notesize = 16                  /* size-16 added &dA12/31/08&d@ 
                if beampar(passtype,passnum,BM_SIZE) = CUESIZE 
                  beamfont = 107                 
                else 
                  beamfont = 109                 
                end 
              end 
              if notesize = 18                  /* size-18 added &dA12/18/04&d@ 
                if beampar(passtype,passnum,BM_SIZE) = CUESIZE 
                  beamfont = 107                 
                else 
                  beamfont = 110                 
                end 
              end 
              if notesize = 21 
                if beampar(passtype,passnum,BM_SIZE) = CUESIZE 
                  beamfont = 109                 
                else 
                  beamfont = 112                 
                end 
              end 

              c4 = beampar(passtype,passnum,BM_CNT)        
              c5 = 1 
              c6 = 0 
              c7 = beampar(passtype,passnum,BM_STEM) << 1 
              loop for c3 = 1 to c4 
                c7 >>= 1 
                if c7 & 0x01 <> 1 
                  c6 = 1 
                end 
                c5 <<= 1 
              repeat 

              c7 += beampar(passtype,passnum,BM_SUGG)        /* New code &dA05/14/03

              out = chs(c7) // " "               /* first stem direction 
              c8 = beampar(passtype,passnum,BM_STEM) 
              if c6 = 0 or c8 = 0 
                out = out // "0 "                /* consistant stem directions 
              else 
                if c7 & 0x01 = UP                            /* New code &dA05/14/03
                  c5 -= 1                        /* c5 = 111 ... for number of notes
                  c8 = not(c8) & c5 
                end 
                out = out // chs(c8) // " " 
              end 
              out = out // chs(beamfont) // " " 
              out = out // chs(beampar(passtype,passnum,BM_READY))
              loop for c4 = 1 to beampar(passtype,passnum,BM_READY) 
                out = out // " " 
                out = out // chs(beamdata(passtype,passnum,c4))
              repeat 
              ++outpnt 

              if beampar(passtype,passnum,BM_COLOR) > 4 
                if beampar(passtype,passnum,BM_COLOR) = 5 
                  tput [Y,outpnt] P ~beampar(passtype,passnum,BM_SNUM)  B ~out
                else 
                  if beampar(passtype,passnum,BM_COLOR) = 6 
                    tput [Y,outpnt] P 0x00ff00 ~beampar(passtype,passnum,BM_SNUM)  B ~out
                  else 
                    tput [Y,outpnt] P 0x0000ff ~beampar(passtype,passnum,BM_SNUM)  B ~out
                  end 
                end 
              else 
                tput [Y,outpnt] H ~beampar(passtype,passnum,BM_SNUM)  B ~out
              end 

              beampar(passtype,passnum,BM_READY) = 0  
              beampar(passtype,passnum,BM_TUPLE) = 0 
              beampar(passtype,passnum,BM_COLOR) = 0 
            end  
&dA 
&dA &d@      3) Ties            (revised for multiple notes)  
&dA 
            tiecnt = 0 
            loop for c3 = c1 to c2 
              color_flag = ts(c3,SUBFLAG_1) >> 28   /* Added &dA12/21/10&d@ 
              c7 = ts(c3,BACKTIE) 
              if c7 > 0 
&dA 
&dA &d@        compute sitf (situation flag) 
&dA 
&dA &d@        Description of sitf:   range 1 to 16  
&dA &d@    
&dA &d@        If the range were from 0 to 15, then bits 3 to 0     
&dA &d@          would have the following meanings:  
&dA &d@    
&dA &d@                          zero          |         one 
&dA &d@                   -------------------------------------------- 
&dA &d@          bit 3:        tips down       |       tips up 
&dA &d@          bit 2:      note on space     |     note on line  
&dA &d@          bit 1:   no stem interfenence |   stem interference 
&dA &d@          bit 0:    staff interference  | no staff interference 
&dA 
                c9 = tiearr(c7,TIE_VLOC) 
                c10 = tiearr(c7,TIE_FHDIS)        /* local x-offset for first note
                c11 = ts(c3,LOCAL_XOFF)           /* local x-offset for second note
                c12 = tiearr(c7,TIE_FORCE)        /* force flag 
                if c12 = 3 
                  c12 = 9 
                end 
                c8 = ts(c3,MULTI_TRACK) 
                c6 = c8 >> 2                      /* multi-track flag 
                c8 &= 0x03                        /* mcat flag 
&dA 
&dA &d@             Modify multi-track flag under certain conditions 
&dA &d@                   &dAADDED   9-10-93&d@ 
&dA 
                if c6 > 0 
                  if ts(c3,PASSNUM) = 1 and bit(1,ts(c3,STEM_FLAGS)) = DOWN 
                    c6 = 0 
                  end 
                end 

                if c6 = 0 
                  if c8 < 2 
&dA 
&dA &d@             Rules for single note (or chord) of single part 
&dA 
                    if bit(2,ts(c3,STEM_FLAGS)) = 0 /* &dAsingle note&d@ 
                      c5 = tiearr(c7,TIE_FSTEM) + stem 
                      if c5 = 0 
                        sitf = 9                    /* both stems up 
                      else 
                        sitf = 1 
                      end 

                      if c12 > 0 
                        sitf = c12                  /* forced situation 
                      end 

                      if tiearr(c7,TIE_FSTEM) = UP and sitf < 9 
                        sitf += 2                   /* stem interference 
                      end 
                    else                            /* &dAchord&d@ 
                      if c3 < c2 
                        sitf = 1 
                      else 
                        sitf = 9 
                      end 

                      if c12 > 0 
                        sitf = c12                  /* forced situation 
                      end 

                      if sitf = 1 
                        if tiearr(c7,TIE_FSTEM) = UP  
                          if c10 = 0 
                            sitf += 2               /* stem interference 
                          end 
                        else 
                          if stem = DOWN and c3 <> c1 
                            if c11 = 0 
                              sitf += 2             /* stem interference 
                            end 
                          end 
                        end 
                      else 
                        if stem = DOWN 
                          if c11 = 0 
                            sitf += 2               /* stem interference 
                          end 
                        end 
                      end 
                    end 
                  else 
&dA 
&dA &d@             Rules for chords representing multiple parts 
&dA 
                    if c3 = c2                    /* bottom note of chord 
                      sitf = 9 
                    else 
                      sitf = 1 
                    end 

                    if c12 > 0 
                      sitf = c12                  /* forced situation 
                    end 

                    if c3 = c2 
                      if stem = DOWN 
                        sitf += 2                 /* stem interference 
                      end 
                    else 
                      if c3 = c1 
                        if tiearr(c7,TIE_FSTEM) = UP 
                          sitf += 2               /* stem interference 
                        end 
                      else 
                        if tiearr(c7,TIE_FSTEM) = UP or stem = DOWN 
                          sitf += 2               /* stem interference 
                        end 
                      end 
                    end 
                  end 
                else 
&dA 
&dA &d@             Rules for multiple passes on a staff 
&dA 
                  if c6 = 1 
                    sitf = 3 
                    if c12 = 9 
                      sitf = 11          
                    end 
                  else 
                    if c6 = 2 
                      sitf = 11 
                      if c12 = 1 
                        sitf = 3             
                      end 
                    else 
                      if c6 = 3 
                        if stem = UP 
                          sitf = 1 
                          if c12 > 0 
                            sitf = c12            /* forced situation 
                          end 
                          if tiearr(c7,TIE_FSTEM) = UP 
                            sitf += 2 
                          end 
                        else 
                          sitf = 11 
                          if c12 = 1 
                            sitf = 3 
                          end 
                        end 
                      end 
                    end 
                  end 
                end 
                c5 = c9 / notesize 
                if rem = 0 
                  sitf += 4                    /* note on line 
                end 
&dA 
&dA &d@       Note:  you won't know if there is staff interference until 
&dA &d@                   you know the final length of the tie 
&dA 
                c9 += tiearr(c7,TIE_STAFF) * 1000 
&dA 
&dA &d@            New code added &dA04/20/03&d@, modified &dA05/02/03&d@    
&dA 
                c13 = tiearr(c7,TIE_SUGG) & 0xff000000        /* length data
                c6  = tiearr(c7,TIE_SUGG) & 0xff0000          /* position flags
                c4  = tiearr(c7,TIE_SUGG) & 0xff00            /* x data 
                c5  = tiearr(c7,TIE_SUGG) & 0xff              /* y data 
                c13 >>= 24 
                c6 >>= 16 
                c4 >>= 8 
                if c4 > 0 
                  c4 = c4 - 128 * notesize / 10 
                end 
                if c5 > 0 
                  c5 = c5 - 128 * notesize / 10 
                end 
                if bit(2,c6) = 1 
                  c5 += 10000 
                end 
                c6 = 0 
                if c13 > 0 
                  c6 = c13 - 128 * notesize / 10 
                end 

          /* end New code 

                c8 = tiearr(c7,TIE_SNUM) 

                ++outpnt 
                if tiearr(c7,TIE_COLOR) > 4                /* New &dA12/21/10&d@ 
                  if tiearr(c7,TIE_COLOR) = 5 
                    tput [Y,outpnt] P ~c8  T ~c9  ~c10  ~c11  ~c4  ~c5  ~c6  ~sitf  0
                  else 
                    if tiearr(c7,TIE_COLOR) = 6 
                      tput [Y,outpnt] P 0x00ff00 ~c8  T ~c9  ~c10  ~c11  ~c4  ~c5  ~c6  ~sitf  0
                    else 
                      tput [Y,outpnt] P 0x0000ff ~c8  T ~c9  ~c10  ~c11  ~c4  ~c5  ~c6  ~sitf  0
                    end 
                  end 
                else 
                  tput [Y,outpnt] H ~c8  T ~c9  ~c10  ~c11  ~c4  ~c5  ~c6  ~sitf  0
                end 

                tiearr(c7,TIE_SNUM) = 0 
                ts(c3,BACKTIE) = 0 
              end 
&dA 
&dA &d@       If there is a tie leaving this note, build 
&dA &d@         up a new ROW element of tiearr 
&dA 
              if bit(0,ts(c3,SUPER_FLAG)) = 1 
*      identify free slice of tiearr 
                loop for c7 = 1 to MAX_TIES 
                  if tiearr(c7,TIE_SNUM) = 0 
                    goto X2 
                  end 
                repeat 
&dA 
&dA &d@          Here is where tiearr is built 
&dA 
X2:             ++tiecnt 
                tiearr(c7,TIE_SNUM)  = tv4(tiecnt,1) 
                tiearr(c7,TIE_NTYPE) = ts(c3,TYPE) 
                tiearr(c7,TIE_VLOC)  = ts(c3,STAFFLOC) 
                tiearr(c7,TIE_FHDIS) = ts(c3,LOCAL_XOFF) 
                tiearr(c7,TIE_FSTEM) = bit(1,ts(c3,STEM_FLAGS)) 
                tiearr(c7,TIE_NDX)   = c3 
                tiearr(c7,TIE_STAFF) = ts(c3,STAFF_NUM) 
                tiearr(c7,TIE_FOUND) = 0 
                tiearr(c7,TIE_FORCE) = ts(c3,SLUR_FLAG) >> 24 
       /* New code &dA04/20/03&d@ 
                c4 = ts(c3,TSR_POINT) 
                tiearr(c7,TIE_SUGG)  = ors(tsr(c4){69,4}) 
                tiearr(c7,TIE_COLOR) = tv4(tiecnt,2)            /* New &dA12/21/10

                ts(c3,BACKTIE) = c7        /* not used here as a back pointer 
              end 
            repeat 
&dA 
&dA &d@      4) Slurs           (revised for multiple notes) 
&dA 
            loop for c4 = 1 to 8 
              c5 = c4 * 2 - 1  
              if c4 > 4 
                c5 += 8 
              end 
&dA 
&dA &d@     end-slurs  
&dA &d@                       
&dA &d@       first element 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@          bit 27:     start/end flag (0 = start, 1 = end) 
&dA &d@          bits 24-26: slur number - 1 (0 to 7) 
&dA &d@          bits 17-23: curvature information (end only) 
&dA &d@          bit 16:     up/down flag (0 = tips up, 1 = tips down) (end only) 
&dA &d@          bits 0-15:  x-offset + 1000 (always a positive number) 
&dA &d@       second element 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@          y position relative to the staff 
&dA &d@       third element (&dA05/06/03&d@) 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@          print suggestion for this end of the slur 
&dA 
              if bit(c5,slur_flag) = 1 
                c14 = ts(c1,SLUR_X) 
                loop for c13 = 7 to (TS_SIZE - 2) step 3     /* &dA05/06/03&d@ 
                  c12 = ts(c14,c13)          
                  c11 = c12 >> 24 
                  if c11 = c4 + 0x0f       /* c4 - 1 + 0x10  (end of slur) 
                    c11 = c12 & 0xffff - 1000      /* x-offset 
                    c10 = bit(16,c12)              /* up/down flag 
                    c9  = c12 & 0x000e0000 >> 17   /* curvature (1 to 4) 
                    c8 = ts(c14,c13+1) - ts(c1,OBY) /* y-offset 
                    c15 = ts(c14,c13+2)            /* print suggestion at end of slur (&dA05/06/03&d@)
                    c13 = 100                      /* end of loop 
                  end 
                repeat 
                sitf = 0 
                if in_line_edslur > 0       /* New condition &dA01/12/09&d@ 
                  if c4 > 2 
                    sitf = 1                /* dotted slur 
                  end 
                else 
                  if c4 > 4 
                    sitf = 1                /* dotted slur 
                  end 
                end 
                if c10 = UP 
                  sitf += 12 
                end 
                c10 = slurar(c4,SL_SNUM)    /* slur number 
                c7  = slurar(c4,SL_YSHIFT)  /* starting y-shift 
                c6  = slurar(c4,SL_XSHIFT)  /* starting x-shift 
                c9 -= 1 
                c13 = slurar(c4,SL_BEAMF)   /* 0 = slur doesn't start on a beam                 
                                            /* 1 = slur starts on a stem up beam
                                            /* 2 = slur starts on a stem down beam
                c16 = slurar(c4,SL_SUGG)    /* print sugg. from beginning of slur (&dA05/06/03&d@)
                c12 = 0 
                if c13 > 0 
                  if bit(1,ts(c1,BEAM_FLAG)) = 1
                    if stem = UP and c8 < 0 - vpar(6) 
                      c12 = 1 
                    end 
                    if stem = DOWN and c8 > vpar(6) 
                      c12 = 2 
                    end 
                  end 
                  if c12 <> c13 
                    c12 = 0 
                  end 
                end 
&dA 
&dA &d@      Code added &dA04/26/05&d@ to implement suppression of slur printing 
&dA 
                if c16 = -1 
                  sitf = 32            
                  c16 = 0 
                end 
&dA         
                c17 = c16 >> 24                        /* relative x start 
                c17 &= 0xff 
                if c17 > 0 
                  c17 = c17 - 128 * notesize + 5 / 10 
                  c6 += c17 
                end 

                c17 = c16 & 0xff0000 >> 16             /* relative y start 
                if c17 > 0 
                  c17 = c17 - 128 * notesize + 5 / 10 
                  c7 += c17 
                end 

                c17 = c15 >> 24                        /* relative x end 
                c17 &= 0xff 
                if c17 > 0 
                  c17 = c17 - 128 * notesize + 5 / 10 
                  c11 += c17 
                end 

                c17 = c15 & 0xff0000 >> 16             /* relative y end  
                if c17 > 0 
                  c17 = c17 - 128 * notesize + 5 / 10 
                  c8 += c17 
                end 

                c17 = c15 & 0xff00 >> 8                /* change to curvature
                if c17 > 0 
                  c17 = c17 - 128 * notesize + 5 / 10 
                  c9 += c17 
                end 

                c17 = c16 & 0xff00 >> 8                /* global X shift 
                if c17 > 0 
                  c17 = c17 - 128 * notesize + 5 / 10 
                end 
                            
                c16 = c16 & 0xff                       /* global Y shift 
                if c16 > 0 
                  c16 = c16 - 128 * notesize + 5 / 10 
                end 

                ++outpnt 
                tput [Y,outpnt] H ~c10  S ~sitf  ~c6  ~c7  ~c11  ~c8  ~c9  ~c12  ~c17  ~c16
              end  
&dA 
&dA &d@     beginning-slurs  
&dA 
              --c5
              if bit(c5,slur_flag) = 1  
                c14 = ts(c1,SLUR_X) 
                loop for c13 = 7 to (TS_SIZE - 2) step 3     /* &dA05/06/03&d@ 
                  c12 = ts(c14,c13)          
                  c11 = c12 >> 24 
                  if c11 = c4 - 1                  /* c4 - 1  (beginning of slur)
                    c11 = c12 & 0xffff - 1000      /* x-offset 
                    c8 = ts(c14,c13+1) - ts(c1,OBY) /* y-offset 
                    c15 = ts(c14,c13+2)            /* print suggestion at beginning of slur
                    c13 = 100                      /* end of loop 
                  end 
                repeat 
                if c13 < 100 
                  tmess = 37 
                  perform dtalk (tmess) 
                end 
                c12 = 0 
                if ts(c1,BEAM_FLAG) > 1 
                  if stem = UP and c8 < 0 - vpar(6) 
                    c12 = 1 
                  end 
                  if stem = DOWN and c8 > vpar(6) 
                    c12 = 2 
                  end 
                end 
                slurar(c4,SL_SNUM)   = slurar(c4,SL_NEXTSNUM) 
                slurar(c4,SL_YSHIFT) = c8 
                slurar(c4,SL_XSHIFT) = c11 
                slurar(c4,SL_BEAMF)  = c12  /* 0 = slur doesn't start on a beam
                                            /* 1 = slur starts on a stem up beam
                                            /* 2 = slur starts on a stem down beam
                slurar(c4,SL_SUGG)   = c15  /* (&dA05/06/03&d@) 
              end  
            repeat 
&dA 
&dA &d@      5) Long Trills  
&dA 
            if bit(3,super_flag) = 1 and tsnum(passnum) > 0 
              out = "H " // chs(tsnum(passnum)) // " R " // chs(ctrarrf(passnum))
              out = out // " 0" 
              ++outpnt 
              if nodtype = GR_NOTE or nodtype = XGR_NOTE
                tput [Y,outpnt] ~out  0 ~try(passnum) 
              else 
                tput [Y,outpnt] ~out  -~hpar(42)  ~try(passnum) 
              end  
              tsnum(passnum) = 0 
              ctrarrf(passnum) = 0 
            end  
            if pre_tsnum(passnum) > 0                  /* substitute preliminary values
              tsnum(passnum) = pre_tsnum(passnum) 
              ctrarrf(passnum) = pre_ctrarrf(passnum) 
              try(passnum) = pre_try(passnum) 
              pre_tsnum(passnum) = 0 
            end 
ZZZZ: 
          repeat 
          p += a4    

&dA 
&dA &d@    Now that you are all done with the notes and rests of 
&dA &d@       this node, you may set the new inctype 
&dA 
          if ts(a1,DINC_FLAG) > 0 
            inctype = ts(a1,DINC_FLAG) 
          end  
          a1 = a2  
ZZZ:    repeat     
&dA 
&dA &d@    End of processing loop  
&dA &d@************************************************************* 
&dA 
ACT_RETURN: 
        loop for t1 = 1 to 50 
          loop for t2 = 1 to 4                      
            measax(t2,t1) = tclaveax(t1)            
          repeat 
        repeat 
      return   

&dA  ****************************************************************  
&dA ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ» 
&dA º        E N D   O F    P R O C E D U R E    A C T I O N         º 
&dA ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼ 
&dA  **************************  action *****************************  

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P*  4. getpxpy (code,index)     &dA04-08-97&d@ added index variable         ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Purpose:  Save space; get values of px, py, pxx, pyy for          ³          
&dA &d@³              position modification                                   ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Inputs:      code = type of subobject referred to                 ³ 
&dA &d@³                 index = index into ts array                          ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Outputs:     pcontrol                                             ³ 
&dA &d@³                 px                                                   ³ 
&dA &d@³                 py                                                   ³ 
&dA &d@³                 pxx  (1 = absolute, 0 = relative)                    ³           
&dA &d@³                 pyy  (1 = absolute, 0 = relative)                    ³ 
&dA &d@³                                                                      ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure getpxpy (code,index) 
        int t2,t3 
        int code,index 

        getvalue code,index 

        ++code                                      /* all New code &dA05/02/03
        code <<= 2 
        px = 0 
        py = 0 
        pxx = 0 
        pyy = 0                                     
        t2 = ts(index,TSR_POINT) 
        pcontrol = ors(tsr(t2){code-3}) 
        t3 = ors(tsr(t2){code-2}) 

        if bit(0,t3) = 1 
          px = ors(tsr(t2){code-1}) 
          if px > 0 
            px = px - 128 * notesize / 10 
            pxx = t3 & 0x02 >> 1 
          end 
          py = ors(tsr(t2){code}) 
          if py > 0 
            py = py - 128 * notesize / 10 
            pyy = t3 & 0x04 >> 2 
          end 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P*  5. setstem                                                        ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Purpose:  Generate subobjects for note stem, or construct         ³ 
&dA &d@³              beamdata parameters for setting beam.  When beam        ³ 
&dA &d@³              is complete, this procedure will call guessbeam.        ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Inputs:      stem = stem direction  (0=UP, 1=DOWN)                ³ 
&dA &d@³                ntype = type of note                                  ³ 
&dA &d@³             passtype = type of pass (reg,cue,grace,cuegrace)         ³ 
&dA &d@³             passsize = size of notes (full size vs. cue-size)        ³ 
&dA &d@³              passnum = pass number                                   ³ 
&dA &d@³                  obx = x co-ordinate of object                       ³ 
&dA &d@³                  oby = y co-ordinate of object                       ³ 
&dA &d@³                   c1 = pointer to top note head in array             ³ 
&dA &d@³                   c2 = pointer to bottom note head in array          ³ 
&dA &d@³                   c3 = pointer to note head at top of stem           ³ 
&dA &d@³           super_flag = composite of SUPER_FLAGs for this chord       ³ 
&dA &d@³           color_flag = put out stems in color  (&dA12/21/10&d@)            ³ 
&dA &d@³                                                                      ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setstem  
        str temp.80 
        int t2,t3,t4,t5,t11,t12,t13,t14,t15 
        int bcount,note_style 
&dA 
&dA &d@      Determine note style (New &dA01/08/11&d@) 
&dA 
        note_style = ts(c1,SUBFLAG_1) & 0x8000 
        note_style >>= 15 
&dA 
&dA &d@      Determine number of repeaters in "single note" case 
&dA 
        t11 = 0 
        if ts(c1,BEAM_FLAG) = NO_BEAM and ts(c1,BEAM_CODE) > 0 
          t12 = ts(c1,BEAM_CODE) 
          loop 
            t12 /= 10 
            ++t11 
          repeat while t12 > 0 
        end 

        if ntype >= WHOLE 
          if t11 > 0 
            y = ts(c1,STAFFLOC) - vpar(3) 
            z = 127 
            loop for t12 = 1 to t11 
              if color_flag > 0 
                perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
              y -= vpar(2) 
            repeat 
          end 
          if ntype > BREVE 
            z = 60 
            y = oby 
            if ntype = LONGA 
              x = obx + hpar(143) 
            else 
              x = obx + hpar(144) 
            end 
            if stem = 1 
              if color_flag > 0
                perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
              y += vpar(2) 
              if color_flag > 0
                perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
            else 
              y -= vpar(4) 
              if color_flag > 0
                perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
              y -= vpar(2) 
              if color_flag > 0
                perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
            end 
          end 
        else               
          x = obx  
          if note_style = 0               /* New &dA01/08/11&d@ 
            z = 59 + stem                 /* music font 
            if passsize = CUESIZE 
              z += 128                    /* music font 
            end 
          else 
            z = 1009                      /* music font 
          end 
&dA 
&dA &d@  Connect notes of chord 
&dA 
          if c1 <> c2 
            if stem = UP 
              y = ts(c2,STAFFLOC) 
              loop while y > ts(c1,STAFFLOC) 
                if color_flag > 4 
                  perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                else 
                  perform subj 
                end 
                y -= vpar(4) 
              repeat 
            else 
              y = ts(c1,STAFFLOC) 
              loop while y < ts(c2,STAFFLOC) 
                if color_flag > 4 
                  perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                else 
                  perform subj 
                end 
                y += vpar(4) 
              repeat 
            end  
          end 
          y = ts(c3,STAFFLOC)  
          if ntype > EIGHTH
&dA 
&dA &d@  Quarter notes and larger  
&dA 
&dA &d@      First deal with square/diamond notation   &dA01/08/11&d@ 
&dA 
            if note_style = 1 
              y = oby - vpar(1) 
              z = 1009 
              if color_flag > 4 
                perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
              return 
            end 
&dA      
            if ts(c1,BEAM_FLAG) = NO_BEAM

              c16 = y + vpar20 * 2 + 1 / vpar(2) - 20 
              t3 = c16 + 2 

              if stem = UP 
                if t11 = 0 
                  t2 = 8 
                  if t3 <= 0 
                    t2 = t3 - 3 
                  else 
                    if t3 < 7 
                      t2 = t3 - 4 
                    else 
                      if t3 < 13 
                        t2 = t3 - 5 
                      end 
                    end 
                    if passsize = CUESIZE 
                      ++t2 
                    end 
                  end 
                  t2 = t2 + 20 * vpar(2) / 2 - vpar20 

                else 
                  t13 = y / notesize 
                  t14 = rem 
                  if t14 = 0 
                    t15 = 3                       /* tricky code 
                  else 
                    t15 = 2 
                  end 
                  t2 = y - vpar(t15) - vpar(79) 
                  loop for t13 = t15 to t11 
                    t2 -= vpar(2) 
                  repeat 
                  t12 = vpar(77) + vpar(6) 
                  if t2 > t12 
                    t2 = t12 
                  end 
                  if t14 <> 0 and t11 = 1 
                    t14 = y 
                    y = t2 - vpar(80) 
                    if color_flag > 4 
                      perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                    else 
                      perform subj 
                    end 
                    y = t14 
                  end 
                end 
&dA    
&dA &d@          Raise bottom of stem if percussion note head  &dA02/19/06&d@ 
&dA 
                t13 = ts(c1,SUBFLAG_1) & 0xf00000 
                if t13 > 0 
                  t13 >>= 20 
                  if t13 = 1 
                    y -= (vpar(1) - 1) 
                  end 
                end 
&dA    
                loop while y > t2 
                  if color_flag > 4 
                    perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                  y -= vpar(4) 
                repeat 
                y = t2 
                if color_flag > 4 
                  perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                else 
                  perform subj 
                end 
                if t11 > 0 
                  y -= vpar(81) 
                  if ts(c1,TUPLE) > 0 
&dA 
&dA &d@            New &dA11/05/05&d@  Convert tuple to 1000 * n1 + n2 
&dA 
                    t13 = ts(c1,TUPLE) & 0xffff 
                    t14 = t13 >> 8 
                    t13 &= 0xff 
                    t14 *= 1000 
                    t13 += t14 
&dA         
                    t14 = x + hpar(102) 
                    t15 = y - vpar(82) 
                    perform typeset_tuple (t13,t14,t15) 
                  end 
                  z = 125                       /* music font (repeater quarters)
                  loop for t2 = 1 to t11 
                    if color_flag > 4 
                      perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                    else 
                      perform subj 
                    end 
                    y += vpar(2) 
                  repeat 
                end 
              else 
                if t11 = 0 
                  t2 = 0 
                  if t3 > 11 
                    t2 = t3 - 1 
                  else 
                    if t3 > 6 
                      t2 = t3 
                    else 
                      if t3 >= 0 
                        t2 = t3 + 1 
                      end 
                    end 
                    if passsize = CUESIZE 
                      --t2 
                    end 
                  end 
                  t2 = t2 * notesize / 2 
                else 
                  t13 = y / notesize 
                  t14 = rem 
                  if t14 = 0 
                    t15 = 3                       /* tricky code 
                  else 
                    t15 = 2 
                  end 
                  t2 = y + vpar(t15) + vpar(79) 
                  loop for t13 = t15 to t11 
                    t2 += vpar(2) 
                  repeat 
                  t12 = vpar(78) - vpar(4) 
                  if t2 < t12 
                    t2 = t12 
                  end 
                  if t14 <> 0 and t11 = 1 
                    t14 = y 
                    y = t2 + vpar(80) 
                    if color_flag > 4 
                      perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                    else 
                      perform subj 
                    end 
                    y = t14 
                  end 
                end 
&dA 
&dA &d@     Adding code (&dA12/10/03&d@) to decrease down stem for music with text for notes
&dA &d@       where note is on middle line of staff or one step above that.  
&dA 
                t15 = ts(c3,TEXT_INDEX) 
                if t15 > 0 
                  temp = trm(tsdata(t15)) 
                  if temp <> "" 
                    t13 = ts(c3,STAFFLOC) 
                    t14 = notesize << 1 
                    t15 = notesize + 1 
                    if t13 <= t14 and t13 > t15 
                      t2 -= (notesize >> 1) 
                    end 
                  end 
                end 
&dA   

&dA    
&dA &d@          Lower top of stem if percussion note head  &dA02/19/06&d@ 
&dA 
                t13 = ts(c1,SUBFLAG_1) & 0xf00000 
                if t13 > 0 
                  t13 >>= 20 
                  if t13 = 1 
                    y += (vpar(1) - 1) 
                  end 
                end 
&dA    
                loop while y < t2 
                  if color_flag > 4 
                    perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                  y += vpar(4) 
                repeat 
                y = t2 
                if color_flag > 4 
                  perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                else 
                  perform subj 
                end 
                if t11 > 0 
                  if ts(c1,TUPLE) > 0 
&dA 
&dA &d@            New &dA11/05/05&d@  Convert tuple to 1000 * n1 + n2 
&dA 
                    t13 = ts(c1,TUPLE) & 0xffff 
                    t14 = t13 >> 8 
                    t13 &= 0xff 
                    t14 *= 1000 
                    t13 += t14 
&dA         
                    t14 = x + hpar(103) 
                    t15 = ts(c1,STAFFLOC) - vpar(82) 
                    perform typeset_tuple (t13,t14,t15) 
                  end 
                  y += vpar(81) 
                  z = 125                       /* music font (repeater quarters)
                  x -= hpar(101) 
                  loop for t2 = 1 to t11 
                    if color_flag > 4 
                      perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                    else 
                      perform subj 
                    end 
                    y -= vpar(2) 
                  repeat 
                  x += hpar(101) 
                end 
              end 
            else 
*   2) Beams 
              if ts(c1,BEAM_FLAG) = START_BEAM
                bcount = 1 
                ++snum
                beampar(passtype,passnum,BM_SNUM) = snum 
                if bit(4,super_flag) = 1 
                  beampar(passtype,passnum,BM_TUPLE) = 1 + stem 
                end  
                beampar(passtype,passnum,BM_STEM) = stem 
                beampar(passtype,passnum,BM_SIZE) = passsize 

                t2 = ts(c1,TSR_POINT)               /* New code &dA05/14/03&d@ 
                t3 = 28                             /* 28 = code for beam suggestion
                ++t3 
                t3 <<= 2                            /* 116 
                py = ors(tsr(t2){t3-2}) 
                t4 = 0 
                if py > 0 
                  py = py - 128
                  if py > 0 
                    t4 = INT100 * py 
                  else 
                    py = 0 - py 
                    t4 = INT100 * INT100 * py 
                  end 
                end                                               
                beampar(passtype,passnum,BM_SUGG) = t4   /* End new code &dA05/14/03

              else 
                bcount = beampar(passtype,passnum,BM_CNT) + 1 
                beampar(passtype,passnum,BM_STEM) <<= 1 
                beampar(passtype,passnum,BM_STEM) += stem 
                if passsize < beampar(passtype,passnum,BM_SIZE) 
                  beampar(passtype,passnum,BM_SIZE) = passsize 
                end 
              end  
              beamdata(passtype,passnum,bcount) = ts(c1,BEAM_CODE)  
              beampar(passtype,passnum,BM_CNT) = bcount 
              if ts(c1,BEAM_FLAG) = END_BEAM
                beampar(passtype,passnum,BM_READY) = bcount 
              end  
              beampar(passtype,passnum,BM_COLOR) |= color_flag    /* New &dA12/21/10
            end  
          else 
&dA 
&dA &d@  Eighth notes or smaller 
&dA 
            if ts(c1,BEAM_FLAG) = NO_BEAM
*   1) Flags   
&dA 
&dA &d@      First deal with square/diamond notation   &dA01/08/11&d@ 
&dA 
              if note_style = 1 
                z = 1010 
                if ntype = EIGHTH 
                  y = oby - vpar(1) 
                  if color_flag > 4 
                    perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                  return 
                end 
                if ntype = SIXTEENTH 
                  t3 = vpar(1) * 3 / 7 
                  y = oby - t3      
                  if color_flag > 4 
                    perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                  t3 = vpar(1) * 10 / 7 
                  y = oby - t3      
                  if color_flag > 4 
                    perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                  return 
                end 
              end 
&dA      
              if passtype = GRACE and ntype = SLASH8 
                if stem = UP 
                  z = 179                   /* music font 
                else 
                  z = 180                   /* music font 
                end 
                y = ts(c3,STAFFLOC) 
                if color_flag > 4 
                  perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                else 
                  perform subj 
                end 
              else 
                if stem = UP 
                  if ntype = EIGHTH 
                    t3 = 53                 /* music font (eighth flag) 
                    if y <= vpar(4) and passtype = REG and t11 = 0 
                      t3 = 51             /* music font (shortened eighth flag)
                    end 
                    t2 = 10 * notesize / 2 
                  else 
                    t3 = 55                 /* music font (sixteenth flag) 
                    t2 = 0 - ntype * 2 + 20 * notesize / 2 
                  end 
                  z = 59                    /* music font (standard up stem) 
                  t4 = notesize 
                  t5 = 57                   /* music font (extra flag: 32nds, etc)
                  if passsize = CUESIZE 
                    t2 -= vpar(1) 
                    t3 += 128               /* music font 
                    z += 128                /* music font 
                    t4 = vpar(36) 
                    t5 += 128               /* music font 
                  end 
                  loop while y > t2 
                    if color_flag > 4 
                      perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                    else 
                      perform subj 
                    end 
                    y -= vpar(4) 
                  repeat 
                  c16 = t2 * 2 / vpar(2) 
                  if rem <> 0 
                    ++t2 
                  end 
                  t2 += vpar(1) 

                  y = ts(c3,STAFFLOC) 
                  if t11 = 0                /* no repeaters 
                    z = t3                  /* music font (flag character) 
                    if y > t2 
                      y = t2 
                    end 
                    if color_flag > 4 
                      perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                    else 
                      perform subj 
                    end 
                    if ntype < 5 
                      z = t5                  /* music font (extra flag) 
                      loop for t3 = 1 to 5-ntype 
                        y -= t4 
                        if color_flag > 4 
                          perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                        else 
                          perform subj 
                        end 
                      repeat 
                    end 
                  else 
                    t12 = y / notesize 
                    t2 += t11 - 1 * notesize 
                    if y > t2 or rem <> 0       /* note on space 
                      t13 = t11 - 1 * notesize + vpar(67)             
                      t14 = vpar(69)   
                    else                        /* note on line 
                      t13 = t11 - 1 * notesize + vpar(68)            
                      t14 = vpar(70)   
                    end 
&dA 
&dA &d@       t13 = amount to "lengthen" stem 
&dA &d@       t14 = location of first repeater 
&dA 
                    if y > t2 
                      y = t2 
                    end 
                    t15 = y 
                    loop 
                      if color_flag > 4 
                        perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                      else 
                        perform subj 
                      end 
                      y -= vpar(4) 
                    repeat while y > t15 - t13 
                    y = t15 - t13 
                    z = t3 
                    if color_flag > 4 
                      perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                    else 
                      perform subj 
                    end 
                    if ntype < 5 
                      z = t5                  /* music font (extra flag) 
                      loop for t3 = 1 to 5-ntype 
                        y -= t4 
                        if color_flag > 4 
                          perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                        else 
                          perform subj 
                        end 
                      repeat 
                    end 
                    y = t15 - t14 
                    z = 126                   /* music font (repeater for eights)
                    x = x - hpar(99)   
                    loop for t12 = 1 to t11 
                      if color_flag > 4 
                        perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                      else 
                        perform subj 
                      end 
                      y -= notesize 
                    repeat 
                    x = x + hpar(99)  
                    if ts(c1,TUPLE) > 0 
&dA 
&dA &d@              New &dA11/05/05&d@  Convert tuple to 1000 * n1 + n2 
&dA 
                      t13 = ts(c1,TUPLE) & 0xffff 
                      t14 = t13 >> 8 
                      t13 &= 0xff 
                      t14 *= 1000 
                      t13 += t14 
&dA         
                      t14 = x + hpar(102)  
                      t15 = y - vpar(83) 
                      perform typeset_tuple (t13,t14,t15) 
                    end 
                  end 
                else 
                  if ntype = EIGHTH 
                    t3 = 54                 /* music font (eighth flag) 
                    if y >= vpar(5) and passtype = REG and t11 = 0 
                      t3 = 52               /* music font (shortened eighth flag)
                    end 
                    t2 = 0 - 2 * notesize / 2 
                  else 
                    t3 = 56                 /* music font (sixteenth flag) 
                    t2 = 2 * ntype - 12 * notesize / 2 
                  end 
                  z = 60                    /* music font (standard down stem) 
                  t4 = notesize 
                  t5 = 58                   /* music font (extra flag) 
                  if passsize = CUESIZE 
                    t2 += vpar(1) 
                    t3 += 128               /* music font 
                    z += 128                /* music font 
                    t4 = vpar(36) 
                    t5 += 128               /* music font 
                  end 
                  loop while y < t2 
                    if color_flag > 4 
                      perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                    else 
                      perform subj 
                    end 
                    y += vpar(4) 
                  repeat 
                  t2 -= vpar(1) 
                  c16 = t2 * 2 / vpar(2) 
                  if rem <> 0 
                    --t2 
                  end 

                  y = ts(c3,STAFFLOC) 
                  if t11 = 0 
                    z = t3                    /* music font (flag character) 
                    if y < t2 
                      y = t2 
                    end 
                    if color_flag > 4 
                      perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                    else 
                      perform subj 
                    end 
                    if ntype < 5 
                      z = t5                  /* music font 
                      loop for t3 = 1 to 5-ntype 
                        y += t4 
                        if color_flag > 4 
                          perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                        else 
                          perform subj 
                        end 
                      repeat 
                    end 
                  else 
                    t12 = y / notesize 
                    t2 -= t11 - 1 * notesize 
                    if y < t2 or rem <> 0     /* note on space 
                      if t11 = 2 
                        t13 = notesize - vpar(71)
                      else 
                        t13 = t11 - 1 * notesize - vpar(72)
                      end 
                      t14 = vpar(75)
                    else                      /* note on line 
                      if t11 = 2 
                        t13 = notesize - vpar(73)
                      else 
                        t13 = t11 - 1 * notesize - vpar(74)
                      end 
                      t14 = vpar(76)
                    end 
&dA 
&dA &d@       t13 = amount to "lengthen" stem 
&dA &d@       t14 = location of first repeater 
&dA 
                    if y < t2 
                      y = t2 
                    end 
                    t15 = y 
                    loop 
                      if color_flag > 4 
                        perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                      else 
                        perform subj 
                      end 
                      y += vpar(4) 
                    repeat while y < t15 + t13 
                    y = t15 + t13 
                    z = t3 
                    if color_flag > 4 
                      perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                    else 
                      perform subj 
                    end 
                    if ntype < 5 
                      z = t5                  /* music font (extra flag) 
                      loop for t3 = 1 to 5-ntype 
                        y += t4 
                        if color_flag > 4 
                          perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                        else 
                          perform subj 
                        end 
                      repeat 
                    end 
                    y = t15 + t14 
                    z = 126                   /* music font (repeater for eights)
                    x = x - hpar(100) 
                    loop for t12 = 1 to t11 
                      if color_flag > 4 
                        perform subj3 (color_flag)     /* New &dA12/21/10&d@ 
                      else 
                        perform subj 
                      end 
                      y += notesize 
                    repeat 
                    x = x + hpar(100) 
                    if ts(c1,TUPLE) > 0 
&dA 
&dA &d@              New &dA11/05/05&d@  Convert tuple to 1000 * n1 + n2 
&dA 
                      t13 = ts(c1,TUPLE) & 0xffff 
                      t14 = t13 >> 8 
                      t13 &= 0xff 
                      t14 *= 1000 
                      t13 += t14 
&dA         
                      t14 = x + hpar(103)  
                      t15 = ts(c1,STAFFLOC) - vpar(82)
                      perform typeset_tuple (t13,t14,t15) 
                    end 
                  end 
                end 
              end 
            else 
*   2) Beams 
              if ts(c1,BEAM_FLAG) = START_BEAM
                bcount = 1 
                ++snum
                beampar(passtype,passnum,BM_SNUM) = snum 
                if bit(4,super_flag) = 1 
                  beampar(passtype,passnum,BM_TUPLE) = 1 + stem 
                end  
                beampar(passtype,passnum,BM_STEM) = stem 
                beampar(passtype,passnum,BM_SIZE) = passsize 

                t2 = ts(c1,TSR_POINT)               /* New code &dA05/14/03&d@ 
                t3 = 28                             /* 28 = code for beam suggestion
                ++t3 
                t3 <<= 2                            /* 116 
                py = ors(tsr(t2){t3-2}) 
                t4 = 0 
                if py > 0 
                  py = py - 128
                  if py > 0 
                    t4 = INT100 * py 
                  else 
                    py = 0 - py 
                    t4 = INT100 * INT100 * py 
                  end 
                end                                               
                beampar(passtype,passnum,BM_SUGG) = t4   /* End new code &dA05/14/03

              else 
                bcount = beampar(passtype,passnum,BM_CNT) + 1 
                beampar(passtype,passnum,BM_STEM) <<= 1 
                beampar(passtype,passnum,BM_STEM) += stem 
                if passsize < beampar(passtype,passnum,BM_SIZE) 
                  beampar(passtype,passnum,BM_SIZE) = passsize 
                end 
              end  
              beamdata(passtype,passnum,bcount) = ts(c1,BEAM_CODE)  
              beampar(passtype,passnum,BM_CNT) = bcount 
              if ts(c1,BEAM_FLAG) = END_BEAM
                beampar(passtype,passnum,BM_READY) = bcount 
              end  
              beampar(passtype,passnum,BM_COLOR) |= color_flag    /* New &dA12/21/10
            end  
          end  
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P*  6. setax                                                   ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Set accidental                                   ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  c3 = index into ts array                          ³       
&dA &d@³             c4 = accident flag                                ³ 
&dA &d@³       passsize = note size (full, cue-size)                   ³ 
&dA &d@³            obx = x co-ordinate of object                      ³ 
&dA &d@³            oby = y co-ordinate of object                      ³ 
&dA &d@³              y = y co-ordinate of note head                   ³ 
&dA &d@³     color_flag = put out accidental in color  (&dA12/21/10&d@)      ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Internal: x,y,z sent to subj                               ³ 
&dA &d@³                                                               ³ 
&dA &d@³                                                               ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setax  
        int t1,t2,t4 
                                          /* &dA02/25/97&d@ shift changed from 4 to 8
        t2 = c4 >> 8                      /* x-offset (to the left) 
        t1 = c4 & 0x0f                    /* accidental only 

        t4 = 19                           /* New code &dA05/02/03&d@   accidentals code = 19
        perform getpxpy (t4,c3) 

        if pxx = 1 
          x = obx + px 
        else 
          x = obx - t2 + px 
        end 
                                                /* end New code 
        if bit(2,t1) = 1                  /* case: flat-flat or natural-(flat/sharp)
          z = bit(3,t1) + 64              /* flat or natural 
          t2 = hpar(40)  
          if passsize = CUESIZE 
            z += 128                      /* cue size 
            t2 = t2 * 8 / 10 
          end  
          if color_flag > 0
            perform subj3 (color_flag)          /* New &dA12/21/10&d@ 
          else 
            perform subj 
          end 
          x += t2 
        end  
        if t1 & 0x03 = 2 
          if bit(3,t1) = 1  
            z = 66                        /* double sharp 
          else 
            z = 63                        /* regular sharp 
          end  
        else 
          z = bit(1,t1) + 64              /* flat or natural 
        end  
        if passsize = CUESIZE 
          z += 128                        /* cue size  
        end  
        if bit(4,c4) = 0 
          if color_flag > 0
            perform subj3 (color_flag)          /* New &dA12/21/10&d@ 
          else 
            perform subj 
          end 
        else
          perform subj2                   /* Addition to Code &dA02/25/97&d@ 
        end                               
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P*  7. superfor (operates on an entire chord at once)              ³ 
&dA &d@³                                                                   ³ 
&dA &d@³    Purpose:  Get new snums for forward tie, forward slurs and     ³ 
&dA &d@³                forward tuplet                                     ³ 
&dA &d@³                                                                   ³ 
&dA &d@³    Inputs:      c1 = pointer to top of chord                      ³ 
&dA &d@³                 c2 = pointer to bottom of chord                   ³ 
&dA &d@³           passtype = type of pass (reg,cue,grace,cuegrace)        ³ 
&dA &d@³            passnum = pass number                                  ³ 
&dA &d@³                  x = x co-ordinate of object                      ³ 
&dA &d@³                  y = y co-ordinate of object                      ³ 
&dA &d@³         super_flag = composite of SUPER_FLAGs for this chord      ³ 
&dA &d@³          slur_flag = composite of SLUR_FLAGs for this chord       ³ 
&dA &d@³               stem = stem direction                               ³ 
&dA &d@³         color_flag = put out ties in color  (&dA12/21/10&d@)            ³ 
&dA &d@³                                                                   ³ 
&dA &d@³    Function: If there is a forward tie, this procedure increments ³ 
&dA &d@³              snum and puts result in tv4(.,1).  The color for     ³ 
&dA &d@³              that tie is put in tv4(.,2)                          ³ 
&dA &d@³              If there are forward slurs, this procedure increments³ 
&dA &d@³              snum and stores results in the appropriate           ³ 
&dA &d@³              slurar(.,SL_NEXTSNUM).                               ³ 
&dA &d@³              If there is a forward tuplet, this procedure         ³ 
&dA &d@³              increments snum and constructs the tuar for this     ³ 
&dA &d@³              tuplet.                                              ³ 
&dA &d@³              For all cases, the procedure increments supcnt and   ³ 
&dA &d@³              adds the new super-object number to supnums(.) for   ³ 
&dA &d@³              later output in the object record.                   ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure superfor 
        int t1,t2 

        tiecnt = 0 
        loop for c3 = c1 to c2 
          color_flag = ts(c3,SUBFLAG_1) >> 28  /* Added &dA12/21/10&d@ 
          if bit(0,ts(c3,SUPER_FLAG)) = 1      /* if tie starts 
            ++snum 
            ++supcnt 
            supnums(supcnt) = snum 
            ++tiecnt 
            tv4(tiecnt,1) = snum 
            tv4(tiecnt,2) = color_flag 
          end 
        repeat 
        loop for t1 = 1 to 8 
          t2 = t1 * 2 - 2 
          if t1 > 4 
            t2 += 8 
          end 
          if bit(t2,slur_flag) = 1             /* if slur starts 
            ++snum 
            ++supcnt 
            supnums(supcnt) = snum 
            slurar(t1,SL_NEXTSNUM) = snum 
          else 
            slurar(t1,SL_NEXTSNUM) = 0 
          end 
        repeat 
        if bit(4,super_flag) = 1 
          ++snum 
          ++supcnt 
          supnums(supcnt) = snum 
          tuar(passtype,passnum,TU_SNUM) = snum 
          tuar(passtype,passnum,TU_Y1) = y 
          if stem = UP 
            tuar(passtype,passnum,TU_Y2) = y 
          else 
            tuar(passtype,passnum,TU_Y2) = ts(c1,STAFFLOC) 
          end 
          tuar(passtype,passnum,TU_FSTEM) = stem 
          t1 = super_flag & 0x3c0                 /* bits 6,7,8,9 &dA03-21-97&d@ 
          t1 <<= 2 
          tuar(passtype,passnum,TU_FSTEM) |= t1   /* tuplet flags &dA03-21-97&d@ 
        end 
      return   

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P*  8. setart (operates on an entire chord at once)               ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  create sub-objects for dots, spiccato and legato.   ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Inputs:  obx = x-position of object                           ³ 
&dA &d@³             oby = y-position of object                           ³ 
&dA &d@³              c1 = pointer to top note of chord                   ³ 
&dA &d@³              c2 = pointer to bottom note of chord                ³ 
&dA &d@³            stem = stem direction (UP or DOWN)                    ³ 
&dA &d@³      color_flag = put out articulations in color  (&dA12/21/10&d@)     ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Outputs:  Program may modify virtual endpoints in the ts      ³ 
&dA &d@³                array.                                            ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Operation:  There are two rules that can be followed          ³ 
&dA &d@³             Rule 1: (chord = single note, or dot on middle note  ³ 
&dA &d@³                         of chord, or more than one dot)          ³ 
&dA &d@³               If there is a slur, and slur starts (ends) near    ³ 
&dA &d@³                   the dot, put dot under (over) slur;            ³ 
&dA &d@³                 otherwise, if multi-track > 0, put dot on stem;  ³ 
&dA &d@³                   otherwise put dot on note head.                ³ 
&dA &d@³                                                                  ³ 
&dA &d@³             Rule 2: (all other situations)                       ³ 
&dA &d@³               If dot on note at stem end, put dot on stem;       ³ 
&dA &d@³                 otherwise, put dot at head end of chord.         ³ 
&dA &d@³                                                                  ³ 
&dA &d@³             If there is a slur into or out of this chord, then   ³ 
&dA &d@³             information on the placement of dot/legato or        ³ 
&dA &d@³             spiccato has already been compiled and is stored     ³ 
&dA &d@³             in the SLUR_X ROW element.  Otherwise, the place-    ³ 
&dA &d@³             ment needs to be computed here.                      ³ 
&dA &d@³                                                                  ³ 
&dA &d@³             Virtual endpoints are modified in all cases.         ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setart   
        int t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13 
        int dot_xshift                                      /* New &dA05/14/05&d@ 

        t2 = 0 
        t9 = 0 
        loop for t1 = c1 to c2 
          t10 = ts(t1,SUBFLAG_2) & 0x3c    /* &dA05/17/03&d@ Editorial arts not yet supported
          if t10 > 0 
            ++t2      
            t3 = t1 
            t9 |= t10                 /* composite flag for chord 
          end 
&dA 
&dA &d@     Using grace dot to typeset editorial staccato &dA02/06/04&d@ 
&dA 
          t10 = ts(t1,ED_SUBFLAG_2) & 0x0c      /* editorial staccato & spiccato
          if t10 > 0 
            t10 <<= 8                           /* put this in higher order byte
            ++t2      
            t3 = t1 
            t9 |= t10                 
          end 
&dA   
        repeat 
        if t2 = 0 
          return 
        end 
&dA 
&dA &d@   Step 1: determine starting position for dot/legatos or spiccatos 
&dA 
        t13 = 0       /* &dA03/24/97&d@  potential modification to x position of articulation

        if c1 = c2 or (t3 <> c1 and t3 <> c2) or t2 > 1   /* follow rule 1 
          t4 = ts(c1,SLUR_X) 
          if t4 > 0 and ts(t4,6) > 0     /* there is a slur effecting dot 
            y = ts(t4,5) 
            t5 = ts(t4,6)             /* above/below flag 
            t8 = 0                    /* no adjustment to virtual end points 
          else 
            t10 = ts(c1,MULTI_TRACK) >> 2 
            if t10 > 0                      /* &dACHANGED&d@ from = 3  on &dA03/24/97
              if ts(c1,PASSNUM) = 1 and stem = DOWN 
                t10 = 0 
              end 
              if ts(c1,PASSNUM) = 2 and stem = UP  
                t10 = 0 
              end 
            end 
&dA 
&dA &d@     Code added &dA03/24/97&d@ to check for print suggestions for articulations 
&dA 
            t12 = 1                        /* articulation code = 1 
            if t9 & 0x04 > 0               /* spiccato code = 2         &dA05/02/03
              ++t12 
            end 

            perform getpxpy (t12,c1) 
            if pcontrol & 0x03 = 0x03      /* major location change flag 
              if bit(2,pcontrol) = 1       /* place below 
                t5 = BELOW 
                if stem = UP 
                  y = ts(c1,VIRT_NOTE) 
                  t8 = notesize 
                else 
                  y = ts(c1,VIRT_STEM) 
                  t8 = vpar(1) 
                  if ts(c1,BEAM_FLAG) > NO_BEAM 
                    t8 = vpar(2) 
                  end 
                end 
              else 
                t5 = ABOVE 
                if stem = UP 
                  y = ts(c1,VIRT_STEM) 
                  t8 = vpar(1) 
                  if ts(c1,BEAM_FLAG) > NO_BEAM 
                    t8 = vpar(2) 
                  end 
                else 
                  y = ts(c1,VIRT_NOTE) 
                  t8 = notesize 
                end 
              end 
            else 
&dA 
&dA &d@     End of &dA03/24/97&d@ addition 
&dA 
              if t10 > 0 
                y = ts(c1,VIRT_STEM) 
                if stem = UP 
                  t5 = ABOVE 
                else 
                  t5 = BELOW 
                end 
                t8 = vpar(1) 
                if ts(c1,BEAM_FLAG) > NO_BEAM 
                  t8 = vpar(2) 
                end 
              else 
                y = ts(c1,VIRT_NOTE) 
                if stem = UP 
                  t5 = BELOW 
                else 
                  t5 = ABOVE 
                end 
                t8 = notesize 
              end 
&dA 
&dA &d@      New &dA11/10/07&d@   We need some code here which disables the interference section
&dA &d@                     below when there is a y-position modifier, 
&dA 
              if pcontrol & 0x01 > 0 
                if (py = 0 and pyy = 0) or pyy = 1 
                  t8 = 0  
                end 
              end 
&dA         
            end 

            if pyy > 0 
              y = py 
            else 
              y += py 
            end 
            t13 = px 

          end 
        else                                              /* follow rule 2 
&dA 
&dA &d@     Code added &dA03/24/97&d@ to check for print suggestions for articulations 
&dA 
          t12 = 1                        /* articulation code = 1 
          if t9 & 0x04 > 0               /* spiccato code = 2         &dA05/02/03
            ++t12 
          end 

          perform getpxpy (t12,c1) 
          if pcontrol & 0x03 = 0x03      /* major location change flag 
            if bit(2,pcontrol) = 1       /* place below 
              t5 = BELOW 
              if stem = UP 
                y = ts(c1,VIRT_NOTE) 
                t8 = notesize 
              else 
                y = ts(c1,VIRT_STEM) 
                t8 = vpar(1) 
              end 
            else 
              t5 = ABOVE 
              if stem = UP 
                y = ts(c1,VIRT_STEM) 
                t8 = vpar(1) 
              else 
                y = ts(c1,VIRT_NOTE) 
                t8 = notesize 
              end 
            end 
          else 
&dA 
&dA &d@     End of &dA03/24/97&d@ addition 
&dA 
            if stem = UP 
              if t3 = c1                                    /* top note 
                t5 = ABOVE 
                y = ts(c1,VIRT_STEM) 
                t8 = vpar(1) 
              else 
                t5 = BELOW 
                y = ts(c1,VIRT_NOTE) 
                t8 = notesize 
              end 
            else 
              if t3 = c1                                    /* top note 
                t5 = ABOVE 
                y = ts(c1,VIRT_NOTE) 
                t8 = notesize 
              else 
                t5 = BELOW 
                y = ts(c1,VIRT_STEM) 
                t8 = vpar(1) 
              end 
            end 
&dA 
&dA &d@      New &dA11/10/07&d@   We need some code here which disables the interference section
&dA &d@                     below when there is a y-position modifier, 
&dA 
            if pcontrol & 0x01 > 0 
              if (py = 0 and pyy = 0) or pyy = 1 
                t8 = 0 
              end 
            end 
&dA         
          end 

          if pyy > 0 
            y = py 
          else 
            y += py 
          end 
          t13 = px 

        end 
&dA 
&dA &d@     New (&dA05/14/05&d@) code to set value of dot_xshift for staccato over (under) stem
&dA 
        dot_xshift = 0                                      
        if t5 = ABOVE 
          if stem = UP 
            dot_xshift = hpar(19)                           
            if ts(c1,BEAM_FLAG) <= NO_BEAM 
              y -= vpar(1) 
            end 
          end 
        else 
          if stem = DOWN 
            dot_xshift = 0 - hpar(19)
            if ts(c1,BEAM_FLAG) <= NO_BEAM 
              y += vpar(1) 
            end 
          end 
        end 
&dA         

&dA 
&dA &d@     check for interference in cases where y is based on VIRT_ 
&dA 
        if t8 <> 0 
          if (stem = DOWN and t5 = ABOVE) or (stem = UP and t5 = BELOW) 
            t11 = HEAD 
          else 
            t11 = TAIL 
          end 
          if (t9 & 0x04 > 0) or (t9 & 0x400 > 0)     /* spiccato is special case (&dA02/06/04&d@)
            if stem = DOWN 
              if t5 = ABOVE         /* note 
                if y > vpar(1) 
                  y = vpar(1) 
                end 
                y -= 5 * notesize / 4 
              else 
                if y < vpar(8) 
                  y = vpar(8) 
                end 
                y += vpar(1) + vpar(50)      /* OK 4-22-95 
              end 
            else                /* UP 
              if t5 = ABOVE 
                if y > 0 
                  y = 0 
                end 
                y -= vpar(1) 
                c16 = y * 2 / vpar(2) 
                if rem <> 0 
                  --y 
                end 

              else                  /* note 
                if y < vpar(7) 
                  y = vpar(7) 
                end 
                y += 5 * notesize / 4 + vpar(50) 
              end 
            end 
          else 
            t6 = 1 
            if t5 = ABOVE 
              y -= t8 
              if y >= 0 
                t6 = y / notesize 
                t6 = rem 
              else 
                y = 0 - notesize / 4 + y 
              end 
              t7 = -1 
            else 
              y += t8 
              if y <= vpar(8) 
                t6 = y / notesize 
                t6 = rem 
              else 
                y = notesize / 4 + y 
              end 
              t7 = 1 
            end 
&dA 
&dA &d@     adjust for interference with staff 
&dA 
            if t6 = 0 
              c16 = t7 + 20 * vpar(2) / 2 - vpar20 
              y += c16 

            end 
          end 
        end 
&dA 
&dA &d@   Step 2: write out articulations 
&dA 

&dA 
&dA &d@    Code addition &dA01/06/06&d@: If art_flag = 48, then please set all staccatos and/or
&dA &d@                            legatos above the note and above the staff lines.
&dA 
        if art_flag = 48 
          if t9 & 0x38 > 0 
            if y > (0 - vpar(1)) 
              y = 0 - vpar(1) 
            end 
          end 
        end 
&dA      
        x = obx + t13 
        if t9 & 0x18 > 0                  /* staccato 
          z = 96                          /* music font 
          x += dot_xshift                 /* New &dA05/14/05&d@ 
          if color_flag > 4 
            perform subj3 (color_flag)    /* New &dA12/21/10&d@ 
          else 
            perform subj 
          end 
          x -= dot_xshift                 /* New &dA05/14/05&d@ 
          y = notesize * t7 + y 
        end 
        if t9 & 0x30 > 0                  /* legato 
          z = 99                          /* music font 
          x += dot_xshift                 /* New &dA05/14/05&d@ 
          if color_flag > 4 
            perform subj3 (color_flag)    /* New &dA12/21/10&d@ 
          else 
            perform subj 
          end 
          x -= dot_xshift                 /* New &dA05/14/05&d@ 
          y = notesize * t7 + y 
        end 
&dA 
&dA &d@   Using grace dot to typeset editorial staccato &dA02/06/04&d@ 
&dA 
        if t9 & 0x800 > 0 
          z = 172                         /* grace dot used as editorial staccato
          x += vpar(1) / 2 
          x += dot_xshift / 2             /* New &dA05/14/05&d@ and &dA09/22/05&d@ 
          perform subj 
          x -= dot_xshift / 2             /* New &dA05/14/05&d@ and &dA09/22/05&d@ 
          x -= vpar(1) / 2 
          y = notesize * t7 + y 
        end 
&dA 
&dA &d@   Using ordinary spiccato for the moment to typeset editorial spiccato &dA02/06/04
&dA 
        if t9 & 0x400 > 0                 /* spiccato 
          z = 98                          /* music font 
          if t5 = ABOVE 
            --z                           /* music font 
          end 
          x += dot_xshift                 /* New &dA05/14/05&d@ 
&dA 
&dA &d@      Code added &dA05/26/05&d@ to implement arbitrary placement of editorial spiccatos
&dA 
          if bit(2,art_flag) = 1 
            t13 = y 
            if stem = UP 
              y = oby + vpar(4) 
            else 
              y = oby - (vpar(5) / 2) 
            end 
            perform subj 
            y = t13 
          else 
            perform subj 
          end 
&dA       
          x -= dot_xshift                 /* New &dA05/14/05&d@ 
          if t5 = BELOW 
            y -= vpar(50) 
          end 
          if y >= 0  
            y = y * 2 + 1 / vpar(2) 
          else 
            y = y * 2 - 1 / vpar(2) 
          end 
          y = y * vpar(2) / 2   
        else 
&dA   
          if t9 & 0x04 > 0                /* spiccato 
            z = 98                        /* music font 
            if t5 = ABOVE 
              --z                         /* music font 
            end 
            x += dot_xshift               /* New &dA05/14/05&d@ 
&dA 
&dA &d@      Code added &dA05/26/05&d@ to implement arbitrary placement of spiccatos 
&dA 
            if bit(2,art_flag) = 1 
              t13 = y 
              if stem = UP 
                y = oby + vpar(4) 
              else 
                y = oby - (vpar(5) / 2) 
              end 
              if color_flag > 4 
                perform subj3 (color_flag)    /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
              y = t13 
            else 
              if color_flag > 4 
                perform subj3 (color_flag)    /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
            end 
&dA       
            x -= dot_xshift               /* New &dA05/14/05&d@ 
            if t5 = BELOW 
              y -= vpar(50) 
            end 
            if y >= 0 
              y = y * 2 + 1 / vpar(2) 
            else 
              y = y * 2 - 1 / vpar(2) 
            end 
            y = y * vpar(2) / 2 

          else 
            y -= notesize * t7 
          end 
        end 
&dA 
&dA &d@   Step 3: adjust virtual end points 
&dA 
        if t8 <> 0 
          if t11 = HEAD 
            loop for t8 = c1 to c2 
              ts(t8,VIRT_NOTE) = y 
            repeat 
          else 
            loop for t8 = c1 to c2 
              ts(t8,VIRT_STEM) = y 
            repeat 
          end 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P*  9. setperf (operates on an entire chord at once)                ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Purpose:  create sub-objects for turns, trills, shakes,         ³ 
&dA &d@³              mordents, horizontal accents, thumb positions,        ³ 
&dA &d@³              open string, numbers, harmonics, down-bows,           ³ 
&dA &d@³              up-bows, fermatas. (and tremulos as of &dA01/07/06&d@)      ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Inputs:    obx = x-position of object                           ³ 
&dA &d@³               oby = y-position of object                           ³ 
&dA &d@³                c1 = pointer to top of chord                        ³ 
&dA &d@³                c2 = pointer bottom of chord                        ³ 
&dA &d@³                c4 = virtual vertical position of controlling       ³ 
&dA &d@³                         note head                                  ³ 
&dA &d@³                c5 = virtual vertical position of end of stem       ³ 
&dA &d@³                c8 = slur present flag                              ³ 
&dA &d@³                                     0 = not present (usually)      ³ 
&dA &d@³                                     1 = present at head            ³ 
&dA &d@³                                     2 = present at stem            ³ 
&dA &d@³              stem = stem direction  0 = up                         ³ 
&dA &d@³                                     1 = down                       ³ 
&dA &d@³        super_flag = composite of SUPER_FLAGs for this chord        ³ 
&dA &d@³        color_flag = put out articulations in color  (&dA12/21/10&d@)     ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Operation:  If multi-track > 0, put indications at the stem     ³ 
&dA &d@³                  end of the chord;                                 ³ 
&dA &d@³                else, put indications above the chord               ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Internal: c4,c5,c7,c9,c13 used to communicate with yadjust      ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    &dA04-08-97&d@ Modification.                                          ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    It turns out that for turns, trill, shakes, and mordents,       ³ 
&dA &d@³                 and tremulos, as of &dA01/07/06&d@,                      ³ 
&dA &d@³    we want to allow multiple ornaments on a chord.  Therefore,     ³ 
&dA &d@³    these ornaments need to be processed individually, and not      ³ 
&dA &d@³    grouped, as are accents, numbers, up and down bows, fermatas,   ³ 
&dA &d@³    etc.                                                            ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setperf  
        str temp.100                             /* &dA04/24/03&d@ 
        bstr bs.600,bt.600 
        int t1,t2,t3,t4,t5,t7,t8,t9,t10 
        int subflag_1,subflag_2 
        int ed_subflag_1,ed_subflag_2            /* New variables &dA05/17/03&d@ 
        int merged_subflag_1,merged_subflag_2 
        int lsqx,rsqx,sqy,glyph,sq_glyph 
        int sugg_flg3(MAX_OBJECTS)                         /* New &dA12/21/10&d@ 
&dA 
&dA &d@   1. Determine placement: c7 = situation flag: 0 = place on note head 
&dA &d@                                                1 = place on stem 
&dA 
        if ts(c1,MULTI_TRACK) >> 2 > 0 
          c7 = 1 
        else 
          c7 = 1 - stem 
        end 
&dA 
&dA &d@   2. Long trill 
&dA 
        if super_flag & 0x06 > 0          /* if begin ~~~~~ 
          subflag_1 = 0 
          loop for t8 = c1 to c2            /* loop added &dA11/05/05&d@ to accomodate all ornaments
            subflag_1 = subflag_1 | ts(t8,SUBFLAG_1)           /* on notes of a chord
          repeat 

          t5 = ts(c1,PASSNUM) 
          ++snum
          pre_tsnum(t5) = snum 
          ++supcnt 
          supnums(supcnt) = snum 
          c13 = vpar(53) 
          pre_ctrarrf(t5) = bit(2,super_flag)     /* tr. trill 
          if pre_ctrarrf(t5) = 0 
            c13 = vpar(51) 
          end 

          if pre_ctrarrf(t5) = 1         /* tr. present 
            t3 = subflag_1 & 0x70 >> 4   /* t3 = 0 to 7 (&dA05/17/03&d@ editorial not supported yet)
            t3 = int("01312311"{t3+1}) 
            pre_ctrarrf(t5) += t3 
            if subflag_1 & 0x80000 > 0   /* bit 19 is set &dA11/05/05&d@ 
              pre_ctrarrf(t5) += 3       /* add 3 to R super-object parameter 4
            end 
          end 

          ++pre_ctrarrf(t5) 
          perform yadjust 
          pre_try(t5) = y - oby 
                                  /* Code added &dA02/24/97&d@ 
          t2 = 4                        /* ornament code = 4 
          perform getpxpy (t2,c1) 
          
          if pyy > 0 
            pre_try(t5) = py 
          else 
            pre_try(t5) += py 
          end 
                                  /* End of &dA02/24/97&d@ addition 
        else 
&dA 
&dA &d@   3. Back ties (sub-objects)  New code &dA04/22/08&d@ 
&dA 
&dA &d@      Note: Back ties are handled like ornaments.  This means that a note with
&dA &d@            a back tie can have at most one ornament attached to it.  Limitation??
&dA 
          loop for t8 = c1 to c2            /* New code &dA12/21/10&d@ 
            sugg_flg3(t8) = 0 
          repeat 

          loop for t8 = c1 to c2            /* loop accomodates back ties on all chord notes
            subflag_1 = ts(t8,SUBFLAG_1)
            t5 = subflag_1 & 0x03000000     /*  000000&dE11&d@ 00000000 00000000 00000000
            if t5 > 0                       
              t2 = 4 + sugg_flg3(t8)        /* ornament code = 4  New variable &dA12/21/10
              if sugg_flg3(t8) = 0          /* New code &dA12/21/10&d@ 
                ++sugg_flg3(t8) 
              end 

              x = obx - vpar(4) 
              t5 >>= 24 
              if t5 = 1                     /* overhand back tie 
                y = 0 - vpar(2) 
                z = 2036                    /* overhand tie character 
              else 
                y = vpar(2) 
                z = 2164                    /* underhand tie charachter 
              end 
              y += oby 

              perform getpxpy (t2,t8) 

              x += px 
              if pyy > 0 
                py -= y 
                pyy = 0 
              end 
              y += py 
              perform subj                  /* this feature not implemented in autoscr yet
            end 
          repeat 
&dA 
&dA &d@   4+5. Ornaments and their accidentals need to be handled together 
&dA 
&dA &d@      New code rewrite &dA05/17/03&d@ to accommodate editorial ornaments and their accidentals
&dA 
          loop for t8 = c1 to c2            /* loop added &dA04-08-97&d@ to accomodate all ornaments
            subflag_1 = ts(t8,SUBFLAG_1)                       /* on notes of a chord
            subflag_2 = ts(t8,SUBFLAG_2) 
            ed_subflag_1 = ts(t8,ED_SUBFLAG_1)
            ed_subflag_2 = ts(t8,ED_SUBFLAG_2) 
            merged_subflag_1 = subflag_1 | ed_subflag_1 
            merged_subflag_2 = subflag_2 | ed_subflag_2 

            t5 = merged_subflag_1 & 0x0f             /* turn,tr,shake,mordent, etc.
            if t5 > 0 and t5 < 7                     /* &dA6 ornaments&d@ as of &dA01/07/06
&dA 
&dA &d@      Raise (lower) turn, if slur and turn are present on note head 
&dA 
              color_flag = subflag_1 >> 28 
              if c7 = 0 and c8 = 1 
                if t5 = 1                   /* turn 
                  if stem = UP 
                    c16 = c4 * 2 / vpar(2) 
                    if rem <> 0 
                      ++c4 
                    end 
                    c4 += vpar(1) 
                  else 
                    c4 -= vpar(1) 
                    c16 = c4 * 2 / vpar(2) 
                    if rem <> 0 
                      --c4 
                    end 
                  end 
                end 
              end 
&dA 
&dA &d@     a. We must know definitively whether ornament goes above or below notes, 
&dA &d@          and we must determine whether there is an "intervening" accidental.  
&dA 
              t7 = c7                       /* save c7 
              t2 = 4 + sugg_flg3(t8)        /* ornament code = 4   New variable &dA12/21/10
              if sugg_flg3(t8) = 0          /* New code &dA12/21/10&d@ 
                ++sugg_flg3(t8) 
              end 
              perform getpxpy (t2,t8) 

              if bit(0,pcontrol) = 1 
                if bit(1,pcontrol) = 1 
                  if bit(2,pcontrol) = 0 
                    c7 = 1 - stem 
                  else 
                    c7 = stem 
                  end 
                end 
              end 
              t1 = c7 + stem                /* t1 = 1 means ornament goes above

              t2 = 0 
              t3 = merged_subflag_1 & 0x3f0 >> 4 
              t9 = ed_subflag_1 & 0x3f0 >> 4 
              t10 = 0                       /* 0 will mean actual, as opposed to editorial
              if t3 > 0 
                if t1 = 1 
                  if t3 > 7                 /* ax under on ornament above 
                    t2 = 1 
                    if t9 > 7 
                      t10 = 1               /* and this is editorial 
                    end 
                  end 
                else 
                  if t3 & 0x07 > 0          /* ax over on ornament below 
                    t2 = 2 
                    if t9 & 0x07 > 0 
                      t10 = 1               /* and this is editorial 
                    end 
                  end 
                end 
              end 
              if t2 > 0                     /* put accidental first 
                if t2 = 1 
                  t4 = t3 >> 3 
                else 
                  t4 = t3 & 0x07 
                end 
                c13 = vpar(56) 
                perform yadjust 
                if c9 <> 1 
                  y -= vpar(1) 
                  c16 = y * 2 / vpar(2) 
                  if rem <> 0 
                    --y 
                  end 
                end 
                x = obx 
                if t2 = 1 and (t5 = 1 or t5 = 5) 
                  x += hpar(70) 
                end 
                x += px 
                if pyy > 0 
                  py -= y 
                  pyy = 0 
                end 
                y += py 
&dA 
&dA &d@           Deal with case where ornament is real, but accidental is editorial
&dA 
                if subflag_1 & 0x0f > 0 and t10 = 1 
                  x -= hpar(124) 
                  y -= vpar(86) 
                  z = 244                         /* open square bracket 
                  perform subj 
                  x += hpar(124) 
                  y += vpar(86) 
                end 
&dA 
&dA &d@           Put out "first" accidental 
&dA 
                z = int("39389"{t4})              /* music font 
                z += 210                          /* music font 
                if color_flag > 4 
                  perform subj3 (color_flag)    /* New &dA12/21/10&d@ 
                else 
                  perform subj 
                end 
                if t4 < 3 
                  z = int("39"{t4})                 /* music font 
                  x += hpar(z+67)                   /* hpar(70) or hpar(76) 
                  z += 210                          /* music font 
                  if t2 = 1 and (t5 = 1 or t5 = 5) 
                    x += hpar(70) 
                  end 
                  if color_flag > 4 
                    perform subj3 (color_flag)    /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                end 
&dA 
&dA &d@           Deal with case where ornament is real, but accidental is editorial
&dA 
                if subflag_1 & 0x0f > 0 and t10 = 1 
                  x += hpar(125) 
                  y -= vpar(86) 
                  z = 245                         /* close square bracket 
                  perform subj 
                end 
              end 
&dA 
&dA &d@     b. Now put out turn, tr., shake, mordent, delayed turn 
&dA &d@           tremulo added &dA01/07/06&d@ (primary only) 
&dA 
              t3 = t5 
              if c3 = 5 
                c3 = 1 
              end 
              c13 = 51 + t3 
              c13 = vpar(c13) 
&dA &d@                                   &dA01/07/06&d@ for tremulos 
              if t3 = 6 
                c13 = vpar(4) 
              end 
&dA    
              perform yadjust 
              if c9 <> 1 
                y -= vpar(1) 
                c16 = y * 2 / vpar(2) 
                if rem <> 0 
                  --y 
                end 
              end 
              x = obx 
              x += px 
              if pyy > 0 
                py -= y 
                pyy = 0 
              end 
              y += py 
&dA 
&dA &d@           Deal with case where ornament is editorial 
&dA 
              if ed_subflag_1 & 0x0f > 0 
                if t3 = 1 or t3 = 5          /* turn and delayed turn 
                  lsqx  = hpar(126) 
                  rsqx  = hpar(127) 
                  sqy   = vpar(87) 
                  glyph = 242                /* turn ornament 
                  sq_glyph = 244             /* small square bracket 
                else 
                  if t3 = 2                  /* tr. trill 
&dA 
&dA &d@      Conditional code added &dA02/04/04&d@ to implement Roman editorial trills 
&dA 
#if ROMAN_EDIT 
                    ++sobcnt 
                    sobx = x - obx 
                    soby = y - oby 
                    sobl(sobcnt) = "W " // chs(sobx) // " " // chs(soby) // " "
                    sobl(sobcnt) = sobl(sobcnt) // "31 tr" 
                    goto SETP01 
&dA   
#else 
                    lsqx  = hpar(122) 
                    rsqx  = hpar(123) 
                    sqy   = vpar(85) 
                    glyph = 254              /* editorial trill ornament 
                    sq_glyph = 195           /* cue square bracket 
#endif 
                  else 
                    if t3 = 3                /* shake 
                      lsqx  = hpar(128) 
                      rsqx  = hpar(129) 
                      sqy   = vpar(88) 
                      glyph = 239            /* shake ornament              
                      sq_glyph = 244         /* small square bracket 
                    else                     /* mordant 
                      lsqx  = hpar(130) 
                      rsqx  = hpar(131) 
                      sqy   = vpar(89) 
                      glyph = 238            /* mordant ornament 
                      sq_glyph = 244         /* small square bracket 
                    end 
                  end 
                end 
                x -= lsqx 
                y -= sqy 
                z = sq_glyph                      /* open square bracket 
                perform subj 
                x += lsqx 
                y += sqy 
                z = glyph 
                perform subj 
                x += rsqx 
                y -= sqy 
                z = sq_glyph + 1                  /* close square bracket 
                perform subj 
              else 
&dA 
&dA &d@           Deal with case where ornament is primary  
&dA 
&dA &d@           &dA01/07/06&d@  Adding code to deal with tremulo ornament (T) 
&dA 
                if t3 < 6 
                  z = int("71437"{t3})       /* music font 
                  z += 235                   /* music font 
                  if color_flag > 4 
                    perform subj3 (color_flag)    /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                else 
                  c16 = y 
                  z = 127 
                  if color_flag > 4 
                    perform subj3 (color_flag)    /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                  y -= vpar(3) / 2 
                  if color_flag > 4 
                    perform subj3 (color_flag)    /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                  y -= vpar(3) / 2 
                  if color_flag > 4 
                    perform subj3 (color_flag)    /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                  y = c16 
                end 
              end 
&dA 
&dA &d@     c. Put out remaining accidentals above or below notes.  
&dA 
SETP01: 
                                          /* t1 = 1 means ornament goes above 
              t2 = 0 
              t3 = merged_subflag_1 & 0x3f0 >> 4 
              t9 = ed_subflag_1 & 0x3f0 >> 4 
              t10 = 0                       /* 0 will mean actual, as opposed to editorial
              if t3 > 0 
                if t1 = 1 
                  if t3 & 0x07 > 0          /* ax over on ornament above 
                    t2 = 1 
                    if t9 & 0x07 > 0 
                      t10 = 1               /* and this is editorial 
                    end 
                  end 
                else 
                  if t3 > 7                 /* ax under on ornament below 
                    t2 = 2 
                    if t9 > 7 
                      t10 = 1               /* and this is editorial 
                    end 
                  end 
                end 
              end 
              if t2 > 0                     /* put accidental 
                if t2 = 1 
                  t4 = t3 & 0x07 
                else 
                  t4 = t3 >> 3 
                end 
                c13 = vpar(56) 
                perform yadjust 
                if c9 <> 1 
                  y -= vpar(1) 
                  c16 = y * 2 / vpar(2) 
                  if rem <> 0 
                    --y 
                  end 
                end 
                x = obx 
                if t2 = 2 and (t5 = 1 or t5 = 5) 
                  x += hpar(70) 
                end 
                x += px 
                if pyy > 0 
                  py -= y 
                  pyy = 0 
                end 
                y += py 
&dA 
&dA &d@           Deal with case where ornament is real, but accidental is editorial
&dA 
                if subflag_1 & 0x0f > 0 and t10 = 1 
                  x -= hpar(124) 
                  y -= vpar(86) 
                  z = 195                         /* open square bracket 
                  perform subj 
                  x += hpar(124) 
                  y += vpar(86) 
                end 
&dA 
&dA &d@           Put out "second" accidental 
&dA 
                z = int("39389"{t4})              /* music font 
                z += 210                          /* music font 
                if color_flag > 4 
                  perform subj3 (color_flag)      /* New &dA12/21/10&d@ 
                else 
                  perform subj 
                end 
                if t4 < 3 
                  z = int("39"{t4})                 /* music font 
                  x += hpar(z+67)                   /* hpar(70) or hpar(76) 
                  z += 210                          /* music font 
                  if t2 = 2 and (t5 = 1 or t5 = 5) 
                    x += hpar(70) 
                  end 
                  if color_flag > 4 
                    perform subj3 (color_flag)      /* New &dA12/21/10&d@ 
                  else 
                    perform subj 
                  end 
                end 
&dA 
&dA &d@           Deal with case where ornament is real, but accidental is editorial
&dA 
                if subflag_1 & 0x0f > 0 and t10 = 1 
                  x += hpar(125) 
                  y -= vpar(86) 
                  z = 196                         /* close square bracket 
                  perform subj 
                end 
              end 
              c7 = t7                               /* restore "real" c7 
            end 
          repeat 
        end 
&dA 
&dA &d@      End of code rewrite for editorial ornaments and their accidentals 
&dA 
&dA &d@   6. Construct composite subflag_1 and subflag_2, ed_subflag_1 and ed_subflag_2
&dA 
&dA &d@      New code rewrite &dA05/17/03&d@ to accommodate other editorial marks 
&dA 
        subflag_1 = ts(c1,SUBFLAG_1) 
        subflag_2 = ts(c1,SUBFLAG_2) 
        ed_subflag_1 = ts(c1,ED_SUBFLAG_1) 
        ed_subflag_2 = ts(c1,ED_SUBFLAG_2) 
        if c2 > c1 
          t5 = ts(c1,TSR_POINT) 
          bs = cbi(tsr(t5){5..68})                  /* &dA04/24/03&d@  merge only subobj suggs.
          loop for t3 = c1+1 to c2 
            subflag_1 |= ts(t3,SUBFLAG_1) 
            subflag_2 |= ts(t3,SUBFLAG_2) 
            ed_subflag_1 |= ts(t3,ED_SUBFLAG_1) 
            ed_subflag_2 |= ts(t3,ED_SUBFLAG_2) 
            t4 = ts(t3,TSR_POINT) 
            bt = cbi(tsr(t4){5..68})                /* &dA04/24/03&d@  merge only subobj suggs.
            bs = bor(bs,bt) 
          repeat 
          temp = cby(bs) 
          t3 = TSR_LENG 
          tsr(t5) = tsr(t5){1,4} // temp // tsr(t5){69..t3}    /* &dA05/02/03&d@     
        end    
        merged_subflag_1 = subflag_1 | ed_subflag_1 
        merged_subflag_2 = subflag_2 | ed_subflag_2 
&dA 
&dA &d@   7. Horizontal and vertical accents 
&dA 
        if merged_subflag_2 & 0x01c0 > 0 
&dA 
&dA &d@      Lower (raise) horizontal accent, if it and slur are present on note head
&dA 
          if c7 = 0 and c8 = 1 
            if bit(6,merged_subflag_2) = 1   /* horizontal accent 
              if stem = UP 
                c4 -= vpar(1) 
                c16 = c4 * 2 / vpar(2) 
                if rem <> 0 
                  --c4 
                end 
              else 
                c16 = c4 * 2 / vpar(2) 
                if rem <> 0 
                  ++c4 
                end 
                c4 += vpar(1) 
              end 
            end 
          end 
          t7 = c7 
          t2 = 3                        /* accent code = 3 
          perform getpxpy (t2,c1) 

          if bit(0,pcontrol) = 1 
            if bit(1,pcontrol) = 1 
              if bit(2,pcontrol) = 0 
                c7 = 1 - stem 
              else 
                c7 = stem 
              end 
            end 
          end 
          x = obx + px 
          if bit(6,merged_subflag_2) = 1    /* &dA01/26/08&d@  Fixing a small bug 
            c13 = vpar(57) 
            glyph    = 93                   /* horizontal accent 
            lsqx     = hpar(132) 
            rsqx     = hpar(133) 
            sqy      = vpar(90) 
            sq_glyph = 195                  /* cue square bracket 
          end 
          if bit(7,merged_subflag_2) = 1    /* &dA01/26/08&d@  Fixing a small bug 
            c13 = vpar(58) 
            glyph = 94                      /* vertical accent--point up 
            lsqx  = hpar(134) 
            rsqx  = hpar(135) 
            sqy   = vpar(91) 
            sq_glyph = 244                  /* small square bracket 
          end 
          if bit(8,merged_subflag_2) = 1    /* &dA01/26/08&d@  Fixing a small bug 
            c13 = vpar(58) 
            glyph = 95                      /* vertical accent--point down 
            lsqx  = hpar(134) 
            rsqx  = hpar(135) 
            sqy   = vpar(91) 
            sq_glyph = 244                  /* small square bracket 
          end 
          perform yadjust 
          if c9 <> 1 
            y -= vpar(1) 
            c16 = y * 2 / vpar(2) 
            if rem <> 0 
              --y 
            end 
          end 
          if pyy > 0 
            y = py 
          else 
            y += py 
          end 
          if ed_subflag_2 & 0x01c0 > 0 
            x -= lsqx 
            y -= sqy 
            z = sq_glyph                          /* open square bracket 
            perform subj 
            x += lsqx 
            y += sqy 
          end 
          z = glyph 
          if color_flag > 4 
            perform subj3 (color_flag)            /* New &dA12/21/10&d@ (this may be an error)
          else 
            perform subj 
          end 
          if ed_subflag_2 & 0x01c0 > 0 
            x += rsqx 
            y -= sqy 
            z = sq_glyph + 1                      /* close square bracket 
            perform subj 
          end 
          c7 = t7 
        end 
&dA 
&dA &d@   8. harmonics
&dA 
        if merged_subflag_2 & 0x0200 > 0 
          t2 = 7                        /* harmonics code = 7 
          perform getpxpy (t2,c1) 

          x = obx + px 
          z = 123                     /* music font 
          c13 = vpar(59) 
          t7 = c7 
          if stem = 0 
            c7 = 1 
          else 
            c7 = 0 
          end 
          perform yadjust             /* c9 set by yadjust 
          c7 = t7 
          if pyy > 0 
            y = py 
          else 
            y += py 
          end 
          perform subj 
        end  
&dA 
&dA &d@   9. thumb positions, open string 
&dA 
        c9 = merged_subflag_2 & 0x0c00 
        if c9 > 0  
          t2 = 8                        /* thumb-open code = 8 
          perform getpxpy (t2,c1) 

          x = obx + px 
          if bit(10,merged_subflag_2) = 1 
            z = 124                   /* music font 
            c13 = vpar(60) 
          else 
            z = 199                   /* music font 
            c13 = vpar(48) 
          end 
          t7 = c7 
          if stem = 0 
            c7 = 1 
          else 
            c7 = 0 
          end 
          perform yadjust             /* c9 set by yadjust 
          c7 = t7 
          if pyy > 0 
            y = py 
          else 
            y += py 
          end 
          perform subj 
        end  
&dA 
&dA &d@  10. fingerings (above staff for the moment)   Note: suggestions for fingerings 
&dA &d@                                                not yet implemented here.    
&dA 
        c9 = merged_subflag_2 >> 12
        if c9 > 0 
&dA 
&dA &d@    If above the staff, reverse the flags 
&dA 
          t4 = 0 
VVV2: 
          t1 = 0x0f 
          t3 = 4 
VVV1: 
          t2 = c9 & t1 
          if t2 > t1 >> 1 
            t1 = t1 << 4 + t1 
            t3 += 4 
            goto VVV1 
          end 
          t4 <<= t3 
          t4 += t2 
          c9 >>= t3 
          if c9 > 0 
            goto VVV2 
          end 
          t5 = t4 


VVV4: 
          t1 = 0x0f 
          t3 = 4 
VVV3: 
          t2 = t5 & t1 
          if t2 > t1 >> 1 
            t1 = t1 << 4 + t1 
            t3 += 4 
            goto VVV3 
          end 
&dA 
&dA &d@     Typeset t2 
&dA 
          c13 = vpar(48) 
          perform yadjust             /* c9 set by yadjust 
          t4 = t3 - 1 >> 2 * (hpar(73) / 2) 
          x = obx - t4 
VVV5: 
          t4 = t2 & 0x0f 
          z = t4 & 0x07 + 199             /* music font 
          perform subj 
          if t4 > 7 
            x += hpar(73) 
            t2 >>= 4 
            goto VVV5 
          end 

          t5 >>= t3 
          if t5 > 0 
            goto VVV4 
          end 
        end 
&dA 
&dA &d@  11. up-bows, down-bows                 
&dA 
        if merged_subflag_2 & 0x03 > 0 
          t2 = 6                        /* bowing code = 6 
          perform getpxpy (t2,c1) 

          x = obx + px 
          if bit(0,merged_subflag_2) = 1 
            c13 = vpar(61) 
            z = 117                       /* music font
          else   
            c13 = vpar(62) 
            z = 116                       /* music font 
          end  
          t7 = c7 
          if stem = 0 
            c7 = 1 
          else 
            c7 = 0 
          end 
          perform yadjust 
          c7 = t7 
          if c9 <> 1 
            y -= vpar(1) 
            c16 = y * 2 / vpar(2) 
            if rem <> 0 
              --y 
            end 
          end 
          if pyy > 0 
            y = py 
          else 
            y += py 
          end 
          perform subj 
        end  
&dA 
&dA &d@   12. fermatas (&dA12/21/10&d@ rewrite) 
&dA 
        loop for c3 = c1 to c2 
          color_flag = ts(c3,SUBFLAG_1) >> 28 
          if bit(26, ts(c3,SUBFLAG_1)) = 1 or bit(26, ts(c3,ED_SUBFLAG_1)) = 1
            t2 = 15                       /* upright fermata code = 15 
            perform getpxpy (t2,c1) 

            x = obx + px 
            c13 = vpar(63) 
            z = 101                         /* music font 
            perform yadjust 
            if pyy > 0 
              y = py 
            else 
              y += py 
            end 
            if color_flag > 4 
              perform subj3 (color_flag)           /* New &dA12/21/10&d@ 
            else 
              perform subj 
            end 
          end 
          if bit(27, ts(c3,SUBFLAG_1)) = 1 or bit(27, ts(c3,ED_SUBFLAG_1)) = 1
            t2 = 16                       /* inverted fermata code = 16 
            perform getpxpy (t2,c1) 

            x = obx + px 
            c13 = vpar(63) 
            z = 102                         /* music font 
            t7 = c7 
            if stem = 0 
              c7 = 0 
            else 
              c7 = 1 
            end 
            perform yadjust 
            c7 = t7 
            y -= vpar(63) 
            if pyy > 0 
              y = py 
            else 
              y += py 
            end 
            if color_flag > 4 
              perform subj3 (color_flag)           /* New &dA12/21/10&d@ 
            else 
              perform subj 
            end 
          end 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 10. yadjust (operates on an entire chord at once)                ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Purpose:  to work in conjunction with setperf to adjust         ³ 
&dA &d@³              the y position so that the indication will            ³ 
&dA &d@³              fall on c4/c5 or above/below the staff line,          ³ 
&dA &d@³              whichever is higher/lower.  Procedure also            ³ 
&dA &d@³              determines a new value of the virtual endpoints,      ³ 
&dA &d@³              c4/c5 based on the y position and the vertical        ³ 
&dA &d@³              space parameter, c13, which is passed to the          ³ 
&dA &d@³              procedure.                                            ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Inputs:   c4 = virtual vertical position of controlling         ³ 
&dA &d@³                       note head                                    ³ 
&dA &d@³              c5 = virtual vertical position of end of stem         ³ 
&dA &d@³              stem = stem direction  0 = up                         ³ 
&dA &d@³                                     1 = down                       ³ 
&dA &d@³              c7 = situation flag    0 = place on note head         ³ 
&dA &d@³                                     1 = place on stem              ³ 
&dA &d@³             c13 = vertical space of next character to set          ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Outputs:  c4 = updated vertical position of controlling         ³ 
&dA &d@³                       note head                                    ³ 
&dA &d@³              c5 = updataed vertical position of end of stem        ³ 
&dA &d@³              c9 = position flag (1 = place on top of staff)        ³ 
&dA &d@³                                                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure yadjust 
        int t1 

        if c7 = 0  
          if stem = DOWN
            if c4 > vpar(1)  
              c4 = vpar(1) 
            end  
          else   
            if c4 < vpar(7)  
              c4 = vpar(7) 
            end  
          end  
        else 
          if stem = DOWN
            if c5 < vpar(8)  
              c5 = vpar(8) 
            end  
          else 
            if c5 > 0  
              c5 = 0 
            end  
          end  
        end  
*   determine y location 
        c9 = stem + c7 
        t1 = 1 
        if c9 = 1  
          t1 = -1 
        end  
        if c7 = 0  
          y = 5 * notesize / 4 * t1 + c4 
          if stem = UP 
            y += c13 
          end  
        else 
          y = vpar(2) * t1 + c5        /* &dAwas vpar(1)&d@ 
          if stem = DOWN
            y += c13 
          end  
        end  
*    compute new vertual endpoints   
        if c7 = 1  
          c5 += c13 * t1 
        else 
          c4 += c13 * t1 
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 11. setleger                                         ³ 
&dA &d@³                                                        ³ 
&dA &d@³    Purpose, set leger lines for a chord (object)       ³ 
&dA &d@³                                                        ³ 
&dA &d@³    Inputs:  obx = x-position of object                 ³ 
&dA &d@³        passsize = note size (full, cue-size)           ³ 
&dA &d@³              c7 = pointer to lowest note in chord      ³ 
&dA &d@³              c8 = pointer to highest note in chord     ³ 
&dA &d@³              c9 = extra width of leger lines           ³ 
&dA &d@³            stem = stem direction   0 = up, 1 = down    ³ 
&dA &d@³      color_flag = put out leger in color  (&dA12/21/10&d@)   ³ 
&dA &d@³                                                        ³ 
&dA &d@³    Internal: x,y,z  sent to subj                       ³ 
&dA &d@³                                                        ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setleger 
        z = passsize * 128 + 45                 /* music font 
        x = obx  
        if stem = UP 
          ++x
        end  
        if ts(c8,STAFFLOC) < 0 
          y = 0 - notesize 
          loop while y >= ts(c8,STAFFLOC)  
            if color_flag > 4 
              perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
            else 
              perform subj 
            end 
            if c9 > 0  
              x += c9 
              if color_flag > 4 
                perform subj3 (color_flag)      /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
              x -= c9 
            end  
            y -= notesize 
          repeat 
        end  
        if ts(c7,STAFFLOC) > vpar(9) 
          y = vpar(10) 
          loop while y <= ts(c7,STAFFLOC)  
            if color_flag > 4 
              perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
            else 
              perform subj 
            end 
            if c9 > 0  
              x += c9 
              if color_flag > 4 
                perform subj3 (color_flag)      /* New &dA12/21/10&d@ 
              else 
                perform subj 
              end 
              x -= c9 
            end  
            y += notesize 
          repeat 
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 12. wideleger                                                  ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose: set wide a leger line for a note head located on,    ³ 
&dA &d@³                above, or below a leger line                      ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Inputs:  obx = x-position of object                           ³ 
&dA &d@³             oby = y-position of object                           ³ 
&dA &d@³               x = x-position of note head                        ³ 
&dA &d@³               y = y-position of note head                        ³ 
&dA &d@³        passsize = note size (full size, cue size)                ³ 
&dA &d@³             c10 = note-on-line flag:  0 = on line, 1 = on space  ³ 
&dA &d@³      color_flag = put out leger in color  (&dA12/21/10&d@)             ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Internal:  x,y,z  sent to subj                                ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure wideleger  
        int t1 

        z = passsize * 128 + 45                 /* music font 
        t1 = x 
        if c10 = 0   
          --x
        end  
        if color_flag > 4 
          perform subj3 (color_flag)            /* New &dA12/21/10&d@ 
        else 
          perform subj 
        end 
        if c10 = 0   
          x += hpar(106) 
        else   
          x += hpar(107) 
        end  
        if color_flag > 4 
          perform subj3 (color_flag)            /* New &dA12/21/10&d@ 
        else 
          perform subj 
        end 
        x = t1 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 13. number (na,dva)                              ³ 
&dA &d@³                                                    ³ 
&dA &d@³    Purpose:  Create subobject for number           ³ 
&dA &d@³                                                    ³ 
&dA &d@³    Inputs:  na = number                            ³ 
&dA &d@³             dva = center position for number       ³ 
&dA &d@³                                                    ³ 
&dA &d@³    Outputs: dva = right boundary of number         ³ 
&dA &d@³                                                    ³ 
&dA &d@³             x,z sent to subj                       ³ 
&dA &d@³                                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure number (na,dva) 
        int na,dva 

        getvalue na,dva 
        x = dva - hpar(21) 
        if na > 99    
          x = dva + hpar(21) 
        else   
          if na > 9   
            x = dva    
          end  
        end  
        dva = x + hpar(20) 
NU1:    na /= 10 
        z = rem + 71                      /* music font
        perform subj 
        if na = 0   
          passback dva 
          return   
        end  
        x -= hpar(20) 
        goto NU1   
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 14. setdots                                                ³ 
&dA &d@³                                                              ³ 
&dA &d@³    Purpose:  typeset sub-object dot(s)                       ³ 
&dA &d@³                                                              ³ 
&dA &d@³    Inputs:  c3 = pointer into set array for this note        ³ 
&dA &d@³            obx = horizontal position of object               ³ 
&dA &d@³            oby = vertical position of object                 ³ 
&dA &d@³       passsize = note size (full size, cue size)             ³ 
&dA &d@³     color_flag = put out dots in color  (&dA12/21/10&d@)           ³ 
&dA &d@³                                                              ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setdots     
        int t1,t2,t3,t4,t6 

        t4 = ts(c3,DOT) 
        if t4 > 0 
          t1 = t4 >> 4                          /* code modified &dA12-24-96&d@ 
          t1 /= INT10000 
          t2 = rem 
          if t2 > (INT10000 >> 1) 
            t2 -= INT10000 
            ++t1 
          end 
          
          t6 = 18                               /* New code &dA05/02/03&d@ extension dot code = 18
          perform getpxpy (t6,c3) 

          if pxx = 1 
            x = obx + px 
          else 
            x = obx + t1 + px 
          end 
          if pyy = 1 
            y = oby + py 
          else 
            y = oby + t2 + py 
          end 
                                                /* end New code 

          z = 128 * passsize + 44               /* music font 
          if color_flag > 0
            perform subj3 (color_flag)          /* New &dA12/21/10&d@ 
          else 
            perform subj                        /* first dot 
          end 
          if t4 & 0x03 = 3 
            t3 = hpar(91) 
            if passsize = CUESIZE
              t3 = t3 * 8 / 10 
            end 
            x += t3                       
            if color_flag > 0
              perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
            else 
              perform subj                      /* second dot 
            end 
          end

&dA &d@    added code  &dA12-24-96&d@ 

          if t4 & 0x04 = 4 
            t3 = hpar(91) 
            if passsize = CUESIZE
              t3 = t3 * 8 / 10 
            end 
            x += t3                       
            if color_flag > 0
              perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
            else 
              perform subj                      /* third dot 
            end 
          end
          if t4 & 0x08 = 8 
            t3 = hpar(91) 
            if passsize = CUESIZE
              t3 = t3 * 8 / 10 
            end 
            x += t3                       
            if color_flag > 0
              perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
            else 
              perform subj                      /* fourth dot 
            end 
          end
        end  
      return   

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 15. setrest (t6)                                             ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Purpose:  write object rest                                 ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Inputs:  c1       = pointer into set array for this rest    ³ 
&dA &d@³             obx      = horizontal position of rest             ³ 
&dA &d@³             oby      = vertical position of rest               ³ 
&dA &d@³             c3       = oby offset (for grand staff)            ³ 
&dA &d@³             ntype    = type of note (e.g. sixteenth)           ³ 
&dA &d@³             passsize = rest type (full size, cue size)         ³ 
&dA &d@³             passtype = type of pass (reg,cue,grace,cuegrace)   ³ 
&dA &d@³             passnum  = pass number for this rest               ³ 
&dA &d@³             inctype  = increment type for next node            ³ 
&dA &d@³                          with a new spn (used in putobj)       ³ 
&dA &d@³             opt_rest_flag = put out rest with small r          ³ 
&dA &d@³             color_flag = put out rest in color  (&dA12/21/10&d@)     ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Output:  t6       = amount of space taken up                ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Operation:  In addition to writing the object rest, this    ³ 
&dA &d@³                procedure must also check to see if the rest is ³ 
&dA &d@³                the beginning or end of a tuplet group.  In the ³ 
&dA &d@³                former case, the tuplet array, tuar, must be    ³ 
&dA &d@³                constructed; in the latter case, the tuplet     ³ 
&dA &d@³                super-object must be compiled and written out.  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setrest (t6) 
        str temp.100 
        int t1,t2,t3,t4,t5,t6,t7,t8,t9,t10 

        t10 = c3 
        x = obx
        y = oby  
        t1 = 0
        if ntype > QUARTER 
          t6 = hpar(87)                   /* total horizontal space taken 
        else 
          t6 = hpar(88)                   /* total horizontal space taken 
        end 
              
        if ntype > SIXTEENTH
          z = 128 * passsize + 55 - ntype       /* music font 
          if color_flag > 0
            perform subj3 (color_flag)          /* New &dA12/21/10&d@ 
          else 
            perform subj 
          end 
        else 
          y += notesize 
          if ntype < THIRTY_SECOND
            y = 4 - ntype * notesize + y   
          end  
          z = 128 * passsize + 49               /* music font 
          if color_flag > 0
            perform subj3 (color_flag)          /* New &dA12/21/10&d@ 
          else 
            perform subj 
          end 
          ++z
          if passsize = FULLSIZE
            t3 = notesize 
            t4 = hpar(54) 
          else 
            t3 = vpar(65) 
            t4 = hpar(89) 
          end 
          t2 = ntype 
          loop while t2 < EIGHTH
            y -= t3
            x += t4
            t6 += t4                      /* total horizontal space taken 
            ++t1
            if color_flag > 0
              perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
            else 
              perform subj 
            end 
            ++t2 
          repeat 
        end  
        if ts(c1,DOT) > 0  
          t3 = ts(c1,DOT) 
          t8 = t3 & 0x0f                  /* actual DOT code  (modified &dA12-24-96&d@)
          t3 >>= 4                        /* code modified &dA12-24-96&d@ 
          t3 /= INT10000 
          t7 = rem 
          if t7 > (INT10000 >> 1) 
            t7 -= INT10000 
            ++t3 
          end 
          y = oby + t7 
          x += t3 
          t6 = vpar(1) 
          if passsize = CUESIZE
            t6 = t6 * 8 / 10              /* space for dot   
          end 
          t6 += t3 
          z = 128 * passsize + 44               /* music font 
          if color_flag > 0
            perform subj3 (color_flag)          /* New &dA12/21/10&d@ 
          else 
            perform subj                        /* first dot 
          end 
          if t8 & 0x02 = 2 
            t5 = hpar(91) 
            x += t5                       
            if color_flag > 0
              perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
            else 
              perform subj                      /* second dot 
            end 
            t6 += t5 
          end

&dA &d@     code added &dA12-24-96&d@ 

          if t8 & 0x04 = 4 
            t5 = hpar(91) 
            x += t5                       
            if color_flag > 0
              perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
            else 
              perform subj                      /* third dot 
            end 
            t6 += t5 
          end
          if t8 & 0x08 = 8 
            t5 = hpar(91) 
            x += t5                       
            if color_flag > 0
              perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
            else 
              perform subj                      /* fourth dot 
            end 
            t6 += t5 
          end

        end 
SRST1: 
        passback t6                       /* total horizontal space taken 
&dA 
&dA &d@    New &dA10/15/07&d@ 
&dA 
        if opt_rest_flag = 0 
          jtype = "R" 
        else 
          jtype = "r" 
        end 

        jcode = ntype  
        out = "0"  
        if bit(4,ts(c1,SUPER_FLAG)) = 1   /* if begin tuplet
          ++snum
          tuar(passtype,passnum,TU_SNUM) = snum 
          tuar(passtype,passnum,TU_Y1) = y  
          tuar(passtype,passnum,TU_Y2) = y  
          tuar(passtype,passnum,TU_FSTEM) = DOWN   /*  (default)
          t7 = 0 
          if bit(6,ts(c1,SUPER_FLAG)) = 1         /* tuplet has a bracket 
            t7 = ts(c1,SUPER_FLAG) & 0x3c0        /* bits 6,7,8,9 &dA03-21-97&d@ 
            t7 <<= 2 
          end 
          tuar(passtype,passnum,TU_FSTEM) += t7   /* tuplet flags &dA03-21-97&d@ 
          out = "1 " // chs(snum)  
        end  
        if bit(5,ts(c1,SUPER_FLAG)) = 1   /* if end tuplet
          t7 = tuar(passtype,passnum,TU_FSTEM) & 0xff 
          goto TPFF(tpflag+1) 
TPFF(1):                                   /* default tuplet placement 
TPFF(2):                                   /* place tuplet near note heads 
          if t7 = UP 
            goto TPFFA 
          else 
            goto TPFFB 
          end 
TPFF(3):                                   /* place tuplet near stems 
          if t7 = UP 
            goto TPFFB 
          else 
            goto TPFFA 
          end 
TPFF(4):                                   /* place all tuplets above notes 
          goto TPFFB 
TPFF(5):                                   /* place all tuplets below notes 
          goto TPFFA 

TPFFA:
          t3 = tuar(passtype,passnum,TU_Y2) + notesize + vpar(64) 
          t4 = notesize * 6 
          if t7 <> UP 
            t3 += vpar(7) 
          end 
          if t3 < t4 
            t3 = t4 
          end 
          t9 = 4          /* tips up &dA03-21-97&d@ 
          goto TPFFC 
TPFFB: 
          t3 = tuar(passtype,passnum,TU_Y2) - notesize 
          t4 = 0 - vpar(1)         
          if t7 = UP 
            t3 -= vpar(7) 
          end 
          if t3 > t4 
            t3 = t4 
          end 
          t9 = 0          /* tips down &dA03-21-97&d@ 
TPFFC:
          t3 -= tuar(passtype,passnum,TU_Y1) 
          t5 = t4 - oby 
          out = "1 " // chs(tuar(passtype,passnum,TU_SNUM))   
        end  
&dA 
&dA &d@ fermata over rest  
&dA 
        if bit(26,ts(c1,SUBFLAG_1)) = 1        /* New &dA12/18/10&d@ 
          t2 = 15                       /* upright fermata code = 15 
          perform getpxpy (t2,c1) 

          x = obx + px 
          if pyy > 0 
            y = py 
          else 
            y = py - vpar(1) 
          end 
          z = 101                         /* music font
          if color_flag > 4 
            perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
          else 
            perform subj 
          end 
        end  
        if bit(27,ts(c1,SUBFLAG_1)) = 1        /* New &dA12/18/10&d@ 
          t2 = 16                       /* inverted fermata code = 16 
          perform getpxpy (t2,c1) 

          x = obx + px 
          z = 102                         /* music font
          y = vpar(10)                    /* changed &dA05/02/03&d@ 
          if pyy > 0 
            y = py 
          else 
            y += py 
          end 
          if color_flag > 4 
            perform subj3 (color_flag)        /* New &dA12/21/10&d@ 
          else 
            perform subj 
          end 
        end  
        if sobcnt = 1  
          pcode = z  
        else 
          pcode = sobcnt 
        end  
        t7 = inctype 
        if ts(c1,CLAVE) = 101             /* if movable rest
          inctype = 10000  
        end  
&dA 
&dA &d@    New code add 01/03/04 to deal with special case of type 7 whole rests 
&dA 
        if ts(c1,CLAVE) = 102             /* flag whole rest as potentially "removable"
          inctype = 10001 
        end  
        oby += t10 
&dA 
&dA &d@       Now look for print suggestions for this note object 
&dA 
        putobjpar = 0 
        t4 = ts(c1,TSR_POINT) 
        pcontrol = ors(tsr(t4){1})                      /* &dA05/02/03&d@ 
        px = ors(tsr(t4){3}) << 8 
        py = ors(tsr(t4){4}) << 16 
        t1 = ors(tsr(t4){2}) << 24 
        putobjpar = t1 + px + py + pcontrol             /* Note: order of data has been changed

        perform putobj                    
        inctype = t7 
        if bit(5,ts(c1,SUPER_FLAG)) = 1   /* if end tuplet
          t1 = tuar(passtype,passnum,TU_FSTEM) >> 8           /* tuplets flags &dA03-21-97
          if t1 > 0 
            t1 >>= 1                /* remove bracket present flag 
            t1 <<= 5 
            t9 |= t1 
            t9 |= 0x02              /* bracket present flag 
          else 
            t9 = 1 
          end 
          ++outpnt 
&dA 
&dA &d@      New &dA11/05/05&d@  Convert TUPLE to 1000 * n1 + n2 format and get x,y adjustments
&dA 
          t1 = ts(c1,TUPLE) & 0xffff 
          t2 = t1 >> 8 
          t1 &= 0xff 
          t2 *= 1000 
          t1 += t2 

          t6 = ts(c1,TUPLE) & 0xff0000        /* x adjustment 
          t6 >>= 16 
          if t6 > 0 
            t6 = t6 - 128                     /* center to zero 
          else 
            t6 = 0 
          end 

          t4 = ts(c1,TUPLE) & 0xff000000      /* y adjustment 
          t4 >>= 24 
          if t4 > 0 
            t4 = t4 - 128                     /* center to zero 
          else 
            t4 = 0 
          end 
          t3 += t4 
          t5 += t4 
&dA                  

          tput [Y,outpnt] H ~tuar(passtype,passnum,TU_SNUM)  X ~t9  ~t1  ~t6  ~t3  ~t6  ~t5  0
          tuar(passtype,passnum,TU_SNUM) = 0        /* New added from s2ed 
          tpflag = global_tpflag 
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 16. putobj                                                        ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Purpose:  write object and sub-objects to intermediate list      ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Inputs:  jtype = object type (field 2)                           ³ 
&dA &d@³             jcode = object code (field 3)                           ³ 
&dA &d@³             obx   = object offset from staff x-position (field 4)   ³ 
&dA &d@³             oby   = object offset form staff y-position (field 5)   ³ 
&dA &d@³             pcode = print code (field 6) (or sobl counter)          ³ 
&dA &d@³             spn   = space node (field 7)                            ³ 
&dA &d@³             inctype = increment type for next node with a new spn   ³ 
&dA &d@³             out     = fields 9 --                                   ³ 
&dA &d@³             temp3   = occationally temp3 is used in place of        ³ 
&dA &d@³                         sobl(1) when there is only 1 subobject      ³ 
&dA &d@³             sobl()  = subobject line                                ³ 
&dA &d@³             c1,c2   = pointer to first and last elements in         ³ 
&dA &d@³                         ts(.,.) array for this object               ³ 
&dA &d@³                                                                     ³ 
&dA &d@³             putobjpar = parameters modifying operation of putobj    ³ 
&dA &d@³                                                                     ³ 
&dA &d@³                putobjpar & 0x01 = control    0 = no modifications   ³ 
&dA &d@³                                                    in this byte     ³ 
&dA &d@³                                              1 = possible mods in   ³ 
&dA &d@³                                                    this byte        ³ 
&dA &d@³                                                                     ³ 
&dA &d@³                putobjpar & 0x06 = blank flag 0 = no blanking        ³ 
&dA &d@³                                              2 = blank all sub-obj  ³ 
&dA &d@³                                              4 = replace all sub-obj³           
&dA &d@³                                                    with one         ³ 
&dA &d@³                                                    extension dot    ³ 
&dA &d@³                                                                     ³ 
&dA &d@³                putobjpar & 0xf0 = (four) various flags              ³ 
&dA &d@³                  For Notes, Grace Notes, Cue Notes ("NGQ" con jtype)³ 
&dA &d@³                                           0x10 = stem present       ³ 
&dA &d@³                                                   0 = no stem       ³ 
&dA &d@³                                                   1 = stem          ³ 
&dA &d@³                                           0x20 = stem direction     ³ 
&dA &d@³                                                   0 = UP            ³ 
&dA &d@³                                                   1 = DOWN          ³ 
&dA &d@³                                           0x40 = note/chord         ³ 
&dA &d@³                                                   0 = single note   ³ 
&dA &d@³                                                   1 = chord         ³ 
&dA &d@³                                                                     ³ 
&dA &d@³                                                                     ³ 
&dA &d@³                putobjpar & 0x00ff00   = x position data + 128       ³ 
&dA &d@³                                          (in tenths of notesize)    ³ 
&dA &d@³                                         0 = no data                 ³ 
&dA &d@³                                                                     ³ 
&dA &d@³                putobjpar & 0xff0000   = y position data + 128       ³ 
&dA &d@³                                          (in tenths of notesize)    ³ 
&dA &d@³                                         0 = no data                 ³ 
&dA &d@³                                                                     ³ 
&dA &d@³                putobjpar & 0xff000000 = position data flags         ³ 
&dA &d@³                                                                     ³ 
&dA &d@³                                  0x01 = data active flag            ³ 
&dA &d@³                                  0x02 = x data flag                 ³ 
&dA &d@³                                         1 = x location relative to  ³ 
&dA &d@³                                             obx                     ³ 
&dA &d@³                                         0 = modification to         ³ 
&dA &d@³                                             x location as calculated³ 
&dA &d@³                                  0x04 = y data flag                 ³ 
&dA &d@³                                         1 = y location on staff     ³ 
&dA &d@³                                         0 = modification to         ³ 
&dA &d@³                                             y location as calculated³ 
&dA &d@³                                                                     ³ 
&dA &d@³             fix_next_inctype = static variable initialized at BIG,  ³  New &dA01/19/04
&dA &d@³                                  set and used only by putobj.       ³ 
&dA &d@³                                Variable provides a means for putobj ³ 
&dA &d@³                                to "remember" when it has altered an ³ 
&dA &d@³                                inctype, and a way to "add back" any ³ 
&dA &d@³                                amount taken away.                   ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Outputs: sobcnt set to 0                                         ³ 
&dA &d@³             supcnt set to 0                                         ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Internal variable:  oldspn = spn from previous object            ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putobj 
        str temp.180,super.180 
        str params.30(20) 
        int oldspn,t 
        int t1,t2,t3,t4,t5,t6,t8,t9 
        int s1,s2,s3,s4,s5,s6,s7,s8,s9 
        int stem,chord 
        int high,low,highpoint,lowpoint 
        int highstem,lowstem,stemlength 
        int nflags,slash,pcnt 
        int grflag 
&dA 
&dA &d@    This code added &dA01/19/04&d@ to fix the accumulation of inctypes 
&dA 
        if fix_next_inctype > 0 and inctype > 0          
          if (Debugg & 0x06) > 0 
            pute Program Warning: 
            pute     Attempting to adjust the next Inctype from ~inctype  ...
          end 
          inctype -= fix_next_inctype 
          if inctype < 0 
            inctype = 0 
          end 
          if (Debugg & 0x06) > 0 
            pute to ~inctype 
          end 
          fix_next_inctype = 0 
        end 
&dA   

&dA 
&dA &d@       New Code &dA09/14/03&d@ 
&dA &d@       ----------------- 
&dA &d@       If jtype = "I", then inctype may need to be recalculated from the ts(.) array
&dA 
        if jtype = "I" and a1 > 1 
          t3 = 10000 
          loop for t1 = a1 - 1 to 1 step -1 
            t2 = ts(t1,DIV) 
            if t2 < ts(a1,DIV) 
              t3 = ts(a1,DIV) - t2 * 576 / divspq 
              t1 = 1 
            end 
          repeat 

          if t3 <> 10000 and t3 <> inctype 
            if (Debugg & 0x06) > 0 
              pute Program Caution:  Inctype for "I" type object changed from ~inctype  to  ~t3
            end 
            fix_next_inctype = t3 - inctype      /* fix_next_inctype set &dA01/19/04
            inctype = t3 
          end 
        end 

        t = inctype 
        if t <> 10000 and t <> 10001             /* 10001 added &dA01/03/04&d@ 
          if spn = oldspn 
            t = 0 
          end 
          if spn = 1 
            t = 0 
          end 
        end 
        stem = 0 
        if "NGQ" con jtype and jcode < WHOLE 
          stem = putobjpar & 0xf0 
          stem >>= 4 
          putobjpar &= 0xffffff0f                /* strip stem codes from putobjpar
        end 
&dA 
&dA &d@    Determine: t1 = final obx   as modified by print suggestions 
&dA &d@               t2 = final oby                                       &dA05/02/03
&dA 
        px = putobjpar >> 8   & 0xff 
        py = putobjpar >> 16  & 0xff 
        if px > 0 
          px = px - 128 * notesize / 10 
        end 
        t1 = obx + px 
        if py > 0 
          py = py - 128 * notesize / 10 
          t4 = putobjpar >> 24  & 0xff 
          if bit(2,t4) = 1 
            t2 = py 
            if oby > 700 
              t2 += 1000 
            end 
          else 
            t2 = oby + py 
          end 
        else 
          t2 = oby 
        end 
&dA 
&dA &d@    If putobjpar & 0x01 = 1, then we are dealing with certain rennaisance notation
&dA &d@      which allows a note duration to extend beyond a bar line.  In this case,
&dA &d@      the note beyond the barline may be blanked entirely (putobjpar & 0x02 = 1),
&dA &d@      or it may be replaced with an extension dot (putobjpar & 0x04 = 1).  
&dA 
        if (bit(0,putobjpar)) = 1 
          putobjpar &= 0xff 
          t3 = pcode 
          t4 = putobjpar >> 1 
          if t4 = 1 or t4 = 2 
            if t3 > 0 and t3 < 32 
              if sobl(1) = "" 
                t3 = 0 
              else 
                t6 = 0 
                if t4 = 2 
                  ++t6 
                  t8 = t2 / vpar(2) 
                  if rem = 0 
                    t8 = vpar(1) - notesize 
                  else 
                    t8 = 0 
                  end 

                  t9 = DOT_CHAR 
                  sobl(t6) = "K 0 " // chs(t8) // " " // chs(t9) 
                end 
                loop for t5 = 1 to t3 
                  if sobl(t5){1} = "A" 
                    ++t6 
                    sobl(t6) = sobl(t5) 
                  end 
                repeat 
                t3 = t6 
              end 
            end 
          end 
        else 
          t3 = pcode 
        end 

        ++outpnt 
&dA 
&dA &d@     &dA11/20/06&d@  This code added for special case of a slur terminating 
&dA &d@               on a non-printed note.  
&dA 
        if jtype = "N" and jcode = 0 
          t3 = 0 
        end 
&dA                 &d@ End of &dA11/20/06&d@ addition 

        tput [Y,outpnt] J ~jtype  ~jcode  ~t1  ~t2  ~t3  ~spn  ~t  ~out 
&dA 
&dA &d@    Look for marks that could be incorporated with this object 
&dA 
        super = "" 
        if jtype = "N" 
          tget [Y,outpnt-1] temp .t5 s1 s2 s3 s4 s5 s6 s7 s8 
          if temp{1} = "H" 
            super = temp 
            tget [Y,outpnt-2] temp .t5 s1 s2 s3 s4 s5 s6 s7 s8 
          end 
          if temp{1,3} = "J M" and s2 = t1 and s5 = spn and s7 = 1 
            if super = "" 
              --outpnt 
            else 
              outpnt -= 2 
            end 
            out = trm(out) 
            out = out // " " 
            s9 = int(out) 
            ++s9 
            out = chs(s9) // out{sub..} // chs(s8) 
            t = s6 
            tput [Y,outpnt] J ~jtype  ~jcode  ~t1  ~t2  ~t3  ~spn  ~t  ~out 
          else 
            super = "" 
          end 
        end 

        oldspn = spn 
        if t3 > 0 and t3 < 32 
          if sobl(1) = "" 
            ++outpnt 
            tput [Y,outpnt] ~temp3 
          else 
            loop for sobcnt = 1 to t3 
              ++outpnt 
              tput [Y,outpnt] ~sobl(sobcnt) 
            repeat 
          end 
        end 
        sobcnt = 0 
        supcnt = 0 
        if super <> "" 
          ++outpnt 
          tput [Y,outpnt] ~super 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 17. subj                                                 ³ 
&dA &d@³                                                            ³ 
&dA &d@³    Purpose:  write sub-object to intermediate list         ³ 
&dA &d@³                                                            ³ 
&dA &d@³    Inputs:  x = horizontal position of sub-object          ³ 
&dA &d@³             y = vertical position of sub-object            ³ 
&dA &d@³             z = character number                           ³ 
&dA &d@³             obx = object offset from staff x-position      ³ 
&dA &d@³             oby = object offset from staff y-position      ³ 
&dA &d@³             sobcnt = counter in intermediate list          ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure subj   
        ++sobcnt
        sobx = x - obx
        soby = y - oby 
        sobl(sobcnt) = "K " // chs(sobx) // " " // chs(soby) // " "
        sobl(sobcnt) = sobl(sobcnt) // chs(z) 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 18. subj2     /* Addition to Code &dA02/25/97&d@               ³ 
&dA &d@³                                                            ³ 
&dA &d@³    Purpose:  write "invisible" sub-object to               ³ 
&dA &d@³                intermediate list                           ³ 
&dA &d@³                                                            ³ 
&dA &d@³    Inputs:  x = horizontal position of sub-object          ³ 
&dA &d@³             y = vertical position of sub-object            ³ 
&dA &d@³             z = character number                           ³ 
&dA &d@³             obx = object offset from staff x-position      ³ 
&dA &d@³             oby = object offset from staff y-position      ³ 
&dA &d@³             sobcnt = counter in intermediate list          ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure subj2 
        ++sobcnt
        sobx = x - obx
        soby = y - oby 
        sobl(sobcnt) = "k " // chs(sobx) // " " // chs(soby) // " "
        sobl(sobcnt) = sobl(sobcnt) // chs(z)   
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 18b. subj3 (cc)        Addition to Code &dA12/21/10&d@         ³ 
&dA &d@³                                                            ³ 
&dA &d@³    Purpose:  write "color" sub-object to                   ³ 
&dA &d@³                intermediate list                           ³ 
&dA &d@³                                                            ³ 
&dA &d@³    Inputs:  x = horizontal position of sub-object          ³ 
&dA &d@³             y = vertical position of sub-object            ³ 
&dA &d@³             z = character number                           ³ 
&dA &d@³             obx = object offset from staff x-position      ³ 
&dA &d@³             oby = object offset from staff y-position      ³ 
&dA &d@³             sobcnt = counter in intermediate list          ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 

      procedure subj3 (cc) 
        str temp.80 
        int cc 
        getvalue cc 

        cc &= 0x3 
        ++sobcnt 
        sobx = x - obx 
        soby = y - oby 
        temp = "C " 
        if cc = 2 
          temp = temp // "0x00ff00 " 
        else 
          if cc = 3 
            temp = temp // "0x0000ff " 
          end 
        end 
        sobl(sobcnt) = temp // chs(sobx) // " " // chs(soby) // " " // chs(z)
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 19. cancelsig (t4,t2,t1,klave)                               ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Purpose:  Write out cancellation of sharps or flats         ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Inputs:   obx = object location                             ³ 
&dA &d@³              oby =   "       "                                 ³ 
&dA &d@³              x  = x starting point                             ³ 
&dA &d@³              t1 = number of sharps or flats to cancel          ³ 
&dA &d@³              t2 = one less than starting point in zak(.,.)     ³ 
&dA &d@³              t4 = selection   1 = sharps                       ³ 
&dA &d@³                               2 = flats                        ³ 
&dA &d@³                               3 = sharps (clef = tenor)        ³ 
&dA &d@³              klave = line on which to start calcellations      ³ 
&dA &d@³                        (from which y is computed)              ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure cancelsig  (t4,t2,t1,klave) 
        int t1,t2,t3,t4 
        int klave,tenor 

        getvalue t4,t2,t1,klave 

        tenor = 0 
        if t4 = 3 
          t4 = 1 
          tenor = 1     /* exception for sharps in the tenor cler 
        end 

        z = 64 
        loop for t3 = 1 to t1 
          if tenor = 0 or klave >= 0 
            y = klave + 20 * notesize / 2 - vpar20 
          else 
            y = klave + 27 * notesize / 2 - vpar20 
          end 
          perform subj 
          ++t2 
          klave += zak(t4,t2) 
          x += hpar(11) 
        repeat 

        passback klave 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 20. setmrest (mrest, wrest)                                  ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Purpose:  Set multiple rests and terminating bar line       ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Inputs:     p = horizontal starting point                   ³ 
&dA &d@³            mrest = number of rests to set                      ³ 
&dA &d@³          measnum = measure number for terminating bar line     ³ 
&dA &d@³            wrest = optional type 7 whole rest flag (&dA01/03/04&d@)  ³ 
&dA &d@³how_much_mrest(2) = divspq, divspm                              ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Outputs:    p = new horizontal point                        ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Operation: For multiple rests we need to communicate        ³ 
&dA &d@³                 P7 = rest's rhythmic duration                  ³ 
&dA &d@³                                                                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setmrest (mrest, wrest) 
        str temp.80 
        int t1,t2,t3,t4,t5,t6 
        int mrest,wrest 

        getvalue mrest,wrest 

        putobjpar = 0 
        if mrest > 1   
          p += hpar(22) 
          obx = p  
          oby = vpar(3)  
          x = obx  
          y = oby  
          z = 62 
          perform subj 
          y = oby + vpar(11) 
          perform subj 
          z = 92 
          x = obx  
          y = vpar(4)  
          loop for t1 = 1 to 3  
            perform subj 
            x += 30 
            p += 30 
          repeat 
          y = oby  
          z = 62 
          perform subj 
          y = oby + vpar(11) 
          perform subj 
          t6 = p - 45 
          t5 = mrest  

&dA          &d@ Slight code modification &dA11/18/08&d@ 
&dA 
&dA &d@     In the case of musical parts, for notesize 21 anyway, I think 
&dA &d@     the number above a multiple rest is easier to read if it is 2 dots 
&dA &d@     above the middle line.  Admittedly, this is a magic number at the 
&dA &d@     moment.  
&dA 
          if notesize = 21 
            y = vpar(4) - 2 
          else 
            y = vpar(4) 
          end 
&dA 
&dA          

          perform number (t5,t6)   /* t6 is returned, but is not needed here
          jtype = "S"  
          jcode = 4    
          out = "0"  
          pcode = sobcnt 
          spn = mrest  

          perform putobj 
          p += hpar(23) 

          t1 = 1                /* New &dA10/29/08&d@: 1 was the old value for J B (field 8)

        else   
          obx = p + hpar(24) 
          oby = vpar(4)  
          ++outpnt 
          if wrest = 1 
            tput [Y,outpnt] J R 9 ~obx  ~oby  46 1 10001 0 
          else 
            tput [Y,outpnt] J R 9 ~obx  ~oby  46 1 10000 0 
          end 
          p += hpar(25) 

&dA                  &d@  New &dA10/29/08&d@ 
&dA 
&dA &d@       We need to try to compute a J B (field 8) value that mirrors 
&dA &d@       the expected distance increment flag in a normal measure.  
&dA &d@       We will use the data in: how_much_mrest(2) = divspq, divspm 
&dA 
          t1 = 576 * how_much_mrest(2) / how_much_mrest(1) 
&dA 
&dA                  

        end  
        obx = p + hpar(36) 
&dA 
&dA &d@     &dA03/07/06&d@    Adding capability of setmrest to set "mdotted", "mdouble",
&dA &d@                 "mheavy2", "mheavy3", in addition to "measure".  No repeat dots,
&dA &d@                 endings, or other signs are allowed here.  
&dA 
        if mrest_line{2,6} = "easure" 
          ++outpnt                                       
          tput [Y,outpnt] J B ~measnum  ~obx  1 82 6913 ~t1  0
          p = obx + hpar(37) 
        end 
        if mrest_line{2,6} = "dotted" 
          ++outpnt 
          tput [Y,outpnt] J B ~measnum  ~obx  3 86 6913 ~t1  0
          p = obx + hpar(37) 
        end 
&dA 
&dA &d@     hpar(44) = actual white space between two light lines 
&dA &d@     hpar(45) = actual white space between heavy/light, light/heavy and heavy/heavy combinations
&dA &d@     hpar(79) = thickness of light line 
&dA &d@     hpar(81) = thickness of heavy line 
&dA 
        if mrest_line{2,6} = "double" 
          t2 = hpar(44) + hpar(79) 
          t4 = obx + t2 
          ++outpnt 
          tput [Y,outpnt] J B ~measnum  ~t4  5 2 6913 ~t1  0
          ++outpnt 
          tput [Y,outpnt] K -~t2  0 82 
          ++outpnt 
          tput [Y,outpnt] K 0 0 82 
          p = t4 + hpar(37)
        end 
        if mrest_line{2,6} = "heavy3" 
          t2 = hpar(45) + hpar(81) 
          ++outpnt 
          tput [Y,outpnt] J B ~measnum  ~obx  9 2 6913 ~t1  0
          ++outpnt 
          tput [Y,outpnt] K 0 0 84 
          ++outpnt 
          tput [Y,outpnt] K ~t2  0 82 
          p = obx + hpar(37) + t2 
        end 
        if mrest_line{2,6} = "heavy2" 
          t2 = hpar(45) + hpar(81) + hpar(79) - 1 
          t3 = hpar(81) - 1 
          t4 = obx + t2 
          ++outpnt 
          tput [Y,outpnt] J B ~measnum  ~t4  6 2 6913 ~t1  0
          ++outpnt 
          tput [Y,outpnt] K -~t2  0 82 
          ++outpnt 
          tput [Y,outpnt] K -~t3  0 84 
          p = t4 + hpar(37)
        end 

        loop for t5 = 1 to MAX_STAFF 
          loop for t6 = 1 to 45 
            emptyspace(t5,t6) = hpar(37) 
          repeat 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 21. getspace                                                      ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Purpose:  Determine space parameter for particular note value    ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Inputs:    a5 = pointer into set array                           ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Outputs:   a6 = space parameter                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure getspace   
        int t1,t2,t3,t4 
        int gsp_ntype                 /* new &dA10/15/07&d@ 
        int note_style                /* new &dA01/08/11&d@ 

&dA 
&dA &d@      Determine note style (New &dA01/08/11&d@) 
&dA 
        note_style = ts(a5,SUBFLAG_1) & 0x8000 
        note_style >>= 15 
&dA     
        if ts(a5,CLAVE) = 101 or ts(a5,CLAVE) = 102       /* movable rest (altered &dA01/03/04&d@)
          a6 = hpar(24) + hpar(25) - hpar(37)  
          return 
        end  

        gsp_ntype = ts(a5,NTYPE) & 0xff            /* new &dA10/15/07&d@ 
        a6 = gsp_ntype * 3                         /* new &dA10/15/07&d@ 

        if a6 = 0  
          a6 = 3 
        end  
        --a6
        if ts(a5,DOT) > 0 
          ++a6
        else 
          if (ts(a5,TUPLE) & 0xffff) > 2          /* New &dA11/05/05&d@ 
            --a6
          end  
        end  
        a6 = nsp(a6)   

        t4 = hpar(28) * xmindist / 100 / hpar(4)   /* New &dA01/08/11&d@ 

*  make extra space for up-flags 
        if ts(a5,TYPE) = NOTE and bit(1,ts(a5,STEM_FLAGS)) = UP 
          if ts(a5,BEAM_FLAG) = NO_BEAM and gsp_ntype    < QUARTER     /* new &dA10/15/07
            a6 += t4       
            if note_style = 0                     /* New &dA01/08/11&d@ 
              t3 = hpar(26) + t4 + hpar(82) 
            else 
              t3 = hpar(26) + t4 
            end 

            if a6 < t3 
              loop for t1 = a5+1 to sct 
                if ts(t1,DIV) > ts(a5,DIV) 
                  loop for t2 = t1 to sct 
                    if ts(t2,DIV) = ts(t1,DIV) 
                      if ts(t2,TYPE) <= NOTE_OR_REST 
                        if ts(t2,STAFF_NUM) = ts(a5,STAFF_NUM) 
                          if ts(t2,CLAVE) >= ts(a5,CLAVE) 
                            a6 = t3 
                            t2 = sct 
                          end 
                        end 
                      end 
                    else 
                      t2 = sct 
                    end 
                  repeat 
                  t1 = sct 
                end 
              repeat 
            end 
          end 
        end  
*  allow mininum extra space if next note on staff has stem-down repeaters 


*  make extra space for sixteenth and smaller rests  
        if ts(a5,TYPE) = REST and gsp_ntype    < EIGHTH        /* new &dA10/15/07
          a6 = 6 - gsp_ntype    * hpar(54) + a6                /* new &dA10/15/07
        end 
*  shrink space if cue-size flag is set 
        if bit(16,ts(a5,SUBFLAG_1)) = CUESIZE 
          a6 = a6 * 8 / 10 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 22. wordspace                                    ³ 
&dA &d@³                                                    ³ 
&dA &d@³    Purpose:  Calculate length of word              ³ 
&dA &d@³                                                    ³ 
&dA &d@³    Inputs:    ttext   = word                       ³ 
&dA &d@³                  c5   = font number                ³ 
&dA &d@³               curfont = currently active font      ³ 
&dA &d@³                                                    ³ 
&dA &d@³    Outputs:   a5 = space taken up by word          ³ 
&dA &d@³                                                    ³ 
&dA &d@³               curfont possibly modified            ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure wordspace  
        int t1,t2,d1 

        a5 = 0 
*   get new spacing parameters, if needed  
        perform spacepar (c5) 

&dA                                            
&dA 
&dA &d@    Rewriting this section &dA04/22/04&d@ 
&dA 
        loop for t2 = 1 to len(ttext) 
          if ttext{t2} = "\" 
            if t2 = len(ttext) 
              tmess = 5 
              perform dtalk (tmess) 
            end 
            if "!@#$%^&*(-=" con ttext{t2+1} 
              if mpt < 10 
                ++t2 
                a5 += mpt 
                goto NXC 
              else 
                ++t2 
                a5 -= (mpt - 9) 
                goto NXC 
              end 
            end 
&dA 
&dA &d@       New &dA02/02/09&d@ 
&dA 
            if ttext{t2+1} = "+"  
              ++t2 
              a5 += spc(32) 
              goto NXC 
            end 
&dA     
            if t2 + 1 = len(ttext) 
              tmess = 5 
              perform dtalk (tmess) 
            end 
            ++t2 
            if ttext{t2} = "0" 
              t1 = ors(ttext{t2+1}) + 128 
              if chr(t1) in [160,206,212,224] 
                tmess = 5 
                perform dtalk (tmess) 
              end 
              ++t2 
              a5 += spc(t1) 
              goto NXC 
            end 
            if ttext{t2} = "\" 
              t1 = ors(ttext{t2}) 
              a5 += spc(t1) 
              goto NXC 
            end 
            if ttext{t2} in ['a'..'z','A'..'Z'] 
              d1 = ors(ttext{t2}) 
              if "1345789" con ttext{t2+1} 
                t1 = ors(ttext{t2}) 
              else 
                if ttext{t2+1} = "2" 
                  if ttext{t2} = "s" 
                    t1 = 244                                /* German ss 
                  else 
                    t1 = ors(ttext{t2}) 
                  end 
                else 
                  tmess = 5 
                  perform dtalk (tmess) 
                end 
              end 
              ++t2 
            else 
              --t2 
              t1 = ors(ttext{t2}) 
            end 
          else 
            t1 = ors(ttext{t2})  
          end  
          a5 += spc(t1) 
NXC: 
        repeat 
&dA 
&dA &d@    End of &dA04/22/04&d@ rewrite 
&dA 
&dA                                      

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 23. kernttext     NEW &dA04/22/04&d@                   ³ 
&dA &d@³                                                    ³ 
&dA &d@³    Purpose:  Apply kerning to ttext                ³ 
&dA &d@³                                                    ³ 
&dA &d@³    Inputs:    ttext   = word                       ³ 
&dA &d@³               c5      = current font               ³ 
&dA &d@³                                                    ³ 
&dA &d@³    Outputs:   revised ttext                        ³ 
&dA &d@³                                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure kernttext 
        str tline.300 
        int t1,t2,t3

        if ttext = "" 
          return 
        end 

        ttext = ttext // " " 
        tline = "" 
        loop for t1 = 1 to len(ttext) 
          if "abcdefghijklmnopqrstuvwxyz" con ttext{t1} 
            t2 = mpt 
            if "abcdefghijklmnopqrstuvwxyz" con ttext{t1+1} 
              t3 = mpt 
              if kernmap(t2,t3) = 0 
                tline = tline // ttext{t1} 
              else 
                if kernmap(t2,t3) = -1 
                  tline = tline // ttext{t1} // "\-" 
                else 
                  if kernmap(t2,t3) = 1 
                    tline = tline // ttext{t1} // "\!" 
                  end 
                end 
              end 
            else 
              tline = tline // ttext{t1} 
            end 
          else 
            if "ABCDEFGHIJKLMNOPQRSTUVWXYZ" con ttext{t1} 
              t2 = mpt + 26 
              if "abcdefghijklmnopqrstuvwxyz" con ttext{t1+1} 
                t3 = mpt 
                if kernmap(t2,t3) = 0 
                  tline = tline // ttext{t1} 
                else 
                  if kernmap(t2,t3) = -1 
                    tline = tline // ttext{t1} // "\-" 
                  else 
                    if kernmap(t2,t3) = -2 
                      tline = tline // ttext{t1} // "\=" 
                    end 
                  end 
                end 
              else 
                tline = tline // ttext{t1} 
              end 
            else 
              tline = tline // ttext{t1} 
            end 
          end 
        repeat 
        t1 = len(tline) - 1 
        ttext = tline{1,t1} 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 24. spacepar (t5)                                          ³ 
&dA &d@³                                                              ³ 
&dA &d@³    Purpose:  Be sure that proper space parameters are loaded ³ 
&dA &d@³                                                              ³ 
&dA &d@³    Inputs:    t5 = font number                               ³ 
&dA &d@³                                                              ³ 
&dA &d@³    Outputs:   valid spc(.) array for this font               ³ 
&dA &d@³               font_base, font_height, zero_height            ³ 
&dA &d@³                 for this font (new &dA02/03/08&d@)                 ³ 
&dA &d@³               valid kernmap(.,.) for this font               ³ 
&dA &d@³               updated value of curfont                       ³ 
&dA &d@³                                                              ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure spacepar (t5) 
        int t1,t2,t3,t4,t5 

        getvalue t5 

        if t5 = curfont 
          return 
        end 

&dA &d@       t5 is a font number between 51 and 140  (90 possibilities) 
&dA &d@       We want three numbers:  font_base font_height zero_height 
&dA &d@       They are permanently contained in a file called fonthite 
&dA &d@       (90 records, three numbers in a record)   This could all 
&dA &d@       be stored in a string which is 270 characters long.  
&dA &d@       We have loaded this data into a string called hitestr.270 

        sizenum = revsizes(notesize) 
        t1 = t5 - 29                        /* 1 <= t1 <= 19 
        t2 = XFonts(sizenum,t1) - 50        /* 1 <= t2 <= 90 (text font) 
        --t2 
        t2 *= 3 
        ++t2 

        font_base   = ors(hitestr{t2})   - 30 
        font_height = ors(hitestr{t2+1}) - 30 
        zero_height = ors(hitestr{t2+2}) - 30 

&dA      

        curfont = t5 

        t1  = t5 - 29                      /* 1 <= t1 <= 19 
        t2  = XFonts(sizenum,t1) - 50      /* 1 <= t2 <= 90 (text font) 
        t2  = (t2 - 1) * 200 + 1 

        loop for t3 = 1 to 31 
          spc(t3) = 0 
        repeat 
        loop for t3 = 32 to 127 
          spc(t3) = ors(fontspac{t2}) 
          ++t2 
        repeat 
        t2 += 4 
        loop for t3 = 128 to 159 
          spc(t3) = 0 
        repeat 
        loop for t3 = 160 to 255 
          spc(t3) = ors(fontspac{t2}) 
          ++t2 
        repeat 

&dA                                                                  

        t1 = t5 - 29                                        /* 1 <= t1 <= 19
        t2 = XFonts(sizenum,t1) - 50                        /* 1 <= t2 <= 90 (text font)

        if t2 < 31 
          loop for t3 = 1 to 26 
            loop for t4 = 1 to 26 
              kernmap(t3,t4) = all_real_kernmaps(t2,t3,t4) 
            repeat 
          repeat 
        else 
          loop for t3 = 1 to 26 
            loop for t4 = 1 to 26 
              kernmap(t3,t4) = 0 
            repeat 
          repeat 
        end 
&dA 
&dA &d@    Note: The higher section of kernmap(.,.) is for the moment 
&dA &d@          permanantly set to zeros (in procedure &dCload_font_stuff&d@) 
&dA 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 25. newnsp                                                    ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Purpose:  Calculate new nsp array                            ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Inputs:    scnt     = next logical record in input table     ³ 
&dA &d@³               divspq   = number of divisions per quarter note   ³ 
&dA &d@³               xmindist = minimum distance between notes (x100)  ³ 
&dA &d@³               mindist  = minimum distance between notes         ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Outputs:   new nsp array for this section                    ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Internal variables:  t1,t2,t3,t4,t5,t6                       ³ 
&dA &d@³                         mtot                                    ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Strategy:  (1) read through file until the next time         ³ 
&dA &d@³                      signature change or until the end          ³ 
&dA &d@³               (2) count number of measures where shortest       ³ 
&dA &d@³                      duration occurs                            ³ 
&dA &d@³               (3) if this represents more than xx% of the       ³ 
&dA &d@³                      outstanding measures, then this is         ³ 
&dA &d@³                      the shortest note                          ³ 
&dA &d@³               (4) otherwise, the shortest note is the           ³ 
&dA &d@³                      next one up; i.e.                          ³ 
&dA &d@³                         triplets --> regular                    ³ 
&dA &d@³                          regular --> double regular             ³ 
&dA &d@³                                                                 ³ 
&dA &d@³       nsp(35) will be space for longa                           ³ 
&dA &d@³       nsp(32) will be space for longa                           ³ 
&dA &d@³       nsp(29) will be space for breve                           ³ 
&dA &d@³       nsp(26) will be space for whole                           ³ 
&dA &d@³       ...                                                       ³ 
&dA &d@³       nsp(5)  will be space for 128th note                      ³ 
&dA &d@³       nsp(2)  will be space for 256th note                      ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure newnsp 
        int t1,t2,t3,t4,t5,t6,t7 
        int mtot
        str line.120 

        t6  = scnt                 /* temporary counter in input 
        loop for t1 = 1 to 36 
          nsp(t1) = xmindist       /* New &dA12/16/03&d@ 
        repeat 
        if minshort <> 0 
          t1 = minshort * 4 
          rem = 0                  /* sloppy code 
          goto NOCALC 
        end 

        t2 = 100   
        mtot = 0 
        t7 = 0                     /* "durations found" flag (initialize at 0) 
        loop 
          t1 = 0   
          tget [X,t6] line .t6 t1 
          ++t6                     /* increment temporary counter 
          line = line // pad(4)  
          if line{1,4} = "/END" or line{1,4} = "/FIN" 
            goto NW1 
          end  
          if line{1} = "$" and line con "T:" and t7 = 1 
            goto NW1 
          end 
          if t6 > 9990 
            tmess = 38 
            perform dtalk (tmess) 
          end 
          if line{1,3} = "mea" 
            ++mtot
            t4 = 0   
          end  
*
          if line{1} in ['A'..'G','r'] and t1 > 0  /* positive dur
            t7 = 1 
            if t1 < t2 
              t2 = t1                   /* new shortest note
              t3 = 0   
              t4 = 0   
            end  
            if t1 = t2 and t4 = 0
              t4 = 1   
              ++t3                      /* inc number of measures 
            end  
          end    
        repeat 
&dA 
&dA &d@  t2 = shortest note value  
&dA &d@  t3 = number of measures where this note occurs    
&dA 
NW1:
        if t7 = 0           /* No durations found (unusual case) 
          mtot = 1 
          t2 = 1 
          t3 = 1 
        end 

        t5 = divspq * 16 / t2  
        if t5 > 96   
          t4 = 0            /* case 1: always double shortest note
        else 
          if t5 > 48   
            t4 = 5          /* case 2: double if less than 16%
          else 
            if t5 > 24 
              t4 = 8        /* case 3: double if less than 11%
            else 
              t4 = 10       /* case 4: double if less than 9%
            end  
          end  
        end  
*  
        t1 = mtot / t3 
        if t1 > t4   
          t1 = divspq / 3  
          if rem = 0 
            t1 = t2 / 2  
            if rem = 0 
              t2 = t1 * 3  
            else 
              t2 *= 2 
            end  
          else 
            t2 *= 2 
          end  
        end  
*  
        t1 = divspq * 16 / t2  
&dA &d@  if t1 = 1, shortest note is longa   
&dA &d@  if t1 = 2, shortest note is breve   
&dA &d@  if t1 = 4, shortest note is whole   
&dA &d@  if t1 = 8, shortest note is half, etc   
        t2 = t1 / 3  
        if rem = 0 
          t1 = t2 * 2  
        end  
 
NOCALC: 
        t5 = 32          /* 32 = code for longa 
        t4 = 160   
*
        t1 >>= 1 
        loop while t1 > 0           /* i.e., if t1 started as 16th (t1 = 64), loop 6 times
          t5 -= 3 
          t4 -= 20 
          t1 >>= 1 
        repeat
*
        if rem = 0                             /* sloppy code.  See up 100 lines for expl.
          nsp(t5) = xmindist * 10 / 9        /* New &dA12/16/03&d@ 
        end  
        if t4 > 100  
          nsp(t5) = nsp(t5) * t4 / 100   
        end  
        nsp(t5+1) = nsp(t5) * 12 / 10  
        t1 = 13  
*
        loop while t5 < 34 
          t4 = t5 + 3  
          nsp(t4) = nsp(t5) * t1 / 10    
          ++t1 
          t5 = t4  
          nsp(t5-1) = nsp(t5) * 9 / 10 
          nsp(t5+1) = 2 * nsp(t5) - nsp(t5-3)
        repeat   
&dA 
&dA &d@    Now reduce all nsp(.) numbers by factor of 100  (&dA12/16/03&d@) 
&dA 
        loop for t1 = 1 to 36 
          nsp(t1) = nsp(t1) + 50 / 100 
        repeat 
&dA   
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 26. settime (t1)                             ³ 
&dA &d@³                                                ³ 
&dA &d@³    Purpose:  Set time signature                ³ 
&dA &d@³                                                ³ 
&dA &d@³    Inputs:    tnum = time numerator            ³ 
&dA &d@³               tden = time denominator          ³ 
&dA &d@³                p   = current x position        ³ 
&dA &d@³               oby  = 0 or 1000 (staff 0 or 1)  ³ 
&dA &d@³               spn  = space node (obj field 7)  ³   &dA01/17/04&d@ 
&dA &d@³                                                ³ 
&dA &d@³    Outputs:   p = new x position               ³ 
&dA &d@³               t1 = amount of empty space       ³ 
&dA &d@³                                                ³ 
&dA &d@³    Internal variables:  t2,t3,t4,t5,t6         ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure settime (t1) 
        int t1,t2,t3,t4,t5,t6 
        int t22 
        str mcode.4 
        label MCDS(17) 

        jcode = tnum * 100 + tden 
        putobjpar = 0 

        t2 = 0   
        if tnum = 1 and tden = 1
          t2 = 1   
        end    
        if tden = 0 
          if tnum = 0 
            t2 = 2 
          else 
            t2 = 3 
            mcode = "****" 
            if tnum > 99 
              mcode = " " // chs(tnum) 
            else 
              if tnum > 10 
                mcode = "  " // chs(tnum) 
              end 
            end 
          end 
          t22 = 0 
          if "  11  12  21  22  31  41  51  61  71  81  91 101 102 103 111 112 121" con mcode
            t22 = (mpt - 1) / 4 + 1     /* 1,2, ...,17 
          end 
        end 
*  
        if (Debugg & 0x06) > 0 
          pute Time = ~tnum :~tden 
        end 
*   set time signature 
        jtype = "T"  
        out = "0"  
        if t2 > 0    
          if t2 < 3 
            obx = p 
            oby += vpar(6) 
            pcode = 1 
            t3 = 36 + t2 
            sobl(1) = "K 0 0 " // chs(t3) 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - hpar(92) 
            oby -= vpar(6) 
          else 
            t1 = hpar(14) 
            obx = p 
            oby += vpar(4) 
            if t22 = 0 
              goto MCDS_END 
            end 
            goto MCDS(t22) 
MCDS(1):                     /* circle 
            pcode = 2 
            sobl(1) = "K 0 0 1011" 
            sobl(2) = "K 0 0 1012" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(4) - 3 
            goto MCDS_END 
MCDS(2):                     /* circle w/colon 
            pcode = 4 
            sobl(1) = "K 0 0 1011" 
            sobl(2) = "K 0 0 1012" 
            sobl(3) = "K 0 -" // chs(vpar(95)) // " 1015" 
            sobl(4) = "K 0 " // chs(vpar(95)) // " 1015" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(4) - 3 
            goto MCDS_END 
MCDS(3):                     /* circle w/dot 
            pcode = 3 
            sobl(1) = "K 0 0 1011" 
            sobl(2) = "K 0 0 1012" 
            sobl(3) = "K 0 0 1015" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(4) - 3 
            goto MCDS_END 
MCDS(4):                     /* circle w/three dots(2+1) 
            pcode = 5 
            sobl(1) = "K 0 0 1011" 
            sobl(2) = "K 0 0 1012" 
            sobl(3) = "K -" // chs(hpar(141)) // " -" // chs(vpar(94)) // " 1015"
            sobl(4) = "K " // chs(hpar(141)) // " -" // chs(vpar(94)) // " 1015"
            sobl(5) = "K 0 " // chs(vpar(95)) // " 1015" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(4) - 3 
            goto MCDS_END 
MCDS(5):                     /* circle open to the right 
            pcode = 1 
            sobl(1) = "K 0 0 1012" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(4) 
            goto MCDS_END 
MCDS(6):                     /* circle open to the right w/dot 
            pcode = 2 
            sobl(1) = "K 0 0 1012" 
            sobl(2) = "K 0 0 1015" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(4) 
            goto MCDS_END 
MCDS(7):                     /* circle open to the left 
            pcode = 1 
            sobl(1) = "K 0 0 1011" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(4) - 3 
            goto MCDS_END 
MCDS(8):                     /* circle open to the right w/cut 
            pcode = 1 
            sobl(1) = "K 0 0 1013" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(4) 
            goto MCDS_END 
MCDS(9):                     /* circle open to the right, followed by "2" 
            pcode = 2 
            sobl(1) = "K 0 0 1012" 
            sobl(2) = "K " // chs(hpar(142)) // " 0 1016" 
            perform putobj 
            p += (hpar(14) + vpar(3)) 
            t1 = hpar(14) - hpar(142) 
            goto MCDS_END 
MCDS(10):                    /* circle, followed by "2" 
            pcode = 3 
            sobl(1) = "K 0 0 1011" 
            sobl(2) = "K 0 0 1012" 
            sobl(3) = "K " // chs(hpar(142)) // " 0 1016" 
            perform putobj 
            p += (hpar(14) + vpar(3)) 
            t1 = hpar(14) - hpar(142) 
            goto MCDS_END 
MCDS(11):                    /* circle w/cut 
            pcode = 2 
            sobl(1) = "K 0 0 1011" 
            sobl(2) = "K 0 0 1013" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(4) 
            goto MCDS_END 
MCDS(12):                    /* circle open to the right w/cut, followed by "3"
            pcode = 2 
            sobl(1) = "K 0 0 1013" 
            sobl(2) = "K " // chs(hpar(142)) // " 0 1017" 
            perform putobj 
            p += (hpar(14) + vpar(3)) 
            t1 = hpar(14) - hpar(142) 
            goto MCDS_END 
MCDS(13):                    /* simple "3" 
            pcode = 1 
            sobl(1) = "K 0 0 1017" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(3) 
            goto MCDS_END 
MCDS(14):                    /* "3" over "2" 
            pcode = 1 
            sobl(1) = "K 0 0 1018" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(3) 
            goto MCDS_END 
MCDS(15):                    /* circle open to the right w/cut, followed by "2"
            pcode = 2 
            sobl(1) = "K 0 0 1013" 
            sobl(2) = "K " // chs(hpar(142)) // " 0 1016" 
            perform putobj 
            p += (hpar(14) + vpar(3)) 
            t1 = hpar(14) - hpar(142) 
            goto MCDS_END 
MCDS(16):                    /* simple "2" 
            pcode = 1 
            sobl(1) = "K 0 0 1016" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(3) 
            goto MCDS_END 
MCDS(17):                    /* concentric circles 
            pcode = 1 
            sobl(1) = "K 0 0 1014" 
            perform putobj 
            p += hpar(14) 
            t1 = hpar(14) - vpar(3) 
            goto MCDS_END 
MCDS_END: 
            oby -= vpar(4) 
          end 
        else   
          t6 = p + hpar(16) 
          if tden < 10 and tnum < 10
            t6 = p + hpar(17) 
          end  
*  
          obx = t6 
*  
          y = vpar(4) + oby 
          t3 = tnum 
          t4 = obx 
          perform number (t3,t4) 
          t5 = t4 
          y = vpar(8) + oby 
          t3 = tden 
          t4 = obx 
          perform number (t3,t4) 
          pcode = sobcnt 
          perform putobj 
          if t4 > t5 
            t4 = t5 
          end  
          p = t4 + hpar(18) 
          t1 = hpar(18) 
        end  
        passback t1 
      return

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 27. process_section (f4)                           ³ 
&dA &d@³                                                      ³ 
&dA &d@³    Purpose:  Set parameters for new section          ³ 
&dA &d@³                                                      ³ 
&dA &d@³    Inputs:  divspq   = divisions per quarter         ³ 
&dA &d@³                 tnum = time numerator                ³ 
&dA &d@³                 tden = time denominator              ³ 
&dA &d@³                 @n   = set array counter (for        ³ 
&dA &d@³                         changes within measure)      ³ 
&dA &d@³                 line = "$" control code line         ³ 
&dA &d@³                                                      ³ 
&dA &d@³    Outputs:    p = new x position                    ³ 
&dA &d@³               f4                                     ³ 
&dA &d@³                                                      ³ 
&dA &d@³    Internal variables:  @spn                         ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure process_section (f4) 
        str line2.180 
        int t1,t2,t3,t4,t5,t6,t7 
        int f4 
        int @spn                                     /* New &dA01/17/04&d@ 

        getvalue f4 

&dA &d@ &dAÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dA &d@ &dA³  BEGINNING OF SECTION PROCESSING        ³&d@ 
&dA &d@ &dAÀÄÄ-ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@      New code for single line staff    &dA12/18/05&d@ 
&dA 
        if line con "C:0" 
          single_line = 1 
        end 
&dA     
        if @n > 0 or outslurs <> "00000000" 
          if @n = 0 
            @spn = 6913 
          else 
            @spn = 0                      /* code for "don't use this information"
          end         
          if line con "I:" 
            vflag = int(line{mpt+2..}) 
            if vflag < 1 
              vflag = 1 
            end 
            if vflag > 3 
              vflag = 3 
            end 
          end 
          if line con "S:" 
            nstaves = int(line{mpt+2..}) 
            if nstaves < 1 
              nstaves = 1 
            end 
            if nstaves > 2 
              nstaves = 2 
            end 
          end 
          if line con "C:" or line con "C1:"               
            ++@n 
            tv1(@n) = CLEF_CHG 
            if line{mpt+2} = ":" 
              ++mpt 
            end 
            tv2(@n) = int(line{mpt+2..}) 
            tv3(@n) = 0                     /* staff number 
            if line con "D:" or line con "D1:" or large_clef_flag > 0  /* New &dA02/02/09
              tcode(@n) = "0"               /* music font 
            else 
              tcode(@n) = "128"             /* music font 
            end 
            tv5(@n) = @spn                  /* added &dA01/17/04&d@ 
          end 
          if line con "C2:" 
            ++@n 
            tv1(@n) = CLEF_CHG 
            tv2(@n) = int(line{mpt+3..}) 
            tv3(@n) = 1                     /* staff number 
            if line con "D2:" or large_clef_flag > 0                   /* New &dA02/02/09
              tcode(@n) = "0"               /* music font 
            else 
              tcode(@n) = "128"             /* music font 
            end 
            nstaves = 2 
            tv5(@n) = @spn                  /* added &dA01/17/04&d@ 
          end 
          if line con "D:" or line con "D1:" 
            ++@n 
            tv1(@n) = DESIGNATION 
            tv2(@n) = 0 
            tv3(@n) = 0                     /* staff number 
            tcode(@n) = "" 
            if line{mpt+1} <> ":" 
              ++mpt 
            end 
            line2 = trm(line{mpt+2..}) 
            tdata(@n,1) = mrt(line2) 
            tv5(@n) = @spn                  /* added &dA01/17/04&d@ 
          end 
          if line con "D2:" 
            ++@n 
            tv1(@n) = DESIGNATION 
            tv2(@n) = 0 
            tv3(@n) = 1                     /* staff number 
            tcode(@n) = "" 
            line2 = trm(line{mpt+3..}) 
            tdata(@n,1) = mrt(line2) 
            nstaves = 2 
            tv5(@n) = @spn                  /* added &dA01/17/04&d@ 
          end 
&dA 
&dA &d@     Another change on &dA05/29/05&d@.  In this case, I am moving the keychange "K:"
&dA &d@     code from below the "Q:" code to above the time "T:" code.  This conforms 
&dA &d@     with the normal way sections are introduced.  What I don't know, however,
&dA &d@     is whether this conflicts with some other convention, or whether the program
&dA &d@     code depended in some way on the old order.  Again, we must watch this
&dA &d@     and see if it produces strange results in the future.  
&dA 
          if line con "K:" 
            ++@n 
            tv1(@n) = AX_CHG 
            tv2(@n) = int(line{mpt+2..}) 
            tv3(@n) = nstaves 
            tcode(@n) = "" 
            tv5(@n) = @spn                  /* added &dA01/17/04&d@ 
          end 
&dA        
          if line con "T:" 
            ++@n 
            tv1(@n) = METER_CHG 
            tnum = int(line{mpt+2..}) 
            if line con "/" 
              tden = int(line{mpt+1..}) 
            else 
              tmess = 6 
              perform dtalk (tmess) 
            end 
            tv2(@n) = 100 * tnum + tden 
            tv3(@n) = nstaves 
            tcode(@n) = "" 
            tv5(@n) = @spn                  /* added &dA01/17/04&d@ 
          end 
          if line con "Q:" 
            ++@n 
            tv1(@n) = DIV_CHG 
            tv2(@n) = int(line{mpt+2..}) 
            tv3(@n) = 0           
            tcode(@n) = "" 
            tv5(@n) = @spn                  /* added &dA01/17/04&d@ 
          end 
          return  
        end 
*
        spn = 6913 
        if line con "I:" 
          vflag = int(line{mpt+2..}) 
          if vflag < 1 
            vflag = 1 
          end 
          if vflag > 3 
            vflag = 3 
          end 
        end 
        if line con "S:" 
          nstaves = int(line{mpt+2..}) 
          if nstaves < 1 
            nstaves = 1 
          end 
          if nstaves > 2 
            nstaves = 2 
          end 
        end 
        if line con "D2:" 
          nstaves = 2 
        end 
&dA 
&dA &d@   (1) clef 
&dA 
        if line con "C:" or line con "C1:" or line con "C2:" 
          t2 = 0 
          t1 = 0 
          if line con "C:" or line con "C1:" 
            if line{mpt+1} = ":" 
              t2 = mpt + 2 
            else 
              t2 = mpt + 3 
            end 
          end 
          if line con "C2:" 
            t1 = mpt + 3 
            nstaves = 2 
          end 
          if (t2 * t1) = 0      /* Case1: only one clef designator 
            if t2 > 0 
              t3 = 1 
            else 
              t2 = t1 
              t3 = 2 
            end 
            clef(t3) = int(line{t2..}) 
&dA 
&dA &d@      Special code for single line instruments &dA12/18/05&d@ 
&dA 
            if single_line = 1 
              clef(1) = 4 
            end 
&dA     
            perform zjcline (t3) 
            if p > 0 
              p -= hpar(37) 
            end 
            p += hpar(5) 
*   print clef 
            obx = p 
            oby = 5 - clef_vpos * notesize 
            oby = (t3 - 1) * 1000 + oby 
            if single_line = 0                   /* New condition &dA12/18/05&d@ 
              perform putclef (t3) 
            end 
          else            /* Case2: two clef designators 
            t3 = 1 
            clef(t3) = int(line{t2..}) 
            perform zjcline (t3) 
            if p > 0 
              p -= hpar(37) 
            end 
            p += hpar(5) 
*   print clef on staff 1  
            obx = p 
            oby = 5 - clef_vpos * notesize 
            perform putclef (t3) 
            t3 = 2 
            clef(t3) = int(line{t1..}) 
            perform zjcline (t3) 
*   print clef on staff 2 
            obx = p 
            oby = 5 - clef_vpos * notesize 
            oby += 1000
            perform putclef (t3) 
          end 
*   advance horizontal pointer 
          p += hpar(8) 
          t6 = hpar(8) - hpar(86) 
          loop for t1 = 1 to MAX_STAFF 
            loop for t5 = 1 to 45 
              emptyspace(t1,t5) = t6 
            repeat 
          repeat 
        end 
&dA 
&dA &d@   (2) key signature  
&dA 
        if line con "K:" 
          t4 = int(line{mpt+2..}) 
          if line{sub} = "("                  /* new code &dA08/23/06&d@ 
            if line{sub+1} = "+" 
              t1 = int(line{sub+2..}) 
            else 
              t1 = int(line{sub+1..}) 
            end 
          else 
            t1 = 0 
          end 
          t5 = 1 
          perform key_change (t4, key, nstaves, t5, t1)    /* fifth variable added &dA08/23/06

          /* this sets key = t4 and resets claveax(.), emptyspace(.,.)  etc.  

        end 
&dA 
&dA &d@   (3) divisions per quarter 
&dA 
        if line con "Q:" 
          olddivspq = int(line{mpt+2..}) 
        end 
&dA 
&dA &d@   (4) time word 
&dA 
        if line con "D:" or line con "D1:" or line con "D2:" 
          a1 = 6913 
          if line not_con "T:" 
            a1 = 1 
&dA 
&dA &d@    f4 is set when a directive is placed with spn = 1.  This 
&dA &d@    directive takes its position from the next controlling 
&dA &d@    object in the part.  Therefore, it must not be followed 
&dA &d@    by a multiple rest.  
&dA 
            f4 = 1 
            passback f4 
          end 
          if line con "D:" 
            temp3 = trm(line{mpt+2..}) 
            temp3 = mrt(temp3) 
            oby = 0 - tword_height * vpar(1) 
            ++outpnt 
            tput [Y,outpnt] J D 5 ~p  ~oby  1 ~a1  0 0 
            ++outpnt 
            tput [Y,outpnt] W 0 0 ~dtivfont  ~temp3 
          end 
          if line con "D1:" 
            temp3 = trm(line{mpt+2..}) 
            temp3 = mrt(temp3) 
            oby = 0 - tword_height * vpar(1) 
            ++outpnt 
            tput [Y,outpnt] J D 5 ~p  ~oby  1 ~a1  0 0 
            ++outpnt 
            tput [Y,outpnt] W 0 0 ~dtivfont  ~temp3 
          end 
          if line con "D2:" 
            temp3 = trm(line{mpt+2..}) 
            temp3 = mrt(temp3) 
            oby = 0 - tword_height * vpar(1) 
            oby += 1000 
            ++outpnt 
            tput [Y,outpnt] J D 5 ~p  ~oby  1 ~a1  0 0 
            ++outpnt 
            tput [Y,outpnt] W 0 0 ~dtivfont  ~temp3 
          end 
        end 
&dA 
&dA &d@   (5) time signature (also new note spacing calculations) 
&dA 
        if line con "T:" 
          tnum = int(line{mpt+2..}) 
          if line con "/" 
            tden = int(line{mpt+1..}) 
          else 
            tmess = 6 
            perform dtalk (tmess) 
          end 
          oby = 0 
          t6 = p 
          loop for t5 = 1 to nstaves 
            p = t6 
            perform settime (t1) 
&dA 
&dA &d@       Actually, we will set emptyspace to hpar(29), the mimimum space 
&dA &d@       space allowed before an accidental.  This way, no note-type 
&dA &d@       objects will be able to crowd the time signature.  If this 
&dA &d@       works, we can remove the code that returns the value (t1) from 
&dA &d@       settime.  (We actually shouldn't be interested in this value 
&dA &d@       anyway, because we do NOT want to get too close to the time 
&dA &d@       signature.) 
&dA 
            loop for t7 = 1 to 45 
              emptyspace(t5,t7) = min_space            /* replaces hpar(29)   &dA11/19/07
            repeat 
            oby += 1000 
          repeat 
          if tnum = 1 and tden = 1 
            tnum = 4 
            tden = 4 
          end 
          if tnum = 0 and tden = 0 
            tnum = 2     
            tden = 2 
          end 
&dA 
&dA &d@   determine note spacing 
&dA &d@   ---------------------- 
&dA 
          divspq = olddivspq 
          perform newnsp 
        end 
      return 

&dA &d@ &dAÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dA &d@ &dA³  END OF SECTION PROCESSING    ³&d@ 
&dA &d@ &dAÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 28. key_change (newkey, oldkey, nstaves, t1, t2)   ³ 
&dA &d@³                                                      ³ 
&dA &d@³    Purpose:  Typeset a key change                    ³ 
&dA &d@³                                                      ³ 
&dA &d@³    Inputs:   int  newkey    new key                  ³ 
&dA &d@³              int  oldkey    old key                  ³ 
&dA &d@³              int  nstaves   number of staves         ³ 
&dA &d@³              int  t1        operation code           ³ 
&dA &d@³                               1 = change emptyspace  ³ 
&dA &d@³                               0 = don't do it        ³ 
&dA &d@³              int  t2        part of new key in       ³ 
&dA &d@³                               parenthesis  &dA08/23/06&d@  ³ 
&dA &d@³                                                      ³ 
&dA &d@³    Global variables:                                 ³ 
&dA &d@³                                                      ³ 
&dA &d@³              sobcnt         subobject counter        ³ 
&dA &d@³              p              x position pointer       ³ 
&dA &d@³              x              actual x-coordinate      ³ 
&dA &d@³              y              actual y-coordinate      ³ 
&dA &d@³              z              font number              ³ 
&dA &d@³              obx            object x-coordinate      ³ 
&dA &d@³              oby            object y-coordinate      ³ 
&dA &d@³              clef(.)        current clef             ³ 
&dA &d@³              measax(.,.)    current measure ax array ³ 
&dA &d@³              claveax(.)     global ax array          ³ 
&dA &d@³              jtype          object type              ³ 
&dA &d@³              jcode          object code              ³ 
&dA &d@³              pcode          number of sub objects    ³ 
&dA &d@³              out            ASCII string             ³ 
&dA &d@³                                                      ³ 
&dA &d@³    Outputs:    p = new x position                    ³ 
&dA &d@³                emptyspace(.,.) changed (if t1 = 1)   ³ 
&dA &d@³                                                      ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure key_change (newkey, oldkey, nstaves, t1, t2)    /* t2 added &dA08/23/06
        int newkey, oldkey, nstaves 
        int save_oldkey                          /* added &dA11/05/05&d@ 
        int sy 
        int hh 
        int t1,t2,t3,t4,t5,t6,t7,t8,t9 
        int klave,sklave 
        int tenor 
        int m1,m2,m3,m4,m5,m6                    /* added &dA08/23/06&d@ 

        getvalue newkey, oldkey, nstaves, t1, t2 

        if t2 <> 0                               /* magic numbers for editorial [] &dA08/23/06
          m1 = (2 * notesize + 3 / 6) 
          m2 = (4 * notesize + 3 / 6) 
          m3 = (7 * notesize + 3 / 6) 
          m4 = notesize + 3 / 6 
          m5 = (5 * notesize + 3 / 6) 
          m6 = notesize 
        end 

        t3 = newkey                  /* added &dA08/23/06&d@ 
        newkey = newkey + t2         /* added &dA08/23/06&d@ 
&dA 
&dA &d@    This code added &dA11/26/06&d@ to allow reprint of existing key signature 
&dA 
        if newkey = oldkey and key_reprint_flag > 0 
          oldkey = 0 
        end 
&dA                &d@ End of &dA11/26/06&d@ addition 

&dA                                                                
&dA 
&dA &d@    New code.  &dA10/15/07&d@.  It used to be the case that a non key 
&dA &d@    change in an orchestra part (such as horns) simply returned 
&dA &d@    at this point.  No i-file entry was generated because none was 
&dA &d@    needed.  The problem created by this was that if the mskpage 
&dA &d@    program was looking for a key change node (because other parts 
&dA &d@    had one) and didn't find one, this could cause a misalignment 
&dA &d@    of control node.  It turns out that the program crashed only 
&dA &d@    when the key change came at the end of a line, so nothing was 
&dA &d@    done about it.  (The bug was rare, and difficult to identify).  
&dA &d@    The advent of justification made the bug more likely to occur, 
&dA &d@    and it did (once too often).  So I decided on this fix, namely: 
&dA &d@     
&dA &d@    From now on, all key changes will generate a "J K" node, even 
&dA &d@    if there is none to be printed.  In this case, the node will 
&dA &d@    have no sub-objects and will therefore be "silent."  This seems 
&dA &d@    to have caused no other problems with the programs.  
&dA 

        if newkey = oldkey 
          loop for hh = 1 to nstaves 
            putobjpar = 0 
            sobcnt = 0 
            oby = 0 
            obx = p 
            x = obx 
            jtype = "K" 
            jcode = newkey 
            pcode = 0             
            out = "0" 
            oby = (hh - 1) * 1000 
            perform putobj 
          repeat 
          return 
        end 
&dA 
&dA &d@    End of &dA10/15/07&d@ addition 
&dA 
&dA                                                               &d@    

&dA                                                                
&dA 
&dA &d@    New code.  &dA11/02/07&d@.   Another situation has come up, which 
&dA &d@    I believe can be dealt with here.  In the case where the timpani 
&dA &d@    plays on the notes B-flat and F, the notation shows these two 
&dA &d@    pitches without a key signature.  In order to make this work, the 
&dA &d@    encoder used the pitches B-natural and F, and a key signature of 
&dA &d@    0 (no sharps or flats).  This of course would wreck havoc in a 
&dA &d@    midi file.  It would be far better to encode the key as -1 (one 
&dA &d@    flat) and then encode the pitches B-flat and F, as they would 
&dA &d@    actually sound.  The problem with this is that the key signature 
&dA &d@    would appear at the beginning of every line.  We need to have 
&dA &d@    a way to suppress this.  I propose a new global flag, suppress_key, 
&dA &d@    which can be set by the "k" global suggestion.  The following 
&dA &d@    code deals with this situation.  
&dA 
        if suppress_key > 0 
          save_oldkey = oldkey 
          loop for hh = 1 to nstaves 

*   set up new global accidentals for claveax 

            oldkey = newkey 
            loop for t7 = 1 to 50 
              claveax(t7) = 0 
            repeat 
            t6 = newkey 
            if t6 > 0 
              t5 = 4 
              loop for t7 = 1 to t6 
                loop for t8 = t5 to 50 step 7 
                  claveax(t8) = 2 
                repeat 
                t5 += 4 
                if t5 > 7 
                  t5 -= 7 
                end 
              repeat 
            end 
            if t6 < 0 
              t6 = 0 - t6 
              t5 = 7 
              loop for t7 = 1 to t6 
                loop for t8 = t5 to 50 step 7 
                  claveax(t8) = 3 
                repeat 
                t5 -= 4 
                if t5 < 1 
                  t5 += 7 
                end 
              repeat 
            end 
            oldkey = save_oldkey  

            putobjpar = 0 
            sobcnt = 0 
            oby = 0 
            obx = p 
            x = obx 
            jtype = "K" 
            jcode = 0        
            pcode = 0             
            out = "0" 
            oby = (hh - 1) * 1000 
            perform putobj 
          repeat 

          loop for t7 = 1 to 50 
            loop for t6 = 1 to 4                 /* &dA06/04/08&d@ was 3 
              measax(t6,t7) = claveax(t7) 
            repeat 
          repeat 
          oldkey = newkey                        /* moved &dA11/05/05&d@ 
          passback  oldkey 

          return 
        end 
&dA 
&dA &d@    End of &dA11/02/07&d@ addition 
&dA 
&dA                                                               &d@    

        putobjpar = 0 

        save_oldkey = oldkey                     /* added &dA11/05/05&d@ 
        loop for hh = 1 to nstaves 
          sobcnt = 0 
          oby = 0 
          t7 = clef(hh) / 10 
          klave = rem - 1 * 2
          t7 /= 3 
          t5 = 2 - rem * 3        
          klave -= t5 
          obx = p 
          x = obx 
          tenor = 0 
          if clef(hh) = 12 
            tenor = 2 
          end 
*   sharps 
          if newkey > 0 
*     cancellations?  
            sklave = klave 
            if oldkey > newkey 
              loop for t4 = 1 to newkey 
                klave += zak(1,t4) 
              repeat 
              t6 = oldkey - newkey 
              t9 = 1 + tenor 
              perform cancelsig (t9,t4,t6,klave) 
            end 
            if oldkey < 0 
              t6 = 0 - oldkey 
              klave += 4 
              t4 = 0 
              t9 = 2 
              perform cancelsig (t9,t4,t6,klave) 
            end 
            klave = sklave 
*   set new key 
            if t2 = 0 
              loop for t4 = 1 to newkey 
                z = 63 
                if tenor = 0 or klave >= 0 
                  y = klave + 20 * notesize / 2 - vpar20 
                else 
                  y = klave + 27 * notesize / 2 - vpar20    /* exception for tenor clef
                end 
                perform subj 
                klave += zak(1,t4) 
                x += hpar(9) 
              repeat 
            else 
&dA 
&dA &d@      This code added &dA08/23/06&d@ to deal with editorial additions of sharps 
&dA 
              if t2 > 0 
                loop for t4 = 1 to t3 
                  z = 63 
                  if tenor = 0 or klave >= 0 
                    y = klave + 20 * notesize / 2 - vpar20 
                  else 
                    y = klave + 27 * notesize / 2 - vpar20  /* exception for tenor clef
                  end 
                  perform subj 
                  klave += zak(1,t4) 
                  x += hpar(9) 
                repeat 
                loop for t4 = t3 + 1 to newkey 
                  x += m1                                   /* magic number 
                  z = 67 
                  if tenor = 0 or klave >= 0 
                    y = klave + 20 * notesize / 2 - vpar20 
                  else 
                    y = klave + 27 * notesize / 2 - vpar20  /* exception for tenor clef
                  end 
                  perform subj 
                  x += m2                                   /* magic number 
                  z = 63 
                  perform subj 
                  x += m3                                   /* magic number 
                  z = 68 
                  perform subj 
                  klave += zak(1,t4) 
                  x += (hpar(9) - m3)                       /* magic number 
                repeat 
              end 
&dA 
&dA        &d@ End of &dA08/23/06&d@ addition 
            end 
          end 
*   no sharps or flats 
          if newkey = 0 
*     cancellations?  
            t4 = 0 
            if oldkey > 0 
              t6 = oldkey 
              t9 = 1 + tenor 
              perform cancelsig (t9,t4,t6,klave) 
            end 
            if oldkey < 0 
              t6 = 0 - oldkey 
              t9 = 2 
              klave += 4
              perform cancelsig (t9,t4,t6,klave) 
            end 
          end 
*   flats 
          if newkey < 0 
*     cancellations?  
            sklave = klave 
            if oldkey < newkey 
              t6 = 0 - newkey 
              klave += 4       
              loop for t4 = 1 to t6 
                klave += zak(2,t4) 
              repeat 
              t6 = newkey - oldkey 
              t9 = 2 
              perform cancelsig (t9,t4,t6,klave) 
            end 
            if oldkey > 0 
              t6 = oldkey 
              t4 = 0 
              t9 = 1 + tenor 
              perform cancelsig (t9,t4,t6,klave) 
            end 
            klave = sklave + 4 
*   set new key 
            if t2 = 0 
              t6 = 0 - newkey 
              loop for t4 = 1 to t6 
                z = 65 
                y = klave + 20 * notesize / 2 - vpar20 
&dA 
&dA &d@   Code added &dA09/13/06&d@ to fix flats in soprano clef 
&dA 
                if y > vpar(8) 
                  y -= vpar(7) 
                end 
&dA      
                perform subj 
                klave += zak(2,t4) 
                x += hpar(11) 
              repeat 
            else 
&dA 
&dA &d@      This code added &dA08/23/06&d@ to deal with editorial additions of flats  
&dA 
              if t2 < 0 
                t3 = 0 - t3 
                t6 = 0 - newkey 
                loop for t4 = 1 to t3 
                  z = 65 
                  y = klave + 20 * notesize / 2 - vpar20 
&dA 
&dA &d@   Code added &dA09/13/06&d@ to fix flats in soprano clef 
&dA 
                  if y > vpar(8) 
                    y -= vpar(7) 
                  end 
&dA      
                  perform subj 
                  klave += zak(2,t4) 
                  x += hpar(9) 
                repeat 
                loop for t4 = t3 + 1 to t6        
                  x += m4                                   /* magic number 
                  z = 67 
                  y = klave + 20 * notesize / 2 - vpar20 
&dA 
&dA &d@   Code added &dA09/13/06&d@ to fix flats in soprano clef 
&dA 
                  if y > vpar(8) 
                    y -= vpar(7) 
                  end 
&dA      
                  perform subj 
                  x += m5                                   /* magic number 
                  z = 65 
                  perform subj 
                  x += m6                                   /* magic number 
                  z = 68 
                  perform subj 
                  klave += zak(2,t4) 
                  x += (hpar(11) - m6)                      /* magic number 
                repeat 
              end 
&dA 
&dA        &d@ End of &dA08/23/06&d@ addition 
            end 
          end 
*   Write out object and subobjects 
          jtype = "K" 
          jcode = newkey 
          pcode = sobcnt 
          out = "0" 
          oby = (hh - 1) * 1000 
          perform putobj 
* 
          if newkey = 0 and oldkey = 0 
            t7 = hpar(13) 
            if t1 = 1 
              loop for t4 = 1 to 45 
                emptyspace(hh,t4) += t7 
              repeat 
            end 
          else 
            t7 = hpar(12) 
            if t1 = 1 
              loop for t4 = 1 to 45 
                emptyspace(hh,t4) = t7 
              repeat 
            end 
          end 
        
          if hh = nstaves 
            p = x + t7 
          end 
*   set up new global accidentals for claveax 
          oldkey = newkey 
          loop for t7 = 1 to 50 
            claveax(t7) = 0 
          repeat 
          t6 = newkey 
          if t6 > 0 
            t5 = 4 
            loop for t7 = 1 to t6 
              loop for t8 = t5 to 50 step 7 
                claveax(t8) = 2 
              repeat 
              t5 += 4 
              if t5 > 7 
                t5 -= 7 
              end 
            repeat 
          end 
          if t6 < 0 
            t6 = 0 - t6 
            t5 = 7 
            loop for t7 = 1 to t6 
              loop for t8 = t5 to 50 step 7 
                claveax(t8) = 3 
              repeat 
              t5 -= 4 
              if t5 < 1 
                t5 += 7 
              end 
            repeat 
          end 
          oldkey = save_oldkey                   /* changed &dA11/05/05&d@ (was oldkey = newkey)
        repeat 
        loop for t7 = 1 to 50 
          loop for t6 = 1 to 4                   /* &dA06/04/08&d@ was 3 
            measax(t6,t7) = claveax(t7) 
          repeat
        repeat 
        oldkey = newkey                          /* moved &dA11/05/05&d@ 
        passback  oldkey 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 29. zjcline (staff)                                              ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Purpose:  Compute values of z, clef_vpos and cline from clef    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Inputs:   staff     = staff number (1 or 2)                     ³ 
&dA &d@³              clef(.)   = clef flag                                 ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Outputs:  z         = clef font                                 ³ 
&dA &d@³              clef_vpos = vertical postion of clef                  ³ 
&dA &d@³              cline(.)  = location of middle C                      ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure zjcline (staff) 
        int t1,t2,t3,t4,t5 
        int staff 

        getvalue staff 
        t3 = clef(staff) / 10  
        clef_vpos = 6 - rem 
        t4 = t3 / 3  
        t2 = rem  
        if rem = 0 
          z = 33 
        else 
          z = 34 + t2   
        end  
        t5 = clef_vpos * 2 + 20 
        t1 = 0  
        if t4 > 0 
          if t4 = 1 
            t1 = 7  
          else 
            t1 = -7 
          end  
        end  
        cline(staff) = t2 - 1 * 4 + t5 + t1 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 30. putclef (staff)                                 ³ 
&dA &d@³                                                       ³ 
&dA &d@³    Purpose:  write clef sign to intermediate file     ³ 
&dA &d@³                                                       ³ 
&dA &d@³    Inputs:   staff   = staff number (1 or 2)          ³ 
&dA &d@³              clef(.) = clef code                      ³ 
&dA &d@³              obx     = x offset                       ³ 
&dA &d@³              oby     = y offset                       ³ 
&dA &d@³              z       = clef font                      ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putclef (staff) 
        int t1,t2,t3 
        int staff 

        getvalue staff 
        t2 = clef(staff) / 10  
        t3 = t2 / 3  
        t1 = rem  
        jtype = "C"  
        jcode = clef(staff) 
        out = "0"  
        if t1 = 0 
          x = obx  
          y = oby  
          perform subj 
          ++z
          perform subj 
          if t3 = 1 
            x = obx + hpar(52) 
            y = oby + vpar(23) 
            z = 234  
            perform subj 
          end  
          pcode = sobcnt 
        else 
          pcode = z  
        end  
        putobjpar = 0 
        perform putobj 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 31. rotate_array (t1,t2)                                      ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Purpose:  Move ts array elements at t2 to t1 position.       ³ 
&dA &d@³              Rotate all other elements down one                 ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Inputs:   t1    = top of rotation                            ³ 
&dA &d@³              t2    = bottom of rotation (t2 > t1)               ³ 
&dA &d@³                                                                 ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure rotate_array (t1,t2) 
        int temp(TS_SIZE) 
        int t1,t2,t3,t4 

        getvalue t1,t2 
        if t2 = t1 
          return 
        end 
        loop for t3 = 1 to TS_SIZE 
          temp(t3) = ts(t2,t3)          /* create hole at the bottom (save bottom)
        repeat 
        loop for t4 = t2 to t1+1 step -1    /* loop in backwards order 
          loop for t3 = 1 to TS_SIZE 
            ts(t4,t3) = ts(t4-1,t3)     /* copy each row from the one above it 
          repeat 
        repeat 
        loop for t3 = 1 to TS_SIZE 
          ts(t1,t3) = temp(t3)          /* store bottem piece at top 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 32. get_topbottom (t1,t2,t3)                                  ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Purpose:  If t1 points to a ts row element which is a note   ³ 
&dA &d@³              head, then t2 will point to the ts row element     ³ 
&dA &d@³              which is the top of the chord, and t3 will point   ³ 
&dA &d@³              to the ts row element which is the bottom of the   ³ 
&dA &d@³              chord                                              ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Inputs:   t1    = index to ts row element                    ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Outputs:  t2    = index to top of chord                      ³ 
&dA &d@³              t3    = index to bottom of chord                   ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Note:  Do not call this procedure before GLOBAL_XOFF is set  ³ 
&dA &d@³                                                                 ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure get_topbottom (t1,t2,t3) 
        int t1,t2,t3,t4 

        getvalue t1 
        t4 = ts(t1,GLOBAL_XOFF) 
        if t4 > INT10000 
          t2 = t4 / INT10000 
          t3 = rem 
        else 
          t4 = ts(t1+1,GLOBAL_XOFF) 
          if t4 > INT10000 
            t2 = t4 / INT10000 
            t3 = rem 
          else 
            t2 = t1 
            t3 = t1 
          end 
        end 
        passback t2,t3 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 33. ps_setchord (p1,p2,p3)                                    ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Purpose:  Add a chord to the simultaneity                    ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Inputs:   p1 = pass number (chord number)                    ³ 
&dA &d@³              p2 = second chord number (for unisons) or 100      ³ 
&dA &d@³              p3 = initialize parameter (0 = initialize)         ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Outputs:  p3 = initialize parameter (1 = don't initialize)   ³ 
&dA &d@³              printpos(.) = print position for this chord        ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Method:   construct the left boundary of the new chord.      ³ 
&dA &d@³              Move the chord to the right until it bumps         ³ 
&dA &d@³              with previous chords.                              ³ 
&dA &d@³                                                                 ³ 
&dA &d@³    Output:   when a note for a chord is set, ndata(*,PASS)      ³ 
&dA &d@³              for that note is set to zero.                      ³ 
&dA &d@³                                                                 ³ 
&dA &d@³              printpos(p1) and maybe printpos(p2)                ³ 
&dA &d@³                                                                 ³ 
&dA &d@³                                                                 ³ 
&dA &d@³                                                                 ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure ps_setchord (p1,p2,p3) 
        int t1,t2,t3,t4,t5 
        int x 
        int aa,bb,cc,dd 
        int tr(2,45),tl(2,45)
        int pseudo_tr(2,45) 
        int pseudo_tl(2,45) 
        int ff,gg,hh,ii,jj 
        int p1, p2, p3 
        int ps_width 
        int stem_up_flag 
        int stem_down_flag 

        getvalue p1,p2,p3 
        if p3 = 0 
          p3 = 1 
          x = 10000 
        else 
          x = 0 
        end 
        passback p3 
&dA 
&dA &d@       Calling ps_setchord  pass = ~p1   pass2 = ~p2 
&dA 
        ff = 0
        hh = 0

        loop for jj = 1 to 45 
          tl(1,jj) = 200 
          tr(1,jj) = -200 
          pseudo_tr(1,jj) = -200 
          pseudo_tl(1,jj) = 200 
          tl(2,jj) = 200 
          tr(2,jj) = -200 
          pseudo_tr(2,jj) = -200 
          pseudo_tl(2,jj) = 200 
        repeat 

        stem_up_flag    = 0 
        stem_down_flag  = 0 
        repeater_case   = 0 
        t3 = 100 
        loop for ii = 1 to pcnt 
          if ndata(ii,PS_PASS) = p1 or ndata(ii,PS_PASS) = p2 
            t2 = ndata(ii,PS_XPOS)
            t1 = ndata(ii,PS_PITCH)
            if t1 = 100 
              ndata(ii,PS_PASS) = 0 
              return 
            end 

            if t3 = 100 
              t3 = ndata(ii,PS_STAFF) + 1       /* staff number 
              t4 = ndata(ii,PS_HEAD) 
              if ndata(ii,PS_NSTYLE) = 0      /* New  &dA01/08/11&d@ 
                if t4 < 3 
                  ps_width = hpar(82) 
                else 
                  if t4 = 3 
                    ps_width = hpar(83) 
                  else 
                    ps_width = hpar(84) 
                  end 
                end 
              else 
                if t4 < 3 
                  ps_width = vpar(2) 
                else 
                  if t4 = 3 
                    ps_width = vpar(2) * 5 / 4 
                  else 
                    ps_width = hpar(84) 
                  end 
                end 
              end 

              if ndata(ii,PS_NSIZE) = CUESIZE 
                ps_width = ps_width * 8 / 10    
              end 
            end 

            if bit(0,ndata(ii,PS_STEM)) = UP         /* stem up 
              if t2 = 0
                if tl(t3,t1) > 0 
                  tl(t3,t1) = 0 
                end 
                if tl(t3,t1+1) > hpar(95)                
                  tl(t3,t1+1) = hpar(95) 
                end 
                if pseudo_tl(t3,t1) > 0 
                  pseudo_tl(t3,t1) = 0
                end 
                if pseudo_tl(t3,t1+1) > 0
                  pseudo_tl(t3,t1+1) = 0
                end 
                if tr(t3,t1) < ps_width - hpar(95) 
                  tr(t3,t1) = ps_width - hpar(95) 
                end 
                if tr(t3,t1+1) < ps_width                
                  tr(t3,t1+1) = ps_width 
                end 
                if pseudo_tr(t3,t1) < ps_width 
                  pseudo_tr(t3,t1) = ps_width 
                end 
                if pseudo_tr(t3,t1+1) < ps_width 
                  pseudo_tr(t3,t1+1) = ps_width 
                end 
              else
                dd = ps_width << 1 - hpar(90) 
                if tr(t3,t1) < dd - hpar(95) 
                  tr(t3,t1) = dd - hpar(95) 
                end 
                if tr(t3,t1+1) < dd 
                  tr(t3,t1+1) = dd 
                end 
                if pseudo_tr(t3,t1) < dd + hpar(49) 
                  pseudo_tr(t3,t1) = dd + hpar(49) 
                end 
                if pseudo_tr(t3,t1+1) < dd + hpar(49) 
                  pseudo_tr(t3,t1+1) = dd + hpar(49) 
                end 
              end
              if ff = 0
                ff = t1 + 8                     /* 8 = length of stem 
              end
              stem_up_flag |= ndata(ii,PS_STEM) >> 2 
            else
              if t2 = 0
                if tr(t3,t1) < ps_width - hpar(95) 
                  tr(t3,t1) = ps_width - hpar(95) 
                end 
                if tr(t3,t1+1) < ps_width 
                  tr(t3,t1+1) = ps_width 
                end 
                if pseudo_tr(t3,t1) < ps_width 
                  pseudo_tr(t3,t1) = ps_width 
                end 
                if pseudo_tr(t3,t1+1) < ps_width 
                  pseudo_tr(t3,t1+1) = ps_width 
                end 
                if tl(t3,t1) > 0 
                  tl(t3,t1) = 0 
                end 
                if tl(t3,t1+1) > hpar(95) 
                  tl(t3,t1+1) = hpar(95) 
                end 
                if pseudo_tl(t3,t1) > 0 
                  pseudo_tl(t3,t1) = 0
                end 
                if pseudo_tl(t3,t1+1) > 0
                  pseudo_tl(t3,t1+1) = 0
                end 
              else
                if tl(t3,t1) > hpar(90) - ps_width 
                  tl(t3,t1) = hpar(90) - ps_width 
                end 
                if tl(t3,t1+1) > hpar(90) - ps_width + hpar(95) 
                  tl(t3,t1+1) = hpar(90) - ps_width + hpar(95) 
                end 
                if pseudo_tl(t3,t1) > hpar(90) - ps_width - hpar(49) 
                  pseudo_tl(t3,t1) = hpar(90) - ps_width - hpar(49) 
                end 
                if pseudo_tl(t3,t1+1) > hpar(90) - ps_width - hpar(49) 
                  pseudo_tl(t3,t1+1) = hpar(90) - ps_width - hpar(49) 
                end 
              end
              if hh = 0
                hh = t1 - 1 
              end
              stem_down_flag |= ndata(ii,PS_STEM) >> 2 
            end
            repeater_case |= bit(1,ndata(ii,PS_STEM)) 
            if ndata(ii,PS_PASS) = p1 
              ndata(ii,PS_PASS) = 0
            end
            if ndata(ii,PS_PASS) = p2 
              ndata(ii,PS_PASS) = 0
            end
          end
        repeat
        if hh > 45 
          hh = 45 
        end
        if ff > 0               /*  put in stem up restraints
          if ndata(ii,PS_NSTYLE) = 0       /* modern 
            t5 = ps_width - hpar(90) 
            t4 = ps_width 
          else                             /* New  &dA01/08/11&d@ 
            t5 = ps_width / 2 
            t4 = t5 
          end 
          if repeater_case = 1 
            aa = t5 - hpar(98) 
            bb = t4 + hpar(98) 
          else 
            aa = t5 
            bb = t4 
          end 
          if stem_up_flag > 0 
            if stem_up_flag > 2 
              ff += stem_up_flag - 2 << 1 
            end 
            if ndata(ii,PS_NSTYLE) = 0       /* modern 
              dd = t4 + hpar(26) 
            else                             /* New  &dA01/08/11&d@ 
              dd = t4 / 2 + hpar(26) 
            end 
          else 
            dd = t4 
          end 
          if ff > 45 
            ff = 45 
          end 
          loop for ii = ff - 6 to ff
            if tl(t3,ii) > aa 
              tl(t3,ii) = aa 
            end
            if tr(t3,ii) < bb 
              tr(t3,ii) = bb 
            end
            if pseudo_tr(t3,ii) < dd 
              pseudo_tr(t3,ii) = dd 
            end 
          repeat
          loop for ii = t1 + 2 to ff - 7 
            if tl(t3,ii) > t5 
              tl(t3,ii) = t5 
            end
            if tr(t3,ii) < t4 
              tr(t3,ii) = t4 
            end
          repeat
        end
        if hh > 0               /*  put in stem down restraints
          t1 = t1 - 7
          if stem_down_flag > 0 
            if stem_down_flag > 2 
              t1 -= stem_down_flag - 2 << 1 
            end 
            dd = hpar(90) + hpar(26) 
          else 
            dd = hpar(90) 
          end 
          if t1 < 1
            t1 = 1
          end
&dA 
&dA &d@      Fixing the left border on stems down with repeaters 
&dA &d@      &dA06/04/08&d@   plus bug correction  &dA11/23/09&d@ 
&dA 
#if XPOS_FIXED 
          loop for ii = t1 + 4 to hh 
            if tl(t3,ii) > 0             /* aa 
              tl(t3,ii) = 0              /* aa 
            end
            if tr(t3,ii) < hpar(90)      /* bb 
              tr(t3,ii) = hpar(90)       /* bb 
            end
            if pseudo_tr(t3,ii) < dd 
              pseudo_tr(t3,ii) = dd 
            end 
          repeat
#else 
          loop for ii = t1 + 4 to hh 
            if tl(t3,ii) > 0   /* aa 
              tl(t3,ii) = 0    /* aa 
            end
            if tr(t3,ii) < bb       
              tr(t3,ii) = bb          
            end
            if pseudo_tr(t3,ii) < dd 
              pseudo_tr(t3,ii) = dd 
            end 
          repeat
#endif 

          if repeater_case = 1 
            aa = 0 - hpar(98) 
            bb = hpar(90) + hpar(98) 
          else 
            aa = 0 
            bb = hpar(90) 
          end 

          loop for ii = t1 to t1 + 3           /* 4 is magic number 
            if tl(t3,ii) > aa                 /* Repeaters only at bottom 
              tl(t3,ii) = aa 
            end
            if tr(t3,ii) < bb       
              tr(t3,ii) = bb          
            end
            if pseudo_tr(t3,ii) < dd 
              pseudo_tr(t3,ii) = dd 
            end 
          repeat
        end

        if x = 10000
          loop for ii = 1 to 45 
            gr(t3,ii) = tr(t3,ii)
            gl(t3,ii) = tl(t3,ii) 
            pseudo_gr(t3,ii) = pseudo_tr(t3,ii) 
          repeat
          x = 0                   /* amount shifted to the right 
        else
          ff = 1000
          loop for ii = 1 to 45 
            gg = 1000 - gr(t3,ii) + tl(t3,ii) - hpar(90)  /* &dA01/08/11&d@  hpar(90) replaces "5"
            if gg < ff
              ff = gg
            end
          repeat
          x = 1000 - ff           /* amount shifted to the right 
          loop for ii = 1 to 45 
            gg = x + tr(t3,ii)
            if gg > gr(t3,ii) and tr(t3,ii) <> -200 
              gr(t3,ii) = gg
            end
            gg = x + pseudo_tr(t3,ii) 
            if gg > pseudo_gr(t3,ii) and pseudo_tr(t3,ii) <> -200 
              pseudo_gr(t3,ii) = gg 
            end
            gg = x + tl(t3,ii) 
            if gg < gl(t3,ii) 
              gl(t3,ii) = gg
            end 
          repeat
        end

        loop for jj = 1 to 45 
          if pseudo_gl(1,jj) > pseudo_tl(1,jj) 
            pseudo_gl(1,jj) = pseudo_tl(1,jj) 
          end 
          if pseudo_gl(2,jj) > pseudo_tl(2,jj) 
            pseudo_gl(2,jj) = pseudo_tl(2,jj) 
          end 
        repeat 

        printpos(p1) = x
        if p2 <> 100 
          printpos(p2) = x 
        end 
      return

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³P* 34. guessbeam (slope, t12)                                                 ³
&dA &d@³                                                                              ³
&dA &d@³                                                                              ³
&dA &d@³    Purpose:  Make a guess about the position of a beam                       ³
&dA &d@³                                                                              ³
&dA &d@³    Inputs:   int  c6            = number of notes under beam                 ³
&dA &d@³              int  mf(.)         = y-position of note                         ³
&dA &d@³              int  beamcode(.)   = beam code                                  ³
&dA &d@³              int  stem          = stem direction (UP/DOWN)                   ³
&dA &d@³              int  c5            = size: 0 = regular; 1 = small               ³
&dA &d@³                                                                              ³
&dA &d@³    Outputs:  int slope  = BHPAR1 * slope of beam                             ³
&dA &d@³              int t12    = end point of first stem (relative to top of staff) ³
&dA &d@³                                                                              ³
&dA &d@³    Internal variables:  beamfy = y coordinate of first note under beam       ³
&dA &d@³                         vrange = vertical range of note set                  ³
&dA &d@³                         zstaff = top of staff line                           ³
&dA &d@³                          slope = slope of beam                               ³
&dA &d@³                           ypiv = temporary variable                          ³
&dA &d@³                        (x1,y1) = temporary coordinates                       ³
&dA &d@³                        (x2,y2) = temporary coordinates                       ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure guessbeam (slope, t12) 
        int t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12 
        int zstaff,ypiv,slope 
        int x1,x2,y1,y2,vrange,beamfy 
        int xf(100) 
        int beamh,beamt,bthick 
        int beamtype 
        int loopcnt 
*  
        if c5 = 0 
          beamh = bvpar(16) 
          beamt = bvpar(32) 
          bthick = vpar(2) * 6 / 14 
        else 
          beamh = bvpar(16) * 4 / 5 
          beamt = bvpar(32) * 4 + 3 / 5 
          bthick = vpar(2) * 5 / 14 
        end 

        t6 = 0 
        loop for t5 = 1 to c6 
          xf(t5) = t6 
          t6 += vpar(6)                 /* average x increment (a guess) 
        repeat 

        beamfy = mf(1) 
* reverse if stem down 
        t3 = 0 
        if stem = DOWN 
          t3 = 150 * vpar(2) - vpar(8) 
          loop for t6 = 1 to c6 
            mf(t6) = 150 * vpar(2) - mf(t6) 
          repeat 
        end  
        zstaff = t3 
* determine slope and pivot of beam  
        t9  = 0 
        x1  = 5000 
        y1  = 5000 
        t11 = 6 
        t1  = 0 
        t4  = 0          /* changes in absolute height 
        t2  = 0 
        t5  = mf(1) 
&dA 
&dA &d@  identify:  t9 = 6 - smallest note type under beam 
&dA &d@            (x1,y1) = position of note closest to beam  
&dA &d@            (x2,y2) = position of note next closest to beam 
&dA &d@             t1 = y coordinate of note furthest from beam 
&dA 
        loop for t6 = 1 to c6 
*  also compute sum of absolute changes in vertical height 
          t8 = t5 - mf(t6) 
          testfor t8 < 0 
            if t2 = 0  
              t2 = -1  
            end  
            if t2 = 1  
              t2 = 2 
            end  
            t8 = 0 - t8 
          else (>) 
            if t2 = 0 
              t2 = 1 
            end 
            if t2 = -1 
              t2 = 2 
            end 
          end  
          t5 = mf(t6) 
          t4 += t8 
*  
          t8 = 0                 /* number of additional beams on this note 
          loop while beamcode(t6) > 9 
            ++t8 
            beamcode(t6) /= 10 
          repeat 
          if t8 > t9 
            t9 = t8              /* max number of additional beams 
          end 
          if t8 < t11 
            t11 = t8             /* min number of additional beams 
          end 

          t8 = mf(t6) 
          if t8 > t1 
            t1 = t8              /* lowest y co-ord of notes in beam set 
          end 
          if t8 < y1 
            y2 = y1 
            x2 = x1 
            y1 = t8              /* nearest y co-ord 
            x1 = xf(t6) 
          else 
            if t8 < y2 
              y2 = t8 
              x2 = xf(t6) 
            end  
          end  
        repeat 
&dA 
&dA &d@    Check point one: (x1,y1); (x2,y2); t1  set  
&dA 
        vrange = t1 - y1 
&dA 
&dA &d@    Formula for initial stem length 
&dA 
&dA &d@        note     t9      y1-t8 
&dA &d@      ÄÄÄÄÄÄÄ  ÄÄÄÄÄÄ   ÄÄÄÄÄÄÄ 
&dA &d@        8th:      0      beamh  
&dA &d@       16th:      1      beamh + (1 * notesize / 4) 
&dA &d@       32th:      2      beamh + (4 * notesize / 4)   
&dA &d@       64th:      3      beamh + (7 * notesize / 4) 
&dA &d@      128th:      4      beamh + (10 * notesize / 4)  
&dA &d@      256th:      5      beamh + (13 * notesize / 4)  
&dA 
        beamtype = t9 
        if t9 = 0  
          t8 = y1 - beamh  
        else 
          t8 = t9 * 3 - 2    
          t8 = 0 - notesize * t8 / 4 - beamh + y1  
        end  
        t1 = x1  
*   deal with case of severe up-down pattern   
        if t2 = 2  
          t4 /= c6 
          if t4 > bvpar(18) 
            slope = 0 
            goto GSB1 
          end  
        end  
*  
        slope = y1 - y2 * 2 * BHPAR1 
        t7 = x1 - x2 
        slope /= t7 
&dA 
&dA &d@  Comment: slope is (2*BHPAR1) times slope between two notes 
&dA &d@                nearest the beam  
&dA 
        t7 = mf(c6) - mf(1) * 2 * BHPAR1 
        t6 = xf(c6) 
        if t6 < vpar(5)  
          t6 = vpar(5) 
        end  
        t7 /= t6 
&dA 
&dA &d@  Comment: t7 is (2*BHPAR1) times slope between outside notes 
&dA 
&dA &d@  Formula:  slope = (slope + t7) / 6   provided 
&dA 
&dA &d@     |slope| must be equal to or less than |t7| 
&dA 
        t6 = abs(slope) - abs(t7) 
        if t6 > 0 
          if slope > 0 
            slope -= t6 
          else 
            slope += t6 
          end 
        end 
*  
        slope = slope + t7 / 6 
GSB1:   t7 = abs(slope) 
        if t7 > BHPAR1 / 2
          t7 = BHPAR1 / 2 
        end  
*   Soften slant for thirty-seconds and smaller  
        if t9 > 2 and t7 > 5 
          t7 = 0 - t9 / 2 + t7 
        end  
        if t7 < 0  
          t7 = 0 
        end  
&dA 
&dA &d@  set reduce slant if end note are closer than vpar(6)  
&dA 
        t4 = xf(c6) 
        if t4 <= vpar(6)  and  t7 > bvpar(35) 
          t7 = bvpar(35) 
        end  
&dA 
&dA &d@  shorten shortest stem, if gradual slope and large vertical range  
&dA &d@                              and relatively high note  
&dA 
        if vrange > vpar(3) 
          t4 = t9 * beamt + t8 - zstaff 
          t4 = 0 - t4 
          if t4 > vpar(3)  
            if t7 < 6  
              if x1 > 0 and x1 < xf(c6) 
                t8 += bvpar(17) 
              end  
              if c6 = 2 
                t8 += bvpar(17) 
              end  
            end  
          end  
        end  
*  
        if slope < 0 
          slope = 0 - t7 
        else 
          slope = t7 
        end  
&dA 
&dA &d@  slope   = BHPAR1 * slope of beam 
&dA &d@  t8      = y coordinate of pivot point (on highest note) of first beam 
&dA &d@  t7      = absolute value of @m 
&dA &d@  t3      = y coordinate of top of staff line 
&dA &d@  (x1,y1) = coordinate of note closest to beam (highest note) 
&dA &d@  (x2,y2) = coordinate of second closest note to beam (2nd highest note)  
&dA &d@  t9      = 6 - smallest note type number (number of beams - 1 
&dA &d@  t11     = 6 - largest note type number 
&dA 
        ypiv = t8 
        ++t9 
&dA 
&dA &d@    Check point two:  t9 = number of beams, current slope = slope 
&dA 
&dA &d@   Adjust slope and t8 so that beams will fall properly on staff lines 
&dA 
&dA &d@    Case I:   slope = 0 
&dA 
GCSI:   if slope = 0 
          t2 = t9 - 1 * notesize + t8 
          if t2 >= t3 
&dA 
&dA &d@    Adjust flat beam height   
&dA 
            t5 = t2 - t3 / notesize  
            if t9 = 1  and   rem <= bvpar(20) 
              rem += bvpar(20) 
            end  
            if t9 = 2  
              if rem <= bvpar(20) 
                rem += bvpar(34) 
              else 
                rem = rem - notesize + bvpar(20)  
              end  
            end  
            if t9 = 3  
              rem += bvpar(34) 
            end  
            if t9 = 4  
              if t5 = 3  
                beamt = bvpar(33) 
              end  
              if t5 < 3  
                t5 = rem 
                t5 -= vpar(1) / 2
                rem = t5   
              end  
            end  
            t8 -= rem 
*     (*) extremely low notes  
            if t9 = 1  
              t2 = vpar(4) + zstaff 
            else 
              t2 = 4 - t9 * vpar(2) + zstaff 
            end  
            if t8 > t2 
              t8 = t2 
              if t9 > 3  and  c5 = 0 
                beamt = bvpar(33) 
              end  
            end  
          end  
        else 
&dA 
&dA &d@    Case II:   slope <> 0 
&dA 
          loopcnt = 0 
GCSII:    
          ++loopcnt 
          t6 = 0 - x1 * slope / BHPAR1 + t8 
          t5 = xf(c6) * slope / BHPAR1 + t6 
          t2 = t5 + t6 / 2 
          if t9 > 1  
            if t11 > 0  
              t2 += beamt 
              if t9 = 2  
                t2 += 2 
              end  
            end  
            t10 = bvpar(22)  
          else 
            t10 = bvpar(23)  
          end  
&dA &d@  t6  = starting point of top beam 
&dA &d@  t5  = stopping point of top beam 
&dA &d@  t2  = average height of beam (second beam if always 2 or more) 
&dA &d@  t10 = fudge factor 
          t4 = t3 
          t3 -= notesize 
          if t9 > 2  
            t3 -= notesize 
          end  
          if t2 > t3 
&dA 
&dA &d@    Adjust slanted beam height  
&dA 
            if t9 > 2  
              if t2 > t4 
                beamt = bvpar(33) 
              else 
                t2 -= 2 
              end  
            end  
            t4 = abs(t5 - t6) 
            t5 = t2 - t3 / notesize  
            t5 = rem 
&dA &d@  t4 = rise/fall of beam  
&dA &d@  t5 = amount by which the average beam height lies below a line  
            if t4 < bvpar(24) 
              if t5 >= t10 
                t5 -= notesize 
                if t9 = 1  
                  ++t5 
                end  
              else 
                if t9 = 1  
                  --t5 
                end  
              end  
              t8 -= t5 
              goto GCV  
            end  
            if t4 < beamt  
              if loopcnt > 4 
                goto GCV 
              end 
              if t7 > 1  
                goto GCSJJ  
              end  
              ++t7 
              if slope < 0 
                slope = 0 - t7 
              else 
                slope = t7 
              end  
              goto GCSII  
            end  
            if t4 < bvpar(25) 
              c16 = t5 * 2 / vpar(2) 
              if rem <> 0 
                ++t5 
              end 
              t5 += vpar(1) 

              if t5 > t10 
                t5 -= notesize 
              end  
              t8 -= t5 
              goto GCV  
            end  
            if t4 > bvpar(26) 
              if t5 > t10      
                t5 -= notesize 
              end  
              t8 -= t5 
              goto GCV  
            end  
            if t7 = 2  
              c16 = t5 * 2 / vpar(2) 
              if rem <> 0 
                ++t5 
              end 
              t5 += vpar(1) 

              if t5 > t10 
                t5 -= notesize 
              end  
              t8 -= t5 
              goto GCV  
            end  
            if loopcnt > 4 
              goto GCV 
            end 
GCSJJ:      --t7 
            if slope < 0 
              slope = 0 - t7 
            else 
              slope = t7 
            end  
            goto GCSII  
          else 
            if t9 < 4  
              t8 = notesize / 3 + t8 
            end  
          end  
*   Check for extra low notes  
GCV:      t4 = 0 - x1 * slope / BHPAR1 + t8 
          t6 = xf(c6) - x1 * slope / BHPAR1 + t8 
          t5 = 0 
          if t9 = 1  
            t2 = vpar(4) + zstaff - 2 
          else 
            t2 = 4 - t9 * notesize + zstaff - 2 
          end  
          if slope > 0 
            if t4 > t2 
              t5 = 1 
              t4 = t2 + 1  
            end  
          else 
            if t6 > t2 
              t5 = 1 
              t6 = t2 + 1  
            end  
          end  
          t2 = t2 + bvpar(20) + 2 
          if slope > 0 
            if t6 > t2 
              t5 = 1 
              t6 = t2 
            end  
          else 
            if t4 > t2 
              t5 = 1 
              t4 = t2 
            end  
          end  
          if t5 = 1  
*    Correction necessary  
            t7 = xf(c6) 
            slope = t6 - t4 * BHPAR1 / t7 
            t8 = x1 * slope / BHPAR1 + t4 
            t7 = abs(slope) 
          end  
          t8 -= vpar(1) / 2
        end  
*  
        t12 = slope * t1 
        t12 = t8 * BHPAR1 - t12 
&dA 
&dA &d@    Check point three:  beam slope = slope; 
&dA &d@                        y intercept (times BHPAR1) = t12 
&dA 
&dA &d@     Post adjustment:  sometimes the stems of sixteenths are too  
&dA &d@       short.  This will be the case when (y2-t8) - ((t9-1)*beamt) < xxx  
&dA &d@       where xxx is some number.  In this case, we should raise the 
&dA &d@       beam by some small amount, yyy.  
&dA 
        t6 = 0 - (t9 - 1) * beamt + y2 - t8 
        if t6 < bvpar(29) 
          t12 -= bvpar(30) * BHPAR1 
        end  
&dA 
&dA &d@     In the case where c6 = 4, compare sum of the first two notes 
&dA &d@     verses the last two notes.  If the direction is different from 
&dA &d@     the slope, then the slope should be zero.  
&dA 
        if c6 = 4 
          t2 = mf(1) + mf(2) 
          t3 = mf(3) + mf(4) 
          if t2 > t3 
            if slope > 0 
              goto GSB2 
            end  
          end  
          t2 = t2 - t3 * slope 
          if t2 > 0  
            goto GSB2 
          end  
          goto GSB3 
GSB2:     slope = 0 
          t3 = zstaff 
          t8 = ypiv 
          goto GCSI 
        end  
GSB3: 
&dA 
&dA &d@  slope = BHPAR1 * slope of beam 
&dA &d@  t12   = y-intercept of beam (times BHPAR1) 
&dA 

        t8 = vpar(6) / 7 
        if beamtype > 0 
          t8 = vpar(5) / 4 
        end 
        t12 /= BHPAR1 

        if stem = DOWN 
          t12 = 150 * vpar(2) - t12 + bthick - t8
          slope = 0 - slope 
        else 
          t12 += t8
        end  
        passback slope, t12 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 35. rest_occupy_space (t1,t2)                              ³ 
&dA &d@³                                                              ³ 
&dA &d@³                                                              ³ 
&dA &d@³    Purpose:  For a given location on the staff line and      ³ 
&dA &d@³                a given type of rest, set the gr(.,.) and     ³ 
&dA &d@³                gl(.,.) arrays to reflect the placement       ³ 
&dA &d@³                of the rest in this spot                      ³ 
&dA &d@³                                                              ³ 
&dA &d@³    Inputs:   ntype  = type of rest                           ³ 
&dA &d@³              t1     = position on staff (0 = top line)       ³ 
&dA &d@³                         (i.e.,STAFFLOC)                      ³ 
&dA &d@³              t2     = staff number                           ³ 
&dA &d@³                                                              ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure rest_occupy_space (t1,t2) 
        int t1,t2,t3,t4,t5,t6,t7,t8 

        getvalue t1,t2 
        c16 = t1 + vpar20 * 2 + 1 / vpar(2) - 20 
        t1 = 23 - c16 

        t5 = ntype << 1 - 1 

        t3 = int("1008060402020402030303"{t5,2}) 
        t4 = int("0505050505030301000101"{t5,2}) 

        if ntype > WHOLE 
          t6 = hpar(87) * 4 / 3 
        else 
          if ntype > QUARTER 
            t6 = hpar(87) 
          else 
            if ntype > EIGHTH 
              t6 = hpar(88) 
            else 
              t6 = EIGHTH - ntype * hpar(54) + hpar(88) 
            end 
          end 
        end 
&dA &d@       t6 += hpar(85) 

        t7 = t1 - t4 
        if t7 < 1 
          t7 = 1 
        end 
        t8 = t1 + t3 
        if t8 > 45 
          t8 = 45 
        end 
        loop for t5 = t7 to t8
          gr(t2,t5) = t6 
          gl(t2,t5) = 0 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 36. place_accidental (t1,t2,t3,t4)                                  ³ 
&dA &d@³                                                                       ³ 
&dA &d@³                                                                       ³ 
&dA &d@³    Purpose:  Determine the absolute x-location of an                  ³ 
&dA &d@³                accidental, given gl(.,.) and the imputs:              ³ 
&dA &d@³                                                                       ³ 
&dA &d@³    Inputs:   t1     = staff number                                    ³ 
&dA &d@³              t2     = position on staff (23 = top line)               ³ 
&dA &d@³              t3     = accidental code                                 ³ 
&dA &d@³              t4     = note size (full size vs. cue size)              ³ 
&dA &d@³                                                                       ³ 
&dA &d@³    Output:   t4     = absolute x location                             ³ 
&dA &d@³                                                                       ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure place_accidental (t1,t2,t3,t4) 
        int t1,t2,t3,t4,t5,t6,t7,t8,t9,savet3,savet4,t14 

        getvalue t1, t2, t3, t4 
        t14 = t4 

        if t2 > 42 or t2 < 3 or t3 = 10    /* use old system 
          t5 = t2 - int("221002200100001"{t3})  /* lower limit 
          t6 = t2 + int("333003300200003"{t3})  /* upper limit 
          t8 = 200 
          loop for t7 = t5 to t6 
            if t7 > 0 and t7 <= 45 
              if gl(t1,t7) < t8 
                t8 = gl(t1,t7) 
              end 
            end 
          repeat 
          t9 = hpar(t3) 
          if t14 = CUESIZE 
            t9 = t9 * 8 / 10    /* cue or grace size 
          end 
          t4 = t8 - t9          /* absolute x position 
          loop for t7 = t5 to t6 
            if t7 > 0 and t7 <= 45 
              gl(t1,t7) = t4   /* new global left boundary 
            end 
          repeat 
          passback t4 
          return 
        end 

&dA &d@ hpar(1)  =  shift following accidental natural 
&dA &d@ hpar(2)  =  shift following accidental sharp 
&dA &d@ hpar(3)  =  shift following accidental flat 
&dA &d@ hpar(6)  =  shift following accidental natural-sharp 
&dA &d@ hpar(7)  =  shift following accidental natural-flat 
&dA &d@ hpar(10) =  shift following accidental double sharp 
&dA &d@ hpar(15) =  shift following accidental double flat 

&dA 
&dA &d@    (1) determine absolute x location 
&dA 
        if chr(t3) in [3,7,15] 
          t5 = hpar(3) * 7 / 10 
          t6 = gl(t1,t2+3) + t5 
          loop for t7 = t2 - 1 to t2 + 2 
            if gl(t1,t7) < t6 
              t6 = gl(t1,t7) 
            end 
          repeat 
          if t3 = 7 and gl(t1,t2-2) + hpar(3) < t6 
            t6 = gl(t1,t2-2) + hpar(3) 
          end 
        else 
          if chr(t3) in [2,6] 
            t5 = hpar(2) * 2 / 10 
            t6 = gl(t1,t2+3) + t5 
            loop for t7 = t2 - 1 to t2 + 2 
              if gl(t1,t7) < t6 
                t6 = gl(t1,t7) 
              end 
            repeat 
            if t6 > gl(t1,t2-2) + t5 
              t6 = gl(t1,t2-2) + t5 
            end 
          else 
            t5 = hpar(3) * 6 / 10 
            t6 = gl(t1,t2+3) + t5 
            loop for t7 = t2 - 2 to t2 + 2 
              if gl(t1,t7) < t6 
                t6 = gl(t1,t7) 
              end 
            repeat 
          end 
        end 
        t5 = hpar(t3) 
        if t14 = CUESIZE 
          t5 = t5 * 8 / 10    /* cue or grace size 
        end 
        t4 = t6 - t5                        /* absolute x position 
        passback t4 
&dA 
&dA &d@    (2) determine new values for gl(.,.) 
&dA 
        if chr(t3) in [1,6,7] 
          loop for t7 = t2 - 1 to t2 + 3 
            gl(t1,t7) = t4                  /* new global left boundary 
          repeat 
          gl(t1,t2-2) = hpar(1) / 2 + t4 
        else 
          if chr(t3) in [3,15] 
            loop for t7 = t2 - 1 to t2 + 3 
              gl(t1,t7) = t4                /* new global left boundary 
            repeat 
          else 
            t5 = hpar(2) / 10 
            gl(t1,t2+3) = t4 + t5 
            loop for t7 = t2 - 1 to t2 + 2 
              gl(t1,t7) = t4                /* new global left boundary 
            repeat 
            gl(t1,t2-2) = t4 + t5 
          end 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 37. typeset_tuple (t1,t2,t3)                               ³ 
&dA &d@³                                                              ³ 
&dA &d@³    Purpose:  Typeset tuple companion to repeater             ³ 
&dA &d@³                                                              ³ 
&dA &d@³    Inputs:   t1     = tuple number                           ³ 
&dA &d@³              t2     = centered x-location to place tuple     ³ 
&dA &d@³              t3     = y-location to place tuple              ³ 
&dA &d@³                                                              ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure typeset_tuple (t1,t2,t3) 
        int t1,t2,t3 
        int savex,savey,savez 

        getvalue t1,t2,t3 

        savex = x 
        savey = y 
        savez = z 
        x = t2 
        y = t3 
        if t1 > 9 
          x -= hpar(104) 
          z = t1 / 10 + 221 
          t1 = rem 
          perform subj 
          x += hpar(105) 
          z = t1 + 221 
          perform subj 
        else 
          z = t1 + 221 
          perform subj 
        end 
        x = savex 
        y = savey 
        z = savez 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³P* 38. setarpeggio  (New &dA01/13/06&d@)                              ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Purpose:  write object arpeggio                             ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Inputs:  c1           = pointer into set array for arpeggio ³ 
&dA &d@³             obx          = horizontal position of arpeggio     ³ 
&dA &d@³             ntype        = ARPEGGIO                            ³ 
&dA &d@³             passnum      = pass number for this arpeggio       ³ 
&dA &d@³             inctype      = increment type for next node        ³ 
&dA &d@³                              with a new spn (used in putobj)   ³ 
&dA &d@³                                                                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setarpeggio  
        int arpeg_flag 
        int arpeg_top 
        int arpeg_bottom 
        int t1,t2,t3,t4

        arpeg_flag   = ts(c1,ARPEG_FLAG) 
        arpeg_top    = ts(c1,ARPEG_TOP) 
        arpeg_bottom = ts(c1,ARPEG_BOTTOM) 

        t3 = ts(c1,STAFF_NUM) * 1000 
        oby = arpeg_top * 2 - 1 * vpar(2) / 2 
        sobcnt = 0 

        x = obx  
        y = oby  

        t1 = arpeg_bottom * 2 - 1 * vpar(2) / 2 
        if arpeg_flag > 0 
          t1 += arpeg_flag 
        end 

        z = 120                                 /* music font for arpeggio 
        perform subj 

        t2 = t1 - vpar(4) 
        loop while y <= t2 
          perform subj 
          y += vpar(4) 
        repeat 
        y -= vpar(2) 
        if y <= t2 
          perform subj 
        end 

        jtype = "G"  
        jcode = EIGHTH 
        out = "0"  
&dA 
&dA &d@    Duration attribute of arpeggio 
&dA 
        ++sobcnt
        sobl(sobcnt) = "A D 1 8"

        pcode = sobcnt 
        oby += t3 
        putobjpar = 0 

        t4 = ts(c1,TSR_POINT) 
        pcontrol = ors(tsr(t4){1})                      /* &dA05/02/03&d@ 
        px = ors(tsr(t4){3}) << 8 
        py = ors(tsr(t4){4}) << 16 
        t1 = ors(tsr(t4){2}) << 24 
        putobjpar = t1 + px + py + pcontrol             /* Note: order of data has been changed

        perform putobj                    
        oby -= t3 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³P* 39. load_font_stuff                                                        ³
&dA &d@³                                                                              ³
&dA &d@³    Operation:  This procedure runs only once in this program.                ³
&dA &d@³                It loads the fontspac string from data provided               ³
&dA &d@³                It loads the kernfile string from data provided               ³
&dA &d@³                                                                              ³
&dA &d@³    Inputs:     provided inside the procedure                                 ³
&dA &d@³                                                                              ³
&dA &d@³    Output:     18000 byte fontspac string                                    ³
&dA &d@³                                                                              ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure load_font_stuff 
        str newXFstr.19(12) 
        str ks.4000 

        str temp.800 
        str blanks.32 
        int gg,hh,ii,jj,kk 
        int ksleng 
        int font 
        int t1,t2 
        int a1 
&dA 
&dA &d@    Step 1: Do fontspac and mfontspac 
&dA 
        open [8,8] gfontspac 
        len(fontspac) = sze 
        read [8] fontspac 
        close [8] 
        open [8,8] gmfontspac 
        len(mfontspac) = sze 
        read [8] mfontspac 
        close [8] 
        loop for gg = 1 to 12 
          jj = 32 
          loop for hh = 1 to 196 
            ii = (gg - 1) * 200 + hh 
            Mfontinc(gg,jj) = ors(mfontspac{ii}) 
            ++jj 
            if jj = 132 
              jj = 160 
            end                   
          repeat 
        repeat 
&dA 
&dA &d@    Step 2: Do kernmaps 
&dA 
        open [8,8] gkernspac 
        len(ks) = sze 
        read [8] ks 
        close [8] 

        ksleng = len(ks) 
        blanks = "                                " 

        loop for font = 1 to 30 
          gg = (font - 1) * 4 + 1 
          temp = ks{gg,4} 
          gg = int(temp) 
          gg += 121             /* jump over the offset section 

          temp = "" 
LF_B: 
          hh = ors(ks{gg}) 
          if bit(6,hh) = 1 
            jj = hh & 0x1f 
            if bit(5,hh) = 1 
              temp = temp // blanks{1,jj} // "1" 
            else 
              temp = temp // blanks{1,jj} // "0" 
            end 
          else 
            temp = temp // blanks{1,31} 
          end 
          if len(temp) < 676 and gg < ksleng 
            ++gg 
            goto LF_B 
          end 
          temp = temp // pad(700) 
          temp = temp{1,676} 

          gg = 0 
          loop for t1 = 1 to 26 
            loop for t2 = 1 to 26 
              ++gg 
              if temp{gg} = " " 
                all_real_kernmaps(font,t1,t2) = 0 
              end 
              if temp{gg} = "0" 
                all_real_kernmaps(font,t1,t2) = 1 
              end 
              if temp{gg} = "1" 
                all_real_kernmaps(font,t1,t2) = -1 
              end 
            repeat 
          repeat 
        repeat 

        loop for t1 = 27 to 52 
          loop for t2 = 1 to 26 
            kernmap(t1,t2) = 0 
          repeat 
        repeat 
&dA 
&dA &d@    Step 3: Load the hitestr stuff 
&dA 
        hitestr = "$&#(,&*.'+/(,1).3*/5+06,29.4</5=07?19B2<F4>I6AL7BL8FQ:GS;HU=IV>LZ@N]ATdFYkK]pM]qObwSp‰\p‰\"
        hitestr = hitestr // "+/(+/(+/(+/(.4).4*/5+16,18-4:.5</7=08?1;C3>F5?J6AL7DO9EQ:HS<HV=LX?M\AQaEUgHZjK]nMbuQl…Zl…Z"
        hitestr = hitestr // ",0(,0(,0(,0(-2).4*/5+18,4;.5=/7?08A19B2<G4?J6@L8AL9DP;FS<GT>JY?M]AN]BScFYmJ[lL^tNcwRp‰\p‰\"
&dA 
&dA &d@    Step 4: Do newfont_init stuff 
&dA 
        revsizes(1)  = 1 
        revsizes(2)  = 1 
        revsizes(3)  = 1 
        revsizes(4)  = 1 
        revsizes(5)  = 2 
        revsizes(6)  = 3 
        revsizes(7)  = 4 
        revsizes(8)  = 5 
        revsizes(9)  = 6 
        revsizes(10) = 6 
        revsizes(11) = 7 
        revsizes(12) = 7 
        revsizes(13) = 8 
        revsizes(14) = 8 
        revsizes(15) = 9 
        revsizes(16) = 9 
        revsizes(17) = 10 
        revsizes(18) = 10 
        revsizes(19) = 10 
        revsizes(20) = 11 
        revsizes(21) = 11 
        revsizes(22) = 11 
        revsizes(23) = 12 
        revsizes(24) = 12 

        newXFstr(1)  = "33Qo3Qo4Rp5Sq6Tr8Vt"   /* "  51  51  81 111  51  81 111  52  82 112  53  83 113  54  84 114  56  86 116"
        newXFstr(2)  = "34Rp5Sq6Tr7Us8Vt:Xv"   /* "  51  52  82 112  53  83 113  54  84 114  55  85 115  56  86 116  58  88 118"
        newXFstr(3)  = "36Tr7Us8Vt9Wu:Xv<Zx"   /* "  51  54  84 114  55  85 115  56  86 116  57  87 117  58  88 118  60  90 120"
        newXFstr(4)  = "47Us9Wu:Xv;Yw<Zx?]{"   /* "  52  55  85 115  57  87 117  58  88 118  59  89 119  60  90 120  63  93 123"
        newXFstr(5)  = "59Wu:Xv;Yw=[y>\z@^|"   /* "  53  57  87 117  58  88 118  59  89 119  61  91 121  62  92 122  64  94 124"
        newXFstr(6)  = "7;Yw=[y?]{@^|A_}Db€"   /* "  55  59  89 119  61  91 121  63  93 123  64  94 124  65  95 125  68  98 128"
        newXFstr(7)  = "9>\z@^|A_}CaEcHf„"   /* "  57  62  92 122  64  94 124  65  95 125  67  97 127  69  99 129  72 102 132"
        newXFstr(8)  = ":@^|B`~Db€Fd‚Hf„Jh†"   /* "  58  64  94 124  66  96 126  68  98 128  70 100 130  72 102 132  74 104 134"
        newXFstr(9)  = "<CaEcGeƒIg…Jh†Ljˆ"   /* "  60  67  97 127  69  99 129  71 101 131  73 103 133  74 104 134  76 106 136"
        newXFstr(10) = "=EcGeƒIg…Jh†Ki‡NlŠ"   /* "  61  69  99 129  71 101 131  73 103 133  74 104 134  75 105 135  78 108 138"
        newXFstr(11) = "@Hf„Jh†Ki‡Mk‰NlŠOm‹"   /* "  64  72 102 132  74 104 134  75 105 135  77 107 137  78 108 138  79 109 139"
        newXFstr(12) = "AJh†Ki‡Mk‰NlŠOm‹PnŒ"   /* "  65  74 104 134  75 105 135  77 107 137  78 108 138  79 109 139  80 110 140"

        loop for t1 = 1 to 12 
          loop for t2 = 1 to 19 
            XFonts(t1,t2) = ors(newXFstr(t1){t2}) 
          repeat 
        repeat 

        loop for a1 = 1 to 24 
          revmap(a1) = revsizes(a1) 
        repeat 
        loop for a1 = 1 to 12 
          revmap(100+a1) = a1 + BEAM_OFFSET 
        repeat 
        revmap(114)     = 13 + BEAM_OFFSET 

        revmap(98) = 48 
        revmap(99) = 49 
        revmap(100) = 50 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³P* 40. dtalk (messnum)                                                        ³
&dA &d@³                                                                              ³
&dA &d@³    Operation:  This procedure runs only once in this program,                ³
&dA &d@³                and only if the debug option is on and the                    ³
&dA &d@³                program is about to terminate.                                ³
&dA &d@³                                                                              ³
&dA &d@³    Inputs:     messnum    Message number                                     ³
&dA &d@³                                                                              ³
&dA &d@³    Output:     halt                                                          ³
&dA &d@³                                                                              ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure dtalk (messnum) 
        int messnum 
        label E(120) 
        getvalue messnum 

        if Debugg = 0 
          stop 
        end 

        goto E(messnum) 
E(1): 
        pute Chord format error 
        goto EE 
E(2): 
        pute Figured harmony error 
        goto EE 
E(3): 
        pute Tie error 
        pute 
        pute This is most often caused by a tie that has no terminating note
        pute in any part.  You should first check to see that all ties in 
        pute region where this error occurred are properly terminated.  The 
        pute problem can also be caused by excessive durations in a measure 
        pute that has a tie.  This will cause the program to think the measure
        pute has ended (early) and it will look for a terminating note in the
        pute next measure; i.b46 e., it will skip a properly placed terminating
        pute note.  If you still can't find the error, you might try deleting
        pute ties one at a time to see which one is causing the problem.  
        pute 
        pute Another cause can be trying to tie notes which are on different
        pute staves of the grand staff.  At the moment, autoset does not support
        pute this feature.  
        goto EE 
E(4): 
        pute Bar error 
        goto EE 
E(5): 
        pute Text error 
        goto EE 
E(6): 
        pute Time signature error 
        goto EE 
E(7): 
        pute No recognizable control character 
        goto EE 
E(8): 
        pute Figured harmony out of order 
        pute 
        pute Possibly you have entered a figured offset improperly.  
        pute 
        pute For example, the offset to the second figure actually appears 
        pute in the record for the first figure.  The interpretation of the 
        pute offset number is how must to advance the division counter after
        pute a figure is printed.  
        pute 
        goto EE 
E(9): 
        pute This will cause a Pitch decoding error 
        goto EE 
E(10): 
        pute No pitch found to match tie termination (X) direction (*).  
        pute 
        pute Check musical direction records (*) in this measure for tie 
        pute terminations and verify that the pitch in column 25 appears 
        pute earlier in the measure, on the same staff.  
        pute 
        goto EE 
E(11): 
        goto EE 
E(12): 
        pute Error in the command line.  The specified group is not supported.
        pute "score", "parts", "skore", "short", "sound", and "data" 
        pute are the only groups allowed.  
        goto EE 
E(13): 
        pute Attempting to read a MuseData module within the data stream. 
        pute Bad format in the file header (first 11 lines).  
        pute One possible reason: missing /eof or misreading /END 
        goto EE 
E(14): 
        pute A MuseData module within the data stream is incomplete 
        pute or improperly terminated.  
        goto EE 
E(15): 
        pute Mismatch of group types following the Group Membership line.  
        goto EE 
E(16): 
        pute No termination found to a MuseData module.
        goto EE 
E(17): 
        pute There is a part number missing in the sequence, or 
        pute there is an ambiguity in the number of parts.  
        goto EE 
E(18): 
        pute Some part number is represented twice 
        goto EE 
E(19): 
        pute Missing one or more /END statements 
        goto EE 
E(20): 
        pute Mis-use of "/" or File not properly terminated.  
        pute This error can also be caused by a missing comment 
        pute terminator "&".  
        goto EE 
E(21): 
        pute Missing "/END" or some other error 
        goto EE 
E(22): 
        pute   Attempting to use indefinite rests (rest with no letter) 
        pute   of successively different lengths, without change 
        pute   of meter.  
        goto EE 
E(23): 
        pute Unable to represent cue note in terms of current 
        pute   value of divisions per quarter 
        goto EE 
E(24): 
        pute Missing note type (column 17). 
        goto EE 
E(25): 
        pute This program cannot deal with certain situations where there 
        pute are more than three independent instruments encoded in one part.
        goto EE 
E(26): 
        pute This code will not work with more than 4 notes in chord 
        goto EE 
E(27): 
        pute Note out of staff range.  Please check clef.  
        goto EE 
E(28): 
        pute Slur error: Can't stop a non-existant slur (possible missing instigation)
        goto EE 
E(29): 
        pute Slur error: Can't start an existing slur (possible missing termination)
        goto EE 
E(30): 
        pute Can't find start to a slur 
        goto EE 
E(31): 
        pute Too many simultaneous wedges in source file.  
        goto EE 
E(32): 
        pute Too many simultaneous sets of dashes in source file.  
        goto EE 
E(33): 
        pute Too many simultaneous transpositions of one type 
        pute in source file.  
        goto EE 
E(34): 
        pute Attempt to end a wedge that wasn't properly started.  
        goto EE 
E(35): 
        pute Attempt to end a set of dashes that wasn't properly started.  
        pute 
        goto EE 
E(36): 
        pute Attempt to end a transposition of a type that wasn't 
        pute properly started.  
        goto EE 
E(37): 
        pute Problem finding the end of a slur 
        pute Possible causes: 
        pute   1. A slur has not been closed properly 
        pute   2. Overlapping slurs using the same code 
        goto EE 
E(38): 
        pute In searching for something, like for example, the end of a slur,
        pute AUTOSET has searched past the end of the file.  There definitely
        pute is an error in the source file.  Please find and correct.  
        goto EE 
E(39): 
        pute This problem occurred in collating the parts 
        goto EE 
E(40): 
        pute To find error, look at durations in source file for this part 
        pute as well as for the top part (which provides the original count).
        pute Look also for the possible inconsistant use of non-contolling bar
        pute lines.  
        pute 
        pute A couple of things to note:  (1) The bar nubmer given above is 
        pute only approximate.  If there is a pickup at the beginning, for 
        pute example, the bar number could be one number too high.  Try 
        pute looking at the previous bar.  
        pute 
        pute (2) In most cases, the duration problem will be an obvious encoding
        pute error; but there is a subtle case which can escape normal detection.
        pute This is the case where an irest in a part produces an isolated 
        pute node in a part.  Isolated means that there in not another object
        pute in that part at that location.  In this case it is necessary to
        pute allocate space for this irest, even though it is not printed.  
        pute This is done by using the  "P   C1:p1" print suggestion below 
        pute the offending irest.  
        goto EE 
E(41): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(42): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(43): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(44): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(45): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(46): 
        pute Error: Wrong number of superobjects 
        pute 
        pute    This obscure error sometimes occurs when collapse two 
        pute    parts (I:2) into one.  We suggest you check source file 
        pute    for duplicated triplets, or perhaps other duplicated 
        pute    super-objects (duplicate ties and slurs are O.K.) 
        pute 
        pute    Another cause could be beam super-object "=" characters 
        pute    extending across grace notes.  
        goto EE 
E(47): 
        pute Error: No more superobject capacity.  Too many simultaneous ties,
        pute slurs, endings, beams, wedges, octave transpositions, dash lines.
        goto EE 
E(48): 
        pute Error: Unexplained non-controlling object at end of line 
        pute   This error can sometimes result from a mistake in one of the 
        pute   source files.  Essentially, MSKPAGE found an object at the 
        pute   end of a measure that it did not expect to find.  For example,
        pute   word objects such as "Da Capo" may occur at the end of a measure,
        pute   but letter dynamics (symbols) should not.  In one case I ran 
        pute   across recently, a word musical direction (B,C,or D) was mistakenly
        pute   encoded as a letter dynamic (G).  This generated a symbol at 
        pute   the end of a measure, which caused MSKPAGE to fail at this point.
        goto EE 
E(49): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(50): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(51): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(52): 
        pute Error: Beam extends over control bar line 
        pute This problem occurred in collating the parts.  
        goto EE 
E(53): 
        pute Error: No refererce to superobject ~supernum  in previous objects
        pute This problem occurred in collating the parts.  
        goto EE 
E(54): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(55): 
        pute You have reached a point in this program where the code below will
        pute fail.  While not all cases of this situation have been identified, it
        pute is known that this situation will arise when the follow conditions hold:
        pute 
        pute (1) You are typesetting a part (not a score) 
        pute (2) You are using the C0:y<#> control flag to turn lines off 
        pute 
        pute In this situation, you must turn off the multiple measure feature,
        pute which is automatically (and silently) turned on when parts are being
        pute compiled by autoset.  Use the print suggestion:   P  C0:m0 
        pute in all relevent stage2 files.  
        goto EE 
E(56): 
        pute Mixed stem directions on two separate staves.  This case is often
        pute often impossible to draw and is therefore not handled by this program!
        goto EE 
E(57): 
        pute Notes on the staff with mixed stem directions are not sufficiently
        pute far apart to set a horizontal beam.  
        goto EE 
E(58): 
        pute Unable to find a slope to mixed stem beam 
        pute Try setting more distance between staves of the grand staff 
        goto EE 
E(59): 
        pute Program error in finding position of beam with mixed stems 
        goto EE 
E(60): 
        pute Unable to typeset this particular beam 
        goto EE 
E(61): 
        pute Stem up notes are not sufficiently higher that stem down notes 
        pute to allow space for a horizontal beam.  
        goto EE 
E(62): 
        pute Error: Unexplained object thrown to next line 
        goto EE 
E(63): 
        pute Error: Parts of different length.  This is probably caused 
        pute by an encoding error.  
        pute One possibility is that a slur was started but not 
        pute terminated.                                                  
        pute Another possibility is that a measure was left out of a 
        pute part with multiple rests. 
        pute Look also for the misspelling of measure, mdouble, mheavy, etc.
        pute somewhere in the source.
        goto EE 
E(64): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(65): 
        pute This problem occurred in collating the parts.  
        goto EE 
E(66): 
        pute Program storage capacity has been exceeded 
        goto EE 
E(67): 
        pute Program Error.  Sorry.  
        goto EE 
E(68): 
        pute Incompatable syscode (left hand spine descriptor).  
        goto EE 
E(69): 
        goto EE 
E(70): 
        goto EE 
E(101): 
        pute Command line format error 
        pute 
        goto EE 

EE:     pute 
        pute    Program Halted 
        pute 
        stop 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³P* 41. get_options                                                            ³
&dA &d@³                                                                              ³
&dA &d@³    Operation:  Read and process the command line.                            ³
&dA &d@³                                                                              ³
&dA &d@³    Inputs:     terminal (at the moment)                                      ³
&dA &d@³                                                                              ³
&dA &d@³    Output:     options set                                                   ³
&dA &d@³                                                                              ³
&dA &d@³      int Source_type:  0 = Musedata                                          ³
&dA &d@³                        1 = Page specific i-files                             ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Addfiles: -1 = Not present in command line                        ³
&dA &d@³                       0 = no files                                           ³
&dA &d@³                       1 = Musedata files                                     ³
&dA &d@³                       2 = I-files                                            ³
&dA &d@³                       3 = Both Dmuse and I-files                             ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Cfactor: -1 = Not present in command line                         ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Debugg:  -1 = Not present in command line                         ³
&dA &d@³                     no number = 0x01                                         ³
&dA &d@³                  bit 0 of #:  ON = print error messages                      ³
&dA &d@³                  bit 1 of #:  ON = print all diagnostics                     ³
&dA &d@³                  bit 3 of #:  ON = print measure numbers from autoset        ³
&dA &d@³                  bit 4 of #:  ON = print diagnostics from mskpage            ³
&dA &d@³                  bit 5 of #:  ON = print diagnostics from pspage             ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Vspace_flag: -1 = Not present in command line                     ³
&dA &d@³                                                                              ³
&dA &d@³                  0 = don't try to extend vertical space to the bottom        ³
&dA &d@³                        of the page                                           ³
&dA &d@³                  1 = extend vertical space to the bottom of the page         ³
&dA &d@³                        using proportional expansion                          ³
&dA &d@³                  2 = extend vertical space to the bottom of the page         ³
&dA &d@³                        using inter system spacing only                       ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Granddist: -1 = Not present in command line                       ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Min_space: -1 = Not present in command line                       ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Just_flag: -1 = Not present in command line                       ³
&dA &d@³                        0 = do not right justify last system                  ³
&dA &d@³                        1 = right justify last system                         ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Length_of_page:  -1 = Not present in command line                 ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Marg_left:  -1 = Not present in command line                      ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Max_sys_cnt:  -1 = Not present in command line                    ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Minshort:  -1 = Not present in command line                       ³
&dA &d@³                                                                              ³
&dA &d@³      int C_W(32):  all zero  -> Not present in command line                  ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Sys_width:  -1 = Not present in command line                      ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Top_of_page:  -1 = Not present in command line                    ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Defeat_flag:  -1 = Not present in command line                    ³
&dA &d@³                           0 = no defeats                                     ³
&dA &d@³                  bit 0 of #:  ON = defeat all part inclusion suggestions     ³
&dA &d@³                  bit 1 of #:  ON = defeat all line control suggestions       ³
&dA &d@³                                                                              ³
&dA &d@³      int C_Notesize:  -1 = Not present in command line                       ³
&dA &d@³                                                                              ³
&dA &d@³      str C_Syscode:  "NULL" = Not present in command line                    ³
&dA &d@³                                                                              ³
&dA &d@³      str C_Group:  "NULL" = Not present in command line                      ³
&dA &d@³                                                                              ³
&dA &d@³      int C_eof_flag:  -1 = Not present in command line                       ³
&dA &d@³                        1 = "/END" = "/eof"                                   ³
&dA &d@³                                                                              ³
&dA &d@³      str C_Work_name: "NULL" = Not present in command line                   ³
&dA &d@³                                                                              ³
&dA &d@³      str C_Work_number: "NULL" = Not present in command line                 ³
&dA &d@³                                                                              ³
&dA &d@³      str C_Composer: "NULL" = Not present in command line                    ³
&dA &d@³                                                                              ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure get_options 
        str command_line.400,temp.400,temp2.80 
        str save_command_line.400 
        str temp_s.100,temp_g.100 
        str temp_w.180,temp_n.80,temp_c.120 
        str bad_char.1 
        int t1,t2,t3 

        C_Syscode = "NULL" 
        Source_type = 0 
        C_Addfiles  = -1 
        C_Cfactor   = -1 
        C_Debugg    = 0 
        Debugg      = 0 
        C_Vspace_flag = -1 
        C_Granddist = -1  
        C_Min_space = -1 
        C_Just_flag = -1 
        C_Length_of_page = -1   
        C_Marg_left = -1 
        C_Max_sys_cnt = -1 
        C_Minshort    = -1 
        loop for t1 = 1 to 32 
          C_W(t1) = 0 
        repeat 
        C_Sys_width = -1   
        C_Top_of_page = -1 
        C_Defeat_flag = -1 
        C_Notesize    = -1 
        C_Group = "NULL" 
        temp_s = "NULL" 
        temp_g = "NULL" 
        temp_w = "NULL" 
        temp_n = "NULL" 
        temp_c = "NULL" 
        C_Syscode = temp_s 
        C_Work_name = temp_w 
        C_Work_number = temp_n 
        C_Composer = temp_c 
        C_Group = temp_g 
        C_eof_flag = -1 

        getC command_line 
        command_line = trm(command_line) 
        save_command_line = command_line 
        if command_line = "" 
          return 
        end 
        command_line = " " // command_line // " " 
&dA 
&dA &d@    Step 1: strip strings from command line 
&dA 
COMAGN: 
        if command_line con "^" 
          t1 = sub 
          if command_line{t1+1..} con "^" 
            t2 = sub 
            if "GsTuC" con command_line{t1-1} 
              if mpt = 1 
                temp_g = command_line{t1+1..t2-1} 
              end 
              if mpt = 2 
                temp_s = command_line{t1+1..t2-1} 
              end 
              if mpt = 3 
                temp_w = command_line{t1+1..t2-1} 
              end 
              if mpt = 4 
                temp_n = command_line{t1+1..t2-1} 
              end 
              if mpt = 5 
                temp_c = command_line{t1+1..t2-1} 
              end 
              command_line = command_line{1,t1-2} // command_line{t2+1..} 
              goto COMAGN 
            else 
              putc Improper command line syntax 
              pute Command line = ~save_command_line 
              tmess = 101 
              perform dtalk (tmess) 
            end 
          else 
            pute Missing a closing "^" in the command line 
            pute Command line = ~save_command_line 
            tmess = 101 
            perform dtalk (tmess) 
          end 
        end 
&dA 
&dA &d@    Step 2: Set Debugg = 1. This allows command_line 
&dA &d@              errors to be reported 
&dA 
        if command_line con "d" 
          t1 = mpt+1 
          if "0123456789" con command_line{t1} 
            C_Debugg = int(command_line{t1..}) 
          else 
            C_Debugg = 1 
          end 
          Debugg = C_Debugg 
        end 
&dA 
&dA &d@    Step 3: verify that command line starts with "=" 
&dA 
        command_line = mrt(command_line) 
        if command_line{1} <> "=" 
          pute Missing the equals "=" sign at the beginning of the command line
          pute Command line = ~save_command_line 
          tmess = 101 
          perform dtalk (tmess) 
        end 
&dA 
&dA &d@    Step 4: Now look for and set options
&dA 
        C_Syscode = temp_s 
        if temp_g <> "NULL" 
          C_Group = temp_g 
          if "score^parts^skore^short^sound^data^" con C_Group 
          else 
            tmess = 12 
            perform dtalk (tmess) 
          end 
        end 
        C_Work_name = temp_w 
        C_Work_number = temp_n 
        C_Composer = temp_c 

        if command_line con "c" 
          t1 = mpt+1 
          C_Cfactor = int(command_line{t1..}) 
        end 
        if command_line con "M" or command_line con "P" 
          C_Addfiles = 0 
          if command_line con "M" 
            C_Addfiles |= 0x01 
          end 
          if command_line con "P" 
            C_Addfiles |= 0x02 
          end 
        end 
        if command_line con "p" 
          Source_type = 1 
          if C_Addfiles > 0 
            C_Addfiles &= 0x02       /* make sure 0x01 is off 
          end 
        end 
        if command_line con "f" 
          t1 = mpt+1 
          if "012" con command_line{t1} 
            C_Vspace_flag = mpt - 1 
          else 
            C_Vspace_flag = 1 
          end 
        end 
        if command_line con "F" 
          C_Vspace_flag = 2 
        end 
        if command_line con "E" 
          C_eof_flag = 1 
        end 
        if command_line con "g" 
          t1 = mpt+1 
          C_Granddist = int(command_line{t1..}) 
        end 
        if command_line con "h" 
          t1 = mpt+1 
          C_Min_space = int(command_line{t1..}) 
        end 
        if command_line con "j" 
          t1 = mpt+1 
          if "01" con command_line{t1} 
            C_Just_flag = mpt - 1 
          else 
            C_Just_flag = 1 
          end 
        end 
        if command_line con "l" 
          t1 = mpt+1 
          C_Length_of_page = int(command_line{t1..}) 
        end 
        if command_line con "t" 
          t1 = mpt+1 
          C_Top_of_page = int(command_line{t1..}) 
        end 
        if command_line con "m" 
          t1 = mpt+1 
          C_Marg_left = int(command_line{t1..}) 
        end 
        if command_line con "n" 
          t1 = mpt+1 
          C_Max_sys_cnt = int(command_line{t1..}) 
        end 
        if command_line con "Q" 
          t1 = mpt+1 
          C_Minshort = int(command_line{t1..}) 
        end 
        if command_line con "v" 
          t1 = mpt 
          t2 = 0 
          loop while "0123456789" con command_line{t1+1} 
            ++t1 
            ++t2 
            C_W(t2) = int(command_line{t1..}) 
            t1 = sub 
          repeat while command_line{t1} = "," 
        end 
        if command_line con "w" 
          t1 = mpt+1 
          C_Sys_width = int(command_line{t1..}) 
        end 
        if command_line con "x" or command_line con "y" 
          C_Defeat_flag = 0    
          if command_line con "x" 
            C_Defeat_flag |= 0x01 
          end 
          if command_line con "y" 
            C_Defeat_flag |= 0x02 
          end 
        end 
        if command_line con "z" 
          t1 = mpt+1 
          t3 = int(command_line{t1..}) 
          if chr(t3) in [6,14,16,18,21] 
            C_Notesize = t3 
          end 
        end 
&dA 
&dA &d@    Step 5: look for errors of commission 
&dA 
        loop for t1 = 1 to len(command_line) 
          if "ab.:e;[i]k'<>oqrs()+/\ABD|GHIJKLNO_RSUVWXYZ" con command_line{t1}
            bad_char = command_line{t1} 
            pute Command line contains an unrecognized character:  ~bad_char
            pute Command line = ~save_command_line 
            tmess = 101 
            perform dtalk (tmess) 
          end 
          if command_line con chr(34) 
            bad_char = chr(34) 
            pute Command line = ~save_command_line 
            pute Command line contains an unrecognized character:  ~bad_char
            tmess = 101 
            perform dtalk (tmess) 
          end 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³P* 42. get_source                                                             ³
&dA &d@³                                                                              ³
&dA &d@³    Operation:  (1) Read the source file.  Strip off any "@" lines at         ³
&dA &d@³                the top.  Put the result in table [UR].  We will need         ³
&dA &d@³                a dedicated counter for this table: urcnt                     ³
&dA &d@³                (2) Using any "@" lines found, and the output from            ³
&dA &d@³                the get_options procedure, determine the final values         ³
&dA &d@³                for each of the program options.                              ³
&dA &d@³                                                                              ³
&dA &d@³    Inputs:     Source_type:  0 = Musedata                                    ³
&dA &d@³                              1 = Page specific i-files                       ³
&dA &d@³                                                                              ³
&dA &d@³    Output:     (1) in table UR(900000), length = urcnt                       ³
&dA &d@³                (2) options set                                               ³
&dA &d@³                                                                              ³
&dA &d@³      int Addfiles:  0 (default) = no files                                   ³
&dA &d@³                     1           = Musedata files                             ³
&dA &d@³                     2           = I-files                                    ³
&dA &d@³                     3           = Both Dmuse and I-files                     ³
&dA &d@³                                                                              ³
&dA &d@³      int Cfactor: default = 100                                              ³
&dA &d@³                                                                              ³
&dA &d@³      int Debugg:  default = 0                                                ³
&dA &d@³                   no number = 0x01                                           ³
&dA &d@³                  bit 0 of #:  ON = print error messages                      ³
&dA &d@³                  bit 1 of #:  ON = print all diagnostics                     ³
&dA &d@³                  bit 3 of #:  ON = print measure numbers from autoset        ³
&dA &d@³                  bit 4 of #:  ON = print diagnostics from mskpage            ³
&dA &d@³                  bit 5 of #:  ON = print diagnostics from pspage             ³
&dA &d@³                                                                              ³
&dA &d@³      int Vspace_flag: default = 0                                            ³
&dA &d@³                                                                              ³
&dA &d@³                  0 = don't try to extend vertical space to the bottom        ³
&dA &d@³                        of the page                                           ³
&dA &d@³                  1 = extend vertical space to the bottom of the page         ³
&dA &d@³                        using proportional expansion                          ³
&dA &d@³                  2 = extend vertical space to the bottom of the page         ³
&dA &d@³                        using inter system spacing only                       ³
&dA &d@³                                                                              ³
&dA &d@³      int Granddist: default = 100                                            ³
&dA &d@³                                                                              ³
&dA &d@³      int Min_space: default = 100                                            ³
&dA &d@³                                                                              ³
&dA &d@³      int Just_flag: default = 0   1 = right justify last system              ³
&dA &d@³                                                                              ³
&dA &d@³      int Length_of_page:  default = 2740 dots                                ³
&dA &d@³                                                                              ³
&dA &d@³      int Marg_left:  default = 200 dots                                      ³
&dA &d@³                                                                              ³
&dA &d@³      int Max_sys_cnt:  default = 0  -> no maximum                            ³
&dA &d@³                                                                              ³
&dA &d@³      int Minshort:  default = 0  -> let the program decide                   ³
&dA &d@³                                                                              ³
&dA &d@³      int W(32):  default, all zero  -> let the program decide                ³
&dA &d@³                                                                              ³
&dA &d@³      int Sys_width:  default = 2050 dots                                     ³
&dA &d@³                                                                              ³
&dA &d@³      int Top_of_page:  default = 120 dots                                    ³
&dA &d@³                                                                              ³
&dA &d@³      int Defeat_flag:  0 = no defeats                                        ³
&dA &d@³                  bit 0 of #:  ON = defeat all part inclusion suggestions     ³
&dA &d@³                  bit 1 of #:  ON = defeat all line control suggestions       ³
&dA &d@³                                                                              ³
&dA &d@³      int Notesize:  default = size-14   supported sizes = 6,14,16,18,21      ³
&dA &d@³                                                                              ³
&dA &d@³      str Syscode:  default = ""  -> let the program decide                   ³
&dA &d@³                                                                              ³
&dA &d@³      str Group:  default = "score"                                           ³
&dA &d@³                                                                              ³
&dA &d@³      int eof_flag:  0 = "/eof" at the end of each S2 file module (default)   ³
&dA &d@³                     1 = "/END" = "/eof"                                      ³
&dA &d@³                                                                              ³
&dA &d@³      str Work_name: optional work name (default = NULL)                      ³
&dA &d@³                                                                              ³
&dA &d@³      str Work_number: optional work number (default = NULL)                  ³
&dA &d@³                                                                              ³
&dA &d@³      str Composer: optional composer name (default = NULL)                   ³
&dA &d@³                                                                              ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure get_source 
        str command_line.400
        str save_command_line.400 
        str temp_s.100,temp_g.100 
        str temp_w.180,temp_n.80,temp_c.120 
        str cr.1 
        str temp.100,record.180,save_record.180 
        str @lines.180(100) 
        int @cnt,@flag 
        int t1,t2,t3 
        int t11 
        int z_size,vnum 

        cr = chr(13) 
        if C_Notesize <> -1         /* set the "active" z_size here 
          z_size = C_Notesize 
        else 
          z_size = 14 
        end 
&dA 
&dA &d@    Step 1: put in the lowest level defaults 
&dA 
        Syscode = "" 
        Addfiles    = 0    
        Cfactor     = 100 
        Debugg      = 0 
        Vspace_flag = 0 
        Granddist   = 100 
        Min_space   = 100 
        Just_flag   = 0 
        Length_of_page = 2740 
        Top_of_page = 120  
        Marg_left   = 200 
        Max_sys_cnt = 0 
        Minshort    = 0 
        loop for t1 = 1 to 32 
          W(t1) = 0 
        repeat 
        Sys_width   = 2050 
        Defeat_flag = 0 
        Notesize    = 14 
        Group       = "score" 
        Work_name   = "" 
        Work_number = "" 
        Composer    = "" 
        eof_flag = 0 
&dA 
&dA &d@    Step 2: put in the highest level defaults 
&dA 
        if C_Syscode <> "NULL" 
          Syscode = C_Syscode 
        end 
        if C_Group <> "NULL" 
          Group = C_Group 
        end 
        if C_Work_name <> "NULL" 
          Work_name = C_Work_name 
        end 
        if C_Work_number <> "NULL" 
          Work_number = C_Work_number 
        end 
        if C_Composer <> "NULL" 
          Composer = C_Composer 
        end 
        if C_Cfactor <> -1 
          Cfactor = C_Cfactor 
        end 
        if C_Addfiles <> -1 
          Addfiles = C_Addfiles 
        end 
        if C_Vspace_flag <> -1 
          Vspace_flag = C_Vspace_flag 
        end 
        if C_eof_flag <> -1 
          eof_flag = C_eof_flag 
        end 
        if C_Granddist <> -1 
          Granddist = C_Granddist 
        end 
        if C_Min_space <> -1 
          Min_space = C_Min_space 
        end 
        if C_Just_flag <> -1 
          Just_flag = C_Just_flag 
        end 
        if C_Length_of_page <> -1 
          Length_of_page = C_Length_of_page 
        end 
        if C_Top_of_page <> -1 
          Top_of_page = C_Top_of_page 
        end 
        if C_Marg_left <> -1 
          Marg_left = C_Marg_left 
        end 
        if C_Max_sys_cnt <> -1 
          Max_sys_cnt = C_Max_sys_cnt 
        end 
        if C_Minshort <> -1 
          Minshort = C_Minshort 
        end 
        if C_W(1) <> 0 
          loop for t1 = 1 to 32 
            W(t1) = C_W(t1) 
          repeat 
        end 
        if C_Sys_width <> -1 
          Sys_width = C_Sys_width 
        end 
        if C_Defeat_flag <> -1 
          Defeat_flag = C_Defeat_flag 
        end 
        if C_Notesize <> -1 
          Notesize = C_Notesize 
        end 
&dA 
&dA &d@    Step 3: Read source into UR table; get "@" lines at the top 
&dA 
        urcnt = 0 
        @cnt = 0 
        @flag = 0 
#if DMUSE 
        putc Source file?  
        getc temp 
        open [1,1] temp 
        loop      
          getf [1] record 
          record = record // pad(1) 
          if @flag = 0 
            if record{1} <> "@" 
              record = trm(record) 
              ++urcnt 
              tput [UR,urcnt] ~record 
              @flag = 1 
            else 
              ++@cnt 
              @lines(@cnt) = record 
            end 
          else 
            ++urcnt 
            tput [UR,urcnt] ~record 
          end 
        repeat 
eof1: 
        close [1] 
#else 
        save_record = "pyrzqxgl" 
        t3 = 0                        /* duplicate counter 
        loop 
          getc record 
          t2 = len(record) 
          if record{t2} = cr 
            record = record{1,t2-1} 
          end 
          if record = save_record     /* "backup" halting apparatus 
            ++t3 
            if t3 = 20 
              urcnt -= 20             /* i.e., you received 20 "extra" records from pipe
              goto IEND 
            end 
          else 
            t3 = 0 
            save_record = record 
          end 
          if @flag = 0 
            if record{1} <> "@" 
              record = trm(record) 
              ++urcnt 
              tput [UR,urcnt] ~record 
              @flag = 1 
            else 
              ++@cnt 
              @lines(@cnt) = record 
            end 
          else 
            ++urcnt 
            tput [UR,urcnt] ~record 
            record = record // pad(4) 
            if Source_type = 0 
              if record{1,2} = "//"     /* Normal halting apparatus for S2 sources
                goto IEND 
              end 
            else 
              if record{1,4} = "/eof"   /* Normal halting apparatus for i-file sources
                goto IEND 
              end 
            end 
          end 
        repeat 
IEND: 
#endif 
&dA 
&dA &d@    Step 4: Process any "@" lines found 
&dA 
        if @cnt > 0 
          temp_g = "" 
          temp_s = "" 
          temp_w = "" 
          temp_n = "" 
          temp_c = "" 
          loop for t11 = 1 to @cnt 
            record = @lines(t11) // pad(80) 
            if record{1,9} <> "@muse2psv" 
              goto NO_NEWOP 
            end 
            vnum = int(record{10..}) 
            t2 = sub 
            if record{t2} <> "=" 
              goto NO_NEWOP 
            end 
            ++t2 
            if record{t2} <> "=" 
              if record{t2} <> "z" 
                goto NO_NEWOP 
              end 
              ++t2 
              t3 = int(record{t2..}) 
              t2 = sub 
              if t3 <> z_size or record{t2} <> "=" 
                goto NO_NEWOP 
              end 
            end 
            ++t2 
&dA &d@           
&dA &d@        Here is where the "in-line" command line gets processed 
&dA 
            command_line = " " // record{t2..} // " " 
&dA 
&dA &d@    Step 4a: strip strings from command line 
&dA 
G_COMAGN: 
            if command_line con "^" 
              t1 = sub 
              if command_line{t1+1..} con "^" 
                t2 = sub 
                if "GsTuC" con command_line{t1-1} 
                  if mpt = 1 
                    temp_g = command_line{t1+1..t2-1} 
                  end 
                  if mpt = 2 
                    temp_s = command_line{t1+1..t2-1} 
                  end 
                  if mpt = 3 
                    temp_w = command_line{t1+1..t2-1} 
                  end 
                  if mpt = 4 
                    temp_n = command_line{t1+1..t2-1} 
                  end 
                  if mpt = 5 
                    temp_c = command_line{t1+1..t2-1} 
                  end 
                  command_line = command_line{1,t1-2} // command_line{t2+1..}
                  goto G_COMAGN 
                end 
              end 
            end 
&dA 
&dA &d@    Step 4b: Now look for and set options
&dA 
            if C_Syscode = "NULL" 
              if temp_s <> "" 
                Syscode = temp_s    
              end 
            end 

            if C_Group = "NULL" 
              if temp_g <> "NULL" 
                if "score^parts^skore^short^sound^data^" con temp_g 
                  Group = temp_g 
                end 
              end 
            end 

            if C_Work_name = "NULL" 
              if temp_w <> "NULL" 
                Work_name = temp_w 
              end 
            end 

            if C_Work_number = "NULL" 
              if temp_n <> "NULL" 
                Work_number = temp_n 
              end 
            end 

            if C_Composer = "NULL" 
              if temp_c <> "NULL" 
                Composer = temp_c 
              end 
            end 

            if C_Cfactor = -1 
              if command_line con "c" 
                t1 = mpt+1 
                Cfactor = int(command_line{t1..}) 
              end 
            end 

            if C_Addfiles = -1 
              if command_line con "M" or command_line con "P" 
                Addfiles = 0 
                if command_line con "M" 
                  Addfiles |= 0x01 
                end 
                if command_line con "P" 
                  Addfiles |= 0x02 
                end 
              end 
            end 

            if command_line con "p"    /* Source_type can be changed here 
              Source_type = 1 
              if Addfiles > 0 
                Addfiles &= 0x02       /* make sure 0x01 is off 
              end 
            end 

            if C_Vspace_flag = -1 
              if command_line con "f" 
                t1 = mpt+1 
                if "012" con command_line{t1} 
                  Vspace_flag = mpt - 1 
                else 
                  Vspace_flag = 1 
                end 
              end 
              if command_line con "F" 
                Vspace_flag = 2 
              end 
            end 

            if C_eof_flag = -1 
              if command_line con "E" 
                eof_flag = 1 
              end 
            end 

            if C_Granddist = -1 
              if command_line con "g" 
                t1 = mpt+1 
                Granddist = int(command_line{t1..}) 
              end 
            end 

            if C_Min_space = -1 
              if command_line con "h" 
                t1 = mpt+1 
                Min_space = int(command_line{t1..}) 
              end 
            end 

            if C_Just_flag = -1 
              if command_line con "j" 
                t1 = mpt+1 
                if "01" con command_line{t1} 
                  Just_flag = mpt - 1 
                else 
                  Just_flag = 1 
                end 
              end 
            end 

            if C_Length_of_page = -1 
              if command_line con "l" 
                t1 = mpt+1 
                Length_of_page = int(command_line{t1..}) 
              end 
            end 

            if C_Top_of_page = -1 
              if command_line con "t" 
                t1 = mpt+1 
                Top_of_page = int(command_line{t1..}) 
              end 
            end 

            if C_Marg_left = -1 
              if command_line con "m" 
                t1 = mpt+1 
                Marg_left = int(command_line{t1..}) 
              end 
            end 

            if C_Max_sys_cnt = -1 
              if command_line con "n" 
                t1 = mpt+1 
                Max_sys_cnt = int(command_line{t1..}) 
              end 
            end 

            if C_Minshort = -1 
              if command_line con "Q" 
                t1 = mpt+1 
                Minshort = int(command_line{t1..}) 
              end 
            end 

            if C_W(1) = 0 
              if command_line con "v" 
                t1 = mpt 
                t2 = 0 
                loop while "0123456789" con command_line{t1+1} 
                  ++t1 
                  ++t2 
                  W(t2) = int(command_line{t1..}) 
                  t1 = sub 
                repeat while command_line{t1} = "," 
              end 
            end 

            if C_Sys_width = -1 
              if command_line con "w" 
                t1 = mpt+1 
                Sys_width = int(command_line{t1..}) 
              end 
            end 

            if C_Defeat_flag = -1 
              if command_line con "x" or command_line con "y" 
                Defeat_flag = 0 
                if command_line con "x" 
                  Defeat_flag |= 0x01 
                end 
                if command_line con "y" 
                  Defeat_flag |= 0x02 
                end 
              end 
            end 

            if C_Notesize = -1 
              if command_line con "z" 
                t1 = mpt+1 
                t3 = int(command_line{t1..}) 
                if chr(t3) in [6,14,16,18,21] 
                  Notesize = t3 
                  z_size = Notesize       /* somewhat tricky code 
                end 
              end 
            end 
NO_NEWOP: 
          repeat 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M*  1. my_mskpage                                               ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Input: from table Z(400000)                                 ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Output: pages directory                                     ³ 
&dA &d@³                                                                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure my_mskpage 
        str file.280,line2.480,temp2.480 
        str line3.480,tline.480,tline2.180 
        str outlib.400 
        str linepiece.480(5) 
        str htype.1,xbyte.10(32) 

        int t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13 
        int savet3,lastk,delta_e,mdf 
        int a3,a4,a8,a10 
        int q1,q2 
        int f2,f4,f5,f13 
        int nflg1,rflag(40) 
        int tarr2(32),tarr3(32),tarr5(32,2) 
        int adjarr(300,4),adjarc,pdist,larc2 
        int textflag,stopflag 
        int endflag,firstpt,prev_point,point_adv 
        int saverec,endbarrec,backloc(32),uxstart(32),nuxstop(32) 
        int savenoby(32),textlen,newbarnum,cdincf(32),ndincf(32),oldcdincf 
        int rmarg,supermap(32,N_SUPER),superpnt(32,N_SUPER) 
        int sq(32),sobx2,saved_sobx2 
        int sitflag,tspan,page,sysh,syslen,sysy 
        int bolddist(32),dv3,olddv1(32),oldcdv,cdv_adv,backtxobrec 
        int syscnt,new_syscnt(80),maxsystems,firstbarflag 
        int sysbarpar(400,5),old_sysbarpar(400,2),sav_sysbarpar(400,5) 
        int mcnts(5000),mcnt,mspace(2000),mspace2(20000) 
        int deadspace,old_extra,average_extra 
        int new_start_look,start_sys 
        int half_back,conttie(32),trec 
        int single_meas,sv_mainyp 
        int y1p,y2p,y3p 
        int c18,c19 

        table T(30000) 

        str abbr.40(200) 
        int point,oldmp2,oldmpoint,barpar(40,3),barcount 
        int barnum,delta,rest7,bottom_sq,tf11 
        int tsq(32),tvst(32),tnotesize(32)
        int recflag(400000),abbr_cnt,current_recf 
        int type1_dflag(32),type2_dflag(32) 
        int save_type1_dflag(32),save_type2_dflag(32) 
        int sys_jflag 
        int new_maxsystems(80),section_cnt 
        int max_larc 
        int xx(6) 
        int new_direct(100,2) 
        int save_direct(100,2) 
        int new_dircnt 
        int save_dircnt 
        int icnt 
&dA 
&dA &d@   Start Program Code 
&dA 
        icnt = 0 
        cjtype = "" 
        mtfont = 31 
        cdv = 0 
        backtxobrec = 0 
        saved_sobx2 = 100 
LIBQ2: 
        outlib = "pages" 
&dA 
&dA &d@  Transfer source files to X table 
&dA 
        t11 = 0 
        abbr_cnt = 0 

        f12 = 0 
        ++icnt 
        tget [Z,icnt] line 
        if line con "******" 
          ++f12 
        end 
TOP: 
        current_recf = 0 
        ++t11 
        f(f12,1) = t11 
        ++icnt 
        tget [Z,icnt] line 
&dA 
&dA &d@    Set line flag 
&dA 
        f(f12,15) = 1 
        if line{1} = "l" 
          f(f12,15) = 2 
        end 
&dA     
        vst(f12)  = int(line{3..})            /* vertical offset to second staff (or 0)
        f(f12,9)  = int(line{sub..})          /* vertical offset to text line
        f(f12,14) = int(line{sub..})          /* note size 

        if sub <= len(line) 
          line = line{sub..} 
          line = mrt(line)                    /* part name 
        else 
          line = "" 
        end 
        tput [Z,t11] ~line 
        recflag(t11) = current_recf 
&dA 
&dA &d@    This code insures that the movement name doesn't get printed twice 
&dA 
        ++icnt 
        tget [Z,icnt] line 
        if line{3} = "D" 
          ++icnt 
          tget [Z,icnt] line 
        else 
          line = line // pad(80) 
          ++t11 
          tput [Z,t11] ~line 
          recflag(t11) = current_recf 
        end 

        c1 = 0 
        loop 
          if icnt = zcnt 
            goto EOTAZ 
          end 
          ++icnt 
          tget [Z,icnt] line 
          if line con "******" 
            f(f12,2) = t11 
            if c1 = 0 
              c1 = 1 
            end 
            f(f12,13) = c1 
&dA 
&dA &d@   This code is put in to insure that searches do not extend beyond the end 
&dA &d@       of a particular i-file 
&dA &d@                                                                             
            ++t11 
            line = "   "            /* dummy line, beginning with " " 
            tput [Z,t11] ~line 
            recflag(t11) = 0          /* rec flag is 0 

            ++f12 
            goto TOP 
          end 
          line = line // "   " 
          if line{1} = "T" 
            c2 = int(line{3..}) 
            if line{sub} = "|" 
              c2 = int(line{sub+1..}) 
            end 
            c2 = int(line{sub..}) 
            if c1 < c2 
              c1 = c2 
            end 
          end 
&dA 
&dA &d@    Code to deal with Tags 
&dA 
          if line{1} = "Y"                      /* This is a tag.  Don't store it.
            if line{3} = "P"                    /*   abbr part name 
              if line{5} = "0" 
                current_recf &= 0xff00          /* turn off abbr flag completely
              else 
                ++abbr_cnt 
                abbr(abbr_cnt) = line{5..} 
                current_recf &= 0xff00          /* turn off any previous pointer
                current_recf += abbr_cnt        /*   and store new pointer 
              end 
            end 
            if line{3} = "U"                    /*   line control code 
              c3 = int(line{5}) 
              current_recf &= 0x00ff            /* turn off any previous control code
              current_recf += (c3 << 8)         /*   and store new code 
            end 
          else 
            ++t11 
            tput [Z,t11] ~line 
            recflag(t11) = current_recf           /* Flag every record 
          end 
        repeat 
EOTAZ: 
        f(f12,2) = t11 
        if c1 = 0 
          c1 = 1 
        end 
        f(f12,13) = c1 
&dA 
&dA &d@   This code is put in to insure that searches do not extend beyond the end 
&dA &d@       of a particular i-file 
&dA &d@                                                                             
        ++t11 
        line = "   "              /* dummy line, beginning with " " 
        tput [Z,t11] ~line 
        recflag(t11) = 0            /* rec flag is 0 
        f11 = f12 

        perform parameter_init 
&dA 
&dA &d@  Check for snode = 10000  at end of each part 
&dA 
        loop for f12 = 1 to f11 
          tget [Z,f(f12,2)] line .t5 t1 dvar1 t1 t1 t1 
          if t1 <> 10000 
            if (Debugg & 0x01) > 0 
              pute Error: Part ~f12 does not end properly 
            end 
            tmess = 39 
            perform dtalk (tmess) 
          end 
        repeat 
&dA 
&dA &d@   Set up mechanism for page specific output 
&dA 
        perform pageform_init 

REALWORK: 

        if justflag = 3 
          loop for t9 = 1 to maxsystems 
            old_sysbarpar(t9,1) = sysbarpar(t9,1) 
            old_sysbarpar(t9,2) = sysbarpar(t9,2) 
          repeat 
        end 

        new_dircnt = 0            /* New &dA11/21/07&d@ 
        save_dircnt = 0           /* New &dA11/21/07&d@ 
        mnum = 1 
        sys_count = 1 
        syscnt = 0 
        savet3 = 0 
        mcnt   = 0 
        deadspace = 0 
        stopflag  = 0 
        endflag   = 0 
        f4        = 0 
        adj_space = YES 

        loop for t9 = 1 to 32 
          conttie(t9) = 0 
        repeat 
        loop for t9 = 1 to f11 
          f(t9,5)   = 0 
          f(t9,7)   = 0 
          f(t9,8)   = 0 
          f(t9,11)  = 0 
          mkey(t9)  = 0 
&dA 
&dA &d@   initialize superpnt(.,N_SUPER), supermap(.,N_SUPER), superdata(.,N_SUPER,SUPERSIZE)
&dA &d@   drec(.), savenoby(.), nuxstop(.), dxoff(.) 
&dA &d@   dyoff(.), uxstart(.), backloc(.), xbyte(.) 
&dA 
          loop for t10 = 1 to N_SUPER     
            superpnt(t9,t10) = 0 
            supermap(t9,t10) = 0 
            loop for t7 = 1 to SUPERSIZE 
              superdata(t9,t10,t7) = 0 
            repeat 
          repeat 
          drec(t9)      = 0 
          savenoby(t9)  = 0 
          nuxstop(t9)   = 0 
          dxoff(t9)     = 0 
          dyoff(t9)     = 0 
          uxstart(t9)   = 0 
          backloc(t9)   = 0 
          xbyte(t9)     = "**********"{1,f(f12,13)} 
        repeat 

        sp = hxpar(3) + hxpar(9) 
        loop for t9 = 1 to f11 
          sq(t9) = psq(t9) 
        repeat 
        if justflag < 2 
          page = 0 
          treset [Y] 
          mainyp = 0 
          sv_mainyp = 0 
        end 
&dK &d@       if tacetline <> "" 
&dK &d@         if justflag < 2 
&dK &d@           ++mainyp 
&dK &d@           tput [Y,mainyp] X 46 1200C ~sq(1)  ~tacetline 
&dK &d@         end 
&dK &d@         loop for t9 = 1 to f11 
&dK &d@           sq(t9) += 150 
&dK &d@         repeat 
&dK &d@       end 
&dK &d@       if justflag < 2 
&dK &d@         ++mainyp 
&dK &d@         if len(mvtline) > 3 
&dK &d@           if mvtline{1,3} = "(c)" 
&dK &d@             mvtline = mvtline{4..} 
&dK &d@             tput [Y,mainyp] X 46 1200C ~sq(1)  ~mvtline 
&dK &d@           else 
&dK &d@             tput [Y,mainyp] X 46 575 ~sq(1)  ~mvtline 
&dK &d@           end 
&dK &d@         else 
&dK &d@           tput [Y,mainyp] X 46 575 ~sq(1)  ~mvtline 
&dK &d@         end 
&dK &d@       end 
&dK &d@       loop for t9 = 1 to f11 
&dK &d@         sq(t9) += 120                   /* This moves system down to accommodate mvtline
&dK &d@       repeat 

        sysy = sq(1) 
        sysh = sq(f11) - sq(1) + mvpar(f11,8) + vst(f11) 
        bottom_sq = sq(f11) 
        sys_bottom = sq(f11) + vst(f11) 
&dA 
&dA &d@  1. initialize variables   
&dA 
        ldist = sp 
        loop for f12 = 1 to f11 
          rec = f(f12,1) + 1 
          f(f12,4) = rec 
          f(f12,6) = rec 
          f(f12,10) = 0 
          olddist(f12) = 0 
        repeat 
        pdist = 0 
        larc = 0 
        barcount = 0 
        loop for t9 = 1 to 40 
          rflag(t9) = 0 
        repeat 
        textflag = 0 
        barnum = 0 
        oldbarnum = 0 
        newbarnum = 0 
        gbarflag = 0 
        f13 = 0 
&dA 
&dA &d@  2. Start initial system   
&dA 
&dA &d@     A. Generate entries in marr for mclef, mkey and time 
&dA &d@            signatures in that order  (snode = 6913) 
&dA 
        syslen = hxpar(4) - sp 
        marc = 0 
        perform setckt 
        firstpt = ldist - sp 
&dA 
&dA &d@     B. Transfer marr to larr
&dA 
        loop for t9 = 1 to marc 
          ++larc 
          loop for t10 = 1 to MARR_PARS 
            larr(larc,t10) = marr(t9,t10) 
          repeat 
        repeat 
        marc = 0 
        deadspace = ldist 

        stopflag = 0 
        sys_jflag = 0 
        mcnts(syscnt+1) = mcnt 
&dA 
&dA &d@     C. Jump over code that sets up to print pages 2ff.  
&dA &d@          Jump to section that begins reading input 
&dA &d@          data to construct the next measure (III-5).  
&dA 
        goto CF 

&dA                                            
&dA &d@ 
&dA &d@  I. General music system loop (big loop) 
&dA 
&dA &d@    1. Check to see if there is more music.  
&dA &d@         Jump to process end if not.  (FINE) 
&dA &d@                                               
CHH: 
        sys_jflag = 0 
        mcnts(syscnt+1) = mcnt 
        loop for f12 = 1 to f11 
          rec = f(f12,5) 
          perform save3                   /* oby not used here 
          if line{1} = "J" and jtype = "M" and snode = 10000 
            f(f12,8) = 1 
          end 
        repeat 

        perform endcheck (endflag) 
        if endflag = 1 
          if justflag > 0 
            sysbarpar(syscnt,5) = sysbarpar(syscnt,1) 
          end 
          goto FINE 
        end 
&dA 
&dA &d@    2. Determine location of new system.          
&dA 
&dA &d@       Note: We can make a preliminary determination of the vertical 
&dA &d@       size of the new system, but we will not know the final vertical  
&dA &d@       size until we have typeset the system and have performed the 
&dA &d@       the optional removal of "totally resting" lines.  
&dA 
        sq(1) = bottom_sq + vst(f11) + intersys 
        sp = hxpar(3) 

        loop for t9 = 2 to f11 
          if w(1) = 0                                   /* use default spacings
            if f(t9-1,9) = 0 
              sq(t9) = sq(t9-1) + mvpar(t9-1,14) 
            else 
              sq(t9) = sq(t9-1) + mvpar(t9-1,11) 
            end 
          else 
            sq(t9) = sq(t9-1) + w(t9-1) 
          end 
          if f(t9-1,12) = 2 
            sq(t9) += vst(t9-1) 
          end 
        repeat 

        sysy = sq(1) 
        sysh = sq(f11) - sq(1) + mvpar(f11,8) + vst(f11) 
        syslen = hxpar(4) - sp 
        bottom_sq = sq(f11) 
        if justflag < 2 
          old_sys_bottom = sys_bottom 
        end 
        sys_bottom = sq(f11) + vst(f11) 
&dA 
&dA &d@    3. Compute space for new mclef and mkey 
&dA 
        perform clefkeyspace (f5) 
        deadspace = ldist 
&dA 
&dA &d@    4. Initialize music system (line) variables 
&dA 
        hxpar(8) = ldist + hxpar(7) 
        line2 = pad(80) 
        loop for f12 = 1 to f11 
          uxstart(f12) = hxpar(8) 
          backloc(f12) = hxpar(8) 
          olddist(f12) = bolddist(f12) 
          f(f12,6) = f(f12,5)     /* record at new measure of music for part(.)
          f(f12,4) = f(f12,5) 
          f(f12,10) = f(f12,7)    /* multiple rest counter for part(.) 
        repeat 
        pdist = ldist - sp 
        f13 = 1 
        larc = 0 
        marc = 0 
        barcount = 0 
        loop for t9 = 1 to 40 
          rflag(t9) = 0 
        repeat 
        textflag = 0 
        oldbarnum = barnum 
        stopflag = 0 
        if justflag < 2 
          firstsys = FALSE 
        end 

&dA                                                                       
&dA 
&dA &d@  II. Read measures until ldist > hxpar(4), or until end of data.  
&dA 
&dA &d@      Read data one measure at a time.  The definition of a complete 
&dA &d@    measure is when the space node = 6913.   There may be several 
&dA &d@    objects in this position, including clef, key, and time changes, 
&dA &d@    and also some super-objects.  All of these must be read and the 
&dA &d@    distances included in the "measure".  If the last object is not 
&dA &d@    a bar line, the next object must be checked and the distance to 
&dA &d@    it used as a temporary negative adjustment to the potential length 
&dA &d@    of the line (so that there will be space for the last object).  
&dA 
&dA &d@      When the addition of a measure distance to the total distance 
&dA &d@    on a line results in a line overflow, we have two choices: (1) 
&dA &d@    we may try to condense the longer line to fit, or (2) we may 
&dA &d@    try to expand the shorter line (i.e. minus the last measure) to 
&dA &d@    fit.  This decision and the resulting processes are in section 
&dA &d@    III of the process.  
&dA 
&dA &d@      We must first establish which parts are active in this measure.  
&dA &d@    This is also a good time to look for the terminating mark in all 
&dA &d@    parts.  

CF: 
        rmarg = hxpar(4) 
        false_rmarg = rmarg 
        f2 = 0 
        nflg1 = 0xffffffff 
        loop for f12 = 1 to f11 
          notesize = f(f12,14) 
          if f(f12,10) = 0        /* first temporary multiple rest counter 
            rec = f(f12,6) 
CR: 
            perform save3                 /* oby not used here 
            ++rec 
            if line{1,3} = "J S" and f11 > 1 
              if "467" con line{5}                 /*  multiple rests and whole rests
                if mpt = 1 
                  f(f12,10) = snode 
                else 
                  f(f12,10) = 1 
                end 
CP: 
                perform save3             /* oby not used here 
                if line{1,3} <> "J B" 
                  ++rec 
                  goto CP 
                end 
&dA 
&dA &d@  reset olddist(.) to bar line after rest.  This reset occurs only  
&dA &d@  for those parts where f(f12,10) (rest-counter) > 0.  Note: at the 
&dA &d@  point where we start looking at this part again, i.e. the counter 
&dA &d@  is changing from 1 to 0, we must typeset the concluding bar line  
&dA &d@  and check to see if there are any addition 6913 type nodes,   
&dA &d@  e.g., time or key changes, which would have to be included on 
&dA &d@  this line.  
&dA 
                olddist(f12) = dvar1 
                f(f12,6) = rec 
                goto CQ 
              end 
            end 
            if line{1} = "J" 
              if snode = 10000 
                f(f12,8) = 1 
              end 
              goto CQ 
            end 
            goto CR 
          end 
CQ: 
        repeat 
* 
        perform endcheck (endflag) 
        if endflag = 1 
          if justflag > 0 
            ++syscnt 
            sysbarpar(syscnt,1) = barcount 
            sysbarpar(syscnt,2) = rmarg - ldist 
            sysbarpar(syscnt,5) = barcount 
          end 
          if justflag <> 1 
            goto CG 
          else 
            goto CE 
          end 
        end 
&dA 
&dA &d@  endcheck checks all values of f(.,8); they must be either all 0   
&dA &d@     or all 1 

&dA 
&dA &d@  Check for whole rests in all parts  
&dA 
        loop for f12 = 1 to f11 
          if f(f12,10) = 0 
            goto CC 
          end 
        repeat 
&dA 
&dA &d@  If no branch, then whole rest is in all parts,  
&dA 
&dA &d@     0) check for forced termination 
&dA 
        if sysbarpar(syscnt+1,3) = barcount and barcount > 0 
          delta = rmarg - ldist 
*   put in larr entry for terminating bar line 
          ++larc 
          larr(larc,MNODE_TYPE)  = 18                 /* New &dA05/25/03&d@ 
          larr(larc,ACT_FLAG)    = 0xffffffff         /*  "     " 
          larr(larc,M_ADJ)       = adj_space          /*  "     " 
          goto CE 
        end 
&dA 
&dA &d@     1) increment ldist, check for overflow 
&dA 
        ldist += hxpar(6) 

        if ldist > false_rmarg 
*   put in larr entry for terminating bar line 
          ++larc 
          larr(larc,MNODE_TYPE)  = 18 
          larr(larc,ACT_FLAG)    = 0xffffffff 
          larr(larc,M_ADJ)       = adj_space 
          goto CE 
        end 

        ++mcnt 
        mspace(mcnt) = ldist 
&dA 
&dA &d@     2) check to see if this is the last measure of general rest.  If 
&dA &d@          so, then we will want to look for additional objects such as 
&dA &d@          clefs, key changes, etc. beyond the terminating bar line.  
&dA &d@          The code to do this is at CCV.  
&dA 
        a1 = 0 
        loop for f12 = 1 to f11 
          if f(f12,10) = 1 
            a1 = hxpar(6) 
            ndincf(f12) = 0 
          end 
        repeat 
        if a1 > 0 
          f2 = 1 
          --mcnt 
          goto CCV 
        end 
&dA 
&dA &d@     3) recompute delta 
&dA 
        delta = rmarg - ldist 
&dA 
&dA &d@     4) advance record pointer and bolddist; decrement f(.,10) 
&dA 
        loop for f12 = 1 to f11 
          f(f12,5) = f(f12,6) 
          bolddist(f12) = olddist(f12) 
          --f(f12,10) 
        repeat 
&dA 
&dA &d@     5) increment barcount, set empty bar flag for this bar, zero marc 
&dA 
        ++barcount 
        ++barnum 
        rflag(barcount) = hxpar(6) 
&dA 
&dA &d@     6) branch; if delta = 0, go to print, else get next measure 
&dA 
        if delta = 0 
*   put in larr entry for terminating bar line 
          ++larc 
          larr(larc,MNODE_TYPE)  = 18                 /* New &dA05/25/03&d@ 
          larr(larc,ACT_FLAG)    = 0xffffffff         /*  "     " 
          larr(larc,M_ADJ)       = adj_space          /*  "     " 
          if justflag > 0 
            ++syscnt 
            sysbarpar(syscnt,1) = barcount 
            sysbarpar(syscnt,2) = 0 
            sysbarpar(syscnt,5) = 0                  /* New &dA05/28/05&d@ 
          end 
          goto CG 
        end 
        goto CF 

&dAÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ&d@ 
 
&dA 
&dA &d@  At this point we have established that there is at least one active 
&dA &d@  part in the measure.  We now have a well-defined task.  We must look 
&dA &d@  through the active parts (where f(.,10) = 0) for the object(s) which 
&dA &d@  has (have) the next smallest division number.  We are concerned 
&dA &d@  here with objects that need to "line up".  These objects we 
&dA &d@  call "proper" objects and include: 
&dA 
&dA &d@     1. regular notes, cue notes, figures, isolated objects (NRQFI) 
&dA &d@     2. bar lines                                           (B) 
&dA &d@     3. key signatures, time signatures                     (KT) 
&dA 
&dA &d@  For purposes of determining position and space, we can skip over 
&dA &d@  those types of objects in a part that do not have to line up, but 
&dA &d@  the distances through these objects to the line-up type objects 
&dA &d@  must be taken into account.  The objects that do not have to 
&dA &d@  line up are called "passing" objects and include: 
&dA 
&dA &d@     1. clef signs                           (C) 
&dA &d@     2. directives                           (D) 
&dA &d@     3. grace notes                          (G) 
&dA &d@     4. symbols                              (S) 
&dA &d@     5. marks                                (M) 
&dA 
&dA &d@  Clef signs actually get special treatment.  If they follow a 
&dA &d@  bar line and have snode = 6913, they are classified as proper 
&dA &d@  objects; otherwise they are passing objects and their position 
&dA &d@  is determined by the next proper object in the part.  
&dA 
&dA &d@  Our search will cover all objects with snode < 6913.  When 
&dA &d@  snode = 6913, we are at the end of a controlling measure.  This 
&dA &d@  situation will be covered later in the program.  
&dA 
&dA &d@  There is one anomaly which should be mentioned.  We may encounter 
&dA &d@  a non-controlling bar line in the middle of our search.  In this  
&dA &d@  case, we will generate two nodes with the same snode number.  
&dA &d@  These can be differentiated by the node type (marr(.,MNODE_TYPE)).   (&dA05/25/03&d@)
&dA 
CC: 
        loop for f12 = 1 to f11 
          f(f12,5) = f(f12,6)         /* set the "beginning of measure" pointers
          bolddist(f12) = olddist(f12) 
          cdincf(f12) = 0 
          ndincf(f12) = 0 
        repeat 
        oldcdincf = 0 
        loop for t11 = 1 to 32 
          tdist(t11,1) = 0 
        repeat 
&dA 
&dA &d@  Set tarr array for active parts in this measure.  
&dA &d@  Set textflag = 1, if any active parts are parts which contain text. 
&dA 
        loop for f12 = 1 to f11 
          tarr(f12) = f(f12,10) 
          if f(f12,10) = 0 and f(f12,9) > 0 
            textflag = 1 
          end 
        repeat 
&dA 
&dA 
&dA &d@  CHECK POINT:   When a new node is identified, the distance to that  
&dA &d@  node must be added to all the olddist(.) variables, not just to   
&dA &d@  parts in the node.  Then if the next node is generate by part(s) 
&dA &d@  not in this set (the case which we define as syncopation), you won't 
&dA &d@  get some huge distance between these nodes.  This, however, leads 
&dA &d@  to another problem.  The distance to this next node may become very 
&dA &d@  small, or even negative.   We need to set some minimum distance 
&dA &d@  for this node; also, we need to identify this node with a new type, 
&dA &d@  because it will have its own rules for adding distance.  The type 
&dA &d@  shall be 20 + note type that would be generated by the increment 
&dA &d@  in divisions, or in the case of tuplets, the type shall be 40.  
&dA &d@  The minimum distance in the case of syncopation shall be determined 
&dA &d@  in the following manner.  
&dA 
&dA &d@                 Spacing of Syncopated Nodes 
&dA &d@                 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
&dA &d@  Definition:  A node is syncopated when it contains no parts which 
&dA &d@     were also contained in the previous node.  
&dA 
&dA &d@  To compute the minimum distance to a syncopated node: 
&dA 
&dA &d@    1) determine the duration of all of the nodes coming into this 
&dA &d@       node 
&dA 
&dA &d@          To do this, we will have to look ahead to the next node 
&dA &d@          in every active part and read field 8, the preceding 
&dA &d@          duration parameter.  This information can be collected 
&dA &d@          at the time we are putting the objects for the node 
&dA &d@          together, since this process requires that we look at 
&dA &d@          objects up to the point where the node number changes.  
&dA &d@          When this change does occur, the value of dincf will be 
&dA &d@          the duration of this node in this part.  
&dA 
&dA &d@    2) the shortest such duration becomes the "controlling duration" 
&dA 
&dA &d@    3) the space occupied by the node generating the controlling 
&dA &d@       duration becomes the "controlling space" 
&dA 
&dA &d@          The space is the advance in the x-coordinate for this 
&dA &d@          node.  This we will have to determine at the time the 
&dA &d@          syncopation is discovered.  At least we will already 
&dA &d@          know the controlling duration and therefore the part 
&dA &d@          which must be examined.  We must look forward to the 
&dA &d@          first &dDproper&d@ object which has a new node number.  
&dA 
&dA &d@    4) determine the ratio between the duration advance to this 
&dA &d@       node and the controlling duration (always less than 1) 
&dA 
&dA &d@          The duration advance for a particular node can only be 
&dA &d@          computed by keeping track of the duration advances for 
&dA &d@          all active parts from the previous controlling bar line 
&dA &d@          (bar line with snode = 6913).  We must assume that all 
&dA &d@          active parts will have a node at the beginning of the 
&dA &d@          measure, even if it is a rest.  
&dA 
&dA &d@    5) the minimum distance is this ratio times the controlling space 
&dA 
&dA &d@    Note:  syncopated nodes should be reasonably rare in the music 
&dA &d@           we are currently working with.  
&dA 
&dA 
&dA &d@    &dENOTE&d@: The following loop, which occupies about 400 lines, 
&dA &d@            uses a tricky exit mechanism 
&dA 
        t13 = 0 
        loop 
          t8 = 0 
&dA 
&dA &d@  Find the parts which constitute the next node (less than 6913) in 
&dA &d@    measure.  Set tarr2(.) = 1 for these parts. 
&dA 
          t12 = 20000 
          loop for f12 = 1 to f11 
            notesize = f(f12,14) 
            tarr2(f12) = 0 
            if tarr(f12) = 0       /* i.e. if part is active and not at end of measure
              rec = f(f12,6) 
CTT: 
              perform save3               /* oby not used here 
              ++rec 
              if line{1} = "Q" 
                stopflag = 1 
                goto CTT 
              end 
              if line{1} = "J"     /* this is what you are looking for (next object)
                if snode < t12 
                  t12 = snode 
                  loop for t9 = 1 to f12 
                    tarr2(t9) = 0 
                  repeat 
                end 
                if snode = t12 
                  tarr2(f12) = 1 
                end 
                if snode = 6913 
                  ++t8 
                  tarr(f12) = 1        /* end of measure for this part 
                  tarr2(f12) = 0 
                end 
                goto CSS 
              end 
              goto CTT 
            else 
              ++t8 
            end 
CSS: 
          repeat 
&dA 
&dA &d@  Check for end of measure; if so, set value for rflag(barcount) = 0  
&dA 
          if t8 = f11 
            a1 = 0 
            goto CCV       /* this is the exit for the measure loop 
          end 
&dA 
&dA &d@  establish minimum ndincf for active parts coming into this node 
&dA 
          t4 = 20000 
          t5 = 0 
          loop for f12 = 1 to f11 
            if tarr(f12) = 0 and ndincf(f12) < t4 
              t4 = ndincf(f12) 
              t5 = f12 
            end 
          repeat 
&dA 
&dA &d@  Determine values of marr for this node  
&dA 
          ++marc 
          marr(marc,PRE_DIST)    = 0 
          marr(marc,MNODE_TYPE)  = 17 
          marr(marc,SNODE)       = t12 
          marr(marc,ACT_FLAG)    = 0 
          marr(marc,M_ADJ)       = adj_space 
          marr(marc,MARR_TEMP)   = 3           /* New &dA02/09/07&d@  &dE3 = unset&d@ */

          loop for t11 = 1 to 32 
            tdist(t11,1) = 0 
          repeat 
          t11 = 0 
          t6 = 0                           /* WARNING: very tricky code 
          t7 = 0 
          loop for f12 = 1 to f11 
            notesize = f(f12,14) 
            rec = f(f12,6) 
            if tarr2(f12) = 1 

&dA &d@  update the cumulative distance increment flag for this part 
&dA &d@    and set marr(marc,TIME_NUM); also check to see accumulation is correct.  New &dA05/25/03

              cdincf(f12) += ndincf(f12) 
              if t6 = 0 
                t6 = cdincf(f12) 
                marr(marc,TIME_NUM) = t6 - oldcdincf            /* New &dA05/25/03
                oldcdincf = t6 
              else 
                if t6 <> cdincf(f12) 
                  if (Debugg & 0x01) > 0 
                    pute Error: Problem in accumulation of durations 
                    pute Suspected location: part ~f12   measure ~marc  in this system
                    pute or possibly bar ~barnum  in the music.  
                    pute 
                  end 
                  tmess = 40 
                  perform dtalk (tmess) 
                end 
              end 
CT: 
              perform save3               /* oby not used here 
              ++rec 
              if line{1} = "J" 
                if f11 = 1 and jtype = "S" and ntype >= 4 
                  if ntype = 4 
                    marr(marc,MARR_TEMP) = 1           /* multiple rest flag
                  end 
                else 
                  if "TCGMSD" con jtype 
                    goto CT 
                  end 
                end 
&dA 
&dA &d@  if part with min ndincf is also current, compute controlling space  
&dA 
                if f12 = t5 
                  t7 = dvar1 - olddv1(f12) 
                end 
                olddv1(f12) = dvar1 
                t9 = dvar1 - olddist(f12) 
&dA 
&dA &d@    /* Code added &dA02/25/97&d@.  I think this is where we must correct for 
&dA &d@         for extra distance put in by AUTOSET but not used.  
&dA 
                if snode = 1 and conttie(f12) = 0 
                  trec = rec 
                  t2 = 0 - f(f12,14)      /* t2 = -notesize 
CTa: 
                  tget [Z,trec] temp4 .t3 t1 
                  if "TKkWC" con temp4{1}         /* "C" added &dA12/18/10&d@ 
                    if temp4{1} = "k" and t2 > t1 
                      t2 = t1 
                    end 
                    ++trec 
                    goto CTa 
                  end 
                  t2 += f(f12,14)      /* t2 is possibly negative 
                  t9 += t2             /* remove this "dead" space 
                end 
&dA 
&dA &d@    End of &dA02/25/97&d@ addition.  Let's hope it works!  
&dA 
&dA &d@      t9  could possibly be too small, or negative, if the node is  
&dA &d@      syncopated.  We won't be able to compute this until this  
&dA &d@      loop is finished  
&dA 
                if "CKTDBSFIM" con jtype    /* only K,B,F and I are left, actually
                  if mpt < 5 
                    ntype = 13 + mpt 
                  else 
                    ntype = 17 
                  end 
                end 
                if ntype < marr(marc,MNODE_TYPE) 
                  if marr(marc,MNODE_TYPE) = 18 
                    if (Debugg & 0x01) > 0 
                      pute Error: Non-controlling bar line error at ~barnum 
                    end 
                    tmess = 41 
                    perform dtalk (tmess) 
                  end 
                  marr(marc,MNODE_TYPE) = ntype 
                  if f11 = 1 
&dA 
&dA &d@   Code modification &dA02/09/07&d@:  0 will be "sticky" 
&dA 
                    if ntype = 9 and cflag = 1 
                      marr(marc,MARR_TEMP) = 2 
                    else 
                      marr(marc,MARR_TEMP) = 0 
                    end 
&dA 
&dA                              

                  end 
                end 
                if t9 > marr(marc,PRE_DIST) 
                  marr(marc,PRE_DIST) = t9 
                end 
                ++t11 
                tdist(t11,1) = f12 
                tdist(t11,2) = dvar1 
&dA 
&dA &d@   If this node is not a non-controlling bar line (ntype = 18), we  
&dA &d@   must look further in this file for additional proper objects 
&dA &d@   (notes, figures, rests, cues) on this node.  The purpose is to 
&dA &d@   find the smallest ntype.  We must also advance f(f12,6) to the first 
&dA &d@   record beyond the last object in the node.  rec will also point  
&dA &d@   beyond the last object in the node and at or before the next object  
&dA &d@   beyond the node  
&dA 
                f(f12,6) = rec 
                if ntype <> 18 
CR2: 
                  perform save3         /* oby not used here 
                  if line{1} <> "J" 
                    ++rec 
                    goto CR2 
                  end 
                  if snode = marr(marc,SNODE)               /* New &dA05/25/03&d@ 
                    if "CKTDBSFIM" con jtype 
                      if mpt < 5 
                        ntype = 13 + mpt 
                      else 
                        ntype = 17 
                      end 
                    end 
                    if ntype < marr(marc,MNODE_TYPE)        /* New &dA05/25/03&d@ 
                      marr(marc,MNODE_TYPE) = ntype         /*  "      " 
&dA         
&dA 
&dA &d@   Code modification &dA02/09/07&d@:  Be sure to set (marc,MARR_TEMP) 
&dA &d@                                to 0, if this is a regular node 
&dA 
                      if f11 = 1 
                        if ntype = 9 and cflag = 1 
                        else 
                          marr(marc,MARR_TEMP) = 0 
                        end 
                      end 
&dA 
&dA         &d@ End of modification 

                    end 
                    ++rec 
                    f(f12,6) = rec 
                    goto CR2 
                  end 
                end 
                goto CS 
              else 
                if line{1} = " " 
                  line = trm(line) 
                  if line = "" 
                    if (Debugg & 0x01) > 0 
                      pute A search for Bar line was unsuccessful in part ~f12 .
                      pute Measure number = ~barnum .  Try checking durations, especially
                      pute those used in "back" records.  
                    end 
                    tmess = 42 
                    perform dtalk (tmess) 
                  end 
                end 
              end 
              goto CT 
            end 
&dA 
&dA &d@   We must also determine the new values for ndincf(.) for notes  
&dA &d@   in this node (for all active parts, if first pass (t13 = 0)).  
&dA 
CS: 
            if tarr(f12) = 0 
              if t13 = 1 
                if tarr2(f12) = 0 
                  goto CS2 
                end 
              else 
                t13 = 1 
              end 
CR3: 
              perform save3               /* oby not used here 
              ++rec 
              if line{1} = "J" 
                ndincf(f12) = dincf 
              else 
                goto CR3 
              end 
            end 
CS2: 
          repeat 
&dA 
&dA &d@    Code added &dA02/09/07&d@:  If marr(marc,MARR_TEMP) is unset, set it to 0 
&dA 
          if marr(marc,MARR_TEMP) = 3 
            marr(marc,MARR_TEMP) = 0 
          end 

&dA 
&dA &d@   Before going on to the next node, we must: 
&dA 
&dA &d@     1) Compute node flag(s) and determine if this node is 
&dA &d@          syncopated or not.  
&dA 
          t1 = 0x80000000 
          t2 = 0 
          loop for f12 = 1 to f11 
            if tarr2(f12) = 1 
              t2 |= t1 
            end 
            t1 >>= 1 
          repeat 
          t11 = 0 
          if t2 & nflg1 = 0 
            t11 = 1 
          end 
          nflg1 = t2 
&dA 
&dA &d@     2) If syncopated node, compute minimum value for marr(marc,PRE_DIST). 
&dA &d@          Minimum distance is determined by algorithm described   
&dA &d@          earlier.  Also the type for the previous node needs to be   
&dA &d@          recomputed, based on the elapsed duration.  If this duration  
&dA &d@          is 576 multiplied or divided by a power of 2, then the  
&dA &d@          newtype will be the type of the duration + 20.  Otherwise 
&dA &d@          the type will be 40.  
&dA 
          if t11 = 1 
&dA 
&dA &d@   t4 is controlling duration 
&dA &d@   t5 is part with controlling duration 
&dA &d@   if t7 > 0, t7 is controlling space; otherwise, compute it now  
&dA 
            if t7 = 0 
              rec = f(t5,6) 
DS: 
              perform save3               /* oby not used here 
              ++rec 
              if line{1} = "J" 
                if "CGMS" con jtype 
                  goto DS 
                end 
                t7 = dvar1 - olddv1(t5) 
              else 
                goto DS 
              end 
            end 
&dA 
&dA &d@   t7 is controlling space    
&dA 
            t7 = t7 * marr(marc,TIME_NUM) / t4 
            if marr(marc,PRE_DIST) < t7 
              marr(marc,PRE_DIST) = t7 
            end 
*   compute new ntype 
            t5 = t4 / 9 
            if rem = 0 
              loop for t3 = 1 to 11 
                t5 >>= 1 
              repeat while t5 > 0 
              marr(marc-1,MNODE_TYPE) = t3 + 20 
            else 
              marr(marc-1,MNODE_TYPE) = 40 
            end 
          end 
&dA 
&dA &d@     3) Adjust olddist(.) for parts where f(f12,10) = 0 
&dA 
          perform adjolddist 
&dA 
&dA &d@     4) Increment ldist 
&dA 
          ldist += marr(marc,PRE_DIST) 
&dA 
&dA &d@  Proceed to next node (&dEEnd of tricky loop&d@) 
&dA 
        repeat 
&dA 
&dA &d@  Decrease multiple rest counters; save f(.,10) in case ldist > rmarg 
&dA 
CCV: 
        loop for f12 = 1 to f11 
          tarr3(f12) = f(f12,10) 
          if f(f12,10) > 0 
            --f(f12,10) 
          end 
        repeat 
&dA 
&dA &d@  Now is the time to deal with nodes with snode = 6913.  This includes  
&dA &d@  types G,S,M,C,D,B,K,T (not N,R,Q,F,I).  The first proper object-node  
&dA &d@  will always be a type B (bar line).  Types B,K,T will generate proper 
&dA &d@  object-nodes.  Type C will generate a proper node if it follows 
&dA &d@  the bar line. 
&dA 
&dA &d@   Look at bar 
&dA 
        ++marc 
        marr(marc,PRE_DIST)    = 0 
        marr(marc,MNODE_TYPE)  = 18 
        marr(marc,SNODE)       = 6913 
        marr(marc,ACT_FLAG)    = 0xffffffff 
        marr(marc,M_ADJ)       = adj_space 
        marr(marc,MARR_TEMP)   = 0 

&dA 
&dA &d@     I think this is the point where we need to set a new value for adj_space.
&dA &d@     Basically, the normal condition is for adj_space = YES; but if a terminating
&dA &d@     barline object in one of the active parts has a print suggestion that 
&dA &d@     indicates that the next measure must not have its spaces altered in the
&dA &d@     line adjustment process, then the adj_space flag must be set to NO.  
&dA 
        adj_space = YES 
        t6 = 0 
        loop for f12 = 1 to f11 
          notesize = f(f12,14) 
          if f(f12,10) = 0 
            if ndincf(f12) > 0 
              cdincf(f12) += ndincf(f12) 
              if t6 = 0 
                t6 = cdincf(f12) 
                marr(marc,TIME_NUM) = t6 - oldcdincf 
              else 
                if t6 <> cdincf(f12) 
                  if (Debugg & 0x01) > 0 
                    pute Error: Problem in accumulation at bar line ~barnum 
                  end 
                  tmess = 43 
                  perform dtalk (tmess) 
                end 
              end 
            end 
            rec = f(f12,6) 
DT1:        perform save3 
            ++rec 
            if line{1,3} = "J B" 
              t9 = dvar1 - olddist(f12) 
              if t9 > marr(marc,PRE_DIST) 
                marr(marc,PRE_DIST) = t9 
              end 
              olddist(f12) = dvar1 
              f(f12,6) = rec 

              if oby >= 1000000 
                t1 = oby / 1000000 
                if t1 = 1 or t1 = 3 
                  adj_space = NO 
                end 
                if t1 = 10 
                  sys_jflag = barcount + 1 
                end 
              end 

            else 
              goto DT1 
            end 
          end 
        repeat 
&dA 
&dA &d@   Adjust distances 
&dA 
        loop for f12 = 1 to f11 
          if f(f12,10) > 0 
            olddist(f12) += marr(marc,PRE_DIST) 
          end 
        repeat 
        ldist += marr(marc,PRE_DIST) 
&dA 
&dA &d@   Look for clef, key, time signature in 6913 type node 
&dA 
        perform setckt 
&dA 
&dA &d@   Check length, branch back, or proceed  
&dA 
        ++mcnt 
        mspace(mcnt) = ldist 
        if ldist > false_rmarg 
          goto CK 
        end 
&dA 
&dA &d@   Transfer marr to larr  
&dA 

&dA                                                         
&dA 
&dA &d@     New code added &dA10/31/08&d@ to deal with an obscure situation that 
&dA &d@     arrises from the new feature (for parts) that allows multiple rests 
&dA &d@     to be broken into smaller units.  A multiple rest generates a single 
&dA &d@     marr(.,.) entry (a bar line with 0 space), which under normal 
&dA &d@     conditions is transferred to larr(.,.).  And normally there would be 
&dA &d@     real musical notes following this barline.  However, when a multiple 
&dA &d@     rest is broken into smaller units, a second 0 space barline follows 
&dA &d@     the first.  This creates a problem later in the code because this 
&dA &d@     extra bar is "double counted," i.e., it is counted as part of the 
&dA &d@     multiple rest (handled one way), and as a measure with musical 
&dA &d@     notes (handled another way).  Put another way, the larr(.,.) array 
&dA &d@     has too many bar lines in it, so the data in the last measure is 
&dA &d@     not processed, causing a misalignment of pointers.  
&dA 
&dA &d@     The "fix" used here is to skip the tranfer of marr(.,.) to larr(.,.) 
&dA &d@     when marc = 1, and the space parameter of the previous larr(.,.) 
&dA &d@     entry is 0 (as it is for the last bar of a multiple rest).  I 
&dA &d@     have not checked to see if there are other situations which 
&dA &d@     produce this condition -- a possible new problem.  
&dA 

        if marc = 1 and larc > 0 and larr(larc,1) = 0 and larr(larc,2) = 18 
          goto NO_TRANS 
        end 
&dA 
&dA                                                         

        loop for t9 = 1 to marc 
          ++larc 
          loop for t10 = 1 to MARR_PARS 
            larr(larc,t10) = marr(t9,t10) 
          repeat 
        repeat 
&dA 
&dA &d@   Adjust delta and counters  
&dA 

NO_TRANS:                                /* New label &dA10/13/08&d@ 

        delta = rmarg - ldist 

        ++barcount 
        ++barnum 
*  a1 is set earlier; normal case, a1 = 0, for end of G.P. a1 = hxpar(6) 
        rflag(barcount) = a1 
        loop for f12 = 1 to f11 
          if delta = 0 
            bolddist(f12) = olddist(f12) 
            f(f12,5) = f(f12,6) 
          end 
          if stopflag = 1 
            bolddist(f12) = olddist(f12) 
            f(f12,5) = f(f12,6) 
          end 
        repeat 
        if delta = 0 
          if justflag > 0 
            ++syscnt 
            sysbarpar(syscnt,1) = barcount 
            sysbarpar(syscnt,2) = 0 
            sysbarpar(syscnt,5) = sys_jflag 
          end 
          goto CG 
        end 

        if sysbarpar(syscnt+1,3) = barcount and barcount > 0 
          loop for f12 = 1 to f11 
            bolddist(f12) = olddist(f12) 
            f(f12,5) = f(f12,6) 
          repeat 
          goto CE 
        end 

        if stopflag = 1 
          goto CCE 
        end 
        marc = 0 
        goto CF 
&dA 
&dA &d@   This is where the program jumps back to get another measure 
&dA 
&dA                                                                  

&dA                                                                  
&dA 
&dA &d@   At this point, we have added too much music to a line (ldist > false_rmarg)
&dA 
&dA &d@   Provisional transfer of marr to larr (to text "squeezing") 
&dA 
CK: 
        larc2 = larc 
        loop for t9 = 1 to marc 
          ++larc2 
          loop for t10 = 1 to MARR_PARS 
            larr(larc2,t10) = marr(t9,t10) 
          repeat 
        repeat 

&dA 
&dA &d@  III. Compute new distances  
&dA 
&dA &d@    Compute new distances for object nodes on a line.  This 
&dA &d@    is where we determine how to right justify the line.  It 
&dA &d@    is also where we decide whether or not to "squeeze" 
&dA &d@    an extra measure onto the line or not.  
&dA 
&dA &d@    larc = number of object-nodes on the line   
&dA &d@    larc2 = number of object-nodes on extended line   
&dA 
&dA &d@   A. General calculations:  Identify shortest duration in       
&dA &d@        extended line and determine quantity and location        
&dA &d@        of smallest distances                                    
&dA 
&dA &d@      First, we need to know how many barlines are in this line 
&dA &d@        of music.  Specifically, if there is only one, then we 
&dA &d@        must allow space modifications irrespective of whether 
&dA &d@        a print suggestion asked that there be none.  
&dA 
        c2 = 0 
        single_meas = NO 
        loop for c1 = 1 to larc2 
          if larr(c1,MNODE_TYPE) = 18 
            ++c2 
          end 
        repeat 
        if c2 = 1 
          single_meas = YES 
        end 

        a1 = larc2 
        a2 = 0 
        perform getsmall (t5,t11,delta_e,mdf) 

        if single_meas = NO 
          loop for c1 = 1 to scnt2 
            small(c1) = small2(c1) 
          repeat 
          scnt = scnt2 
        end 
&dA 
&dA &d@   B. If there is no text, determine shortest adjustable distance         
&dA &d@        between notes and the number of notes that have this distance.    
&dA &d@        If an additional measure can be accommodated by decreasing        
&dA &d@        this distance by x%, then this should be done.                    
&dA 
        if textflag = 0 
*  scnt = number of notes with smallest distance   

          t2 = t5 * scnt / 15       /* allows for about 6.6% compression 
          t3 = ldist - rmarg 
          if t3 <= t2 and t3 > 0 
            savet3 = t3 
&dA 
&dA &d@      &dETry&d@ to accommodate additional measure by compressing shortest notes 
&dA 
            ++barcount 
            rflag(barcount) = 0 
            larc = larc2 
            loop for f12 = 1 to f11 
              bolddist(f12) = olddist(f12) 
              f(f12,5) = f(f12,6) 
            repeat 
&dA 
&dA &d@  small(.) contains the node numbers where the distance may be decreased 
&dA &d@  scnt = number of candidate nodes 
&dA &d@  t5 = shortest distance 
&dA &d@  t1 = alternation flag for deleting space in type-40 syncopated pairs 
&dA &d@  t2 = distance subtraction flag 
&dA &d@  t3 = distance to subtract 
&dA 
            t1 = 0 
            t2 = 0 
            loop 
              t10 = 1 
              loop for t9 = 2 to larc 
                if t9 = small(t10) 
                  if t10 < scnt 
                    ++t10 
                  end 
                  if larr(t9-1,MNODE_TYPE) < 40 
                    if larr(t9,PRE_DIST) > t5 
                      t2 = 1 
                    else 
                      goto CPB 
                    end 
                    --larr(t9,PRE_DIST) 
                  else 
                    if t2 = 0 
                      goto CPB 
                    end 
                    if t1 = 0 
                      --larr(t9,PRE_DIST) 
                    else 
                      --larr(t9-1,PRE_DIST) 
                    end 
                  end 
                  --t3 
                  if t3 = 0                       /* Success!  Go lay out music at CG
                    if justflag > 0 
                      ++syscnt 
                      sysbarpar(syscnt,1) = barcount 
                      sysbarpar(syscnt,2) = 0 - savet3 
                      sysbarpar(syscnt,5) = sys_jflag 
                    end 
                    goto CG 
                  end 
                end 
CPB:          repeat 
              if t1 = 0 
                t1 = 1 
              else 
                t1 = 0 
              end 
              if t2 = 0 
                --t5 
                t2 = 1 
              else 
                t2 = 0 
              end 
            repeat 
          end 
        end 
&dA 
&dA &d@     Since the effort to squeeze an extra measure onto a line has 
&dA &d@     failed at this point, we must restore the earlier values of 
&dA &d@     f(.,10), which were advanced when we added the bar line to 
&dA &d@     the last (prospective) measure.  
&dA 
CCE: 
        loop for f12 = 1 to f11 
          f(f12,10) = tarr3(f12) 
        repeat 

        --mcnt              /* delete length from list 

&dA 
&dA &d@   If f2 = 1, then we tried unsuccessfully to add an extra measure  
&dA &d@        of general rest.  We must now add a larr entry for the  
&dA &d@        terminating bar line  
&dA 
        if f2 = 1 
          ++larc 
          larr(larc,MNODE_TYPE)  = 18                 /* New &dA05/25/03&d@ 
          larr(larc,ACT_FLAG)    = 0xffffffff         /*  "     " 
          larr(larc,M_ADJ)       = adj_space          /*  "     " 
        end 

&dA &d@  
&dA &d@   C. Assign delta (extra space) to various nodes within line.    
&dA &d@                                                                  
&dA &d@      a. Try to assign delta to multiple measure rests or whole   
&dA &d@           measure rests                                          
&dA &d@  
CE: 
        if justflag > 0 
          ++syscnt 
          sysbarpar(syscnt,1) = barcount 
          sysbarpar(syscnt,2) = delta 
          sysbarpar(syscnt,5) = sys_jflag 
        end 
&dA 
&dA &d@   Look for multiple measure rests 
&dA 
        if f11 = 1 
          t12 = 0 
          loop for c1 = 1 to larc 
            if larr(c1,MARR_TEMP) = 1 
              ++t12 
            end 
          repeat 
          if t12 > 0 
            t1 = delta / t12 + 1 
            if t1 <= MAGIC1 
              loop for c1 = 1 to larc 
                if larr(c1,MARR_TEMP) = 1 
                  if t1 > delta 
                    t1 = delta 
                  end 
                  larr(c1,PRE_DIST) += t1 
                  delta -= t1 
                end 
              repeat 
              goto CG 
            else 
              t1 = MAGIC1 
              if t1 > delta                 /* should never happen, but just to be safe
                t1 = delta 
              end 
              loop for c1 = 1 to larc 
                if larr(c1,MARR_TEMP) = 1 
                  larr(c1,PRE_DIST) += t1 
                  delta -= t1 
                end 
              repeat 
            end 
          end 
        end 
&dA 
&dA &d@   Look for single measure rests 
&dA 
        if f11 = 1 
          t12 = 0 
          loop for c1 = 1 to larc 
            if larr(c1,MARR_TEMP) = 2 
              ++t12 
            end 
          repeat 
          if t12 > 0 
            t1 = delta / t12 + 1 
            t2 = hxpar(6) * 4 / barcount 
            if t1 > t2 
              t1 = t2 
            end 
            loop for c1 = 1 to larc 
              if larr(c1,MARR_TEMP) = 2 
                if t1 > delta 
                  t1 = delta 
                end 
                larr(c1,PRE_DIST) += t1 
                delta -= t1 
                if delta = 0 
                  goto CG 
                end 
              end 
            repeat 
          end 
        end 

        t12 = 0 
        loop for t10 = 1 to barcount 
          if rflag(t10) > 0 
            ++t12 
          end 
        repeat 
        if t12 > 0 
          t1 = delta / t12 + 1 
          t2 = hxpar(6) * 2 / barcount 
          if t1 > t2 
            t1 = t2 
          end 
          loop for t10 = 1 to barcount 
            if rflag(t10) > 0 
              if t1 > delta 
                t1 = delta 
              end 
              rflag(t10) += t1 
              delta -= t1 
              if delta = 0 
                goto CG 
              end 
            end 
          repeat 
        end 
&dA &d@                                                             
&dA &d@      b. Try to assign delta to notes larger than smallest   
&dA 
&dA &d@    1. construct adjarr, compute maximum possible adjustment  
&dA 
&dA &d@    We need to know how many barlines are in this line of music.  
&dA &d@    Specifically, if there is only one, then we must allow space 
&dA &d@    modifications irrespective of whether a print suggestion asked 
&dA &d@    that there be none.  
&dA 
        c2 = 0 
        single_meas = NO 
        loop for c1 = 1 to larc 
          if larr(c1,MNODE_TYPE) = 18 
            ++c2 
          end 
        repeat 
        if c2 = 1 
          single_meas = YES 
        end 

        a1 = larc 
        a2 = 1 
        perform getsmall (t5,t11,delta_e,mdf) 

        if single_meas = NO 
          loop for c1 = 1 to scnt2 
            small(c1) = small2(c1) 
          repeat 
          scnt = scnt2 
        end 
&dA 
&dA &d@  t11 = ntype for shortest node on line 
&dA &d@  t5  = smallest standard internode distance 
&dA 
&dA &d@    Smallest standard internode distance is sometimes not relevent, especially
&dA &d@    in the case where there is text underlay.  Let us also look at the median 
&dA &d@    of the distances for the shortest node on the line 
&dA 
        t10 = 0 
        loop for t9 = 1 to larc - 1 
          if larr(t9,MNODE_TYPE) = t11 
            ++t10 
            adjarr(t10,1) = larr(t9+1,PRE_DIST) 
          end 
        repeat 
        a1 = t10 
        loop for t9 = 1 to a1 - 1 
          loop for t10 = t9 + 1 to a1 
            if adjarr(t9,1) < adjarr(t10,1) 
              t3 = adjarr(t9,1) 
              adjarr(t9,1) = adjarr(t10,1) 
              adjarr(t10,1) = t3 
            end 
          repeat 
        repeat 
        a1 = a1 + 1 >> 1 
        t7 = adjarr(a1,1) 
        if t7 > (t5 * 5 / 4) 
          t5 = t7 
        end 

        adjarc = 0 
        if t11 > 6 
          t1 = t11 + 1 
        else 
          t1 = t11 
        end 

        loop for t9 = 2 to larc 
          if larr(t9,MNODE_TYPE) = 18 and larr(t9-1,MNODE_TYPE) < t1 
            goto CD 
          end 
          if larr(t9,TIME_NUM) > 0 
            dv3 = larr(t9,TIME_NUM) * 10 / mdf 
            if dv3 > 10 
&dA 
&dA &d@     Code modification &dA12/11/03&d@ 
&dA 
&dA &d@     Note &dA04/12/10&d@ The code below is ridiculous and absurd and is 
&dA &d@       being replaced by some "magic" numbers that do the same thing.  
&dA 
&dK &d@             rx = flt(dv3) 
&dK &d@             rx = rx / 10.0 
&dK &d@             ry = lnx(rx) / lnx(2.0) 
&dK &d@             rz = pow(1.5,ry) 
&dK &d@             rz *= 10.0 
&dK &d@             dv3 = fix(rz) 

              if dv3 < 80 
                c18 = dv3 - 10 + 1 
                c19 = ors("AABBCCDDEEFFFGGHHHIIJJJKKKLLLMMMNNNOOOPPPPQQQRRRRSSSTTTTUUUUVVVVWWWWXX"{c18}) - 55
              else 
                if dv3 < 515 
                  c18 = dv3 - 75 / 10 + 1 
                  c19 = ors("!$&(*,.024679;<>@ACDFGIJKMNPQRSUVWYZ[\]_`abc"{c18})
                else 
                  c19 = dv3 - 515 / 10 + 100 
                end 
              end 
              dv3 = c19 
&dA      

              t3 = dv3 * t5 / 10                 /* maximum final distance 
&dA 
&dA &d@   Case: node is preceded by adjustable distance (larr(i,TIME_NUM) > 0);      
&dA &d@         duration preceding node (larr(i,TIME_NUM)) is greater than min. dur. 
&dA &d@         t3 = amount by which duration may be increased  
&dA 
              if t3 > 0 
                if larr(t9,M_ADJ) = YES 
                  ++adjarc 
                  adjarr(adjarc,1) = t9 
                  adjarr(adjarc,2) = t3 
                  adjarr(adjarc,3) = 0 
                end 
              end 
            end 
          end 
CD: 
        repeat 
&dA 
&dA &d@    2. compute adjarr(.,3) = current largest distance for nodes similar to this one.
&dA 
&dA &d@    First, determine maximum PRE_DIST for each TIME_NUM 
&dA 
        t4 = 0 
        loop for t9 = 1 to adjarc 
          t1 = adjarr(t9,1) 
          t2 = larr(t1,PRE_DIST) 
          t3 = larr(t1,TIME_NUM) 
          t10 = 0 
          if t4 > 0 
            loop for t10 = 1 to t4 
              if tarr5(t10,1) = t3 
                if tarr5(t10,2) < t2 
                  tarr5(t10,2) = t2 
                end 
                t10 = 1000 
              end 
            repeat 
          end 
          if t10 < 1000 
            ++t4 
            tarr5(t4,1) = t3 
            tarr5(t4,2) = t2 
          end 
        repeat 
&dA 
&dA &d@    Second, sort by increasing TIME_NUM, smallest first 
&dA 
        loop for t9 = 1 to t4 - 1 
          loop for t10 = t9 + 1 to t4 
            if tarr5(t9,1) > tarr5(t10,1) 
              t3 = tarr5(t9,1) 
              tarr5(t9,1) = tarr5(t10,1) 
              tarr5(t10,1) = t3 
              t3 = tarr5(t9,2) 
              tarr5(t9,2) = tarr5(t10,2) 
              tarr5(t10,2) = t3 
            end 
          repeat 
        repeat 
&dA 
&dA &d@    Third, make sure that increasing TIME_NUM has increasing distance 
&dA 
        loop for t9 = 1 to t4 - 1 
          t1 = tarr5(t9,2) * 5 / 4 
          if tarr5(t9+1,2) < t1 
            tarr5(t9+1,2) = t1 
          end 
        repeat 
&dA 
&dA &d@    Fourth, assign the various maximums to their respective adjarr(.,3) 
&dA 
        loop for t9 = 1 to adjarc 
          t1 = adjarr(t9,1) 
          t2 = larr(t1,TIME_NUM) 
&dA 
&dA &d@   &dA07/14/04&d@  The code below appears to contain a minor bug.  It appears to be
&dA &d@             possible for tarr5(.,2) = 0, in which case, adjarr(.,3) should also
&dA &d@             be zero.  I think the purpose of the test condition below the loop 
&dA &d@             is to flag the case where &dEno match&d@ was found in the loop, in which
&dA &d@             case adjarr(.,3) would also be zero.  We need to have another way
&dA &d@             to flag this condition.  
&dA 
          t12 = 0                              /* new test flag 
          loop for t10 = 1 to t4 
            if tarr5(t10,1) = t2 
              adjarr(t9,3) = tarr5(t10,2) 
              t12 = 1 
            end 
          repeat 

&dA     &d@ End of &dA07/14/04&d@ code change 

        repeat 

&dA                                                    
&dA 
&dA &d@     &dA11/06/08&d@  There is a corner case I don't understand yet.  It can result 
&dA &d@               in delta being 0 at this point, which leads to code failure.
&dA &d@               To avoid this, I include the following code.  The problem 
&dA &d@               of the corner case still exists, however.  
&dA 
        if delta = 0 
          goto CG 
        end 
&dA 
&dA                                                    


        t12 = 0 
        loop for t9 = 1 to adjarc 
          t1 = adjarr(t9,1)                        /* larr index for t9-th adjarr element
          t12 += (adjarr(t9,3) - larr(t1,PRE_DIST)) 
        repeat 
&dA &d@            
&dA &d@    3. determine adjarr(.,4) = distances to add to bring all nodes 
&dA &d@                                 up to the "largest in class" 
&dA 
        if t12 < delta 
          t12 = delta 
        end 
        t7 = delta 
        loop for t9 = 1 to adjarc 
          t1 = adjarr(t9,1)                        /* larr index for t9-th adjarr element
          dvar1 = (adjarr(t9,3) - larr(t1,PRE_DIST)) * t7 / t12 
          adjarr(t9,4) = dvar1 
          delta -= dvar1 
        repeat 
        loop for t9 = 1 to adjarc 
          if delta = 0 
            t9 = adjarc 
          else 
            ++adjarr(t9,4) 
            --delta 
          end 
        repeat 
&dA &d@            
&dA &d@    4. if delta is still > 0, try increasing adjarr(.,4) up to allowed maximum
&dA 
        if delta > 0 
          t12 = 0 
          loop for t9 = 1 to adjarc 
            t1 = adjarr(t9,1)                        /* larr index for t9-th adjarr element
            t2 = (adjarr(t9,2) - larr(t1,PRE_DIST) - adjarr(t9,4)) 
            if t2 > 0 
              t12 += t2 
            end 
          repeat 

          if t12 < delta 
            t12 = delta 
          end 
          t7 = delta 
          loop for t9 = 1 to adjarc 
            t1 = adjarr(t9,1)                        /* larr index for t9-th adjarr element
            t2 = (adjarr(t9,2) - larr(t1,PRE_DIST) - adjarr(t9,4)) 
            if t2 > 0 
              dvar1 = t2 * t7 / t12 
              adjarr(t9,4) += dvar1 
              delta -= dvar1 
            end 
          repeat 
          loop for t9 = 1 to adjarc 
            if delta = 0 
              t9 = adjarc 
            else 
              ++adjarr(t9,4) 
              --delta 
            end 
          repeat 
        end 
&dA 
&dA &d@    5. add distance   
&dA 
        loop for t9 = 1 to adjarc 
          t7 = adjarr(t9,1) 
          larr(t7,PRE_DIST) += adjarr(t9,4)             /* New &dA12/11/03&d@ 
        repeat 
        if delta = 0 
          goto CG 
        end 

&dA &d@                                                         
&dA &d@      c. Assign distance to smallest notes               
&dA &d@   
&dA &d@       small(.) = node numbers where distance can be added 
&dA &d@       scnt = number of such nodes 
&dA &d@       t1 = alternation flag for incerting space in type 40 syncopated nodes
&dA &d@       t2 = addition flag 
&dA &d@       t5 = smallest internote distance 
&dA &d@       delta_e = difference between smallest distance and next smallest distance
&dA &d@       delta = distance to subtract 
&dA 
        t1 = 0 
        t2 = 0 
        t12 = delta_e + 1 / 2                           /* New &dA10/14/07&d@ 
        if t12 < 3 
          t12 = 3 
        end 

        if scnt > 0 
          loop for t7 = 1 to t12          /* Limit to loop is new &dA10/14/07&d@ 
            t10 = 1 
            loop for t9 = 2 to larc 
              if t9 = small(t10) 
                if t10 < scnt 
                  ++t10 
                end 
                if larr(t9-1,MNODE_TYPE) < 40            /* New &dA05/25/03&d@ 
                  if larr(t9,PRE_DIST) > t5              /*  "     " 
                    goto CPE 
                  else 
                    t2 = 1 
                  end 
                  ++larr(t9,PRE_DIST)                    /* New &dA05/25/03&d@ 
                else 
                  if t2 = 0 
                    goto CPE 
                  end 
                  if t1 = 0 
                    ++larr(t9,PRE_DIST)                  /* New &dA05/25/03&d@ 
                  else 
                    ++larr(t9-1,PRE_DIST)                /* New &dA05/25/03&d@ 
                  end 
                end 
                --delta 
                if delta = 0 
                  goto CG 
                end 
              end 
CPE:        repeat 
            if t1 = 0 
              t1 = 1 
            else 
              t1 = 0 
            end 
            if t2 = 0 
              t2 = 1 
              ++t5 
            else 
              t2 = 0 
            end 
          repeat 
        end 
&dA &d@                                                        
&dA &d@      d. Assign remaining distance wherever you can     
&dA 
        loop 
          loop for t9 = 2 to larc 
            if larr(t9,TIME_NUM) > 0                   /* New &dA05/25/03&d@ 
              ++larr(t9,PRE_DIST)                      /*  "     " 
              --delta 
              if delta = 0 
                goto CG 
              end 
            end 
          repeat 
        repeat 

&dA 
&dA &d@ &dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dA &d@ &dE³                                                            ³&d@ 
&dA &d@ &dE³ Distances are computed.  Now it is time to read the        ³&d@ 
&dA &d@ &dE³ file the second time and typeset the music                 ³&d@ 
&dA &d@ &dE³                                                            ³&d@ 
&dA &d@ &dE³               PRINT OUT THE MUSIC                          ³&d@ 
&dA &d@ &dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 
&dA 
&dA &d@   Compute offsets for bar lines and values of larc for bar lines 
&dA 
&dA &d@         barcount = number of bars in a line  
&dA &d@         barpar(.,1) = horizontal length of measure 
&dA &d@         barpar(.,2) = value of larc2 for bar-node at end of measure  
&dA &d@         barpar(.,3) = bar type (ntype) at end of measure 
&dA 
&dA &d@     &dA12/17/03&d@ 
&dA 
&dA &d@     At this point, the larr(larc,.) array is fixed and ready for 
&dA &d@     use.  
&dA 
&dA &d@     New &dA11/02/07&d@.  We need to correct a "corner" case here.  When the last item
&dA &d@       object in a line is a key change or a time change, the program places this
&dA &d@       beyond the end of the line.  I'm not sure why this happens, and it would be
&dA &d@       complicated to try to fix.  But there is an easy solution here.  Simply 
&dA &d@       figure out the space needed, and subtract it from the various larr nodes.
&dA &d@       While we are at it, the distance between the last bar line and the time
&dA &d@       change is sometimes excessive.  So let's set this to the standard distance
&dA &d@       as well.  Keep an eye on this change, however; there may be exceptions to
&dA &d@       this fix.  
&dA 
CG: 
        t10 = 0 
        loop for t9 = 1 to larc 
          t10 += larr(t9,PRE_DIST) 
        repeat 
        if chr(larr(larc,MNODE_TYPE)) in [14..16] 
          t9 = rmarg - false_rmarg 
          if larr(larc,MNODE_TYPE) = 15 
            t9 -= (hxpar(5) / 2) 
          end 
          if larr(larc,MNODE_TYPE) = 16 
            t9 -= (hxpar(13) / 2) 
          end 
          if larr(larc,PRE_DIST) > hxpar(7) and larr(larc-1,MNODE_TYPE) = 18
            t6 = larr(larc,PRE_DIST) - hxpar(7) 
            if t6 > t9 
              t6 = t9 
            end 
            larr(larc,PRE_DIST) -= t6 
            t9 -= t6 
          end 

          t6 = t9 
          t3 = 7 
          loop 
            loop for t7 = 2 to larc 
              t11 = larr(t7,PRE_DIST) * t9 * 10 / t10 
              if t11 < 10 and t11 > t3 
                t11 = 10 
              end 
              t11 /= 10 
              if rem > 5 
                ++t11 
              end 
              larr(t7,PRE_DIST) -= t11 
              t6 -= t11 
              if t6 <= 0 
                goto END_CORRECT 
              end 
            repeat 
            --t3 
          repeat 
        end 
END_CORRECT: 
&dA 
&dA &d@     &dA12/17/03&d@ 
&dA 
&dA &d@     At this point, the cumulative larr array can be initialized.  
&dA &d@              
        if endflag = 1 and justflag <> 1 
          c4 = ldist - sp - pdist 
        else 
          c4 = syslen - pdist 
        end 

        mspace(mcnt) += deadspace * 100000 

        if endflag = 1 and justflag <> 1 
          t9 = ldist - sp 
        else 
          t9 = syslen 
        end 
        if justflag < 2 
          sv_mainyp = mainyp 
          ++mainyp 
          y1p = mainyp 
          tput [Y,mainyp] S 0 ~sp  ~sysy  ~t9  ~sysh  ~f11  "~syscode " 
        end 

        loop for t9 = 1 to barcount 
          barpar(t9,3) = 0 
        repeat 
&dA 
&dA &d@   First handle special case of entire system of rests 
&dA 
        if larc = 0 
          loop for t9 = 1 to barcount 
            barpar(t9,1) = rflag(t9) 
            barpar(t9,2) = 1 
          repeat 
          goto CG2 
        end 
&dA 
&dA &d@   Normal case: notes in at least one part in system 
&dA 
        larc2 = 1 
        t4 = 0 
&dA 
&dA &d@   Handle special case of beginning of piece 
&dA 
        if f(1,4) = 2 
          loop for t10 = larc2 to larc 
            if larr(t10,SNODE) = 6913 and larr(t10,MNODE_TYPE) <> 18 
              t4 += larr(t10,PRE_DIST) 
            else 
              larc2 = t10 
              goto CG4 
            end 
          repeat 
        end 
CG4: 
        loop for t9 = 1 to barcount 
          if rflag(t9) > 0 
            barpar(t9,1) = rflag(t9) + t4 
            barpar(t9,2) = larc2 
            t4 = 0 
          else 
            if t9 > 1 and rflag(t9-1) > 0 
              ++larc2 
            end 
            t3 = 0 
            loop for t10 = larc2 to larc 
&dA 
&dA &d@  Exit sequence:  either you run out of 6913 nodes, or you hit another  
&dA &d@                  bar line (i.e. with a multiple rest in between).  
&dA 
              if t3 = 1 
                if larr(t10,SNODE) <> 6913 
                  larc2 = t10 
                  goto CG3 
                else 
                  if larr(t10,MNODE_TYPE) = 18 
                    larc2 = t10 
                    goto CG3 
                  end 
                end 
              end 
* 
              t4 += larr(t10,PRE_DIST) 
              if larr(t10,MNODE_TYPE) = 18 and larr(t10,SNODE) = 6913 
                t3 = 1 
                barpar(t9,2) = t10 
                barpar(t9,1) = t4 
                t4 = 0 
              end 
            repeat 
          end 
CG3: 
        repeat 
&dA 
&dA &d@   Reset record pointers, set up second whole measure rest array  
&dA &d@ 
CG2: 
        loop for f12 = 1 to f11 
          f(f12,6) = f(f12,4) 
          f(f12,11) = f(f12,7) 
        repeat 

        if justflag > 0 
          sysbarpar(syscnt,4) = sysbarpar(syscnt,2) + barpar(barcount,1) 
        end 
&dA 
&dA &d@    If f13 = 0 (and justflag < 2), check to see if part names 
&dA &d@    need to be backed up.  Compute pn_left 
&dA 
        if f13 = 0 and justflag < 2 and f11 > 1 
          c1 = 0 
          loop for f12 = 1 to f11 
            notesize = f(f12,14) 
            rec = f(f12,1) 
            tget [Z,rec] line 
            if line <> "" 
              if line{1} = "!" 
                temp = line{2,2} 
                line = line // pad(4) 
                line = line{4..} 
              else 
                temp = chs(mtfont) 
              end 
              c5 = int(temp) 
              perform spacepar (c5) 
              if len(line) <= NAMELEN 
                line = trm(line) 
                c2 = 0 
                loop for c3 = 1 to len(line) 
                  c2 += spc(ors(line{c3})) 
                repeat 
                if c1 < c2 
                  c1 = c2 
                end 
              else 
                line = line // " " 
                t10 = 0 
FLL: 
                t7 = 0 
                loop for t11 = 1 to len(line) 
                  if line{t11} = " " 
                    if t11 > NAMELEN 
                      if t7 > 0 
                        t11 = t7 
                      end 
                      ++t10 
                      linepiece(t10) = trm(line{1,t11}) 
                      line = mrt(line{t11..}) 
                      goto FLL 
                    else 
                      t7 = t11 
                    end 
                  end 
                repeat 
                line = trm(line) 
                if len(line) > 0 and t10 < 5 
                  ++t10 
                  linepiece(t10) = line 
                end 
                loop for t11 = 1 to t10 
                  c2 = 0 
                  loop for c3 = 1 to len(linepiece(t11)) 
                    c2 += spc(ors(linepiece(t11){c3})) 
                  repeat 
                  if c1 < c2 
                    c1 = c2 
                  end 
                repeat 
              end 
            end 
          repeat 

          c2 = maxnotesize << 1 
          if c1 > hxpar(9) - c2 
            pn_left = c1 - hxpar(9) + c2 
          else 
            pn_left = 0 
          end 
        end 

&dA 
&dA &d@   Loop through parts one at a time and print out.  Set delta 
&dA &d@      to total number of bars for this line.  We will use barcount 
&dA &d@      as the exit indicator for each part.  
&dA 
&dA &d@   There are certain variables which are used only to print parts.  
&dA &d@     The variables and their storage locations are listed below.  
&dA 
&dA &d@           Variable 
&dA &d@          ÄÄÄÄÄÄÄÄÄÄ 
&dA &d@           superpnt(32,N_SUPER) 
&dA &d@           supermap(32,N_SUPER) 
&dA &d@           superdata(32,N_SUPER,SUPERSIZE) 
&dA &d@           drec(32) 
&dA &d@           savenoby(32) 
&dA &d@           nuxstop(32) 
&dA &d@           dxoff(32) 
&dA &d@           dyoff(32) 
&dA &d@           uxstart(32) 
&dA &d@           backloc(32) 
&dA &d@           xbyte(32) 
&dA 
        delta = barcount 
        loop for f12 = 1 to f11 
          if justflag < 2        /* Fixing a bug in the TAKEOUT system  &dA12/22/05
            type1_dflag(f12) = save_type1_dflag(f12) 
            type2_dflag(f12) = save_type2_dflag(f12) 
          end 
          t9 = f(f12,15) 
          lbyte = "Ll"{t9} 

          notesize = f(f12,14) 
          firstbarflag = 0 
          dxoff(f12) = 10000 
&dA 
&dA &d@    a. Set up Line record.  If f13 = 0, put objects for instrument      
&dA &d@       names; else, print clef, key, time-sig and other information.    
&dA 
          t9 = sq(f12) - sysy 
          if f13 = 0 
            xbyte(f12)    = "**********"{1,f(f12,13)} 
            if justflag < 2 
              ++mainyp 
#if CONTINUO 
              tput [Y,mainyp] ~lbyte  ~t9  ~f(f12,9)  0 0 0 ~xbyte(f12)  ~vst(f12)  ~f(f12,14)  -200
#else 
              tput [Y,mainyp] ~lbyte  ~t9  ~f(f12,9)  0 0 0 ~xbyte(f12)  ~vst(f12)  ~f(f12,14)  0
#endif 
            end 
&dA 
&dA &d@       print instrument name 
&dA 
            if f11 > 1 
              rec = f(f12,1) 
              tget [Z,rec] line 
              if line <> "" 
                if line{1} = "!" 
                  temp = line{2,2} 
                  line = line // pad(4) 
                  line = line{4..} 
                else 
                  temp = chs(mtfont) 
                end 
                x = 0 - hxpar(9) - pn_left 
                if len(line) <= NAMELEN 
                  y = mvpar(f12,6) 
                  if justflag < 2 
                    ++mainyp 
                    tput [Y,mainyp] J D 0 ~x  ~y  1 6913 0 0 
                  end 
                  line = trm(line) 
                  if justflag < 2 
                    ++mainyp 
                    tput [Y,mainyp] W 0 0 ~temp  ~line 
                  end 
                else 
                  y = mvpar(f12,9) 
                  line = line // " " 
                  t10 = 0 
FIXLINE: 
                  t7 = 0 
                  loop for t11 = 1 to len(line) 
                    if line{t11} = " " 
                      if t11 > NAMELEN 
                        if t7 > 0 
                          t11 = t7 
                        end 
                        ++t10 
                        y -= mvpar(f12,3) 
                        linepiece(t10) = trm(line{1,t11}) 
                        line = mrt(line{t11..}) 
                        goto FIXLINE 
                      else 
                        t7 = t11 
                      end 
                    end 
                  repeat 
                  line = trm(line) 
                  if len(line) > 0 and t10 < 5 
                    ++t10 
                    y -= mvpar(f12,3) 
                    linepiece(t10) = line 
                  end 
                  if justflag < 2 
                    ++mainyp 
                    tput [Y,mainyp] J D 0 ~x  ~y  ~t10  6913 0 0 
                  end 
                  y = 0 
                  loop for t11 = 1 to t10 
                    if justflag < 2 
                      ++mainyp 
                      tput [Y,mainyp] W 0 ~y  ~temp  ~linepiece(t11) 
                    end 
                    y += mvpar(f12,6) 
                  repeat 
                end 
              end 
            end 
          else 
            if justflag < 2 
              ++mainyp 
              xx(1) = f(f12,9) 
              xx(2) = dyoff(f12) 
              xx(3) = uxstart(f12) 
              xx(4) = backloc(f12) 
              xx(5) = vst(f12) 
              xx(6) = f(f12,14) 
#if CONTINUO 
              tput [Y,mainyp] ~lbyte  ~t9  ~xx(1)  ~xx(2)  ~xx(3)  ~xx(4)  ~xbyte(f12)  ~xx(5)  ~xx(6)  -200
#else 
              tput [Y,mainyp] ~lbyte  ~t9  ~xx(1)  ~xx(2)  ~xx(3)  ~xx(4)  ~xbyte(f12)  ~xx(5)  ~xx(6)  0
#endif 
&dA 
&dA &d@      This code added &dA01/06/04&d@ to implement abbreviated part names 
&dA 
              c4 = f(f12,6) 
              c2 = recflag(c4) & 0xff 
              if c2 > 0 
                temp = abbr(c2) 
                c5 = int(temp) 
                temp = temp{sub..} 
                temp = mrt(temp) 
&dA 
&dA &d@      New &dA01/29/09&d@: Adding code to deal with grand staff 
&dA 
                c7 = 0 
                temp = temp // pad(4) 
                if temp{1,3} = "(g)"           /* special case of grand staff
                  c7 = vst(f12) >> 1 
                  temp = temp{4..} 
                end 
                temp = trm(temp) 

                perform spacepar (c5) 
                if temp con "/" 
                  temp2 = temp{mpt+1..} 
                  temp  = temp{1,mpt-1} 
                else 
                  temp2 = "" 
                end 
                c2 = 0 
                loop for c3 = 1 to len(temp) 
                  if temp{c3} = "_" 
                    temp{c3} = " " 
                  end 
                  if temp{c3,2} = "\0" 
                    ++c3 
                  else 
                    c2 += spc(ors(temp{c3})) 
                  end 
                repeat 
                c4 = 0 
                if temp2 <> "" 
                  loop for c3 = 1 to len(temp2) 
                    if temp2{c3} = "_" 
                      temp2{c3} = " " 
                    end 
                    if temp2{c3,2} = "\0" 
                      ++c3 
                    else 
                      c4 += spc(ors(temp2{c3})) 
                    end 
                  repeat 
                end 
                if c4 > c2 
                  c2 = c4 
                end 

                c4 = notesize * 3 + c7              /* c7 is New &dA01/29/09&d@ 

                c3 = maxnotesize << 1 
                c2 += c3 
                ++mainyp 
                if temp2 = "" 
                  tput [Y,mainyp] J D 0 -~c2  ~c4  1 6913 0 0 
                  ++mainyp 
                  tput [Y,mainyp] W 0 0 ~c5  ~temp 
                else 
                  c7 = 0 
                  loop while temp2{1} = " " 
                    c7 += spc(32) 
                    temp2 = temp2{2..} 
                  repeat 

                  c6 = c4 >> 1 
                  tput [Y,mainyp] J D 0 -~c2  ~c4  1 6913 0 0 
                  ++mainyp 
                  tput [Y,mainyp] W 0 -~c6  ~c5  ~temp 
                  ++mainyp 
                  tput [Y,mainyp] J D 0 -~c2  ~c4  1 6913 0 0 
                  ++mainyp 
                  tput [Y,mainyp] W ~c7  ~c6  ~c5  ~temp2 
                end 
              end 
            end 

&dA                         
&dA 
&dA &d@   New &dA05/06/08&d@.  If the beginning of an ending superobject has been thrown over
&dA &d@                  to a new page, then a mark for this superobject must be placed
&dA &d@                  at the beginning of the line.  &dEclefkey&d@ is the best place to do
&dA &d@                  this.  The flags will be superdata(.,.,5) and superdata(.,.,7).
&dA &d@                  The magic number 123456 is used to signal an ending superobject,
&dA &d@                  and 2 is the value of superdata(.,.,5) which signals that the 
&dA &d@                  ending was thrown over from the previous measure.  supernum is
&dA &d@                  used as the flag for clefkey to typeset a mark.  
&dA 
            supernum = 0 
            loop for t10 = 1 to N_SUPER            /* N_SUPER is New &dA02/01/09
              if superdata(f12,t10,5) = 2 and superdata(f12,t10,7) = 123456 
                supernum = supermap(f12,t10) 
              end 

              if superdata(f12,t10,6) = 234567     /* New &dA06/09/08&d@ magic number for dashes
                superdata(f12,t10,7) = 1           /* New &dA06/09/08&d@ 
              end                                  /* New &dA06/09/08&d@ 

            repeat 
&dA 
&dA                         &d@  End of &dA05/06/08&d@ addition 

            perform clefkey  

&dA                        
&dA 
&dA &d@     New code &dA11/21/07&d@; Typeset directives thrown from previous systme 
&dA 
            if save_dircnt > 0 and justflag < 2 
              loop for c12 = 1 to save_dircnt 
                if save_direct(c12,1) = f12 
                  c13 = save_direct(c12,2) 
                  tget [Z,c13] line2 .t5 c14 c15 c16 c17 
                  if bit(1,c14) = 1 
                    goto LKJ01 
                  end 
                  if bit(2,c14) = 1 
                    goto LKJ01 
                  end 
                  if bit(3,c14) = 1 and f12 = f11 
                    goto LKJ01 
                  end 
                  goto LKJ02 
LKJ01: 
                  c11 = c13 - 1 
LKJ03: 
                  tget [Z,c11] line3 .t5 t6 t6 
                  if line3{1,3} <> "J B" and c11 > 1 
                    --c11 
                    goto LKJ03 
                  end 
                  t5 = c15 - t6           /* This is the horizontal offset (I think)
                  line2 = line2{1,4} // chs(c14) // " " // chs(t5) // " " // chs(c16) // " " // chs(c17) // " 6913 0 0"
                  ++c13 
                  tget [Z,c13] line3 
                  ++mainyp 
                  tput [Y,mainyp] ~line2 
                  ++mainyp 
                  tput [Y,mainyp] ~line3 

                end 
LKJ02: 
              repeat 
            end 
&dA 
&dA                        &d@  End of &dA11/21/07&d@ addition 

          end 
* 
&dA 
&dA &d@    b. Check for multiple rests running over from previous line.        
&dA &d@         Also initialize certain variables.                             
&dA 
          barnum = oldbarnum 
          larc2 = 0 
          rec = f(f12,6) 
          crec = 0 
          csnode = 6913 
          point = pdist 
          prev_point = point 
          point_adv = 0 
          oldmpoint = point 
          if f13 = 1 
            oldmp2 = point 
          else 
            oldmp2 = firstpt 
          end 

          last_jtype = " "               /* added &dA11/25/06&d@ 

          barcount = 0 
          if f(f12,11) > 0 
            rest7 = 0                    /* added &dA12/24/03&d@ 
&dA 
&dA &d@     This code was formerly the procedure "do_wholerests" 
&dA 
            loop 
              t1 = f(f12,12) 
              if t1 = 1                             /* t1 = 1 means don't print rest
                goto DOR_POINT1 
              end 
              x = point + oldmpoint + barpar(barcount+1,1) / 2 - notesize 
              y = mvpar(f12,4) 
              if t1 = 0 
                if justflag < 2 
                  ++mainyp 
                  if rest7 = 1                      /* added &dA12/24/03&d@ "Q" is an internal flag
                    tput [Y,mainyp] Q R 9 ~x  ~y  46 1 0 0 
                  else 
                    tput [Y,mainyp] J R 9 ~x  ~y  46 1 0 0 
                  end 
                end 
                goto DOR_POINT1 
              end 
              if justflag < 2 
                ++mainyp 
                if rest7 = 1                        /* added &dA12/24/03&d@ "Q" is an internal flag
                  tput [Y,mainyp] Q R 9 ~x  ~y  2 1 0 0 
                else 
                  tput [Y,mainyp] J R 9 ~x  ~y  2 1 0 0 
                end 
                ++mainyp 
                tput [Y,mainyp] K 0 0 46 
                ++mainyp 
                tput [Y,mainyp] K 0 ~vst(f12)  46 
              end 
DOR_POINT1: 
              ++barnum 
              --f(f12,11) 
              if f(f12,11) > 0 
                ++barcount 
                point = oldmpoint + barpar(barcount,1) 
                oldmpoint = point 
                oldmp2 = point 
                if barcount = delta 
                  f(f12,6) = rec 
                  return 
                end 
              end 
            repeat while f(f12,11) > 0 
&dA 
&dA                                    

            if barcount = delta 
              goto CW 
            end 
          end 
&dA 
&dA &d@    c. Process the data for each part.  Compute new x-position for all  
&dA &d@       objects.  Collect information on super objects; these may have   
&dA &d@       to be split at the end of line.  Determine where to stop looking 
&dA &d@       (this has turned out to be a problem area for this program).     
&dA 
          if justflag < 2 
            type1_dflag(f12)  = ON 
            type2_dflag(f12)  = OFF 
          end 
CZ: 
          tget [Z,rec] line .t3 jtype c2 c2 c2 c2 snode  
&dA 
&dA &d@    New code added &dA01/06/04&d@ to deal with line control flags 
&dA 
          if justflag < 2 
            c2 = recflag(rec) >> 8 
            if c2 <> 1 
              type1_dflag(f12) = OFF 
            end 
            if c2 = 2 
              type2_dflag(f12) = ON 
            end 
&dA 
&dA &d@      Fixing a bug in the TAKEOUT system  &dA12/22/05&d@ 
&dA 
            save_type1_dflag(f12) = type1_dflag(f12) 
            save_type2_dflag(f12) = type2_dflag(f12) 
          end 
&dA   
          ++rec 

          if line{1} = "Q" 
            goto CZ 
          end 
&dA 
&dA &d@ Process multiple rests and whole rests 
&dA 
          if line{1,3} = "J S" and "467" con line{5} and f11 > 1 
            --rec 
            perform save3                 /* oby not used here 
            ++rec 
&dA 
&dA &d@   a) check for underlines  
&dA 
            c9 = 0 
            loop for c8 = 1 to f(f12,13) 
              if f(f12,9) > 0 and "_,.;:!?" con xbyte(f12){c8} 
                if mpt > 1 
                  c9 = 1 
                end 
                y = sq(f12) + f(f12,9) 
                xbyte(f12){c8} = "*" 
              end 
            repeat 
&dA 
&dA &d@   b) process rest(s) 
&dA 
            if barcount = delta 
              f(f12,11) = 0 
              f(f12,6) = rec - 1 
              f(f12,5) = rec - 1 
              goto CW 
            end 
            rest7 = 0 
            if ntype = 4 
              f(f12,11) = snode 
            else 
              f(f12,11) = 1 
&dA 
&dA &d@     Added &dA12/24/03&d@ for optional staff lines 
&dA 
              if ntype = 7 
                rest7 = 1 
              end 
&dA   
            end 
            loop 
              tget [Z,rec] line 
              ++rec 
            repeat while line{1,3} <> "J B" 
            --rec 
&dA 
&dA &d@     This code was formerly the procedure "do_wholerests" 
&dA 
            loop 
              t1 = f(f12,12) 
              if t1 = 1                             /* t1 = 1 means don't print rest
                goto DOR_POINT2 
              end 
              x = point + oldmpoint + barpar(barcount+1,1) / 2 - notesize 
              y = mvpar(f12,4) 
              if t1 = 0 
                if justflag < 2 
                  ++mainyp 
                  if rest7 = 1                      /* added &dA12/24/03&d@ "Q" is an internal flag
                    tput [Y,mainyp] Q R 9 ~x  ~y  46 1 0 0 
                  else 
                    tput [Y,mainyp] J R 9 ~x  ~y  46 1 0 0 
                  end 
                end 
                goto DOR_POINT2 
              end 
              if justflag < 2 
                ++mainyp 
                if rest7 = 1                        /* added &dA12/24/03&d@ "Q" is an internal flag
                  tput [Y,mainyp] Q R 9 ~x  ~y  2 1 0 0 
                else 
                  tput [Y,mainyp] J R 9 ~x  ~y  2 1 0 0 
                end 
                ++mainyp 
                tput [Y,mainyp] K 0 0 46 
                ++mainyp 
                tput [Y,mainyp] K 0 ~vst(f12)  46 
              end 
DOR_POINT2: 
              ++barnum 
              --f(f12,11) 
              if f(f12,11) > 0 
                ++barcount 
                point = oldmpoint + barpar(barcount,1) 
                oldmpoint = point 
                oldmp2 = point 
                if barcount = delta 
                  f(f12,6) = rec 
                  return 
                end 
              end 
            repeat while f(f12,11) > 0 
&dA 
&dA                                                  

            if barcount = delta 
              goto CW 
            end 
            goto CZ 
          end 
&dA 
&dA &d@         O B J E C T S  
&dA &d@         ÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
&dA &d@  We must compute the new obx for this object.  To do this, we  
&dA &d@  will use the information the larr array.  We must be reminded   
&dA &d@  at this point about the kinds of nodes which are in the larr  
&dA &d@  array.  The larr array locates objects of type N,R,Q,F,I,B,K,T. 
&dA &d@  In addition, type C generates a larr node, if it follows a  
&dA &d@  B type node and has snode = 6913.  The value of snode for the   
&dA &d@  larr nodes in a particular measure is always non-decreasing.  
&dA &d@  In general, the value increases with each node.  Exceptions 
&dA &d@  are as follows:  1) At the end of a measure, there may be   
&dA &d@  several nodes with snode = 6913.  The first of these is   
&dA &d@  always a B type.  Those that follow may include C,K, and T  
&dA &d@  types in that order.  2) It can happen that there is a  
&dA &d@  non-controlling bar line in the middle of a measure.  In this 
&dA &d@  case, the bar line (B) will have the same larr(.,SNODE) value      (&dA05/25/03&d@)
&dA &d@  as the next node.  There can be several proper objects with 
&dA &d@  the same snode value in a node, e.g. F and N types are  
&dA &d@  commonly found together.  In this case, the type for the  
&dA &d@  node is the first time encountered in the part.  It is  
&dA &d@  important when reading the part to realize that there &dDwill not&d@  
&dA &d@  be a new larr node for each proper object encountered.  New 
&dA &d@  larr nodes are generated &dDonly&d@ by:  1) an advance in snode,  
&dA &d@  2) a type N,R,Q,F,I following a type B, when snode < 6913,  
&dA &d@  3) a C and/or K and/or T after a type B, when snode = 6913. 
&dA &d@  Grace notes (G), symbols (S), directives (D), and marks (M) 
&dA &d@  will always take their position from the proper object that 
&dA &d@  follows.  It still isn't clear to me whether marks or symbols 
&dA &d@  can have their own unique snode number.   
&dA 
&dA &d@  To sum all of this up, it is very important that the reading  
&dA &d@  and interpreting of objects in the intermediate file not get    
&dA &d@  out of phase with the nodes in larr.  If this happens, the  
&dA &d@  positions of objects will become messed up. 
&dA 
*  
          if line{1} = "J" 
            if jtype = "M" and snode = 10000 
              if (Debugg & 0x01) > 0 
                pute Error: Unexpected end of file for part ~f12 
              end 
              tmess = 44 
              perform dtalk (tmess) 
            end 
            --rec 
*  Get the remaining object related parameters 
            perform save3          /* oby will be used; it will be modified as needed
&dA 
&dA &d@  Compute the new obx.  
&dA 
&dA &d@    Case I: controlling bar line  
&dA 
&dA &d@      New &dA05/25/03&d@  Remove any measure print suggestions here (also &dA05/28/05&d@)
&dA 
            if jtype = "B" and snode = 6913 
              if oby >= 1000000 
                c9 = oby / 1000000 
                oby = rem 
                sub = 5 
                c8 = int(line{sub..})      /* bar number 
                c7 = int(line{sub..})      /* obx 
                c6 = int(line{sub..})      /* oby 
                line = "J B " // chs(c8) // " " // chs(c7) // " " // chs(oby) // line{sub..}
              end 

              if oby >= 1000 
                oby -= 1000                /* convert to proper bar flag (double etc.)
              end 
              firstbarflag = 1 
              csnode = 6913 
              oldcdv = cdv                                                 /* New &dA12/19/03
              perform getcontrol (barnum) 
              ++barcount 
              if oby > 0 and barnum < ntype 
                barnum = ntype 
              end 
              f4 = 0 
              if barcount = delta 
                f4 = 1 
                endbarrec = rec + 1 
              end 
              point = oldmpoint + barpar(barcount,1) 
              prev_point = point 
              point_adv = 0 
              half_back = point - oldmp2 / 2 
              larc2 = barpar(barcount,2) 
              oldmpoint = point 
              oldmp2 = point 
              obx = 0                                   /* differential obx 
              goto DE 
            end 
&dA 
&dA &d@    Case II: everything else  
&dA 
            a1 = crec 
            oldcdv = cdv 
            perform getcontrol (barnum) 

&dA      
&dA 
&dA &d@    New &dA01/29/09&d@ 
&dA 
&dA &d@    Fixing the object order problem.  Here we impose the special 
&dA &d@    condition that getcontrol should not be allowed to "back up" when 
&dA &d@    dealing with grace notes at the end of a measure.  
&dA 
            if a1 > crec and csnode = 6913 
              if jtype = "G" or jtype = "C" 
                crec = a1 
                cdv = oldcdv 
              end 
            end 
&dA      
            cdv_adv = cdv - oldcdv 
            obx = dvar1 - cdv                           /* differential obx 
            if crec <> a1 
              prev_point = point 
              t9 = larc2 + 1 

              max_larc = 300 

              loop for larc2 = t9 to max_larc 
                point += larr(larc2,PRE_DIST) 
                if larr(larc2,SNODE) = csnode 
                  a10 = larr(larc2,MNODE_TYPE) 
                  if a10 < 12 or a10 > 20 or a10 = cntype 
                    goto DE 
                  end 
                end 
              repeat 
&dA 
&dA &d@      Adding a second filter that relaxes the condition for success (&dA01/18/04&d@)
&dA 
              point = prev_point           /* since you are trying again, get old value of point
              loop for larc2 = t9 to max_larc 
                point += larr(larc2,PRE_DIST) 
                if larr(larc2,SNODE) = csnode 
                  a10 = larr(larc2,MNODE_TYPE) 
                  if csnode = 6913 and a10 = 18 
                    goto DE 
                  end 
                end 
              repeat 
&dA   
            else 
              goto DE 
            end 
            if (Debugg & 0x01) > 0 
              pute Logical error in finding node in part ~f12  at bar ~barnum
            end 
            tmess = 45 
            perform dtalk (tmess) 
&dA 
&dA &d@    differential obx and point now determined 
&dA 
DE: 
            point_adv = point - prev_point 
            obx += point 
            ++rec 
            if jtype = "N" and f(f12,9) > 0    /* text only 

&dA     Code added 2-8-93                             

&dA &d@    There was a problem with the continuation line not stopping  
&dA &d@    when it was supposed to after a carry over from a previous measure.  
&dA &d@    The problem occured only when the stopping note was the first in 
&dA &d@    the new bar.  I was not able to completely understand the logic 
&dA &d@    of the code using nuxstop, but I was able to determine that the 
&dA &d@    value of nuxstop had been set in the previous system of music 
&dA &d@    and was greater than rmarg.  I therefore introduced a new variable 
&dA &d@    called &dAfirstbarflag&d@, which is 0 when setting the first bar on a 
&dA &d@    line, and 1 otherwise.  I think the problem may occur only when            
&dA &d@    nuxstop > rmarg and firstbarflag = 0.  Therefore, in this case I 
&dA &d@    have reset nuxstop to the expected value of sp+obx+mhpar(f12,2).  

              if firstbarflag = 0 and nuxstop(f12) > rmarg 
                nuxstop(f12) = sp + obx + mhpar(f12,2) 
              end 

&dA     End of code added 2-8-93                      &d@ 

              if savenoby(f12) = oby 
                nuxstop(f12) = sp + obx + mhpar(f12,2) 
              else 
                nuxstop(f12) = sp + obx + mhpar(f12,2) 
              end 

              savenoby(f12) = oby 
            end 
            if "Rr" con jtype and cflag = 1            /* New &dA10/15/07&d@ 
              obx = oldmpoint - oldmp2 + barpar(barcount+1,1) / 2 - notesize + oldmp2
              if f(f12,12) = 1 
                obx = 20000         /* Taking this out &dA05/25/03&d@ (not checked)  ????
              end 
            end 
            if jtype = "C" 
              if f(f12,12) = 2 and oby >= 1000 
                mclef(f12,2) = ntype 
              else 
                mclef(f12,1) = ntype 
              end 
            end 
            if jtype = "K" 
              mkey(f12) = ntype 
            end 
            if jtype = "T" 
              if barcount = delta 
                mtcode(f12) = ntype 
              else 
                mtcode(f12) = 10000 
              end 
            end 
&dA 
&dA &d@      Re-writing this section &dA12/24/03&d@.  The problem is that the old code 
&dA &d@      dealt with suppressing D-type records below the top staff line by 
&dA &d@      simply skipping them.  This worked as long as the full score was being
&dA &d@      printed.  But if the top line is taken out for some reason, then 
&dA &d@      "top line" directives are lost.  The solution is to suppress D-type 
&dA &d@      records by setting the font in the W-subobjects to zero.  This way 
&dA &d@      the directives can be turned back on, if necessary 
&dA 
            if jtype = "D" 
              if ntype = 0 
                goto CZ3 
              end 
              if bit(1,ntype) = 1 
                goto CZ3 
              end 
              if bit(2,ntype) = 1 and f12 = 1 
                goto CZ3 
              end 
              if bit(3,ntype) = 1 and f12 = f11 
                goto CZ3 
              end 
&dA 
&dA &d@       Now, turn off W-subobjects associated with this directive 
&dA 
              c8 = rec 
SKD2:         tget [Z,c8] line2 .t3 sobx soby z temp 
              if line2{1} = "W" and z <> 0 
                line2 = "W " // chs(sobx) // " " // chs(soby) // " 0 " 
                line2 = line2 // "(" // chs(z) // ")" // temp 
                tput [Z,c8] ~line2 
                ++c8 
                goto SKD2 
              end 
            end 
&dA 
&dA &d@   General Object Related Activity  
&dA 
&dA &d@    1. Collect super-object information 
&dA 
CZ3: 
            line = line{5..} 
            t10 = int(line)          /* strip object code 
            t10 = int(line{sub+1..}) /* strip obx 
            line = line{sub+1..} 
            line = trm(line) 
            oby = int(line) 
&dA 
&dA &d@    Don't fix oby yet, because we may need staff info when constructing 
&dA &d@    tie, slur, beam, tuplet, transpos, dashes, trills or wedges superobjects 
&dA 
&dA &d@           if oby >= 700 and f(f12,12) = 2 
&dA &d@             oby -= 1000                  /* for superobjects, need oby relative to staff
&dA &d@           end 
&dA 
            if justflag < 2 
#if CONTINUO 
              if jtype = "F" 
                obx += mhpar(f12,23) 
              end 
#endif 
              ++mainyp 
&dA 
&dA &d@   &dA12/17/03&d@ 
&dA 
&dA &d@      Here is where we determine the larr index which generated 
&dA &d@      the value of "point".  
&dA 
              if psysnum = 0 
                t10 = point 
              else 
                t10 = point - pdist      /* reason: For 2nd and subsequent systems, larr does
              end                        /*         not include the clef and key
&dA    
              tput [Y,mainyp] J ~jtype  ~ntype  ~obx  ~line 
            end 
            lpt = int(line)              /* skip Field 5: oby 
            lpt = int(line{sub+1..})     /* skip Field 6: print code 
            lpt = int(line{sub+1..})     /* skip Field 7: space node number 
            lpt = int(line{sub+1..})     /* skip Field 8: distance increment
            line = line{sub+1..}         /* line starts with Field 9: 
            lpt = 0 
            tline = txt(line,[' '],lpt) 
            supcnt = int(tline) 
            if supcnt > 0 
              loop for t9 = 1 to supcnt 
                tline = txt(line,[' '],lpt) 
                t10 = int(tline) 
                if t10 = 0 
                  tmess = 46 
                  perform dtalk (tmess) 
                end 
&dA &d@       look for previous reference to this superobject 
                loop for t11 = 1 to N_SUPER     /* N_SUPER is New &dA02/01/09&d@ 
                  if supermap(f12,t11) = t10 
                    goto WA 
                  end 
                repeat 
                t7 = 0 
                loop for t11 = 1 to N_SUPER     /* N_SUPER is New &dA02/01/09&d@ 
                  if supermap(f12,t11) = 0 
                    t7 = t11 
                    t11 = N_SUPER               /* New &dA02/01/09&d@ 
                  end 
                repeat 
                if t7 = 0 
                  tmess = 47 
                  perform dtalk (tmess) 
                end 
&dA 
&dA &d@       if not found, then set up reference to this superobject 
&dA &d@          also set superdata(f12,t11,5) = 0 for those super-objects 
&dA &d@          which depend on two locations only and which can be 
&dA &d@          split across a line or page break 
&dA 
                t11 = t7 
                supermap(f12,t11) = t10 
                superpnt(f12,t11) = 1 
                superdata(f12,t11,5) = 0 

                superdata(f12,t11,6) = 0             /* New &dA06/09/08&d@ 
                superdata(f12,t11,7) = 0             /* New &dA06/09/08&d@ 

&dA &d@       t11 (value 1 to N_SUPER) = pointer into superdata for this superobject
WA: 
                t7 = superpnt(f12,t11) 
&dA &d@         store object information in superdata and increment superpnt 
                superpnt(f12,t11) = t7 + 2 
                superdata(f12,t11,t7) = obx 
                superdata(f12,t11,t7+1) = oby               /* unfixed 7-22-93
&dA &d@         if this object is the last bar in a line, 
&dA &d@            then set last bar flag in superdata 
                if jtype = "B" and t7 = 1 
                  superdata(f12,t11,6) = f4 
                end 
              repeat 
            end 
&dA 
&dA &d@   End of General Object-related Activity 
&dA &d@ 
            saverec = rec 
            if "Rr" con jtype                        /* New &dA10/15/07&d@ 
              loop for c8 = 1 to f(f12,13) 
                if "_,.;:!?" con xbyte(f12){c8} 
                  xbyte(f12){c8} = "*" 
                end 
              repeat 
            end 
&dA 
&dA                   &d@  End of &dA12/27/05&d@ change (eliminating code that did nothing)

            if jtype = "B" 
&dA 
&dA &d@    If this is the first part in which this particular bar line is  
&dA &d@      encountered, then set value of barpar(.,3) and f5 
&dA 
              if snode = 6913 and barpar(barcount,3) = 0 
                if oby >= 700 and f(f12,12) = 2 
                  oby -= 1000 
                end 
                barpar(barcount,3) = oby 
                f5 = 0 
              end 
              if rec = endbarrec 
                sobx = 0 
                if oby >= 700         /* &dA 
                  oby -= 1000         /* &dA &d@  Added  &dA04/03/94&d@ 
                end                   /* &dA 
                if oby > 8 
                  f5 = 2 
ABX1:             tget [Z,rec] line2 .t3 sobx soby z 
                  if line2{1} = "K" 
                    if z = 44 
                      if sobx < 0 
                        f5 |= 0x04 
                      else 
                        f5 |= 0x01 
                      end 
                    else 
                      if z > 88 
                        line2 = trm(line2) 
                        if justflag < 2 
                          ++mainyp 
                          tput [Y,mainyp] ~line2 
                        end 
                      end 
                    end 
                    ++rec 
                    goto ABX1 
                  end 
                end 
                if oby = 10 and f5 > 3 
                  sobx = 0 - mhpar(f12,16) - mhpar(f12,17) - mhpar(f12,18) 
                  soby = mvpar(f12,3) 
                  if justflag < 2 
                    ++mainyp 
                    tput [Y,mainyp] K ~sobx  ~soby  44 
                    soby = mvpar(f12,5) 
                    ++mainyp 
                    tput [Y,mainyp] K ~sobx  ~soby  44 
                  end 
                end 
                if larc2 = larc and sobx > 0 
                  bolddist(f12) = bolddist(f12) + sobx + mhpar(f12,11) 
                end 
              end 
              oby = 0 
            end 
            if snode = 6913 

&dA     Code added 8-24-93                            
&dA 
&dA &d@    It can happen that there are one or more grace notes before a controlling 
&dA &d@    barline in this part.  In this case, snode will be = 6913, but the 
&dA &d@    grace note(s) DO NOT generate a larr node.  Therefore these proper        
&dA &d@    objects must not be considered as candidates for the end of the line.  
&dA 
              if jtype = "G" 
                goto CZ 
              end 
&dA     End of code added 8-24-93                     &d@ 

&dA 
&dA &d@    In determining whether this node is the last node in the line  
&dA &d@    for this part, we must consider the case where there was a clef 
&dA &d@    change or time change or key change at the end of the line and 
&dA &d@    where this change occurred in some parts but not in others.  
&dA &d@    For this purpose, we have introduced a fifth element in the 
&dA &d@    larr array, which is 0 for nodes <> 6913 and is a flag for active 
&dA &d@    parts for nodes = 6913 (bit 0 corresponds to part 1).  If the 
&dA &d@    current node is a bar line, but is not the last node, and if 
&dA &d@    all remaining nodes are of the type, snode = 6913, and none 
&dA &d@    of these nodes has the current part as active, then this is 
&dA &d@    the last node on the line, EVEN THOUGH LARC <> LARC2!  
&dA 
              t9 = point + sp 
              t11 = 0 
              if larc2 <> larc and f4 = 1 
                q1 = rec 
                loop for t7 = larc2 + 1 to larc 
                  if larr(t7,SNODE) <> 6913 
                    goto C21A 
                  end 
                  if bit(f12-1,larr(t7,ACT_FLAG)) = 1 
                    goto ABX16                         /* goto secondary test
                  end 
                repeat 

                t11 = 1 
                goto C21A     /* This is a test &dA10/12/07&d@ 

ABX16:                                                 /* secondary test 
                tget [Z,q1] line2 .t5 q2 q2 q2 q2 q2 
                ++q1 
                if line2{1} <> "J" 
                  goto ABX16                           /* keep looking for a "J"
                end 
                if q2 = 6913 
                  goto C21A                            /* set k = 1 if not 6913
                end 

                t11 = 1         /* bar &dAis&d@ last node on line 
              end 

C21A: 
              if larc2 = larc or t11 = 1 
&dA 
&dA &d@   Check to see of the current record = the control record 
&dA &d@      if not then this is not the last record in the line 
&dA &d@   And if not last record in line, look for time directive or clef sign 
&dA 
                t7 = saverec - 1 
                if t7 <> crec 
                  if jtype = "D" 
                    if ntype <> 1 
                      dxoff(f12) = obx - point 
                      dyoff(f12) = oby 
                      drec(f12) = rec - 1 
                    end 
                  else 
                    if jtype = "C" 
                      goto CZ 
                    end 
                    if jtype = "M"        /* added &dA9-29-93&d@ but not thoroughly tested
                      goto CZ 
                    end 
                    tmess = 48 
                    perform dtalk (tmess) 
                  end 

&dA                      
&dA 
&dA &d@   &dA11/21/07&d@   Expanding this section to allow directives to be cast to the next line
&dA &d@                (using c12, c13) 
&dA 
                  if endflag = 0 
                    c12 = 0 
                    if jtype = "D"  /* skip over directives and store data for next line
                      c13 = rec - 1 
SKD1:                 tget [Z,rec] line2 .t3 sobx soby z 
                      if line2{1} = "W" 
                        c12 = 1 
                        ++rec 
                        goto SKD1 
                      end 
                    end 
                    if c12 = 1 
                      ++new_dircnt 
                      new_direct(new_dircnt,1) = f12 
                      new_direct(new_dircnt,2) = c13 
                    end 
                  end 
&dA 
&dA                       &d@ End of &dA11/21/07&d@ expansion 

                  goto CZ 
                end 
&dA 
&dA &d@   look for sub-objects to typeset  
&dA 
                t11 = 0 
ABX2: 
                tget [Z,rec] line2 .t3 sobx soby z 
                if line2{1} = "W"          /* code added &dA02-23-97&d@ 
                  if justflag < 2 
                    tget [Z,rec-1] line2 
                    if line2{1,3} = "J B"       /* then this WORD is a centered number
                      tget [Z,rec] line2 
                      line2 = line2{3..} 
                      t7 = int(line2) 
                      line2 = line2{sub..} 
                      line2 = mrt(line2) 
                      t7 -= half_back 
                      line2 = "W " // chs(t7) // " " // line2 
                    end 
                    ++mainyp 
                    tput [Y,mainyp] ~line2 
                  end 
                  ++rec 
                  goto ABX2 
                end                        /* end of &dA02-23-97&d@ addition 
                if line2{1} = "K" 
                  t7 = sobx 
                  if z = 63 
                    t7 += mhpar(f12,6) 
                  end 
                  if z > 63 and z < 66 
                    t7 += mhpar(f12,7) 
                  end 
                  if z > 36 and z < 39 
                    t7 += mhpar(f12,9) 
                  end 
                  if z > 70 and z < 81 
                    t7 += mhpar(f12,10) 
                  end 
                  line2 = trm(line2) 
                  if justflag < 2 
                    ++mainyp 
                    tput [Y,mainyp] ~line2 
                  end 
                  if t7 > t11 
                    t11 = t7 
                  end 
                  ++rec 
                  goto ABX2 
                end 
                if line2{1} = "A"            /* Added &dA11-11-93&d@ 
                  if justflag < 2 
                    ++mainyp 
                    tput [Y,mainyp] ~line2 
                  end 
                  ++rec 
                  goto ABX2 
                end 
                if t11 > 0 
                  bolddist(f12) += t11 
                end 
&dA 
&dA &d@   check for super-objects at this point in the file  
&dA 
&dA &d@   From looking at the code below, it appears that the only kind of 
&dA &d@   super-objects which can appear in this location are those which 
&dA &d@   are allowed to end at a bar line.  These include: transpositions 
&dA &d@   endings, dashes, trills, and wedges.  None of these super-objects 
&dA &d@   are displayable in color (at the moment), so this code shouldn't 
&dA &d@   need to be altered.  
&dA 
                loop 
                  tget [Z,rec] line 
                  ++rec 
                  temp = line{1} 
                  if "H" con temp  /* Don't try to process "P" here, it shouldn't exist.
                    superline = trm(line) 
                    lpt = 3 
                    tline = txt(line,[' '],lpt) 
&dA &d@  line structure = supernum htype . . .  
                    supernum = int(tline) 
&dA &d@  get superdata for this superobject 
                    loop for t11 = 1 to N_SUPER       /* N_SUPER is New &dA02/01/09
                      if supermap(f12,t11) = supernum 
                        goto WB2 
                      end 
                    repeat 
                    if (Debugg & 0x01) > 0 
                      pute Error: No refererce to superobject ~supernum  in previous objects
                    end 
                    tmess = 49 
                    perform dtalk (tmess) 
*  t11 = index into superdata 
WB2: 
                    htype = txt(line,[' '],lpt) 
                    perform do_more_supers (t11,htype) 
                    supermap(f12,t11) = 0 
                  end 
                repeat while "HP" con temp      /* "P" added &dA12/18/10&d@ 
                --rec 
&dA 
&dA &d@   look for incomplete superobjects and underlines 
&dA 
                f(f12,6) = rec 
                f(f12,5) = rec 
                loop for t11 = 1 to N_SUPER      /* N_SUPER is New &dA02/01/09&d@ 
                  if supermap(f12,t11) = 0 
                    goto CL 
                  end 
                  rec = f(f12,6) 
&dA 
&dA &d@      1) look for object that terminates this super-object 
&dA &d@            get x and y coordinates of this object 
&dA 
                  loop 
                    perform save3             /* want vstaff info; (raw oby)
                    ++rec 
                    if line{1} = "J" 
                      if snode = 10000 
                        if (Debugg & 0x01) > 0 
                          pute Error: No terminating object for super-object ~supermap(f12,t11)
                          pute 
                          pute This error occurred in part number ~f12  of the score at
                          pute approximately measure number ~(barnum - 1) .  The first step would be
                          pute to look in the source file for this part.  Be sure to look
                          pute in the right file; it's name may not be the same as it's order
                          pute in the score.  
                          pute 
                          pute The location of the error may be related to location of the
                          pute super-object only indirectly.  For example, a beam on some grace
                          pute notes (a super_object) might be open and closed properly, but if
                          pute a (much) later grace note has an "=" in column 26 (i.b46 e.b46 , super-
                          pute object not properly started), then mskpage may try to re-open
                          pute the earlier super-object -- hence a much lower super-object
                          pute number than would be expected at the error location.
                        end 
                        tmess = 50 
                        perform dtalk (tmess) 
                      end 
                      x = dvar1 - bolddist(f12) 
                      y = oby 
                      line = line{5..}             /* line starts with Field 3:
                      lpt = int(line)              /* skip Field 3: jcode 
                      lpt = int(line{sub+1..})     /* skip Field 4: oby 
                      lpt = int(line{sub+1..})     /* skip Field 5: oby 
                      lpt = int(line{sub+1..})     /* skip Field 6: print code
                      lpt = int(line{sub+1..})     /* skip Field 7: space node number
                      lpt = int(line{sub+1..})     /* skip Field 8: distance increment
                      line = line{sub+1..}         /* line starts with Field 9:
                      lpt = 0 
                      tline = txt(line,[' '],lpt) 
                      t12 = int(tline) 
                      if t12 > 0 
                        loop for a1 = 1 to t12 
                          tline = txt(line,[' '],lpt) 
                          a2 = int(tline) 
                          if a2 = supermap(f12,t11) 
                            goto WC               /* Object found 
                          end 
                        repeat 
                      end 
                    end 
                  repeat 
&dA 
&dA &d@      2) look for superobject  (beyond object) 
&dA 
WC: 
                  loop 
                    perform save3         /* oby not used here 
                    ++rec 
                    if line{1} = "J" and snode = 10000 
                      if (Debugg & 0x01) > 0 
                        pute Missing superobject ~supermap(f12,t11) , possible extra beam code
                      end 
                      tmess = 51 
                      perform dtalk (tmess) 
                    end 
                    if "HP" con line{1}                 /* "P" added &dA12/18/10
                      lpt = 3 
                      tline = txt(line,[' '],lpt) 
                      if line{1} = "P"                  /* This code added &dA01/18/11
                        tline2 = "" 
                        tline = tline // pad(2) 
                        if tline{1,2} = "0x" 
                          tline2 = tline 
                          tline = txt(line,[' '],lpt) 
                        end 
                      end 
                      t12 = int(tline) 
                      if supermap(f12,t11) = t12 
                        htype = txt(line,[' '],lpt) 
                        if htype = "B" 
                          tmess = 52 
                          perform dtalk (tmess) 
                        end 
&dA 
&dA &d@          Incomplete Tie (section re-coded &dA05/28/03&d@ to fix suggestions for incomplete ties)
&dA 
                        if htype = "T" 
                          sub = lpt 
                          y1 = int(line{sub..}) 
                          x1 = int(line{sub..}) 
                          x2 = int(line{sub..}) 
                          c1 = int(line{sub..}) 
                          c2 = int(line{sub..}) 
                          c3 = int(line{sub..}) 
                          sitflag = int(line{sub..}) 
                          tspan = rmarg - sp - x1 
                          if justflag < 2 
*             create mark for end of tie 
                            ++mainyp 
                            tput [Y,mainyp] J M 0 ~syslen  0 0 6913 0 1 ~t12
*             create "first half" of super-object  
                            ++mainyp 
                            if line{1} = "P"      /* New &dA12/18/10&d@ (color_flag not needed here)
                              if tline2 = "" 
                                tput [Y,mainyp] P ~t12  T ~y1  ~x1  0 ~c1  ~c2  0 ~sitflag  0
                              else 
                                tput [Y,mainyp] P ~tline2  ~t12  T ~y1  ~x1  0 ~c1  ~c2  0 ~sitflag  0
                              end 
                            else 
                              tput [Y,mainyp] H ~t12  T ~y1  ~x1  0 ~c1  ~c2  0 ~sitflag  0
                            end 
                          end                                        
&dA 
&dA &d@   By setting supermap(t11) = 0 at this point, you will cause 
&dA &d@   superdata to be collected on only the terminating note of 
&dA &d@   the tie.  In this case, superpnt(.) will be 2 instead of 4, 
&dA &d@   and the program will know to typeset a small end-tie.  
&dA 
                          conttie(f12) = 1        /* Code added &dA02/25/97&d@ 
                          supermap(f12,t11) = 0 
                          goto CL 
                        end 
&dA 
&dA &d@          Incomplete Slur 
&dA 
                        if htype = "S" 
                          tline = txt(line,[' '],lpt) 
                          sitflag = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          a3 = int(tline) 
                          x1 = a3 + superdata(f12,t11,1) 
                          tline = txt(line,[' '],lpt) 
                          a4 = int(tline) 
                          y1 = a4 + superdata(f12,t11,2) 
                          if y1 > 700 
                            y1 -= 1000     /* correct for vstaff flag 
                          end 
                          tline = txt(line,[' '],lpt) 
                          x2 = int(tline) + rmarg + x - sp 
                          tline = txt(line,[' '],lpt) 
                          a5 = 0 
                          if y > 700 
                            y -= 1000      /* correct for vstaff flag 
                            a5 = 1000      /* and add vstaff offset to location flag
                          end 
                          y2 = int(tline) + y 
*              compute second height as a percentage of total change 
                          a2 = x2 - x1 
                          a1 = rmarg - sp - x1 * 20 / a2 
                          y2 = y2 - y1 * a1 / 20 + y1 
                          x2 = rmarg - sp 
                          y2 += a5 
*              set broken super-object flag 
                          if y2 = 0 
                            y2 = 1 
                          end 
                          superdata(f12,t11,5) = y2    /* include virtual staff flag
                          if justflag < 2 
*              create mark for end of slur 
                            ++mainyp 
                            tput [Y,mainyp] J M 0 ~syslen  ~y2  0 6913 0 1 ~t12
*              write "first half" of super-object  
                            ++mainyp 
                            tput [Y,mainyp] H ~t12  S ~sitflag  ~a3  ~a4  0 0 0 0 0
                          end 
                          goto CL 
                        end 
&dA 
&dA &d@          Incomplete figure continuation lines 
&dA 
                        if htype = "F" 
                          tline = txt(line,[' '],lpt) 
                          a3 = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          x1 = int(tline)    /* + superdata(f12,t11,1) 
                          x2 = rmarg - sp 
*            set broken super-object flag 
                          superdata(f12,t11,5) = 1 
                          if justflag < 2 
*              create mark for end of figure continuation lines  
                            ++mainyp 
                            tput [Y,mainyp] J M 0 ~syslen  0 0 6913 0 1 ~t12
*              write "first half" of super-object  
                            ++mainyp 
                            tput [Y,mainyp] H ~t12  F ~a3  ~x1  0 0 
                          end 
                          goto CL 
                        end 
&dA 
&dA &d@          Incomplete octave transposition 
&dA 
                        if htype = "V" 
                          tline = txt(line,[' '],lpt) 
                          a3 = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          x1 = int(tline)     /* + superdata(f12,t11,1) 
                          tline = txt(line,[' '],lpt) 
                          tline = txt(line,[' '],lpt) 
                          y1 = int(tline)     /* + superdata(f12,t11,2) 
                          a1 = 0 
                          x2 = rmarg - sp 
                          a4 = x2 - x1 
*              set broken super-object flag 
                         superdata(f12,t11,5) = 1 
*      create mark for end of octave transposition (mindful of virtual staff possibility)
                          if justflag < 2 
                            if superdata(f12,t11,2) > 700 and f(f12,12) = 2 
                              ++mainyp 
                              tput [Y,mainyp] J M 0 ~syslen  1000 0 6913 0 1 ~t12
                            else 
                              ++mainyp 
                              tput [Y,mainyp] J M 0 ~syslen  0 0 6913 0 1 ~t12
                            end 
*              write "first half" of super-object  
                            ++mainyp 
                            tput [Y,mainyp] H ~t12  V ~a3  ~x1  0 ~y1  0 
                          end 
                          goto CL 
                        end 
&dA 
&dA &d@          Incomplete ending 
&dA 
                        if htype = "E" 
                          tline = txt(line,[' '],lpt) 
                          a3 = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          x1 = int(tline)     /* + superdata(f12,t11,1) 
                          tline = txt(line,[' '],lpt) 
                          tline = txt(line,[' '],lpt) 
                          y1 = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          a1 = int(tline) 
                          a2 = 0 
                          x2 = rmarg - sp 
*              create mark for end of incomplete ending  
                          if justflag < 2 
                            ++mainyp 
                            tput [Y,mainyp] J M 0 ~syslen  0 0 6913 0 1 ~t12
                          end 
&dA 
&dA &d@     &dA05/06/08&d@  superdata(.,.,5) has been designated as the flag from a split ending
&dA &d@               In earlier verious of mskpage, it had only one non-zero value, namely 1
&dA &d@               Now it has three possible non-zero values: 
&dA 
&dA &d@                 1 = normal split.  (I believe this may no longer be used) 
&dA &d@                 2 = split where the ending starts at the beginning of the page
&dA &d@                 3 = signals that the ending was started on a previous page
&dA 
&dA &d@               superdata(.,.,7) is used to flag this superobject as an ending (magic number)
&dA 
                          if superdata(f12,t11,6) = 0 or superdata(f12,t11,5) = 2    /* New &dA05/06/08
*              write "first half" of super-object  
                            if justflag < 2 
                              ++mainyp 
                              tput [Y,mainyp] H ~t12  E ~a3  ~x1  0 ~y1  ~a1  0
                            end 
&dA*&d@              set broken super-object flag to 3 
                            superdata(f12,t11,5) = 3 
                          else 
                            if justflag < 2 
                              ++mainyp 
                              tput [Y,mainyp] H ~t12  N 
                            end 
&dA*&d@              set broken super-object flag to 2 
                            superdata(f12,t11,5) = 2 
                          end 
                          superdata(f12,t11,7) = 123456                            /* New &dA05/06/08

                          goto CL 
                        end 
&dA 
&dA &d@          Incomplete dashes 
&dA 
                        if htype = "D" 
                          tline = txt(line,[' '],lpt) 
                          x1 = int(tline)     /* + superdata(f12,t11,1) 
                          tline = txt(line,[' '],lpt) 
                          tline = txt(line,[' '],lpt) 
                          y1 = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          a1 = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          a2 = int(tline) 
                          x2 = rmarg - sp 
*              set broken super-object flag 
                          superdata(f12,t11,5) = 1 
                          superdata(f12,t11,6)  = 234567    /* New &dA06/09/08&d@ magic number for dashes
                          if justflag < 2 

&dA                  
&dA 
&dA &d@   New code &dA06/09/08&d@  If this is a page length set of dashes, put in a 
&dA &d@                        mark for the beginning 
&dA 
                            if superdata(f12,t11,7) = 1 
                              x1 = hxpar(8) - sp 

                              if superdata(f12,t11,2) > 700 and f(f12,12) = 2
                                ++mainyp 
                                tput [Y,mainyp] J M 0 ~x1  1000 0 6913 0 1 ~t12
                              else 
                                ++mainyp 
                                tput [Y,mainyp] J M 0 ~x1  0 0 6913 0 1 ~t12
                              end 

                              x1 = 0 
                            end 
&dA 
&dA                  &d@  End of &dA06/09/08&d@ Code 

&dA 
&dA &d@   Now create mark for end of dashes (mindful of virtual staff possibility)
&dA 
                            if superdata(f12,t11,2) > 700 and f(f12,12) = 2 
                              ++mainyp 
                              tput [Y,mainyp] J M 0 ~syslen  1000 0 6913 0 1 ~t12
                            else 
                              ++mainyp 
                              tput [Y,mainyp] J M 0 ~syslen  0 0 6913 0 1 ~t12
                            end 
*              write "first half" (or "full length") super-object 
                            ++mainyp 
                            tput [Y,mainyp] H ~t12  D ~x1  0 ~y1  ~a1  ~a2 
                          end 
                          goto CL 
                        end 
&dA 
&dA &d@          Incomplete Long Trill 
&dA 
                        if htype = "R" 
                          tline = txt(line,[' '],lpt) 
                          a1 = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          x1 = int(tline)     /* + superdata(f12,t11,1) 
                          tline = txt(line,[' '],lpt) 
                          x2 = rmarg - sp 
                          tline = txt(line,[' '],lpt) 
                          y1 = int(tline)     /* + superdata(f12,t11,2) 
*              set broken super-object flag 
                          superdata(f12,t11,5) = 1 
*      create mark for end of long trill (mindful of virtual staff possibility)
                          if justflag < 2 
                            if superdata(f12,t11,2) > 700 and f(f12,12) = 2 
                              ++mainyp 
                              tput [Y,mainyp] J M 0 ~syslen  1000 0 6913 0 1 ~t12
                            else 
                              ++mainyp 
                              tput [Y,mainyp] J M 0 ~syslen  0 0 6913 0 1 ~t12
                            end 
*              write "first half" of super-object  
                            ++mainyp 
                            tput [Y,mainyp] H ~t12  R ~a1  ~x1  0 ~y1 
                          end 
                          goto CL 
                        end 
&dA 
&dA &d@          Incomplete Wedge 
&dA 
                        if htype = "W" 
                          tline = txt(line,[' '],lpt) 
                          c1 = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          c2 = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          x1 = int(tline)     /* + superdata(f12,t11,1) 
                          tline = txt(line,[' '],lpt) 
                          y1 = int(tline) 
                          tline = txt(line,[' '],lpt) 
                          x2 = rmarg - sp 
                          tline = txt(line,[' '],lpt) 
                          y2 = int(tline) 
*              compute second spread 
                          if c1 < c2 
                            if c1 = 0 
                              a1 = c2 - 1 / 2 
                              c2 = c2 * 3 / 4 
                            else 
                              a1 = c2 
                            end 
                          else 
                            if c2 = 0 
                              c2 = c1 / 2 
                              a1 = c1 * 3 / 4 
                            else 
                              a1 = c1 
                            end 
                          end 
*              set broken super-object flag 
                          if a1 = 0 
                            a1 = 1 
                          end 
                          superdata(f12,t11,5) = a1 
*      create mark for end of wedge (mindful of virtual staff possibility) 
                          if justflag < 2 
                            if superdata(f12,t11,2) > 700 and f(f12,12) = 2 
                              ++mainyp 
                              tput [Y,mainyp] J M 0 ~syslen  1000 0 6913 0 1 ~t12
                            else 
                              ++mainyp 
                              tput [Y,mainyp] J M 0 ~syslen  0 0 6913 0 1 ~t12
                            end 
*              write "first half" of super-object  
                            ++mainyp 
                            tput [Y,mainyp] H ~t12  W ~c1  ~c2  ~x1  ~y1  0 ~y2
                          end 
                          goto CL 
                        end 
                      end 
                    end 
                  repeat 
CL: 
                repeat 

                loop for c8 = 1 to f(f12,13) 
                  if "_,.;:!?" con xbyte(f12){c8} 
                    xbyte(f12){c8} = "*" 
                  end 
                repeat 
&dA 
&dA &d@   End of &dA12/27/05&d@ code change (to remove code that did nothing) 
&dA 
&dA                    

                goto CW    /* this is the exit for the music line loop (for each part)

              end 
            end 

            goto CZ 
          end 
&dA 
&dA &d@         S U B - O B J E C T S 
&dA &d@         ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          if line{1} = "K" or line{1} = "k" or line{1} = "C"   /* "C" added &dA12/18/10
            tget [Z,rec-1] line2 
            line2 = trm(line2) 
            if justflag < 2 
              if conttie(f12) = 1      /* (somewhat tricky solution) 
                if line{1} = "k"       /* New &dA12/18/10&d@ 
                  line2{1} = "K"       /* (this ignors color for the moment)
                end 
              end 
              ++mainyp 
              tput [Y,mainyp] ~line2 
            end 
            goto CZ 
          end 
&dA 
&dA &d@         A T T R I B U T E S 
&dA &d@         ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   
&dA 
          if line{1} = "A"             /* Added &dA11-11-93&d@ 
            tget [Z,rec-1] line2 
            line2 = trm(line2) 
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] ~line2 
            end 
            goto CZ 
          end 
&dA 
&dA &d@         W O R D S 
&dA &d@         ÄÄÄÄÄÄÄÄÄ 
&dA 
          if line{1} = "W" 
            line = trm(line) 
            if justflag < 2 
              tget [Z,rec-2] line2        /* added &dA02-23-97&d@ 
              if line2{1,3} = "J B"       /* then this WORD is a centered number
                tget [Z,rec-1] line2 
                line2 = line2{3..} 
                x = int(line2) 
                line2 = line2{sub..} 
                line2 = mrt(line2) 
                x -= half_back 
                line = "W " // chs(x) // " " // line2 
              end                         /* end of &dA02-23-97&d@ addition 
              ++mainyp 
              tput [Y,mainyp] ~line 
            end 
            goto CZ 
          end 
&dA 
&dA &d@         T E X T  (This code re-organized &dA12/19/03&d@ to deal with optional sobx2)
&dA &d@         ÄÄÄÄÄÄÄ 
&dA 
&dA &d@       Step 1: determine object record to which this text belongs 
&dA 
          if line{1} = "T" 

            trec = rec - 2                   /* rec was advanced after getting "T" record
TX1: 
            tget [Z,trec] line2 
            if line2{1} <> "J" and trec > 1 
              --trec 
              goto TX1 
            end 
&dA 
&dA &d@       Step 2: save current value of backtxobrec and set a new value for backtxobrec
&dA 
            if c15 <> backtxobrec 
              c15 = backtxobrec 
              backtxobrec = trec 
            end 
&dA 
&dA &d@       Step 3: gather information from current line
&dA 
&dA &d@  line structure = sobx (or optionally sobx|sobx2 ) soby ttext xbyte textlen
&dA 
            line = trm(line) 
            lpt = 3 
            tline = txt(line,[' '],lpt) 
            tline = tline // " " 
            sobx = int(tline) 
            if tline{sub} = "|" 
              sobx2 = int(tline{sub+1..}) 
            else 
              sobx2 = 100 
            end 
            tline = txt(line,[' '],lpt) 
            soby = int(tline) 
            tline = line{lpt..}        /* this is the rest of line, beginning with a " "
&dA 
&dA &d@       Step 4: Determine if the opportunity exists to improve the placement of text
&dA 
&dA &d@           We now have the following information at this point: 
&dA &d@             point_adv = amount by which the x-pointer has advanced to 
&dA &d@                         produce this "group" of objects 
&dA &d@             cdv_adv   = amount by which the x-pointer in the source i-file
&dA &d@                         advanced to produce this note object 
&dA 
&dA &d@           If point_adv is significantly (?) bigger than cdv_adv (i.e., 
&dA &d@             there is now ample space to the left of this note), AND 
&dA &d@             sobx2 is smaller (i.e., more negative) than sobx (i.e., the 
&dA &d@             ideal position of the text is to the left of the practical 
&dA &d@             position), then we can use sobx2 in place of sobx in 
&dA &d@             positioning the text.  
&dA 
&dA &d@           Also, if point_adv is significantly (?) bigger than cdv_adv 
&dA &d@             (i.e., there is now ample space to the left of this note), 
&dA &d@             AND the sobx2 &dEfrom the previous note&d@ containing text &dEwas&d@ 
&dA &d@             &dElarger&d@ (i.e., less negative) &dEthan&d@ the sobx for that note 
&dA &d@             (i.e., the ideal position of the text is to the right of 
&dA &d@             the practical position for the previous note), then we 
&dA &d@             should try to go back to the previous text record(s) and 
&dA &d@             replace the sobx with a saved_sobx2.  To do this, we will 
&dA &d@             need a valid back pointer to &dEnote object&d@ which generated 
&dA &d@             previous text records, and the saved_sobx2 value.  
&dA 
&dA &d@       Step 5: c10 > 0.  Try to determine how best to use this "extra" space.
&dA 
&dA &d@         Step 5a: determine value of sobx (c11) for previous note with text
&dA 
            c10 = point_adv - cdv_adv 
            if c10 > 0 
              if c15 > 0 
                trec = c15 + 1 
TX2: 
                tget [Z,trec] line2 .t3 c11 
                if line2{1} <> "T" 
                  ++trec 
                  goto TX2 
                end 
              else                     /* for corner case of no valid backtxobrec
                c11 = 10000            /*   this guarentees that c12 will be 0
              end 
&dA 
&dA &d@         Step 5b: determine benefit to moving previous text to the right (c12) -->
&dA 
              if saved_sobx2 <> 100 and saved_sobx2 > c11   /* benefit to moving text -->
                c12 = saved_sobx2 - c11 
              else 
                c12 = 0 
              end 
&dA 
&dA &d@         Step 5c: determine benefit to moving current text to the left (c13) <--
&dA 
              if sobx2 <> 100 and sobx2 < sobx 
                c13 = sobx - sobx2                   /* a positive number in this scheme
              else 
                c13 = 0 
              end 
&dA 
&dA &d@         Step 5d: determine how to distribute extra distance.                    
&dA 
              c14 = c12 + c13 
              if c14 > c10 
                if c13 = 0 
                  c12 = c10 
                else 
                  if c12 = 0 
                    c13 = c10 
                  else 
                    c13 = c13 * c10 / c14 
                    c12 = c10 - c13 
                  end 
                end 
              end 
&dA 
&dA &d@       Step 6: Move the horizontal position of text as appropriate               
&dA 
&dA &d@         Step 6a: if c12 > 0,  move previous text position(s) to the right -->
&dA 
              if c12 > 0 
                trec = c15 + 1 
                tget [Z,trec] line2 
                loop 
                  if line2{1} = "T" 
                    c14 = int(line2{3..}) 
                    c14 += c12 
                    line2 = "T " // chs(c14) // line2{sub..} 
                  end 
                  ++trec 
                  tget [Z,trec] line2 
                repeat while "KTkC" con line2{1}   /* "C" added &dA12/18/10&d@ 
              end 
&dA 
&dA &d@         Step 6b: if c13 > 0,  move current text position to the left <-- 
&dA 
              if c13 > 0 
                sobx -= c13 
              end 
            end 
&dA 
&dA &d@       Step 7: Save current value of sobx2
&dA 
            saved_sobx2 = sobx2 
&dA 
&dA &d@       Step 8: Reconstitute this "T" text line without sobx2 and recompute lpt
&dA 
            line = "T " // chs(sobx) // " " // chs(soby) // tline       
            tput [Z,rec-1] ~line 
&dA 
&dA &d@       Step 9: Recompute lpt 
&dA 
&dA &d@  line structure = sobx (or optionally sobx|sobx2 ) soby ttext xbyte textlen
&dA 
            line = trm(line) 
            lpt = 3 
            tline = txt(line,[' '],lpt) 
            tline = tline // " " 
            sobx = int(tline) 
            tline = txt(line,[' '],lpt) 
            soby = int(tline) 
&dA 
&dA &d@       Step 10: if justflag < 2, store line in Y table 
&dA 
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] ~line 
            end 
&dA 
&dA &d@    End of &dA12/19/03&d@ code re-write 
&dA 
            ttext = txt(line,[' '],lpt) 
            xbyte(f12){soby} = txt(line,[' '],lpt) 
            tline = txt(line,[' '],lpt) 
            textlen = int(tline) 
            x = sp + obx + sobx 
            y = sq(f12) + f(f12,9) 
            backloc(f12) = x + textlen 
            uxstart(f12) = x + textlen + mhpar(f12,3) 
            goto CZ 
          end 
&dA 
&dA &d@         S U P E R - O B J E C T S 
&dA &d@         ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@             line structure = supernum htype . . .  
&dA 
          if "HP" con line{1}                 /* "P" added &dA12/18/10&d@ 
            superline = trm(line) 
            lpt = 3 
            tline = txt(line,[' '],lpt) 
            if line{1} = "P"                  /* This code added &dA01/18/11&d@ 
              tline2 = "" 
              tline = tline // pad(2) 
              if tline{1,2} = "0x" 
                tline2 = tline 
                tline = txt(line,[' '],lpt) 
              end 
            end 
            supernum = int(tline) 
*  get superdata for this superobject 
            loop for t11 = 1 to N_SUPER           /* N_SUPER is New &dA02/01/09
              if supermap(f12,t11) = supernum 
                goto WB 
              end 
            repeat 
            tmess = 53 
            perform dtalk (tmess) 
*  t11 = index into superdata 
WB: 
            htype = txt(line,[' '],lpt) 
&dA 
&dA &d@  structure of &dDtie superobject&d@:  4. vertical position of tied note 
&dA &d@                                 5. horiz. displacement from 1st note 
&dA &d@                                 6. horiz. displacement from 2nd note 
&dA &d@                                 7. vacent 
&dA &d@                                 8. vacent 
&dA &d@                                 9. vacent 
&dA &d@                                10. sitflag 
&dA &d@                                11. recalc flag 
&dA 
            if htype = "T" 
              color_flag = 0        /* New &dA12/18/10&d@ 
              if line{1} = "P"      /* We must do this here, because line is changed below
                color_flag = 1 
              end 

              tline = txt(line,[' '],lpt) 
              y1 = int(tline) 
              tline = txt(line,[' '],lpt) 
              x1 = int(tline) + superdata(f12,t11,1) 
              tline = txt(line,[' '],lpt) 
              x2 = int(tline) 
              line = line{lpt+1..} 
              sitflag = int(line)              /* skip Field 7 
              sitflag = int(line{sub+1..})     /* skip Field 8 
              sitflag = int(line{sub+1..})     /* skip Field 9 
              line = line{sub+1..} 
              sitflag = int(line) 
&dA 
&dA &d@    determine first note location (x1,y1) and tspan 
&dA 
&dA &d@       1. Normal case 
&dA 
              if superpnt(f12,t11) = 5 
                if justflag < 2 
                  ++mainyp 
                  tput [Y,mainyp] ~superline 
                end 
                tspan = superdata(f12,t11,3) + x2 - x1 
              end 
&dA 
&dA &d@       2. Continued tie 
&dA 
              if superpnt(f12,t11) = 3 
                x1 = superdata(f12,t11,1) + x2 - mhpar(f12,1) 
                tspan = mhpar(f12,1) 
                if justflag < 2 
*       create mark at beginning of line 
                  ++mainyp 
                  tput [Y,mainyp] J M 0 ~x1  0 0 6913 0 1 ~supernum 
*       create "second half" of super-object 
                  ++mainyp 
                  if color_flag = 1   /* New &dA12/18/10&d@ 
                    if tline2 = "" 
                      tput [Y,mainyp] P ~supernum  T ~y1  0 ~x2  0 0 0 ~sitflag  0
                    else 
                      tput [Y,mainyp] P ~tline2  ~supernum  T ~y1  0 ~x2  0 0 0 ~sitflag  0
                    end 
                  else 
                    tput [Y,mainyp] H ~supernum  T ~y1  0 ~x2  0 0 0 ~sitflag  0
                  end 
                end 
              end 
              supermap(f12,t11) = 0 
              conttie(f12) = 0        /* Code added &dA02/25/97&d@ 
              color_flag = 0          /* New &dA12/18/10&d@ 
              goto CZ 
            end 
&dA 
&dA &d@  structure of &dDbeam superobject&d@: slope vertoff font# #obs bc(1) ...  
&dA 
            if htype = "B" 
              color_flag = 0          /* New &dA12/18/10&d@ 
              if line{1} = "P"        /* We must do this here, because line is changed below
                color_flag = 1 
              end 

              tline = txt(line,[' '],lpt) 
              t3 = int(tline) 
              tline = txt(line,[' '],lpt) 
              t4 = int(tline) 
              temp2 = line{lpt..} 
              temp2 = mrt(temp2) 
              tline = txt(line,[' '],lpt) 
              beamfont = int(tline) 

              tline = txt(line,[' '],lpt) 
              bcount = int(tline) 
              if bcount > MAX_BNOTES 
                t10 = MAX_BNOTES 
                if (Debugg & 0x01) > 0 
                  pute At the present time, this program can only accommodate ~t10  notes
                  pute under one beam.
                end 
                tmess = 54 
                perform dtalk (tmess) 
              end 
              t10 = 1 
              loop for t9 = 1 to bcount 
                bdata(t9,1) = superdata(f12,t11,t10) 
                bdata(t9,2) = superdata(f12,t11,t10+1) 
                temp = txt(line,[' '],lpt) 
                temp = rev(temp) 
                t5 = 6 - len(temp) 
                msk_beamcode(t9) = temp // "00000"{1,t5} 
                t10 += 2 
              repeat 
*   print beam 
              perform setbeam (t3,t4) 

              supermap(f12,t11) = 0 

              if justflag < 2 
                ++mainyp 
                if color_flag = 1   /* New &dA12/18/10&d@ 
                  if tline2 = "" 
                    tput [Y,mainyp] P ~supernum  ~htype  ~t3  ~t4  ~temp2 
                  else 
                    tput [Y,mainyp] P ~tline2  ~supernum  ~htype  ~t3  ~t4  ~temp2
                  end 
                else 
                  tput [Y,mainyp] H ~supernum  ~htype  ~t3  ~t4  ~temp2 
                end 
              end 

              color_flag = 0        /* New &dA12/18/10&d@ 
              goto CZ 
            end 
&dA 
&dA &d@  structure of &dDslur superobject&d@:  4. sitflag 
&dA &d@                                  5. extra horiz. displ. from obj-1 
&dA &d@                                  6. extra vert. displ. from obj-1 
&dA &d@                                  7. extra horiz. displ. from obj-2 
&dA &d@                                  8. extra vert. displ. from obj-2 
&dA &d@                                  9. post horiz. displ.  
&dA &d@                                 10. post vert. displ.  
&dA &d@                                 11. stock slur number 
&dA 
            if htype = "S" 
              tline = txt(line,[' '],lpt) 
              sitflag = int(tline) 
              tline = txt(line,[' '],lpt) 
              y1 = superdata(f12,t11,5) 
              if y1 = 0 
                if justflag < 2 
                  ++mainyp 
                  tput [Y,mainyp] ~superline 
                end 
              else 
                tline = txt(line,[' '],lpt) 
                tline = txt(line,[' '],lpt) 
                a3 = int(tline) 
                x2 = a3 + superdata(f12,t11,3) 
                x1 = hxpar(8) - sp - notesize 
                a1 = x2 - x1 
                if a1 < mhpar(f12,14) 
                  a2 = mhpar(f12,14) - a1 
                  x1 -= a2 
                end 
                tline = txt(line,[' '],lpt) 
                y2 = int(tline)     /* + superdata(f12,t11,4) 
*      create mark at beginning of line (mindful of virtual staff possibility) 
                if justflag < 2 
                  if y1 > 700 and f(f12,12) = 2 
                    ++mainyp 
                    tput [Y,mainyp] J M 0 ~x1  1000 0 6913 0 1 ~supernum 
                    y1 -= 1000 
                  else 
                    ++mainyp 
                    tput [Y,mainyp] J M 0 ~x1  0 0 6913 0 1 ~supernum 
                  end 
*       create "second half" of super-object 
                  ++mainyp 
                  tput [Y,mainyp] H ~supernum  S ~sitflag  0 ~y1  ~a3  ~y2  0 0 0
                end 
              end 
              supermap(f12,t11) = 0 
              goto CZ 
            end 
&dA 
&dA &d@  structure of &dDfigcon super-object&d@:  4. figure level 
&dA &d@                                     5. horiz. disp. from obj1 
&dA &d@                                     6. horiz. disp. from obj2 
&dA 
            if htype = "F" 
              tline = txt(line,[' '],lpt) 
              a3 = int(tline) 
              tline = txt(line,[' '],lpt) 
              x1 = int(tline) 
              tline = txt(line,[' '],lpt) 
              x2 = int(tline)     /* + superdata(f12,t11,3) 
              if justflag < 2 
                if superdata(f12,t11,5) = 0 
                  ++mainyp 
                  tput [Y,mainyp] ~superline 
                  x1 += superdata(f12,t11,1) 
                else 
                  x1 = hxpar(8) - sp 
*       create mark at beginning of line 
                  ++mainyp 
                  tput [Y,mainyp] J M 0 ~x1  0 0 6913 0 1 ~supernum 
*       create "second half" of super-object 
                  ++mainyp 
                  tput [Y,mainyp] H ~supernum  F ~a3  0 ~x2  0 
                end 
              end 
              supermap(f12,t11) = 0 
              goto CZ 
            end 
&dA 
&dA &d@  structure of &dDtuplet super-object&d@:  4. situation flag 
&dA &d@                                     5. tuplet number 
&dA &d@                                     6. horiz. disp. from obj1 
&dA &d@                                     7. vert. disp. from obj1 
&dA &d@                                     8. horiz. disp. from obj2 
&dA &d@                                     9. vert. disp. from obj2 
&dA &d@                                    10. associated beam super-number 
&dA 
            if htype = "X" 
              if justflag < 2 
                ++mainyp 
                tput [Y,mainyp] ~superline 
              end 
              supermap(f12,t11) = 0 
              goto CZ 
            end 
&dA 
&dA &d@    For the rest of the superbjects, please see code 
&dA &d@      at procedure do_more_supers 
&dA 
            perform do_more_supers (t11,htype) 
            supermap(f12,t11) = 0 
            goto CZ 
          end 
CW: 
          if barnum > newbarnum 
            newbarnum = barnum 
          end 
*    mark end of line  
          if justflag < 2 
            ++mainyp 
            tput [Y,mainyp] E ~xbyte(f12) 
          end 
        repeat 
&dA 
&dA &d@    New &dA11/21/07&d@ 
&dA 
        loop for c12 = 1 to new_dircnt 
          save_direct(c12,1) = new_direct(c12,1) 
          save_direct(c12,2) = new_direct(c12,2) 
        repeat 
        save_dircnt = new_dircnt 
        new_dircnt = 0 
&dA                 

        barnum = newbarnum 
&dA 
&dA &d@   Check to see that multiple rest flags are equal 
&dA 
        loop for f12 = 1 to f11 
          f(f12,7) = f(f12,11) 
        repeat 
&dA &d@                                                                   
&dA &d@       Step 8. Typeset bar lines 
&dA &d@                                                                   
        if gbarflag = 1 
          if justflag < 2 
            ++mainyp 
            tput [Y,mainyp] B ~gbar(2)  ~gbar(1)  0 
          end 
          gbarflag = 0 
        end 
        obx = pdist     /* + sp 
        loop for barcount = 1 to delta 
          obx += barpar(barcount,1) 
          a8 = barpar(barcount,3) 
          if barcount = delta 
            if a8 = 9 
              a8 = 5 
            end 
            if a8 = 10 
              a8 = 6 
            end 
          end 
          if justflag < 2 
            ++mainyp 
            tput [Y,mainyp] B ~a8  ~obx  0 
          end 
        repeat 

&dA &d@                                                                              
&dA &d@       Step 9. At this point you have completed the typsetting                
&dA &d@               of a complete system.  Now is the time to look for             
&dA &d@               optional staff lines (i.e., staff line that are                
&dA &d@               flagged to be taken out if they contain nothing                
&dA &d@               but rests.                                                     
&dA 
&dA &d@        New code (&dA12/24/03&d@) added to implement optional staff lines 
&dA 

        if justflag < 2 
          c16 = 0 
          tf11 = f11                        /* number of lines in system; initially f11
          loop for c8 = 1 to f11 
            tsq(c8) = sq(c8) 
            tvst(c8) = vst(c8) 
            tnotesize(c8) = f(c8,14) 
          repeat 

TAKEOUT: 
          y2p = mainyp 
          c9 = 0 
          c10 = 0 
          c11 = 0 
          c12 = 0 
          c13 = 0 

          loop for y3p = y1p to y2p 
            tget [Y,y3p] line 
            if line{1} = "S" 
              c10 = y3p 
            end 
            if line{1} = "L" or line{1} = "l"     /* "l" added &dA12/18/05&d@ 
              ++c9 
              c13 = 0 
              c11 = y3p 
            end 
            if line{1} = "E" 
              c12 = y3p 
              if c13 = 0 or type1_dflag(c9) = ON or type2_dflag(c9) = ON    /* modified &dA01/06/04
&dA 
&dA &d@      Step E-1:  Modify System line 
&dA 
                tget [Y,c10] line2 
                sub = 3 
                c8 = int(line2{sub..})            /* 0 
                c8 = int(line2{sub..})            /* system x 
                c8 = int(line2{sub..})            /* system y 
                c8 = int(line2{sub..})            /* system length 
                c6 = sub 
                c8 = int(line2{sub..})            /* system height 

                if tf11 = 1 
                  tmess = 55 
                  perform dtalk (tmess) 
                end 

                if c9 < tf11 
                  c14 = tsq(c9+1) - tsq(c9) 
                else 
                  c14 = tsq(tf11) - tsq(tf11-1) 

                  c14 += 4 * tnotesize(tf11)      /* staff line thickness for tf11
                  c14 -= 4 * tnotesize(tf11-1)    /* staff line thickness for tf11-1
                  if tvst(tf11) > 0 
                    c14 += tvst(tf11)             /* 2nd line for tf11 
                  end 
                  if tvst(tf11-1) > 0 
                    c14 -= tvst(tf11)             /* 2nd line for tf11-1 
                  end 

                end 
                c8 -= c14                         /* takeout on this "pass" 
                c16 += c14                        /* cumulative total takeout

                c7 = int(line2{sub..})            /* number of parts 
                --c7 

                line2 = line2{1,c6} // chs(c8) // " " // chs(c7) // line2{sub..}
                sub = 1 
                loop for c8 = 1 to c9 
                  if line2{sub..} con "." 
                    ++sub 
                  else 
                    if line2{sub..} con "," 
                      ++sub 
                    else 
                      if line2{sub..} con ":" 
                        ++sub 
                      else 
                        if line2{sub..} con ";" 
                          ++sub 
                        end 
                      end 
                    end 
                  end 
                repeat 
                --sub 
                temp = line2{sub-1,3} 
                line2 = line2 // " " 
MTK: 
                if line2{sub-1} = "(" and line2{sub+1} = ")" 
                  line2 = line2{1,sub-2} // line2{sub} // line2{sub+2..} 
                  --sub 
                  goto MTK 
                end 
                if line2{sub-1} = "[" and line2{sub+1} = "]" 
                  line2 = line2{1,sub-2} // line2{sub} // line2{sub+2..} 
                  --sub 
                  goto MTK 
                end 
                if line2{sub-1} = "{" and line2{sub+1} = "}" 
                  line2 = line2{1,sub-2} // line2{sub} // line2{sub+2..} 
                  --sub 
                  goto MTK 
                end 
                line2 = line2{1,sub-1} // line2{sub+1..} 

                if line2 con "[" 
                  if line2{mpt+1} = "]" 
                    line2 = line2{1,mpt-1} // line2{mpt+2..} 
                  end 
                end 
                if line2 con "{" 
                  if line2{mpt+1} = "}" 
                    line2 = line2{1,mpt-1} // line2{mpt+2..} 
                  end 
                end 

                tput [Y,c10] ~line2 
&dA 
&dA &d@      Step E-2:  Eliminate the records between  c11  and  c12; also adjust all Line records
&dA 
                c15 = c12 - c11 + 1 
                loop for c14 = c12 + 1 to y2p 
                  tget [Y,c14] line2 
                  if line2{1} = "L" or line2{1} = "l"    /* "l" added &dA12/18/05
                    c8 = int(line2{3..}) 
                    if c9 < tf11 
                      c8 = c8 + tsq(c9) - tsq(c9+1) 
                    end 
                    line2 = line2{1} // " " // chs(c8) // line2{sub..}  /* Modified &dA12/18/05
                  end 
                  tput [Y,c14-c15] ~line2 
                repeat 
                mainyp -= c15 
&dA 
&dA &d@      Step E-4:  If c9 = 1, turn on the measure numbers for the new top line
&dA &d@                            and turn on any "top line" directives that might
&dA &d@                            be present in the line    
&dA &d@                                                      
                if c9 = 1 
                  loop for c14 = c11 to mainyp 
                    tget [Y,c14] line2 
                    line2 = line2 // pad(40) 
                    if line2{1,2} = "W " 
                      c8 = int(line2{2..})             /* x offset 
                      c8 = int(line2{sub..})           /* y offset 
                      c7 = sub                         /* c7 -> space before font number
                      c8 = int(line2{sub..}) 
                      if c8 = 0                        /* directive has been "turned off"
                        c17 = sub                      /* c17 -> space after font number
                        if line2{c17+1} = "(" 
                          c8 = int(line2{c17+2..})     /* proper font is in ()
                          if c8 <> 0 
                            c17 = sub + 1              /* c17 -> space after ")"
                          else 
                            c8 = M_NUM_FONT 
                          end 
                        else 
                          c8 = M_NUM_FONT 
                        end 
                        line2 = line2{1,c7} // chs(c8) // line2{c17..} 
                        tput [Y,c14] ~line2 
                      end 
                    else 
                      if line2{1} = "E"                /* Exit loop 
                        c14 = mainyp 
                      end 
                    end 
                  repeat 
                end 
&dA 
&dA &d@      Step E-5:  Adjust tsq(.), tvst(.), tnotesize(.), bottom_sq, tf11, 
&dA &d@                   type1_dflag, type2_dflag, to match with system of 1 fewer lines.
&dA &d@                                                      
                if c9 < tf11 
                  c10 = tsq(c9+1) - tsq(c9) 
                  loop for c8 = c9 + 1 to tf11 
                    tsq(c8-1) = tsq(c8) - c10 
                    tvst(c8-1) = tvst(c8) 
                    tnotesize(c8-1) = tnotesize(c8) 
                    type1_dflag(c8-1) = type1_dflag(c8)        /* New &dA01/06/04
                    type2_dflag(c8-1) = type2_dflag(c8)        /*  "     " 
                  repeat 
                end 
                --tf11 
                bottom_sq = tsq(tf11) 
&dA 
&dA &d@      Step E-6:  Circle back to top of process; look for more lines to take out
&dA 
                goto TAKEOUT 
              end 
            end 
&dA 
&dA &d@      This "J" section looks for legitimate musical notation in the line; 
&dA &d@        sets c13 = 1, if found. 
&dA 
            if line{1} = "J" 
              if "GQNRr" con line{3}                   /* New &dA10/28/07&d@ 
                if line{3} <> "R" and line{3} <> "r"   /* New &dA10/15/07&d@ 
                  c13 = 1 
                else 
                  if line{3,3} <> "R 9" and line{3,3} <> "r 9"   /* New &dA10/15/07
                    if line{3} <> "r"                            /* New &dA10/15/07
                      c13 = 1 
                    end 
                  else 
                    sub = 7 
                    c8 = int(line{sub..})    /* obx 
                    c8 = int(line{sub..})    /* oby 
                    c8 = int(line{sub..})    /* pcode 
                    c8 = int(line{sub..})    /* "1" 
                    c8 = int(line{sub..})    /* inctype 
                    if c8 <> 10001 and line{3} <> "r"            /* New &dA10/15/07
                      c13 = 1 
                    end 
                  end 
                end 
              end 
            end 
          repeat 
&dA 
&dA &d@   Cleanup Section:  Fix all "stray" Q records and 10001 inctypes 
&dA 
          loop for y3p = y1p to y2p 
            tget [Y,y3p] line 
            if line{1,3} = "Q R" or line{1,3} = "Q r"     /* New &dA10/15/07&d@ 
              line = "J R " // line{5..}                  /* New &dA10/15/07&d@ 
              tput [Y,y3p] ~line 
            end 
            if line{1,6} = "J R 9 " or line{1,6} = "J r 9 "   /* New &dA10/15/07
              sub = 7 
              c8  = int(line{sub..})    /* obx 
              c9  = int(line{sub..})    /* oby 
              c10 = int(line{sub..})    /* pcode 
              c11 = int(line{sub..})    /* "1" 
              c11 = int(line{sub..})    /* inctype 
              if c11 = 10001 
                line = "J R 9 " // chs(c8) // " " // chs(c9) // " " // chs(c10) // " 1 0" // line{sub..}
                tput [Y,y3p] ~line 
              end 
            end 
&dA 
&dA &d@    /* New &dA10/15/07&d@ 
&dA 
             if line{1,3} = "J r" 
               line = "J R " // line{5..}                  /* New &dA10/15/07&d@ 
               tput [Y,y3p] ~line 
             end 
&dA    
          repeat 
&dA 
&dA &d@   Cleanup, part II:  Re-set bottom of system 
&dA 
          if c16 > 0 
            sys_bottom -= c16 
          end 
        end 
&dA 
&dA &d@   End of &dA12/24/03&d@ addition 
&dA 
        if justflag < 2 
          ++psysnum 
        end 
&dA &d@                                                                  
&dA &d@      Step 10. Now we have the final sq(.)'s and we can check to  
&dA &d@               see of we have "overrun" the bottom of the page.   
&dA &d@               If so, we need to start a new page and reset the   
&dA &d@               height of the system to top of the page.  If this  
&dA &d@               is the first system on the first page, and we have 
&dA &d@               overrun the bottom, the program needs to report    
&dA &d@               this condition and HALT.                           
&dA 
&dA &d@    New page control code &dA12/24/03&d@ 
&dA 
        if justflag < 2 
          c16 = sys_bottom 
&dA 
&dA &d@     Step 0:  Report on progress
&dA 
          if (Debugg & 0x0a) > 0 
            pute .w3 ~(page+1)  .w1 measure ~mnum 
          end 

          if c16 > lowerlim 
&dA 
&dA &d@     Step 1:  Setup new page and tranfer all but the last system 
&dA 
            page = page + 1 
            if page < 10 
              outfile = outlib // "/0" // chs(page) 
            else 
              outfile = outlib // "/" // chs(page) 
            end 
            t6 = sv_mainyp 
            if t6 = 1 
              t6 = mainyp 
            end 

            if t6 > 0 
              perform output_page (t6) 
            else 
              --page 
            end 
&dA 
&dA &d@     Step 2:  Move last system to top of table; fix system line.  
&dA &d@                There will be a new value of mainyp 
&dA 
            treset [T] 
            c14 = 1 
            c15 = t6 + 1 
            if t6 < mainyp 
              tget [Y,c15] line 
              c10 = int(line{3..})         /* 0 
              c11 = int(line{sub..})       /* x co-ordinate of system on page
              c12 = int(line{sub..})       /* y co-ordinate of system on page
              line = line{sub..} 
              c13 = c12 - toplim           /* amount by which system is moved "up"
              c12 = toplim 
              line = "S " // chs(c10) // " " // chs(c11) // " " // chs(c12) // line
              tput [T,c14] ~line 

              loop for c15 = sv_mainyp + 2 to mainyp 
                tget [Y,c15] line 
                ++c14 
                tput [T,c14] ~line 
              repeat 
            else 
              c14 = 0 
            end 
            treset [Y] 
&dA 
&dA &d@     Step 3:  Load last system into top of Y table.  Increment mainyp 
&dA 
            loop for mainyp = 1 to c14 
              tget [T,mainyp] line 
              tput [Y,mainyp] ~line 
            repeat 
            mainyp = c14 
&dA 
&dA &d@     Step 4:  Adjust value of bottom_sq  (sq(f11)) 
&dA 
            bottom_sq -= c13 
            sys_bottom -= c13 
          end 
        end 
&dA   

&dA &d@                                                                  
&dA &d@      Step 11. If task is not complete, jump to top of general    
&dA &d@               music system loop                                  
&dA &d@                                                                  

        if endflag = 1 
          goto FINE 
        end 
        goto CHH 
&dA &d@                                                                  
&dA &d@        IV. End of program                                        
&dA &d@                                                                  
&dA &d@            Normal exit                                           
&dA &d@                                                                  
FINE: 
        if justflag < 2 
          if mainyp > 0 
            page = page + 1 
            if page < 10 
              outfile = outlib // "/0" // chs(page) 
            else 
              outfile = outlib // "/" // chs(page) 
            end 
            old_sys_bottom = 0                 /* do this for last page only
            perform output_page (mainyp) 
          end 
        end 

        if justflag > 1 
          if (Debugg & 0x0a) > 0 
            pute 
          end 
&dA 
&dA &d@    New code &dA05/28/05&d@ for mid-movement justification 
&dA 
          t1 = 0 
          t2 = 1 
          start_sys = 0 
          start_look = 1 
&dA 
&dA &d@     New code &dA10/15/07&d@ to fix a corner case.  I actually think there may 
&dA &d@     be more to it than this, but this fix is a start.  
&dA 
          loop for t9 = 1 to syscnt 
            if sysbarpar(t9,5) > sysbarpar(t9,1) 
              sysbarpar(t9,5) = 0 
            end 
          repeat 
          loop for t9 = 1 to syscnt 
            if sysbarpar(t9,5) > 0 
              ++t1 

              if start_sys = 0 
                if sysbarpar(t9,5) < sysbarpar(t9,1) 
                  new_syscnt(t1) = t9 
                  if new_maxsystems(t1) = 0 
                    new_maxsystems(t1) = t9 
                  end 
                  start_sys = t1 
                  start_look = t2 

                else 
                  if t9 = syscnt 
                    start_sys = t1 
                    start_look = t2 

                    new_syscnt(t1) = syscnt 
                    if new_maxsystems(t1) = 0 
                      new_maxsystems(t1) = syscnt 
                    end 
                  end 
                end 
                t2 = t9 + 1 
              end 
            end 
HERE: 

          repeat 

          if t1 < 2 
            goto OLD_JUST 
          end 

          section_cnt = t1 

          if (Debugg & 0x0a) > 0 
            pute Execute New Just 
          end 

          mspace(mcnt) += deadspace * 100000 
          t10 = 1 
          loop for t9 = 1 to mcnt 
            if mspace(t9) > 100000 
              t11 = mspace(t9) / 100000 
              mspace(t9) = rem 
              mspace2(t9) = rem 
              loop for t7 = t10 to t9 
                mspace(t7) -= t11 
              repeat 
              loop for t7 = t9 to t10 + 1 step -1 
                mspace(t7) -= mspace(t7-1) 
              repeat 
              t10 = t9 + 1 
            else 
              mspace2(t9) = mspace(t9) 
            end 
          repeat 

          loop for t1 = start_sys to section_cnt 
            if no_action = t1 
              no_action = 0 
              goto NEXT_JUST 
            end 

            t10 = 0 
            t11 = 0 
            loop for t9 = start_look to new_syscnt(t1) 
              t10 += sysbarpar(t9,2) 
              ++t11 
            repeat 
            if t11 > 0 
              average_extra = t10 / t11 
            else 
              goto REALWORK                        /* New &dA11/23/07&d@    Another cluge.
            end 

            if new_syscnt(t1) > new_maxsystems(t1) 

              if (Debugg & 0x0a) > 0 
                pute We have inadvertantly overstepped our target size for section ~t1
              end 
              ++sysbarpar(lastk,3) 
              new_start_look = lastk + 1 
              start_look = lastk + 1 
              if old_extra < 2 * average_extra or lastk >= new_syscnt(t1) - 1
                if (Debugg & 0x0a) > 0 
                  pute We must go back to a previous solution for this section.
                end 
                no_action = t1 
                goto REALWORK 
              end 

              t10 = 1000000 
              t11 = 0 
              loop for t9 = start_look to new_syscnt(t1) 
                if old_sysbarpar(t9,2) < t10 
                  t11 = t9 
                  t10 = old_sysbarpar(t9,2) 
                end 
              repeat 
              if t10 = 1000000 
                if (Debugg & 0x0a) > 0 
                  pute No more situations can be found to improve the layout for
                  pute this section.  We must use the present configuration.
                end 
                goto NEXT_JUST 
              end 

              if (Debugg & 0x0a) > 0 
                pute We will try advancing a measure from system ~t11 
              end 
              justflag = 3 
              lastk = t11 
              sysbarpar(t11,3) = old_sysbarpar(t11,1) - 1 
              goto REALWORK 
            end 

            t2 = new_syscnt(t1) 
            t4 = mcnts(t2) + 1 

            t3 = sysbarpar(t2,5) + mcnts(t2) 
            t3 = rmarg - mspace2(t3) 
&dA 
&dA &d@     Step 1: if sysbarpar(t2,2) < 0, then automatically move measure to next system
&dA 
            if sysbarpar(t2,2) < 0 
              t11 = t2 
              if (Debugg & 0x0a) > 0 
                pute The current configuration has too many bars on the last line of
                pute of this section.  We must move the final bar forward to the next section.
                pute System ~t11  is the one affected.  We will recalculate with this change.
              end 
              justflag = 3 
              lastk = t11 
              sysbarpar(t11,3) = sysbarpar(t11,1) - 1 
              goto REALWORK 
            end 

            if (Debugg & 0x0a) > 0 
              pute Currently there are ~sysbarpar(t2,1)  bars on the last system in
              pute   section ~t1 , and ~sysbarpar(t2,2)  units of extra space on the line.
            end 
            old_extra = sysbarpar(t2,2) 
&dA 
&dA &d@     Step 2: if number of bars is currect and distribution is average, then 
&dA &d@               this section is finished 
&dA 
            if sysbarpar(t2,1) <= sysbarpar(t2,5) 
              if sysbarpar(t2,2) < average_extra 
                if (Debugg & 0x0a) > 0 
                  pute It turns out that this is less than the average for all of the
                  pute systems in this section.  In this case, we should not try to
                  pute reconfigure the systems, but should go with the present configuration.
                end 
                goto NEXT_JUST 
              end 
            end 
&dA 
&dA &d@     Step 3: if number of bars is currect and this section has only one system, them
&dA &d@               this section is finished 
&dA 
            if sysbarpar(t2,1) <= sysbarpar(t2,5) 
              if t1 = 1 
                t10 = new_syscnt(t1) 
              else 
                t10 = new_syscnt(t1) - new_syscnt(t1-1) 
              end 
              if t10 = 1 
                if (Debugg & 0x0a) > 0 
                  pute This section consists of only a single line.  We will justify.
                  pute 
                end 
                goto NEXT_JUST 
              end 
            end 
&dA 
&dA &d@     Step 4: Look at option of throwing a measure from the previous system onto
&dA &d@               last system of this section. 
&dA 
            t10 = 0 
            loop for t4 = 1 to t2 - 1 
              t10 += sysbarpar(t4,1) 
            repeat 

            if t10 > 0 
              if (Debugg & 0x0a) > 0 
                pute Throwing a measure from the previous system onto the last line
                pute would add ~mspace(t10)  units to the line.  
              end 
            end 
&dA 
&dA &d@     Step 4a: Do if only if the average can be improved 
&dA 
            if (average_extra > sysbarpar(t2,2)) or (t10 = 0) 
              if (Debugg & 0x0a) > 0 
                pute Currently, the computed average_extra space = ~average_extra , and this
                pute is greater than the number of extra units ~sysbarpar(t2,2)  on the
                pute last system, so moving forward a measure will not improve the situation.
              end 
            else 
&dA 
&dA &d@     Step 4b: Do if only if added space fits              
&dA 
              if mspace(t10) > t3 
                if (Debugg & 0x0a) > 0 
                  pute As it turns out, the amount of space ~mspace(t10)  added to the
                  pute to the last system exceeds the available space ~t3  so
                  pute no forward movement is possible at this time.  
                end 
              else 
&dA 
&dA &d@     Step 4c: Look backward through systems for the one with the least extra space
&dA &d@                (since we are going to be increasing this space) 
&dA 
                t7 = mspace(t10) 
                t10 = 1000000 
                t11 = 0 

                t6 = start_look 
                if new_start_look > t6 
                  t6 = new_start_look 
                end 

                loop for t9 = t6 to t2 - 1 
                  if sysbarpar(t9,4) < t10 
                    a4 = abs(sysbarpar(t9,2) - sysbarpar(t2,2)) 
                    a5 = abs(sysbarpar(t9,4) - sysbarpar(t2,2) + t7) 
                    if a4 > a5 
                      t11 = t9 
                      t10 = sysbarpar(t9,4) 
                    end 
                  end 
                repeat 
&dA 
&dA &d@     Step 4d: Only if t10 <> 1000000 has a prospect been found 
&dA 
                if t10 <> 1000000 
                  if (Debugg & 0x0a) > 0 
                    pute System ~t11  is the best system from which to advance a measure.
                    pute We will recalculate with this change.  
                  end 
                  justflag = 3 
                  lastk = t11 
                  sysbarpar(t11,3) = sysbarpar(t11,1) - 1 
                  goto REALWORK 
                end 
              end 
            end 
&dA 
&dA &d@     Step 5: If there are extra measures on the last system, then move one of these
&dA &d@               into the next section.  
&dA 
            if sysbarpar(t2,1) > sysbarpar(t2,5) 
              t6 = sysbarpar(t2,1) - sysbarpar(t2,5) 
              t11 = t2 
              if (Debugg & 0x0a) > 0 
                pute Section ~t1  has ~t6  extra bars in the last line.  We need to throw one
                pute these to the next section.  
                pute System ~t11  is the one affected.  We will recalculate with this change.
              end 
              justflag = 3 
              lastk = t11 
              sysbarpar(t11,3) = sysbarpar(t11,1) - 1 
              goto REALWORK 
            end 
&dA 
&dA &d@     Step 6: Follow normal procedure 
&dA 
            if (Debugg & 0x0a) > 0 
              pute Normal procedure being followed 
              pute Currently there are ~sysbarpar(t2,1)  bars on the last system in
              pute   section ~t1 , and ~t3  units of extra space on the line.
            end 
            old_extra = sysbarpar(t2,2) 

            if sysbarpar(t2,2) < average_extra 
              if (Debugg & 0x0a) > 0 
                pute It turns out that this is less than the average for all of the
                pute systems in this section.  In this case, we should not try to
                pute reconfigure the systems, but should go with the present configuration.
              end 
              goto NEXT_JUST 
            end 

            if t1 = 1 
              t10 = new_syscnt(t1) 
            else 
              t10 = new_syscnt(t1) - new_syscnt(t1-1) 
            end 
            if t10 = 1 
              if (Debugg & 0x0a) > 0 
                pute This section consists of only a single line.  We will justify.
                pute 
              end 
              goto NEXT_JUST 
            end 

            t10 = 0 
            loop for t4 = 1 to t2 - 1 
              t10 += sysbarpar(t4,1) 
            repeat 

            if (Debugg & 0x0a) > 0 
              pute Throwing a measure from the previous system onto the last line
              pute would add ~mspace(t10)  units to the line.  
            end 

            if mspace(t10) > sysbarpar(syscnt,2) 
              if (Debugg & 0x0a) > 0 
                pute Since this is more than we can use, we must go with the present
                pute configuration for this section.  We will justify the current last line.
                pute 
              end 
              goto NEXT_JUST 
            else 

              t7 = mspace(t10) 
              t10 = 1000000 
              t11 = 0 

              t6 = start_look 
              if new_start_look > t6 
                t6 = new_start_look 
              end 

              loop for t9 = t6 to t2 - 1 
                if sysbarpar(t9,4) < t10 
                  a4 = abs(sysbarpar(t9,2) - sysbarpar(t2,2)) 
                  a5 = abs(sysbarpar(t9,4) - sysbarpar(t2,2) + t7) 
                  if a4 > a5 
                    t11 = t9 
                    t10 = sysbarpar(t9,4) 
                  end 
                end 
              repeat 

              if t10 = 1000000 
                if (Debugg & 0x0a) > 0 
                  pute No more situations can be found to improve the layout.  We must use the
                  pute present configuration for this section.   We will justify the current
                  pute last line.  
                end 
                goto NEXT_JUST 
              end 

              if (Debugg & 0x0a) > 0 
                pute System ~t11  is the best system from which to advance a measure.
                pute We will recalculate with this change.  
              end 
              justflag = 3 
              lastk = t11 
              sysbarpar(t11,3) = sysbarpar(t11,1) - 1 
              goto REALWORK 
            end 

NEXT_JUST: 
            if new_maxsystems(t1+1) = 0 
              new_maxsystems(t1+1) = new_syscnt(t1+1) 
            end 
          repeat 
          justflag = 1 
          goto REALWORK 

&dA     End of 05/28/05 code for mid-movement justification      

OLD_JUST: 
          t10 = 0 
          loop for t9 = 1 to syscnt 
            t10 += sysbarpar(t9,2) 
          repeat 
          average_extra = t10 / syscnt 

          if justflag = 3 and syscnt > maxsystems 
            if (Debugg & 0x0a) > 0 
              pute We have inadvertantly overstepped our target size.  
            end 
            ++sysbarpar(lastk,3) 
            start_look = lastk + 1 
            if old_extra < 2 * average_extra or lastk >= syscnt - 1 
              if (Debugg & 0x0a) > 0 
                pute We must go back to a previous solution.  
              end 
&dA 
&dA &d@    &dA11/20/06&d@  Restore sysbarpar parameters from a solution that worked 
&dA 
              loop for t9 = 1 to maxsystems 
                sysbarpar(t9,1) = sav_sysbarpar(t9,1) 
                sysbarpar(t9,2) = sav_sysbarpar(t9,2) 
                sysbarpar(t9,3) = sav_sysbarpar(t9,3) 
                sysbarpar(t9,4) = sav_sysbarpar(t9,4) 
                sysbarpar(t9,5) = sav_sysbarpar(t9,5) 
              repeat 
&dA               &d@ End of &dA11/20/06&d@ Addition 

              justflag = 1 
              goto REALWORK 
            end 

            t10 = 1000000 
            t11 = 0 
            loop for t9 = start_look to maxsystems 
              if old_sysbarpar(t9,2) < t10 
                t11 = t9 
                t10 = old_sysbarpar(t9,2) 
              end 
            repeat 
            if t10 = 1000000 
              if (Debugg & 0x0a) > 0 
                pute No more situations can be found to improve the layout.  We must
                pute use the present configuration.   We will justify the current last line.
              end 
              justflag = 1 
              goto REALWORK 
            end 

            if (Debugg & 0x0a) > 0 
              pute We will try advancing a measure from system ~t11 
            end 
            justflag = 3 
            lastk = t11 
            sysbarpar(t11,3) = old_sysbarpar(t11,1) - 1 
            goto REALWORK 
          end 

          mspace(mcnt) += deadspace * 100000 
          t10 = 1 
          loop for t9 = 1 to mcnt 
            if mspace(t9) > 100000 
              t11 = mspace(t9) / 100000 
              mspace(t9) = rem 
              loop for t7 = t10 to t9 
                mspace(t7) -= t11 
              repeat 
              loop for t7 = t9 to t10 + 1 step -1 
                mspace(t7) -= mspace(t7-1) 
              repeat 
              t10 = t9 + 1 
            end 
          repeat 
          if justflag = 2 
            maxsystems = syscnt 
          end 

          if (Debugg & 0x0a) > 0 
            pute Currently there are ~sysbarpar(syscnt,1)  bars on the last 
            pute system and ~sysbarpar(syscnt,2)  units of extra space on the line.
          end 
          old_extra = sysbarpar(syscnt,2) 

          if sysbarpar(syscnt,2) < average_extra 
            if (Debugg & 0x0a) > 0 
#if DMUSE 
              putc It turns out that this is &dAless than&d@ the average for all of the
              putc systems in this piece.  In this case, we should not try to
              putc reconfigure the systems, but should go with the present configuration.
#else 
              pute It turns out that this is less than the average for all of the
              pute systems in this piece.  In this case, we should not try to
              pute reconfigure the systems, but should go with the present configuration.
#endif 
            end 
            justflag = 1 
            goto REALWORK 
          end 
&dA 
&dA &d@    &dA11/20/06&d@  Saving sysbarpar parameters from a solution that worked 
&dA 
          loop for t9 = 1 to maxsystems 
            sav_sysbarpar(t9,1) = sysbarpar(t9,1) 
            sav_sysbarpar(t9,2) = sysbarpar(t9,2) 
            sav_sysbarpar(t9,3) = sysbarpar(t9,3) 
            sav_sysbarpar(t9,4) = sysbarpar(t9,4) 
            sav_sysbarpar(t9,5) = sysbarpar(t9,5) 
          repeat 
&dA               &d@ End of &dA11/20/06&d@ Addition 

          t10 = mcnt - sysbarpar(syscnt,1) 
          if t10 = 0 
            if (Debugg & 0x0a) > 0 
              pute Single line.  We will justify.  
            end 
            justflag = 1 
            goto REALWORK 
          end 

          if (Debugg & 0x0a) > 0 
            pute Throwing a measure from the previous system onto the last line
            pute would add ~mspace(t10)  units to the line.  
          end 

          if mspace(t10) > sysbarpar(syscnt,2) 
            if (Debugg & 0x0a) > 0 
              pute Since this is more than we can use, we must go with the present
              pute configuration.  We will justify the current last line.  
            end 
            justflag = 1 
            goto REALWORK 
          else 
            t7 = mspace(t10) 
            t10 = 1000000 
            t11 = 0 
            loop for t9 = start_look to syscnt - 1 
              if sysbarpar(t9,4) < t10 
                a4 = abs(sysbarpar(t9,2) - sysbarpar(syscnt,2)) 
                a5 = abs(sysbarpar(t9,4) - sysbarpar(syscnt,2) + t7) 
                if a4 > a5 
                  t11 = t9 
                  t10 = sysbarpar(t9,4) 
                end 
              end 
            repeat 
            if t10 = 1000000 
              if (Debugg & 0x0a) > 0 
                pute No more situations can be found to improve the layout.  We must
                pute use the present configuration.   We will justify the current last line.
              end 
              justflag = 1 
              goto REALWORK 
            end 
            if (Debugg & 0x0a) > 0 
              pute System ~t11  is the best system from which to advance a measure.
              pute We will recalculate with this change.  
            end 
            justflag = 3 
            lastk = t11 
            sysbarpar(t11,3) = sysbarpar(t11,1) - 1 
          end 
          goto REALWORK 
        end 

        if (Debugg & 0x0a) > 0 
          pute Total pages = ~page  in ~outlib 
        end 

      return  
&dA 
&dA &d@   End of mskpage processing music data 
&dA 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³M*  2. setbeam (@k,@m)                                                          ³
&dA &d@³                                                                                ³
&dA &d@³    Purpose:  Determine the first stem length and slope of                      ³
&dA &d@³              the beam.                                                         ³
&dA &d@³                                                                                ³
&dA &d@³    Inputs:   bcount        = number of notes under beam                        ³
&dA &d@³              bdata(.,1)    = x-position of note                                ³
&dA &d@³              bdata(.,2)    = y-position of note                                ³
&dA &d@³              msk_beamcode(.)   = beam code                                     ³
&dA &d@³              f12           = staff number                                      ³
&dA &d@³                                                                                ³
&dA &d@³                   beam code = 6 digit number (string)                          ³
&dA &d@³                                                                                ³
&dA &d@³                      0 = no beam                                               ³
&dA &d@³                      1 = continue beam                                         ³
&dA &d@³                      2 = begin beam                                            ³
&dA &d@³                      3 = end beam                                              ³
&dA &d@³                      4 = forward hook                                          ³
&dA &d@³                      5 = backward hook                                         ³
&dA &d@³                      6 = repeater                                              ³
&dA &d@³                      7 = begin repeated beam                                   ³
&dA &d@³                      8 = end repeated beam                                     ³
&dA &d@³                                                                                ³
&dA &d@³                      100000's digit = eighth level beams                       ³
&dA &d@³                       10000's digit = 16th level beams                         ³
&dA &d@³                        1000's digit = 32nd level beams                         ³
&dA &d@³                         100's digit = 64th level beams                         ³
&dA &d@³                          10's digit = 128th level beams                        ³
&dA &d@³                           1's digit = 256th level beams                        ³
&dA &d@³                                                                                ³
&dA &d@³                                                                                ³
&dA &d@³              @k = stem direction for first note under beam, plus possible      ³
&dA &d@³                     modification to first stem length.  (New &dA05/14/03&d@)         ³
&dA &d@³                                                                                ³
&dA &d@³                     If @k < 100, no modifications present                      ³
&dA &d@³                     If 100 < @k < 10000, @k = @k / 100.                        ³
&dA &d@³                        Lengthen stem length (up or down)                       ³
&dA &d@³                        by @k/10 interline distance (mvpar(2))                  ³
&dA &d@³                     If @k > 10000, @k = @k / 10000.                            ³
&dA &d@³                        Shorten stem length (up or down)                        ³
&dA &d@³                        by @k/10 interline distance (mvpar(2))                  ³
&dA &d@³                                                                                ³
&dA &d@³              @m = stem direction flags for notes under beam                    ³
&dA &d@³                        (or 0 or 1 = all same as @k)                            ³
&dA &d@³              beamfont = font for printing beam                                 ³
&dA &d@³              stemchar = character number for stem                              ³
&dA &d@³              beamh    = height parameter for beams                             ³
&dA &d@³              beamt    = vertical space between beams (normally mvpar(.,32))    ³
&dA &d@³                                                                                ³
&dA &d@³    Outputs:  @k = length of first stem (positive = stem up)                    ³
&dA &d@³              @m = slope of beam                                                ³
&dA &d@³                                                                                ³
&dA &d@³    Internal variables:  @b = y-intercept of beam                               ³
&dA &d@³                         @f = temporary variable                                ³
&dA &d@³                         @g = temporary variable (related to @@g)               ³
&dA &d@³                         @h = temporary variable                                ³
&dA &d@³                         @i = temporary variable                                ³
&dA &d@³                         @j = temporary counter                                 ³
&dA &d@³                         @k = |@m|                                              ³
&dA &d@³                         @n = temporary variable                                ³
&dA &d@³                         @q = temporary counter                                 ³
&dA &d@³                         @s = temporary variable                                ³
&dA &d@³                         @t = temporary variable                                ³
&dA &d@³                         @u = temporary variable                                ³
&dA &d@³                        @@b = vertical range of note set                        ³
&dA &d@³                        @@g = top of staff line                                 ³
&dA &d@³                        @@n = temporary variable                                ³
&dA &d@³                        @@q = temporary variable                                ³
&dA &d@³                    (x1,y1) = temporary coordinates                             ³
&dA &d@³                    (x2,y2) = temporary coordinates                             ³
&dA &d@³                   xbeam(6) = temporary flags concerning whether a secondary    ³
&dA &d@³                                beam is above or below the "backbone"           ³
&dA &d@³                 bstem(.,2) = stem flags for notes under a beam                 ³
&dA &d@³                                1 = stem direction                              ³
&dA &d@³                                2 = mimumum stem length to top of "backbone"    ³
&dA &d@³                                      beam                                      ³
&dA &d@³                 max_pslope = maximum positive slope, based on length           ³
&dA &d@³                 max_nslope = maximum negative slope, based on length           ³
&dA &d@³                                                                                ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure setbeam (@k,@m) 
        int t1,t2,t3
        int @b,@f,@g,@h,@i,@j,@k,@m,@n,@p,@q,@r,@s,@t,@u 
        int @@b,@@g,@@n,@@q,@@t 
        int old@k 
        int m1,m2,tm,fm,sum,minsum,leng,minleng 
        int xminsum,ffm 
        int xbeam(6) 
        int max_pslope,max_nslope 
        int stem_mod 
        int stemchar,beamh,beamt 
        int bstem(MAX_BNOTES,2) 
        int dv3 
        int start_beam(2),stop_beam(2) 

        getvalue @k,@m 

        if beamfont = ors("ffffgghiijjkkllmmnoopprr"{notesize})  /* old "Mbeamfont()"
          stemchar = 59 
          beamh = mvpar(f12,16) 
          beamt = mvpar(f12,32) 
        else 
          stemchar = 187 
          beamh = mvpar(f12,16) * 4 / 5 
          beamt = mvpar(f12,32) * 4 + 3 / 5 
        end 

        t1 = bdata(bcount,1) - bdata(1,1)
        max_pslope = mvpar(f12,3) * hxpar(1) / t1 + 1 
        max_nslope = 0 - max_pslope 

        stem = @k & 0x01                              /* New code &dA05/14/03&d@ 
        stem_mod = @k / INT100 
        if stem_mod > 0 
          if stem_mod >= INT100 
            stem_mod /= INT100 
            stem_mod = stem_mod * mvpar(f12,2) + 5 / 10 
            stem_mod = 0 - stem_mod 
          else 
            stem_mod = stem_mod * mvpar(f12,2) + 5 / 10 
          end 
        end 
&dA 
&dA &d@    Deal with situation where stems go up and down 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        if @m > 1
&dA 
&dA &d@       Get stem directions 
&dA 
          loop for @j = bcount - 1 to 0 step -1 
            @g = bit(@j,@m) 
            if stem = 0 
              ++@g 
              @g &= 0x01 
            end 
            bstem(bcount - @j,1) = @g 
          repeat 
&dA 
&dA &d@       Determine number of "backbone" beams 
&dA 
          @b = 7 
          loop for @j = 1 to bcount 
            if msk_beamcode(@j) con "0" 
              if mpt < @b 
                @b = mpt 
              end 
            end 
          repeat 
          --@b                      /* @b = number of "backbone" beams 
&dA 
&dA &d@       Determine "thickness" of backbone 
&dA 
          @t = 0 
          if @b > 1 
            if @b < 4 
              @t = @b - 1 * mvpar(f12,32) 
            else 
              @t = @b - 1 * mvpar(f12,33) 
            end 
          end 
          @@t = @t + mvpar(f12,31)   /* @@t = thickness of backbone (for mixed stems)
          @t += mvpar(f12,31) >> 1   /* @t = thickness of backbone 
&dA 
&dA &d@       Determine minimum length of stem (to top of backbone) 
&dA 
          loop for @j = 1 to 6 
            if @j <= @b 
              xbeam(@j) = 1 
            else 
              xbeam(@j) = 0 
            end 
          repeat 
          @@b = @b 
          @q = 0 
          @p = 0 
          loop for @j = 1 to bcount 
PT1: 
            if @b < 6 
              if msk_beamcode(@j){@b+1} = "2" or msk_beamcode(@j){@b+1} = "7"
                ++@b 
                if bstem(@j,1) = DOWN 
                  ++@p 
                  xbeam(@b) = 2 
                else 
                  ++@q 
                  xbeam(@b) = 3 
                end 
                goto PT1 
              end 
              if "456" con msk_beamcode(@j){@b+1} 
                ++@b 
                if bstem(@j,1) = DOWN 
                  ++@p 
                  xbeam(@b) = 4 
                else 
                  ++@q 
                  xbeam(@b) = 5 
                end 
                goto PT1 
              end 
            end 
&dA 
&dA &d@        compute minimum "free" length 
&dA 
            if @b < 4 
              bstem(@j,2) = mvpar(f12,10 - @b) / 2 
            else 
              bstem(@j,2) = mvpar(f12,3) 
            end 
&dA 
&dA &d@        add length running thought extra beams 
&dA 
            if bstem(@j,1) = DOWN 
              bstem(@j,2) += @p * mvpar(f12,32) 
            else 
              bstem(@j,2) += @q * mvpar(f12,32) 
              bstem(@j,2) += mvpar(f12,31) >> 1 + @t 
            end 
PT2: 
            if xbeam(@b) = 4                    
              xbeam(@b) = 0 
              --@b 
              --@p 
              goto PT2 
            end 
            if xbeam(@b) = 5                   
              xbeam(@b) = 0 
              --@b 
              --@q 
              goto PT2 
            end 
PT3: 
            if @b > @@b 
              if msk_beamcode(@j){@b} = "3" or msk_beamcode(@j){@b} = "8" 
                if xbeam(@b) = 2 
                  --@b 
                  --@p 
                  goto PT3 
                end 
                if xbeam(@b) = 3 
                  --@b 
                  --@q 
                  goto PT3 
                end 
              end 
            end 
          repeat 
PT4: 

&dA 
&dA &d@     Determine number of staves involved 
&dA 
          @j = 0 
          if f(f12,12) = 2 
            @g = bdata(1,2)
            loop for @j = 2 to bcount 
              if abs(bdata(@j,2) - @g) > 500
                @j = 10000 
              end 
            repeat 
          end 
          if @j = 10000 
&dA 
&dA &d@       Case 1: notes span two staves (grand staff) 
&dA 
            @h = vst(f12) - 1000                  /* correction to bottom staff y-coordinage
            @@g = 0 
            loop for @j = 1 to bcount 
              if bdata(@j,2) > 700
                if bstem(@j,1) = DOWN 
                  if @@g = 0 or @@g = 2 
                    @@g = 2                       /* mixed stems on bottom staff
                  else 
                    @@g = 3 
                  end 
                end 
              else 
                if bstem(@j,1) = UP  
                  if @@g = 0 or @@g = 1 
                    @@g = 1                       /* mixed stems on top staff 
                  else 
                    @@g = 3 
                  end 
                end 
              end 
            repeat 
            if @@g = 0 
              goto TWO_STAFF_NORMAL 
            end 

            if @@g = 3 
              tmess = 56 
              perform dtalk (tmess) 
            end 
            if (Debugg & 0x0a) > 0 
              pute Abnormal case 
              pute Mixed stem directions on a single staff for a beam with notes
              pute two staves.  In this case, we will try to set a horizontal beam.
            end 
&dA &d@                
&dA &d@       Find "level" for backbone 
&dA 
            @s = 100000 
            @u = -100000 
            loop for @j = 1 to bcount 
              if @@g = 2                               /* mixed on bottom staff
                if bdata(@j,2) > 700
                  if bstem(@j,1) = DOWN 
                    if bdata(@j,2) > @u
                      @u = bdata(@j,2)
                    end 
                  else 
                    if bdata(@j,2) < @s
                      @s = bdata(@j,2)
                    end 
                  end 
                end 
              else                                     /* mixed on top staff 
                if bdata(@j,2) < 700
                  if bstem(@j,1) = DOWN 
                    if bdata(@j,2) > @u
                      @u = bdata(@j,2)
                    end 
                  else 
                    if bdata(@j,2) < @s
                      @s = bdata(@j,2)
                    end 
                  end 
                end 
              end 
              if bdata(@j,2) > 700
                bdata(@j,2) = bdata(@j,2) + @h
              end 
            repeat 
            if @@g = 2 
              @s = @s + @h
              @u = @u + @h 
            end 
&dA 
&dA &d@       @s = "highest" note below the beam (stem up) 
&dA &d@       @u = "lowest" note above the beam (stem down) 
&dA 
            @n = @u / mvpar(f12,2) 
            @n = rem 
            @h = mvpar(f12,31) >> 1 
            @i = mvpar(f12,31) - mvpar(f12,41) 

            if @b = 1 
              @j = @s - @u 
              if @j < mvpar(f12,6) 
                tmess = 57 
                perform dtalk (tmess) 
              end 
              if @j = mvpar(f12,6) 
                if @n = 0 
                  @u += mvpar(f12,2) + @i 
                else 
                  @u += mvpar(f12,3) + @h 
                end 
              else 
                if @j = mvpar(f12,7) 
                  if @n = 0 
                    @u += mvpar(f12,4) 
                  else 
                    @u += mvpar(f12,3) + @i 
                  end 
                else 
                  if @j = mvpar(f12,8) and @n <> 0 
                    @u += mvpar(f12,5) 
                  else 
                    @j = @s - @u - @@t 
                    @u += @j >> 1 
                    @u -= mvpar(f12,2) + 3 >> 2 
                    if @@g = 2 
                      @u -= vst(f12) 
                    end 
                    @u = @u + mvpar(f12,8) / mvpar(f12,2) * mvpar(f12,2) - mvpar(f12,6)
                    if @@g = 2 
                      @u += vst(f12) 
                    end 
                    @u += @h 
                  end 
                end 
              end 
            else 
              if @b = 2 
                @j = @s - @u 
                if @j < mvpar(f12,7) 
                  tmess = 57 
                  perform dtalk (tmess) 
                end 
                if @j = mvpar(f12,7) 
                  if @n = 0 
                    @u += mvpar(f12,2) + @i 
                  else 
                    @u += mvpar(f12,3) + @h 
                  end 
                else 
                  if @j = mvpar(f12,8) 
                    if @n = 0 
                      @u += mvpar(f12,2) + @i 
                    else 
                      @u += mvpar(f12,3) + @i 
                    end 
                  else 
                    if @j = mvpar(f12,9) and @n <> 0 
                      @u += mvpar(f12,3) + @i 
                    else 
                      @j = @s - @u - @@t 
                      @u += @j >> 1 
                      @u -= mvpar(f12,2) + 3 >> 2 
                      if @@g = 2 
                        @u -= vst(f12) 
                      end 
                      @u = @u + mvpar(f12,8) / mvpar(f12,2) * mvpar(f12,2) - mvpar(f12,6)
                      if @@g = 2 
                        @u += vst(f12) 
                      end 
                      @u += @h - mvpar(f12,41) 
                    end 
                  end 
                end 
                @u += mvpar(f12,32) 
              else 
                @j = @s - @u - @@t 
                if @j < mvpar(f12,4) 
                  tmess = 57 
                  perform dtalk (tmess) 
                end 
                @u += @j >> 1 
                @u -= mvpar(f12,1) 
                if @@g = 2 
                  @u -= vst(f12) 
                end 
                @u = @u + mvpar(f12,8) / mvpar(f12,2) * mvpar(f12,2) - mvpar(f12,6)
                if @@g = 2 
                  @u += vst(f12) 
                end 
                @u += @@t - mvpar(f12,41) 
              end 
            end 
            leng = bdata(1,2) - @u
            if leng > 0 
              leng += @@t - mvpar(f12,41) 
            end 

            @k = leng 

            if stem_mod <> 0                       /* New code &dA05/14/03&d@ 
              if @k > 0 
                @k += stem_mod 
              else 
                @k -= stem_mod 
              end 
            end 

            @m = 0  
            passback @k,@m 
            return 

TWO_STAFF_NORMAL: 

            loop for @j = 1 to bcount 
              if bdata(@j,2) > 700
                bdata(@j,2) = bdata(@j,2) + @h
              end 
            repeat 
&dA 
&dA &d@       I am going to try a different technique for setting mixed beams.  
&dA &d@       They don't happen very often, so I am going to try "brute force", 
&dA &d@       which will take longer, but should yield more accurate results.  
&dA &d@       Basically, I will test every slope from -8 to +8 and all legal 
&dA &d@       levels.   
&dA 
&dA &d@       1. Determine "highest" pivot point 
&dA 
            @@g = -10000 
            loop for @j = 1 to bcount 
              if bdata(@j,2) > @@g and bstem(@j,1) = DOWN
                @@g = bdata(@j,2)
                @g = @j 
              end 
            repeat 
            @@g += bstem(@g,2) 
            xminsum = 1000000000 
            @h = 10000 
&dA 
&dA &d@       2. For each "vertical" position, try all slopes; find the "best" one 
&dA 
            ffm = LIM1                        /* &dA04/23/03&d@ moved this line north of lable

NEXT_VERT_POS: 

            fm = LIM1   
            minsum = LIM1   
            t1 = max_nslope + 1 
            t2 = max_pslope - 1 
            if t1 < -4 
              t1 = -4 
            end 
            if t2 > 4 
              t2 = 4 
            end 

            if bstem(1,1) = bstem(bcount,1) 
              t1 = 0 
              t2 = 0 
            end 

            if t1 > t2 
              t1 = t2 
            end 

            loop for tm = t1 to t2             /* limiting verticle travel &dA04/23/03
              sum = 0 
              loop for @j = 1 to bcount 
                leng = bdata(@j,1) - bdata(@g,1) * tm / hxpar(1) + @@g - bdata(@j,2)
                leng = abs(leng) 
                if leng < bstem(@j,2) 
                  @j = 10000 
                else 
                  if bstem(@j,1) = DOWN        /* For down stems we are interested
                    leng -= @t                 /* only in length to top of backbone
                  end 

                  if @j = 1 or @j = bcount     /* emphasize end points 
                    sum += leng * leng * 6 
                  else 
                    sum += leng * leng 
                  end 

                end 
              repeat 

              @r = bcount - 1 * tm 
              
              sum = abs(@r) * abs(@r) * abs(tm) / 96 + 120 * sum 
              sum /= 1600 
              if sum < minsum and @j < 10000 
                fm = tm 
                minsum = sum 
              end 
            repeat 

            if minsum = LIM1   
              if ffm = LIM1   
                loop for @j = 1 to bcount 
                  bstem(@j,2) -= mvpar(f12,1) 
                  if bstem(@j,2) < mvpar(f12,2) 
                    tmess = 58 
                    perform dtalk (tmess) 
                  end 
                repeat 
                goto PT4 
              else 
                goto PARS_FOUND 
              end 
            end 
&dA 
&dA &d@       3. Now evaluate the control function for the lengths in this "vertical" position
&dA 
            if minsum < xminsum 
              xminsum = minsum 
              @h = @@g 
              ffm = fm 
            end 

            ++@@g 
            goto NEXT_VERT_POS 
&dA 
&dA &d@       4. Check to see of vertical position has been found 
&dA 
PARS_FOUND: 
            if @h = 10000 
              tmess = 59 
              perform dtalk (tmess) 
            end 
            fm = ffm 
            leng = bdata(1,1) - bdata(@g,1) * fm / hxpar(1) + @h - bdata(1,2)
            if bstem(1,1) = DOWN 
              leng += @t 
            end 
            leng = 0 - leng 
&dA 
&dA &d@        END OF New METHOD 
&dA 
            @k = leng 

            if stem_mod <> 0                       /* New code &dA05/14/03&d@ 
              if @k > 0 
                @k += stem_mod 
              else 
                @k -= stem_mod 
              end 
            end 

            @m = fm 
            passback @k,@m 
            return 

          else 
&dA 
&dA &d@       Case 2: notes are on one stave 
&dA 
            if bdata(1,2) > 700
              loop for @j = 1 to bcount 
                bdata(@j,2) -= 1000
              repeat 
            end 
&dA 
&dA &d@       Check to see if "up-down" distribution of notes allows beam to be drawn
&dA 
            if (Debugg & 0x0a) > 0 
              pute Beam with mixed stem directions on a single staff.  
            end 
&dA 
&dA &d@       I am going to try including the situations: 1-up/many-down and 
&dA &d@       many-up/1-down in the case.  
&dA 
            start_beam(1) = 100000 
            if bcount = 2 
              start_beam(1) = bdata(1,1)
              start_beam(2) = bdata(1,2)
              stop_beam(1)  = bdata(2,1)
              stop_beam(2)  = bdata(2,2)
            else 
              if bstem(1,1) = DOWN 
                t1 = 0 
                t2 = 0 
                t3 = 0 
                loop for @j = 2 to bcount 
                  if bstem(@j,1) = DOWN 
                    t2 = 1
                    if t1 = 1 
                      t1 = 2 
                    end 
                  else 
                    t1 += t2 
                    if t1 = 0 
                      t1 = 1 
                    end 
                  end 
                  t3 += abs(bdata(@j,2) - bdata(@j-1,2))
                repeat 
                if t1 < 2                /* down-up-up...  or ...down-down-up
                  if t3 = mvpar(f12,7) 
                    goto DUAL_MIXED_FLAT 
                  end 
                  goto NOT_DUAL_MIXED 
                end 
              end 

              if bstem(1,1) = UP  
                t1 = 0 
                t2 = 0 
                t3 = 0 
                loop for @j = 2 to bcount 
                  if bstem(@j,1) = UP  
                    t2 = 1
                    if t1 = 1 
                      t1 = 2 
                    end 
                  else 
                    t1 += t2 
                    if t1 = 0 
                      t1 = 1 
                    end 
                  end 
                  t3 += abs(bdata(@j,2) - bdata(@j-1,2))
                repeat 
                if t1 < 2                /* up-down-down...  or ...up-up-down
                  if t3 = mvpar(f12,7) 
                    goto DUAL_MIXED_FLAT 
                  end 
                  goto NOT_DUAL_MIXED 
                end 
              end 
              goto DUAL_MIXED_FLAT 

NOT_DUAL_MIXED: 
              start_beam(1) = bdata(1,1)
              start_beam(2) = bdata(1,2)
              stop_beam(1)  = bdata(bcount,1)
              stop_beam(2)  = bdata(bcount,2)
            end 

            if start_beam(1) <> 100000 
              if stem = UP     
                if start_beam(2) < stop_beam(2) + mvpar(f12,2) 
                  tmess = 60 
                  perform dtalk (tmess) 
                end 
              else 
                if start_beam(2) > stop_beam(2) - mvpar(f12,2) 
                  tmess = 60 
                  perform dtalk (tmess) 
                end 
              end 
              @j = abs(start_beam(2) - stop_beam(2)) / mvpar(f12,1) 
              @h = @b - 1 << 1 
              if @b < 3 
                if stem = UP 
                  if @j + @h > 11                   /* 9 
                    goto DUAL_MIXED_FLAT 
                  end 
                else 
                  if @j + @h > 13                   /* 13 
                    goto DUAL_MIXED_FLAT 
                  end 
                end 
              else 
                if @j + @h > 14                     /* 14 
                  goto DUAL_MIXED_FLAT 
                end 
              end 
              
              @n = stop_beam(1) - start_beam(1) 
              if stem = UP 
                @n -= mhpar(f12,8) 
              else 
                @n += mhpar(f12,8) 
              end  

              @s = mvpar(f12,4) * 30 / @n 
              if @s < 16 and @j + @h < 14                  /* changing 15 to 16
                @j += 2 
                @m = @s 
              else 
                @s = mvpar(f12,2) * 30 / @n                 
                if @s < 20 
                  @u = @s + 1 * @n / 30 
                  if @b < 3 
                    if @u <= mvpar(f12,2) * 12 / 11 
                      ++@s 
                    end 
                  else 
                    if @u <= mvpar(f12,3) 
                      ++@s 
                    end 
                  end 
                  if @s > 15 
                    @s = 15 
                  end 
&dA &d@                 if @s > max_pslope                       /* NOT changed &dA04/23/03
&dA &d@                   @s = max_pslope 
&dA &d@                 end 
                  @m = @s 
                else 
                  goto DUAL_MIXED_FLAT 
                end 
              end 

              @n = start_beam(2) / mvpar(f12,2) 
              @n = rem 

              @p = mvpar(f12,31) >> 1 
              @q = mvpar(f12,31) - mvpar(f12,41) 
              if @b = 1 
                if @n <> 0 
                  if @j < 4 
                    @k = mvpar(f12,3) 
                  else 
                    if @j < 6 
                      @k = mvpar(f12,3) + @p 
                    else 
                      if @j < 8 
                        @k = mvpar(f12,4) 
                        @m >>= 1 
                      else 
                        if @j < 10 
                          @k = mvpar(f12,5) + @p 
                        else 
                          @k = mvpar(f12,6) 
                          @m >>= 1 
                        end 
                      end 
                    end 
                  end 
                else 
                  if @j < 4 
                    @k = mvpar(f12,3) 
                  else 
                    if @j < 6 
                      @m >>= 1 
                      @k = mvpar(f12,3) 
                    else 
                      if @j < 8 
                        @k = mvpar(f12,4) + @p 
                      else 
                        if @j < 10 
                          @k = mvpar(f12,5) 
                          @m >>= 1 
                        else 
                          @k = mvpar(f12,6) + @p 
                        end 
                      end 
                    end 
                  end 
                end 
              else 
                if @b = 2 
                  if @n <> 0 
                    if @j < 4 
                      @k = mvpar(f12,3) + @p 
                    else 
                      if @j < 5 
                        @k = mvpar(f12,3) + @p + mvpar(f12,41) 
                        @m >>= 1 
                      else 
                        if @j < 6 
                          @k = mvpar(f12,5) 
                        else 
                          if @j < 8 
                            @k = mvpar(f12,5) + mvpar(f12,41) 
                          else 
                            @k = mvpar(f12,5) + @p 
                            @m = @m + 1 / 3 
                          end 
                        end 
                      end 
                    end 
                  else 
                    if @j < 4 
                      @k = mvpar(f12,4) 
                    else 
                      if @j < 6 
                        @k = mvpar(f12,4) + @p 
                      else 
                        if @j < 8 
                          @k = mvpar(f12,4) + @p 
                          @m = @m + 1 / 3 
                        else 
                          if @j < 10 
                            @k = mvpar(f12,6) + @p 
                          else 
                            @k = mvpar(f12,6) + @p 
                            @m >>= 1 
                          end 
                        end 
                      end 
                    end 
                  end 
                else 
                  if @b = 3 
                    if @n <> 0 
                      if @j < 5 
                        @k = mvpar(f12,5) 
                      else 
                        if @j < 6 
                          @k = mvpar(f12,5) + @p 
                        else 
                          if @j < 7 
                            @k = mvpar(f12,6) 
                          else 
                            @k = mvpar(f12,7) 
                          end 
                        end 
                      end 
                    else 
                      if @j < 5 
                        @k = mvpar(f12,5) 
                      else 
                        if @j < 6 
                          @k = mvpar(f12,5) + @p 
                        else 
                          if @j < 8 
                            @k = mvpar(f12,6) 
                          else 
                            @k = mvpar(f12,6) + @p 
                          end 
                        end 
                      end 
                    end 
                  else 
                    @k = mvpar(f12,7) 
                  end 
                end 
              end 

              if stem = DOWN 
                @m = 0 - @m 
                @k = 0 - @k 
              end 

              if stem_mod <> 0                     /* New code &dA05/14/03&d@ 
                if @k > 0 
                  @k += stem_mod 
                else 
                  @k -= stem_mod 
                end 
              end 

              passback @k,@m 
              return 

            end 

DUAL_MIXED_FLAT: 
&dA 
&dA &d@       Find "level" for backbone 
&dA 
            @s = 100000 
            @u = -100000 
            loop for @j = 1 to bcount 
              if bstem(@j,1) = DOWN 
                if bdata(@j,2) > @u
                  @u = bdata(@j,2)
                end 
              else 
                if bdata(@j,2) < @s
                  @s = bdata(@j,2)
                end 
              end 
            repeat 
&dA 
&dA &d@       @s = "highest" note below the beam (stem up) 
&dA &d@       @u = "lowest" note above the beam (stem down) 
&dA 
            @n = @u / mvpar(f12,2) 
            @n = rem 
            @h = mvpar(f12,31) >> 1 
            @i = mvpar(f12,31) - mvpar(f12,41) 

            if @b = 1 
              @j = @s - @u 
              if @j < mvpar(f12,6) 
                tmess = 61 
                perform dtalk (tmess) 
              end 

              if @j = mvpar(f12,6) 
                if @n = 0 
                  @u += mvpar(f12,2) + @i 
                else 
                  @u += mvpar(f12,3) + @h 
                end 
              else 
                if @j = mvpar(f12,7) 
                  if @n = 0 
                    @u += mvpar(f12,4) 
                  else 
                    @u += mvpar(f12,3) + @i 
                  end 
                else 
                  if @j = mvpar(f12,8) and @n <> 0 
                    @u += mvpar(f12,5) 
                  else 
                    @j = @s - @u - @@t 
                    @u += @j >> 1 
                    @u -= mvpar(f12,2) + 3 >> 2 
                    @u = @u + mvpar(f12,8) / mvpar(f12,2) * mvpar(f12,2) - mvpar(f12,6)
                    @u += @h 
                  end 
                end 
              end 
            else 
              if @b = 2 
                @j = @s - @u 
                if @j < mvpar(f12,7) 
                  tmess = 61 
                  perform dtalk (tmess) 
                end 

                if @j = mvpar(f12,7) 
                  if @n = 0 
                    @u += mvpar(f12,2) + @i 
                  else 
                    @u += mvpar(f12,3) + @h 
                  end 
                else 
                  if @j = mvpar(f12,8) 
                    if @n = 0 
                      @u += mvpar(f12,2) + @i 
                    else 
                      @u += mvpar(f12,3) + @i 
                    end 
                  else 
                    if @j = mvpar(f12,9) and @n <> 0 
                      @u += mvpar(f12,3) + @i 
                    else 
                      @j = @s - @u - @@t 
                      @u += @j >> 1 
                      @u -= mvpar(f12,2) + 3 >> 2 
                      @u = @u + mvpar(f12,8) / mvpar(f12,2) * mvpar(f12,2) - mvpar(f12,6)
                      @u += @h - mvpar(f12,41) 
                    end 
                  end 
                end 
                @u += mvpar(f12,32) 
              else 
                @j = @s - @u - @@t 
                if @j < mvpar(f12,4) 
                  tmess = 61 
                  perform dtalk (tmess) 
                end 
                @u += @j >> 1 
                @u -= mvpar(f12,1) 
                @u = @u + mvpar(f12,8) / mvpar(f12,2) * mvpar(f12,2) - mvpar(f12,6)
                @u += @@t - mvpar(f12,41) 
              end 
            end 
            leng = bdata(1,2) - @u
            if leng > 0 
              leng += @@t - mvpar(f12,41) 
            end 

            @k = leng 

            if stem_mod <> 0                     /* New code &dA05/14/03&d@ 
              if @k > 0 
                @k += stem_mod 
              else 
                @k -= stem_mod 
              end 
            end 

            @m = 0 
            passback @k,@m 
            return 
          end 
        end 
&dA 
&dA &d@   End of situation where stems go up and down 
&dA 

&dA 
&dA &d@    Check for situation where notes span two staves (grand staff) 
&dA 
        if f(f12,12) = 2 
          @g = bdata(1,2)
          loop for @j = 2 to bcount 
            if abs(bdata(@j,2) - @g) > 500
              @j = 10000 
            end 
          repeat 
&dA 
&dA &d@     If @j = 10000 and stem = 0 (up), then beam will be relative to top staff 
&dA &d@                    if stem = 1 (down), then beam will be relative to bottom staff
&dA 
&dA &d@     Otherwise, beam will be relative to staff that notes are on 
&dA 
          if @j = 10000 
            if stem = 0     /* make no adjustments 
              loop for @j = 1 to bcount 
                if bdata(@j,2) > 700
                  bdata(@j,2) -= 1000
                  bdata(@j,2) += vst(f12)
                end 
              repeat 
            else 
              loop for @j = 1 to bcount 
                if bdata(@j,2) < 700
                  bdata(@j,2) -= vst(f12)
                else 
                  bdata(@j,2) -= 1000
                end 
              repeat 
            end 
          else 
            if bdata(1,2) > 700
              loop for @j = 1 to bcount 
                bdata(@j,2) -= 1000
              repeat 
            end 
          end 
        end 
&dA 
&dA &d@     Reverse if stem down 
&dA 
        @g = 0
        if stem = 1  
          @g = mvpar(f12,2) * 500  - mvpar(f12,8) 
          loop for @j = 1 to bcount  
            bdata(@j,2) = mvpar(f12,2) * 500  - bdata(@j,2)
          repeat 
        end  
        @@g = @g 
* determine slope and pivot of beam  
        @q = 0 
        x1 = 50000 
        y1 = 50000 
        @t = 6 
        @b = 0 
        @h = 0           /* changes in absolute height 
        @f = 0 
        @i = bdata(1,2)
&dA 
&dA &d@  identify:  @q = 6 - smallest note type under beam 
&dA &d@            (x1,y1) = position of note closest to beam  
&dA &d@            (x2,y2) = position of note next closest to beam 
&dA &d@             @b = y coordinate of note furthest from beam 
&dA 
        loop for @j = 1 to bcount  
*  also compute sum of absolute changes in vertical height 
          @n = @i - bdata(@j,2)
          testfor @n < 0 
            if @f = 0  
              @f = -1  
            end  
            if @f = 1  
              @f = 2 
            end  
            @n = 0 - @n  
          else (>) 
            if @f = 0 
              @f = 1 
            end 
            if @f = -1 
              @f = 2 
            end 
          end  
          @i = bdata(@j,2)
          @h += @n 
*  
          @n = 5 
          if msk_beamcode(@j) con "0" 
            @n = mpt - 2         /* number of additional beams on this note 
          end 
          if @n > @q 
            @q = @n              /* max number of additional beams 
          end 
          if @n < @t 
            @t = @n              /* min number of additional beams 
          end 
          @n = bdata(@j,2)
          if @n > @b 
            @b = @n              /* lowest y co-ord of notes in beam set 
          end 
          if @n < y1 
            y2 = y1 
            x2 = x1 
            y1 = @n              /* nearest y co-ord 
            x1 = bdata(@j,1)
          else 
            if @n < y2 
              y2 = @n  
              x2 = bdata(@j,1)
            end  
          end  
        repeat 
&dA 
&dA &d@    Check point one: (x1,y1); (x2,y2); @b  set  
&dA 
        @@b = @b - y1  
&dA 
&dA &d@    Formula for initial stem length 
&dA 
&dA &d@        note     @q      y1-@n  
&dA &d@      ÄÄÄÄÄÄÄ  ÄÄÄÄÄÄ   ÄÄÄÄÄÄÄ 
&dA &d@        8th:      0      beamh  
&dA &d@       16th:      1      beamh + (1 * notesize / 4) 
&dA &d@       32th:      2      beamh + (4 * notesize / 4)   
&dA &d@       64th:      3      beamh + (7 * notesize / 4) 
&dA &d@      128th:      4      beamh + (10 * notesize / 4)  
&dA &d@      256th:      5      beamh + (13 * notesize / 4)  
&dA 
        if @q = 0  
          @n = y1 - beamh  
        else 
          @n = @q * 3 - 2    
          @n = 0 - notesize * @n / 4 - beamh + y1  
        end  
        @b = x1  
*   deal with case of severe up-down pattern   
        if @f = 2  
          @h /= bcount 
          if @h > mvpar(f12,18) 
            @m = 0 
            goto SB1 
          end  
        end  
*  
        @m = y1 - y2 * 2 * hxpar(1) 
        @k = x1 - x2 
        @m /= @k 
&dA 
&dA &d@  Comment: @m is (2*hxpar(1)) times slope between two notes 
&dA &d@                nearest the beam  
&dA 
        @k = bdata(bcount,2) - bdata(1,2) * 2 * hxpar(1)
        @j = bdata(bcount,1) - bdata(1,1)
        if @j < mvpar(f12,5) 
          @j = mvpar(f12,5) 
        end  
        @k /= @j 
&dA 
&dA &d@  Comment: @k is (2*hxpar(1)) times slope between outside notes 
&dA 
&dA &d@  Formula:  slope = (@m + @k) / 6   provided  
&dA 
&dA &d@     |@m| must be equal to or less than |@k|  
&dA 
        @j = abs(@m) - abs(@k) 
        if @j > 0 
          if @m > 0 
            @m -= @j 
          else 
            @m += @j 
          end 
        end 
*  
        @m = @m + @k / 6 

        @j = abs(@m) - max_pslope               /* code added &dA04/23/03&d@ 
        if @j > 0 
          if @m > 0 
            @m -= @j 
          else 
            @m += @j 
          end 
        end 

SB1:    @k = abs(@m)  
        if @k > mvpar(f12,19) 
          @k = mvpar(f12,19) 
        end  
*   Soften slant for thirty-seconds and smaller  
        if @q > 2 and @k > 5 
          @k = 0 - @q / 2 + @k 
        end  
        if @k < 0  
          @k = 0 
        end  
&dA 
&dA &d@  set reduce slant if end note are closer than mvpar(f12,6) 
&dA 
        @h = bdata(bcount,1) - bdata(1,1)
        if @h <= mvpar(f12,6)  and  @k > mvpar(f12,35) 
          @k = mvpar(f12,35) 
        end  
&dA 
&dA &d@  shorten shortest stem, if gradual slope and large vertical range  
&dA &d@                              and relatively high note  
&dA 
&dA &d@       @h = bcount + 1  
&dA &d@       if @h > 5  
&dA &d@         @h = 5 
&dA &d@       end  
        @h = 3 
        if @@b > mvpar(f12,@h) 
          @h = @q * beamt + @n - @@g 
          @h = 0 - @h  
          if @h > mvpar(f12,3) 
            if @k < 6  
              if x1 > bdata(1,1) and x1 < bdata(bcount,1)
                @n += mvpar(f12,17) 
              end  
              if bcount = 2  
                @n += mvpar(f12,17) 
              end  
            end  
          end  
        end  
*  
        if @m < 0  
          @m = 0 - @k  
        else 
          @m = @k  
        end  
&dA 
&dA &d@  @m = hxpar(1) * slope of beam 
&dA &d@  @n = y coordinate of pivot point (on highest note) of first beam  
&dA &d@  @k = absolute value of @m 
&dA &d@  @g = y coordinate of top of staff line  
&dA &d@  (x1,y1) = coordinate of note closest to beam (highest note) 
&dA &d@  (x2,y2) = coordinate of second closest note to beam (2nd highest note)  
&dA &d@  @q = 6 - smallest note type number (number of beams - 1)  
&dA &d@  @t = 6 - largest note type number 
&dA 
        @@n = @n 
        ++@q
        @@q = @q 
&dA 
&dA &d@    Check point two:  @q = number of beams, current slope = @m  
&dA 
&dA &d@   Adjust @m and @n so that beams will fall properly on staff lines 
&dA 
&dA &d@    Case I:   @m = 0  
&dA 
CSI:    if @m = 0  
          @f = @q - 1 * notesize + @n  
          if @f >= @g  
&dA 
&dA &d@    Adjust flat beam height   
&dA 
            @i = @f - @g / notesize  
            if @q = 1  and   rem <= mvpar(f12,20) 
              rem += mvpar(f12,20) 
            end  
            if @q = 2  
              if rem <= mvpar(f12,20) 
                rem += mvpar(f12,34) 
              else 
                rem = rem - notesize + mvpar(f12,20) 
              end  
            end  
            if @q = 3  
              rem += mvpar(f12,34) 
            end  
            if @q = 4  
              if @i = 3  
                beamt = mvpar(f12,33) 
              end  
              if @i < 3  
                @i = rem 
                @i -= mvpar(f12,1) / 2 
                rem = @i   
              end  
            end  
            @n -= rem 
*     (*) extremely low notes  
            if @q = 1  
              @f = mvpar(f12,4) + @@g 
            else 
              @f = 4 - @q * mvpar(f12,2) + @@g 
            end  
            if @n > @f 
              @n = @f  
              if @q > 3  and  stemchar = 59 
                beamt = mvpar(f12,33) 
              end  
            end  
          end  
        else 
&dA 
&dA &d@    Case II:   @m <> 0  
&dA 
          old@k = @k 
CSII:
          @j = bdata(1,1) - x1 * @m / hxpar(1) + @n
          @i = bdata(bcount,1) - bdata(1,1) * @m / hxpar(1) + @j
          @f = @i + @j / 2 
          if @q > 1  
            if @t > 0  
              @f += beamt 
              if @q = 2  
                @f += 2 
              end  
            end  
            @s = mvpar(f12,22) 
          else 
            @s = mvpar(f12,23) 
          end  
&dA &d@  @j = starting point of top beam 
&dA &d@  @i = stopping point of top beam 
&dA &d@  @f = average height of beam (second beam if always 2 or more) 
&dA &d@  @s = fudge factor 
          @g = @@g 
          @h = @g  
          @g -= notesize 
          if @q > 2  
            @g -= notesize 
          end  
          if @f > @g 
&dA 
&dA &d@    Adjust slanted beam height  
&dA 
            if @q > 2  
              if @f > @h 
                beamt = mvpar(f12,33) 
              else 
                @f -= 2 
              end  
            end  
            @h = abs(@i - @j) 
            @i = @f - @g / notesize  
            @i = rem 
&dA &d@  @h = rise/fall of beam  
&dA &d@  @i = amount by which the average beam height lies below a line  
            if @h < mvpar(f12,24) 
              if @i >= @s  
                @i -= notesize 
                if @q = 1  
                  ++@i
                end  
              else 
                if @q = 1  
                  --@i
                end  
              end  
              @n -= @i 
              goto CV  
            end  
            if @h < beamt and old@k <> 10000 
              if @k > 1  
                goto CSJJ  
              end  
              ++@k
              if @k = old@k 
                old@k = 10000   /* to prevent looping 
              end 
              if @m < 0  
                @m = 0 - @k  
              else 
                @m = @k  
              end  
              goto CSII  
            end  
            if @h < mvpar(f12,25) 
              @i += mvpar(f12,1) 
              if @i > @s 
                @i -= notesize 
              end  
              @n -= @i 
              goto CV  
            end  
            if @h > mvpar(f12,26) 
              if @i > @s       
                @i -= notesize 
              end  
              @n -= @i 
              goto CV  
            end  
            if @k = 2  
              @i += mvpar(f12,1) 
              if @i > @s 
                @i -= notesize 
              end  
              @n -= @i 
              goto CV  
            end  
CSJJ:       --@k
            if @k = old@k 
              old@k = 10000     /* to prevent looping 
            end 
            if @m < 0  
              @m = 0 - @k  
            else 
              @m = @k  
            end  
            goto CSII  
          else 
            if @q < 4  
              @n = notesize / 3 + @n 
            end  
          end  
*   Check for extra low notes  
CV:       @h = bdata(1,1) - x1 * @m / hxpar(1) + @n
          @j = bdata(bcount,1) - x1 * @m / hxpar(1) + @n
          @i = 0 
          if @q = 1  
            @f = mvpar(f12,4) + @@g - 2 
          else 
            @f = 4 - @q * notesize + @@g - 2 
          end  
          if @m > 0  
            if @h > @f 
              @i = 1 
              @h = @f + 1  
            end  
          else 
            if @j > @f 
              @i = 1 
              @j = @f + 1  
            end  
          end  
          @f = @f + mvpar(f12,20) + 2 
          if @m > 0  
            if @j > @f 
              @i = 1 
              @j = @f  
            end  
          else 
            if @h > @f 
              @i = 1 
              @h = @f  
            end  
          end  
          if @i = 1  
*    Correction necessary  
            @k = bdata(bcount,1) - bdata(1,1)
            @m = @j - @h * hxpar(1) / @k 
            @n = x1 - bdata(1,1) * @m / hxpar(1) + @h
            @k = abs(@m) 
          end  
&dA 
&dA &d@   Deal with special case of two note beam  
&dA 
&dA &d@     compute sum of stem lengths and increase if too short  
&dA &d@         if bcount = 2  
&dA &d@           @f = @q - 1 * beamt + y1 - @n + y2 - @n - @h 
&dA &d@           if @f < mvpar(f12,27) 
&dA &d@             @n -= mvpar(f12,28) 
&dA &d@           end  
&dA &d@         end  
&dA 
&dA &d@   Adjust so that middle of beam falls on/between staff lines 
&dA 
          @n = 100 - beamfont / 2 + @n 
        end  
*  
CSIII: 
        dv3 = @m * @b 
        dv3 = @n * hxpar(1) - dv3 
&dA 
&dA &d@    Check point three:  beam slope = @m;  
&dA &d@                        y intercept (times hxpar(1)) = dv3 
&dA 
&dA &d@     Post adjustment:  sometimes the stems of sixteenths are too  
&dA &d@       short.  This will be the case when (y2-@n) - ((@q-1)*beamt) < xxx  
&dA &d@       where xxx is some number.  In this case, we should raise the 
&dA &d@       beam by some small amount, yyy.  
&dA 
        --@q
        @j = 0 - @q * beamt + y2 - @n  
        if @j < mvpar(f12,29) 
          dv3 -= mvpar(f12,30) * hxpar(1) 
        end  
&dA 
&dA &d@     In the case where bcount = 4, compare sum of the first two notes   
&dA &d@     verses the last two notes.  If the direction is different from 
&dA &d@     the slope, then the slope should be zero.  
&dA 
        if bcount = 4  
          @f = bdata(1,2) + bdata(2,2)
          @g = bdata(3,2) + bdata(4,2)
          if @f > @g 
            if @m > 0  
              goto SB2 
            end  
          end  
          @f = @f - @g * @m  
          if @f > 0  
            goto SB2 
          end  
          goto SB3 
SB2:      @m = 0 
          @q = @@q 
          @g = @@g 
          @n = @@n 
          goto CSI 
        end  
SB3: 
&dA 
&dA &d@  @m = hxpar(1) * slope of beam 
&dA &d@  dv3 = y-intercept of top of beam (times hxpar(1)) 
&dA 

        y1 = @m * bdata(1,1) + dv3 / hxpar(1)
        y2 = bdata(1,2)
        @k = abs(y2 - y1) 
&dA 
&dA &d@  Now check for beam with excessive "vertical" travel   &dA04/23/03&d@ 
&dA 
        if @m > max_pslope or @m < max_nslope 
          if @m > max_pslope 
            t2 = 10000 
            t3 = 10000 
            loop for t1 = 1 to bcount 
              y1 = @m * bdata(t1,1) + dv3 / hxpar(1)
              y2 = bdata(t1,2)
              @k = abs(y2 - y1)                          /* stem length 
              if @k < t2 
                t2 = @k 
                t3 = t1 
              end 
            repeat 
            y1 = @m * bdata(t3,1) + dv3               /* pivit on this point
            @m = max_pslope                              /* new slope 
            dv3 = y1 - (@m * bdata(t3,1))
          end 
          if @m < max_nslope 
            t2 = 10000 
            t3 = 10000 
            loop for t1 = 1 to bcount 
              y1 = @m * bdata(t1,1) + dv3 / hxpar(1)
              y2 = bdata(t1,2)
              @k = abs(y2 - y1)                          /* stem length 
              if @k < t2 
                t2 = @k 
                t3 = t1 
              end 
            repeat 
            y1 = @m * bdata(t3,1) + dv3               /* pivit on this point
            @m = max_nslope                              /* new slope 
            dv3 = y1 - (@m * bdata(t3,1))
          end 
          y1 = @m * bdata(1,1) + dv3 / hxpar(1)
          y2 = bdata(1,2)
          @k = abs(y2 - y1) 
        end 
&dA 
&dA &d@    End of code added &dA04/23/03&d@ 
&dA 
        if stem = 1 
          @m = 0 - @m         /* reverse slope if stem down 
          @k = 0 - @k 
        end 

        if stem_mod <> 0                         /* New code &dA05/14/03&d@ 
          if @k > 0 
            @k += stem_mod 
          else 
            @k -= stem_mod 
          end 
        end 
        passback @k,@m 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M*  3. clefkeyspace (t2)                                          ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Compute space for new clef and key                  ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Operation: Create entry for global double bar, if t2 is set.  ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Inputs:    Staff locations: (sp,sq(.))                        ³ 
&dA &d@³               Clef code:  mclef(.,.)                             ³ 
&dA &d@³               Key code:   mkey(.)                                ³ 
&dA &d@³               Time code:  mtcode(.)                              ³ 
&dA &d@³               t2:         double bar flag                        ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Outputs:   ldist,gbarflag,gbar(if t2 is set),mtcode,savtcode  ³ 
&dA &d@³               tplace                                             ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Internal variables: a1,a2                                     ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure clefkeyspace (t2) 
        int t1,t2,t3,t4,t5 
        getvalue t2 

        gbarflag = 0   
        ldist = sp + hxpar(10) 
&dA 
&dA &d@    1) clef 
&dA 
        ldist = ldist + hxpar(15) 
&dA 
&dA &d@    2) key signature  
&dA 
        t5 = ldist 
        loop for f12 = 1 to f11  
          notesize = f(f12,14) 
          x = ldist  
&dA &d@   sharps 
          if mkey(f12) > 0    
            x = mhpar(f12,6) * mkey(f12) + x 
          end  
&dA &d@   flats  
          if mkey(f12) < 0    
            x = 0 - mkey(f12) * mhpar(f12,7) + x 
          end  
          if mkey(f12) = 0    
            t4 = x   
          else 
            t4 = x + hxpar(2)     
          end  
          if t4 > t5 
            t5 = t4  
          end  
        repeat 
        if t5 > ldist  
          ldist = t5 
        end  
        tplace = ldist - sp  
&dA &d@      
&dA &d@    3) time change  
&dA 
        t5 = ldist 
        loop for f12 = 1 to f11  
          notesize = f(f12,14) 
          savtcode(f12) = mtcode(f12) 
          if mtcode(f12) < 10000  
            a1 = mtcode(f12) / 100  
            a2 = rem 
            t3 = 0   
            if a1 = 1 and a2 = 1 
              t3 = 1 
            end    
            if a1 = 0 and a2 = 0 
              t3 = 2 
            end  
&dA 
            if t3 > 0 
              t5 = ldist + hxpar(12) 
            else 
              t1 = ldist + hxpar(21) + hxpar(19) 
              if a2 < 10 and a1 < 10 
                t1 = ldist + hxpar(22) + hxpar(20) 
              end 
              t5 = t1 - hxpar(13) 
            end  
            if bit(1,t2) = 1 
              t5 += hxpar(11)     /* &dA05-27-94&d@ I'm not sure why this is necessary, but it is.
            end 
          end  
          mtcode(f12) = 10000 
        repeat 
        if ldist < t5  
          ldist = t5 
        end  
&dA 
&dA &d@    4) store info for double bar if left over from last line  
&dA 
        if bit(1,t2) = 1 
          gbarflag = 1   
          gbar(1) = ldist + hxpar(11) - sp 
          gbar(2) = 9  
          ldist = ldist + hxpar(11) + hxpar(16) + hxpar(17) 
          if bit(0,t2) = 1 
            gbar(2) += 16 
            ldist += hxpar(18) 
          end  
        else 
          ldist += hxpar(5) 
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M*  4. clefkey                                                       ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Purpose:  Create object entries for clef, key and time signature ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Operation: Also typeset measure number.                          ³ 
&dA &d@³               Also typeset a mark object object for an ending       ³ 
&dA &d@³                 superobject, if the ending starts at the beginning  ³ 
&dA &d@³                 of the line.  The flag for this is the variable     ³ 
&dA &d@³                 supernum.  If this is positive, then this is the    ³ 
&dA &d@³                 superobject number of the ending superobject.       ³ 
&dA &d@³                                                     New &dA05/06/08&d@    ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Inputs:    Staff locations: (sp,sq(.))                           ³ 
&dA &d@³               Clef code:  mclef(.,.)                                ³ 
&dA &d@³               Key code:   mkey(.)                                   ³ 
&dA &d@³               Time code:  savtcode(.)                               ³ 
&dA &d@³                                                                     ³ 
&dA &d@³    Internal variables: t1 ... t9                                    ³ 
&dA &d@³                                                                     ³ 
&dA &d@³      Clef is defined as a two dimensional array,                    ³ 
&dA &d@³      and if f(f12,12) = 2 then the clef, key, and                   ³ 
&dA &d@³      maybe the time signature need to be duplicated                 ³ 
&dA &d@³      on the auxiliary staff.                                        ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure clefkey  
        str tline.180 
        str line2.80 
        int t1,t2,t3,t4,t5,t6,t7,t8,t9 
        int tenor 
        int clef_obx                /* New &dA10/08/08&d@ 

        obx = hxpar(10) 
&dA 
&dA &d@    1) clef 
&dA 
        if lbyte = "l"              /* New condition &dA12/18/05&d@ 
          goto NO_CLEF 
        end 

        t1 = 0 
        loop for t2 = 1 to 2        /* &dLmax 2 staves at this time&d@ 
          a1 = mclef(f12,t2) / 10 
          a2 = rem 
          t6 = a1 / 3 
          t7 = rem 
          if t7 = 0 
            z = 33 
          else 
            z = 34 + t7 
          end 
          oby = a2 - 1 * notesize + t1 

          clef_obx = obx            /* New &dA10/08/08&d@ 

          if t7 = 0 
            t8 = 2 
            if t6 = 1 
              t8 = 3 
            end 
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] J C ~mclef(f12,t2)  ~obx  ~oby  ~t8  6913 0 0 
              ++mainyp 
              tput [Y,mainyp] K 0 0 33 
              ++mainyp 
              tput [Y,mainyp] K 0 0 34 
              if t6 = 1 
                ++mainyp 
                tput [Y,mainyp] K ~mhpar(f12,5)  ~mvpar(f12,15)  234 
              end 
            end 
          else 
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] J C ~mclef(f12,t2)  ~obx  ~oby  ~z  6913 0 0 
            end 
          end 
          if f(f12,12) <> 2 
            t2 = 100 
          else 
            t1 = vst(f12) 
          end 
        repeat 
NO_CLEF: 
        obx = obx + mhpar(f12,15) 
&dA 
&dA &d@    2) key signature  
&dA 
        t9 = obx   
        t6 = abs(mkey(f12))  
        t1 = 0 
        loop for t2 = 1 to 2        /* &dLmax 2 staves at this time&d@ 
          tenor = 0 
          if mclef(f12,t2) = 12 
            tenor = 1 
          end 

          if justflag < 2 
            ++mainyp 
            tput [Y,mainyp] J K ~mkey(f12)  ~obx  ~t1  ~t6  6913 0 0 
          end 
          if t6 > 0 
            a1 = mclef(f12,t2) / 10 
            t3 = rem - 1 * 2          /* t3 (vertical position) measured in line numbers
            a1 /= 3 
            a2 = 2 - rem * 3      
            t3 -= a2 
            x = 0 
&dA &d@   sharps 
            if mkey(f12) > 0 
              loop for t5 = 1 to t6 
                if tenor = 0 or t3 >= 0 
                  y = t3 + 20 * notesize / 2 - mvpar20(f12) 
                else 
                  y = t3 + 27 * notesize / 2 - mvpar20(f12)   /* exception for tenor clef
                end 
                if justflag < 2 
                  ++mainyp 
                  tput [Y,mainyp] K ~x  ~y  63 
                end 
                t3 += zak(1,t5) 
                x += mhpar(f12,6) 
              repeat 
            end 
&dA &d@   flats  
            if mkey(f12) < 0 
              t3 += 4 
              loop for t5 = 1 to t6 
                y = t3 + 20 * notesize / 2 - mvpar20(f12) 
                if justflag < 2 
                  ++mainyp 
                  tput [Y,mainyp] K ~x  ~y  65 
                end 
                t3 += zak(2,t5) 
                x += mhpar(f12,7) 
              repeat 
            end 
          end 
          if f(f12,12) <> 2 
            t2 = 100 
          else 
            t1 = vst(f12) 
          end 
        repeat 
&dA &d@      
&dA &d@    3) write time change  
&dA 
        obx = tplace 
        t8 = obx   
&dA 
&dA &d@  deal with time directive or segno thrown to new line  
&dA 
        if dxoff(f12) < 10000 
          rec = drec(f12) 
          perform save3                 /* oby not used here 
          if jtype <> "D" 
            tmess = 62 
            perform dtalk (tmess) 
          end 
          if z < 33 
            if f12 = 1 
              if justflag < 2 
                ++mainyp 
                tput [Y,mainyp] J D 0 ~obx  0 1 6913 0 0 
              end 
              ++rec 
              tget [Z,rec] line 
              lpt = 3 
              tline = txt(line,[' '],lpt) 
              x = int(tline) + dxoff(f12) 
              tline = txt(line,[' '],lpt) 
              y = int(tline) + dyoff(f12) 
              line = line{lpt+1..} 
              if justflag < 2 
                ++mainyp 
                tput [Y,mainyp] W ~x  ~y  ~line 
              end 
            end 
          else 
            if justflag < 2 
              if bit(2,ntype) = 1 and f12 = 1 
                x = t9 + dxoff(f12) 
                y = dyoff(f12) 
                ++mainyp 
                tput [Y,mainyp] J D 0 ~x  ~y  ~z  6913 0 0 
              end  
              if bit(3,ntype) = 1 and f12 = f11 
                x = t9 + dxoff(f12) 
                y = dyoff(f12) 
                ++mainyp 
                tput [Y,mainyp] J D 0 ~x  ~y  ~z  6913 0 0 
              end  
            end 
          end  
          dxoff(f12) = 10000 
        end  
&dA 
&dA &d@  write time change, if present 
&dA 
        if savtcode(f12) < 10000   
          a1 = savtcode(f12) / 100   
          a2 = rem 
          t6 = 0   
          if a1 = 1 and a2 = 1 
            t6 = 1 
          end 
          if a1 = 0 and a2 = 0 
            t6 = 2 
          end 
          if t6 > 0 
            obx = obx + mhpar(f12,13) 
            y = mvpar(f12,6) 
            z = 36 + t6 
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] J T ~savtcode(f12)  ~obx  ~y  ~z  6913 0 0 
            end 
            if f(f12,12) = 2 
              y += vst(f12) 
              if justflag < 2 
                ++mainyp 
                tput [Y,mainyp] J T ~savtcode(f12)  ~obx  ~y  ~z  6913 0 0 
              end 
            end 
          else 
            obx = t8 + mhpar(f12,21)  
            t6 = 4 
            if a2 < 10   
              t6 = 3 
              if a1 < 10   
                obx = t8 + mhpar(f12,22)  
              end  
            end  
            if a1 < 10 
              --t6 
            end  
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] J T ~savtcode(f12)  ~obx  0 ~t6  6913 0 0 
            end 
            y = mvpar(f12,4) 
            perform msk_number (a1) 
            y = mvpar(f12,8) 
            perform msk_number (a2) 

            if f(f12,12) = 2 
              if justflag < 2 
                ++mainyp 
                tput [Y,mainyp] J T ~savtcode(f12)  ~obx  ~vst(f12)  ~t6  6913 0 0
              end 
              y = mvpar(f12,4) 
              perform msk_number (a1) 
              y = mvpar(f12,8) 
              perform msk_number (a2) 
            end 

          end  
          obx = obx + mhpar(f12,19) 
        end  
&dA 
&dA &d@    4) write measure number   
&dA &d@      
        if f12 = 1 or f12 > 0            /* f12 > 0 added &dA01/06/04&d@ (dummy boolean TRUE) 
          t2 = M_NUM_FONT                /* font number moved to #define &dA01/06/04
          perform spacepar (t2) 
          if f12 > 1                     /* this also added &dA01/06/04&d@; creates dummy
            t2 = 0                       /*   measure numbers, which "come to life" only
          end                            /*   when top staff line(s) is/are removed.
          ++sys_count 
          mnum = oldbarnum               /* measure number for first measure in this system
          line = chs(oldbarnum)  
          line2 = "" 
          loop for t4 = 1 to len(line)  
            line2 = line2 // "\0" // line{t4} 
          repeat 
          t1 = spc(48+128)               /* space for small numbers 
          t1 = len(line) - 1 * t1 
          x = clef_obx - t1              /* New &dA10/08/08&d@ 
          y = 0 - mvpar(f12,2) 
          if justflag < 2 
            ++mainyp 
            tput [Y,mainyp] J D 0 ~x  ~y  1 6913 0 0 
            ++mainyp 
            tput [Y,mainyp] W 0 0 ~t2  ~line2 
          end 
        end  
&dA 
&dA &d@    5) put down mark for ending superobject, if supernum > 0  New &dA05/06/08&d@ 
&dA 
        t8 = hxpar(8) - sp - mvpar(f12,3) 
        if supernum > 0 
          if justflag < 2 
            ++mainyp 
            tput [Y,mainyp] J D 0 ~t8  0 0 6913 0 1 ~supernum 
          end 
        end 
        supernum = 0 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M*  5. getsmall (t1,t2,t3,df)                                     ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Identify and count the smallest duration in line    ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Inputs:   a1 = number of nodes in larr to look at             ³ 
&dA &d@³              a2 = purpose flag (0 = condensation, 1 = expansion) ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Outputs: t2 =  code for smallest note/rest on line (not       ³ 
&dA &d@³                      including syncopated nodes)                 ³ 
&dA &d@³             t1 =  smallest internote distance (not including     ³ 
&dA &d@³                      syncopated distances)                       ³ 
&dA &d@³             t3 =  difference between e and next smallest         ³ 
&dA &d@³                     distance                                     ³ 
&dA &d@³             df =  proper duration flag for shortest note         ³ 
&dA &d@³              scnt = number of nodes preceded by distance e       ³ 
&dA &d@³              small(.) = node numbers of duration df, where       ³ 
&dA &d@³                            distance adjustment can take place    ³ 
&dA &d@³                                                                  ³ 
&dA &d@³              scnt2 = number of nodes for which adj_space = YES   ³ 
&dA &d@³              small2(.) = node numbers of duration df, where      ³ 
&dA &d@³                             distance adjustment can take place   ³ 
&dA &d@³                             and adj_space = YES                  ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Internal variables:  t4,t5,t6,t7,t8,t9,t10                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure getsmall (t1,t2,t3,df) 
        int df2,first,df 
        int t1,t2,t3,t4,t5,t6,t7,t8,t9,t10 

        t2 = 11 
        t1 = 1000 
        df2 = 100000 
        scnt = 0 
        scnt2 = 0                                      /* New &dA05/25/03&d@ 
        t3 = 0                                         /* New &dA10/14/07&d@ 

        loop for t10 = 2 to a1 
          t6 = larr(t10,TIME_NUM)                      /* New &dA05/25/03&d@ 
          if t6 > 0 
            if larr(t10,MNODE_TYPE) <> 18 or t1 = 1000 /* New &dA05/25/03&d@ 
              t7 = larr(t10-1,MNODE_TYPE)              /*  "     " 
              if t7 > 0 
&dA 
&dA &d@  Case: node is preceded by variable distance (t6 > 0); node is not a bar 
&dA &d@        line (larr(t10,MNODE_TYPE) <> 18); previous node type is t7; we     New &dA05/25/03
&dA &d@        are not including syncopated nodes in our preliminary search 
&dA &d@        for the smallest node type on the line.  
&dA 
                if t7 <= t2 
                  if t7 < t2 
                    t8 = 0 
                  end 
                  t2 = t7 
&dA 
&dA &d@   df2 = 64, t8 = 0 --> previous duration is quarter note, etc.  
&dA &d@   df2 = 64, t8 = 1 --> previous duration is a quarter note triplet, etc.  
&dA 
                  df = t6 / 9 
                  if rem = 0 
                    if df < df2 
                      df2 = df 
                    end 
                  else 
                    df = t6 / 6 
                    if rem = 0 
                      t8 = 1 
                      if df < df2 
                        df2 = df 
                      end 
                    end 
                  end 
&dA 
&dA &d@     We need to change the code here (&dA01/24/04&d@) to deal with the situation 
&dA &d@     that occurs in Baroque music, where (for example) the quarter/eighth 
&dA &d@     combination in triplet is represented by a dotted eighth and sixteenth.
&dA &d@     The problem is that in this situation, the MNODE_TYPE type "under-represents"
&dA &d@     what is really there.  In this example, the dotted eighth (MNODE_TYPE = 6)
&dA &d@     is really a triplet quarter (MNODE_TYPE = 7); and the sixteenth (MNODE_TYPE = 5)
&dA &d@     is really a triplet eighth (MNODE_TYPE = 6).  Because of this, the code
&dA &d@     above thinks these intervals are syncopations.  The trick here will be
&dA &d@     to write some code that will capture this situation, without letting 
&dA &d@     through the syncopated case.  By increasing the value of MNODE_TYPE by
&dA &d@     one, we are increasing the value of t7 by one, which means we are 
&dA &d@     looking at the next larger bit of df2.  The value of df2 is valid; 
&dA &d@     we don't propose to change that.  We need to consider the effect of 
&dA &d@     looking at the next larger bit.  Let us suppose that df2 has the 
&dA &d@     following value: xxy&dE0&d@xx..., where the &dE0&d@ corresponds to the bit read 
&dA &d@     above.  If the value of y is 0, then either this node is very short 
&dA &d@     relative to the note-type represented and is definitely syncopated, 
&dA &d@     or the node is at least four times longer than the note-type 
&dA &d@     represented, which is a logical error.  If the value of y is 1, the 
&dA &d@     node is at least twice as long as the note-type represented, which 
&dA &d@     is also a logical error.  
&dA 
&dA &d@     Based on this analysis, I think the fix is actually very simple.  
&dA &d@     The basic rule is that the node type should NEVER exceed the value 
&dA &d@     of the note-type represented.  If the note-type represented is 
&dA &d@     too small, as happens in the triplet case, the above code fails 
&dA &d@     for the wrong reason.  What we really should be asking is: 
&dA 
&dA &d@                 if df2 >= (0x01 << (t7-1))   /* i.e. not including syncopations
&dA 
&dA &d@     The "=" part of this statement encompasses the normal situation; i.e.,
&dA &d@     the node type is identical to the note-type represented.  The "less than"
&dA &d@     condition is where this statement fails, and this is the syncopated case.
&dA &d@     The "greater than" condition is logically impossible, but now accepts 
&dA &d@     the case where the size of the note-type was under-represented, as 
&dA &d@     happens in the triplet case.  
&dA 
                  if df2 >= (0x01 << (t7-1))   /* i.e. not including syncopations
                    t4 = larr(t10,PRE_DIST)            /* New &dA05/25/03&d@ 
                    if t4 < t1 
                      t3 = t1 - t4             /* New &dA10/14/07&d@ 
                      t1 = t4 
                    end 
                    if t1 + t3 > t4 
                      t3 = t4 - t1             /* New &dA10/14/07&d@ 
                    end 
                  end 
&dA   
                end 
              end 
            end 
          end 
        repeat 
        if df2 = 100000                 /* no valid "smallest" notes 
          passback t1,t2,t3,df 
          return 
        end 
        df = df2    
        if t8 = 0 
          df *= 9
        else 
          df *= 6 
        end 
&dA 
&dA &d@    t2 =  code for smallest note/rest on line 
&dA &d@    t1 =  smallest internote distance 
&dA &d@    df =  proper duration flag for shortest note in search set 
&dA 
&dA &d@   Determine quantity and location of smallest distances 
&dA 
        first = 0 
GSM2: 
        t5 = 0 
        t7 = 0 
        t9 = 0 
        t8 = t1 + hxpar(14)             /* fudge factor for "shortest distance" 
        loop for t10 = 2 to a1 
          if larr(t10,TIME_NUM) > 0                    /* New &dA05/25/03&d@ 
            t5 += larr(t10,TIME_NUM)                   /*  "     " 
            if larr(t10,MNODE_TYPE) = 18               /*  "     " 
              if a2 = 0 
                t7 = t5 / df 
                goto GSM1 
              end 
              if first = 0 
                t7 = t5 / df 
                goto GSM1 
              end 
            end 

            t6 = t5 / df 
            if rem = 0 
&dA 
&dA &d@  Case: node is preceded by variable distance (larr(t10,TIME_NUM) > 0);    (&dA05/25/03&d@)
&dA &d@        node is not a bar line (larr(t10,MNODE_TYPE) <> 18);                       
&dA &d@        node aligns with a multiple of the minimum duration; 
&dA &d@        t6 = cumulative number of minimum durations to this node; 
&dA &d@        t7 = previous cumulative number of minimum durations.  
&dA 
              t4 = t6 - t7 
              if t4 = 1 
                t9 += larr(t10,PRE_DIST)               /* New &dA05/25/03&d@ 
&dA 
&dA &d@   Condensation:  t9 (effective distance) must be within hxpar(14) of  t1 
&dA 
                if a2 = 0 
                  if t9 < t8 
                    ++scnt 
                    small(scnt) = t10 

                    if larr(t10,M_ADJ) = YES          /* New Code &dA05/25/03&d@ 
                      ++scnt2 
                      small2(scnt2) = t10 
                    end 

                  end 
                else 
                  ++scnt 
                  small(scnt) = t10 

                  if larr(t10,M_ADJ) = YES            /* New Code &dA05/25/03&d@ 
                    ++scnt2 
                    small2(scnt2) = t10 
                  end 

                end 
              end 
              t7 = t6 
              t9 = 0 
            else 
              t9 = larr(t10,PRE_DIST)                 /* New &dA05/25/03&d@ 
            end 
          end 
GSM1: 
        repeat 
        if scnt <= 4 and first = 0 
          first = 1 
          scnt = 0 
          scnt2 = 0                                   /* New &dA05/25/03&d@ 
          goto GSM2 
        end 
        passback t1,t2,t3,df 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M*  6. endcheck (endf)                                            ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Check status of end of part flags.                  ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Inputs: f(.,8)                                                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure endcheck (endf) 
        int endf,t1 

        endf = f(1,8) 
        loop for f12 = 2 to f11  
          if f(f12,8) <> endf   
            tmess = 63 
            perform dtalk (tmess) 
          end  
        repeat 
        passback endf 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M*  7. setckt                                                     ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Generate entries in marr for possible clef, key,    ³ 
&dA &d@³                time and clef signatures in that order            ³ 
&dA &d@³                (snode = 6913)                                    ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Input:  marc =  index into marr array                         ³ 
&dA &d@³          f(.,6) =  record pointer in part (.)                    ³ 
&dA &d@³         f(.,10) =  active measure flag for part (.)              ³ 
&dA &d@³      olddist(.) =  value of x-coordinate for previous object     ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Outputs:  Entries in marc for clef, key and time signature    ³ 
&dA &d@³                 when any of these are present                    ³ 
&dA &d@³              Updated marc and f(.,6) pointers                    ³ 
&dA &d@³              Updated olddist(.)                                  ³ 
&dA &d@³              Updated ldist                                       ³ 
&dA &d@³              rmarg changed (this will be changed back to hxpar(4)³ 
&dA &d@³                 at CF: if signatures are not at end of line)     ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Internal variables:  tarr(.)                                  ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setckt 
        int t1,t2,t3,t4,t5,t6 
        int firstclef 
        int tarr4(32,4) 

&dA &d@  check for presence of clef, key, time and clef (again) 

        loop for f12 = 1 to f11 
          loop for t1 = 1 to 4 
            tarr4(f12,t1) = 0 
          repeat 
        repeat 
        loop for t1 = 1 to 4 
          tarr(t1) = 0 
        repeat 

        t3 = 0 
        t4 = 0 
        loop for f12 = 1 to f11  
          firstclef = 0 
          notesize = f(f12,14) 
          if f(f12,10) = 0 
            rec = f(f12,6) 
CKT1:       perform save3              /* oby not used here 
            ++rec
            if line{1} = "J" 
              if snode <> 6913 
                t2 = dvar1 - olddist(f12) 
                if t2 > t3 
                  t3 = t2               /* constructing maximum distance 
                end  
                goto CKT2  
              end  
              if "CKT" con jtype 
                if mpt > 1                        
                  firstclef = 1       /* K or T encountered 
                else 
                  if firstclef = 1 
                    mpt = 4           /* Clef after K or T 
                  end 
                end 
                ++tarr4(f12,mpt)          /* here is where we count 
              end  
            end  
            goto CKT1  
          end  
CKT2:
          loop for t1 = 1 to 4 
            if tarr4(f12,t1) > tarr(t1) 
              tarr(t1) = tarr4(f12,t1)      /* we want maximum of count for each sign
            end 
          repeat 
        repeat 
&dA 
&dA &d@  t3 = maximum distance from bar line to first object beyond signatures 
&dA 
        loop for t1 = 1 to 4 
          if tarr(t1) > 0 
            t4 = 1 
            ++marc
            marr(marc,PRE_DIST) = 0           
            if t1 < 4 
              marr(marc,MNODE_TYPE) = 13 + t1 
            else 
              marr(marc,MNODE_TYPE) = 14       /* Clef following Key or Time
            end 
            marr(marc,TIME_NUM)  = 0          
            marr(marc,SNODE)     = 6913 
            marr(marc,ACT_FLAG)  = 0 
            marr(marc,M_ADJ)     = adj_space 
            marr(marc,MARR_TEMP) = 0

            t5 = 0  
            t6 = 1               /* for constructing marr(marc,ACT_FLAG) 
            loop for f12 = 1 to f11  
              if tarr4(f12,t1) > 0 
                --tarr4(f12,t1) 
                notesize = f(f12,14) 
                if f(f12,10) = 0 
                  rec = f(f12,6) 
CKT3:             perform save3           /* oby not used here 
                  ++rec 
                  if line{1} = "J" and jtype = "CKTC"{t1} 
                    marr(marc,ACT_FLAG) |= t6        
                    t2 = dvar1 - olddist(f12) 
                    if t2 > marr(marc,PRE_DIST)      
                      marr(marc,PRE_DIST) = t2       
                    end 
                    ++t5 
                    tdist(t5,1) = f12 
                    tdist(t5,2) = dvar1 
                    f(f12,6) = rec 
                    goto CKT4 
                  end 
                  if rec < f(f12,2) 
                    goto CKT3 
                  end 
                end 
              end 
CKT4: 
              t6 <<= 1 
            repeat 
            perform adjolddist 
            ldist += marr(marc,PRE_DIST)      
            t3 -= marr(marc,PRE_DIST)          
          end  
          --tarr(t1) 
          if tarr(t1) > 0  /* if more than one of a sign, 
            --t1           /*   go though loop again 
          end 
        repeat 
&dA 
&dA &d@  If t4 = 1, t3 = maximum distance from last signature to the first 
&dA &d@     object beyond signatures.  
&dA 
        if t4 = 1 
          false_rmarg = hxpar(4) - t3     
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M*  8. adjolddist                                                 ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Adjust olddist(.) for parts where f(f12,10) = 0     ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure adjolddist 
        int t1 

        t1 = 1 
        loop for f12 = 1 to f11  
          if f(f12,10) = 0 
            if tdist(t1,1) = f12  
              olddist(f12) = tdist(t1,2)  
              ++t1 
            else 
              olddist(f12) += marr(marc,PRE_DIST)   
            end  
          end  
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³M*  9. getcontrol (gbarnum)                                               ³
&dA &d@³                                                                          ³
&dA &d@³    Purpose:  Find the object that generates a proper-node for            ³
&dA &d@³                 the current object being looked at at rec.               ³
&dA &d@³                                                                          ³
&dA &d@³    Inputs:   rec = record number for current object                      ³
&dA &d@³              f12 = part to search                                        ³
&dA &d@³              cjtype = object type from last call to getcontrol           ³
&dA &d@³              csnode = node number from last call to getcontrol           ³
&dA &d@³              gbarnum = barnum                                            ³
&dA &d@³                                                                          ³
&dA &d@³    Outputs:  crec   = record number which generates proper-node          ³
&dA &d@³              cjtype = object type                                        ³
&dA &d@³              cntype = node type                                          ³
&dA &d@³              cdv    = x coordinate                                       ³
&dA &d@³              coby   = y coordinate                                       ³
&dA &d@³              cz     = value of z                                         ³
&dA &d@³              csnode = snode number                                       ³
&dA &d@³                                                                          ³
&dA &d@³    Operation:  if csnode < 6913 and                                      ³
&dA &d@³                  if csnode = snode and                                   ³
&dA &d@³                    if cjtype = B and                                     ³
&dA &d@³                      if jtype = N,R,Q,F,I, current object generates node ³
&dA &d@³                      otherwise next N,R,Q,F,I object generates node      ³
&dA &d@³                    otherwise current proper node is still valid          ³
&dA &d@³                  if csnode < snode and                                   ³
&dA &d@³                    if jtype = N,R,Q,F,I,B, current object generates node ³
&dA &d@³                    otherwise next N,R,Q,F,I,B object generates node      ³
&dA &d@³                  if csnode > snode, I think you have a problem           ³
&dA &d@³                if csnode = 6913                                          ³
&dA &d@³                  if snode = 6913 and                                     ³
&dA &d@³                    if jtype = B,C,K,T, current object generates node     ³
&dA &d@³                    otherwise next C,K,T generates node                   ³
&dA &d@³                  otherwise next N,R,Q,F,I,B object generates node        ³
&dA &d@³                                                                          ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure getcontrol (gbarnum) 
        int gbarnum,t1 
        str local_last_jtype.1                    /* added &dA11/25/06&d@ 

        getvalue gbarnum 

        local_last_jtype = last_jtype             /* added &dA11/25/06&d@ 
        last_jtype = jtype                        /* added &dA11/25/06&d@ 

        if csnode < 6913 
          if csnode = snode  
            if cjtype = "B"  
              crec = rec 
GC1:          perform save4  
              if "NRrQFI" con cjtype              /* New &dA10/15/07&d@ 
                return 
              end  
              ++crec
              goto GC1 
            end  
            return 
          else 
            if csnode < snode  
              crec = rec 
GC2:          perform save4  
              if "NRrQFIB" con cjtype             /* New &dA10/15/07&d@ 
                if mpt < 7 
                  return 
                end  
                if csnode = 6913 
                  return 
                end  
              end  
              ++crec
              goto GC2 
            else 
              if (Debugg & 0x01) > 0 
                pute Error in part ~f12  at ~gbarnum 
                pute This could be caused by durations that don't properly add up.
              end 
              tmess = 64 
              perform dtalk (tmess) 
            end  
          end  
        else 
&dA 
&dA &d@   Code added &dA11/25/06&d@ to try to fix an End-of-measure Bug 
&dA 
          if csnode = snode and local_last_jtype = "M" and jtype <> "B" 
            crec = rec 
GC2A:       perform save4 
            if "B" con cjtype 
              return 
            end 
            if csnode < 6913 
              tmess = 65 
              perform dtalk (tmess) 
            end 
            ++crec 
            goto GC2A 
          end 

&dA                          &d@ End of &dA11/26/06&d@ Addition 

          crec = rec 
GC3:      perform save4  
          if snode = 6913  
            if "BCKT" con cjtype 
              return 
            end  
          else 
            if "NRrQFIB" con cjtype               /* New &dA10/15/07&d@ 
              return 
            end  
          end  
          ++crec
          goto GC3 
        end  
*     return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M* 10. msk_number (t1)                                            ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Typeset a number                                    ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Inputs:  t1 = number                                          ³ 
&dA &d@³             y = vertical location of number                      ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure msk_number (t1) 
        int t1 
        getvalue t1 

        x = 0 - mhpar(f12,20) 
        if t1 > 99    
          x = 0 + mhpar(f12,20) 
        else   
          if t1 > 9   
            x = 0                                 /* Fixing bug &dA11/05/05&d@ (was x = b)
          end  
        end  
MNU1:   t1 = t1 / 10 
        z = rem + 71   
        if justflag < 2 
          ++mainyp 
          tput [Y,mainyp] K ~x  ~y  ~z 
        end 
        if t1 = 0   
          return   
        end  
        x -= mhpar(f12,19) 
        goto MNU1 
*     return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M* 11. do_more_supers (t1,htype)                                  ³ 
&dA &d@³                                                                  ³ 
&dA &d@³     Purpose:  Continuation of super-object processing            ³ 
&dA &d@³                                                                  ³ 
&dA &d@³     Inputs:  t1 = index into super-object data sets              ³ 
&dA &d@³                                                                  ³ 
&dA &d@³     Internal:  a1,a2                                             ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure do_more_supers (t1,htype) 
        str tline.180,htype.1 
        int t1,t2 
        getvalue t1,htype 

        if htype = "V" 
&dA 
&dA &d@  structure of transp super-object:  4. situation: 0=8av up, 1=8av down 
&dA &d@                                     5. horiz. disp. from obj1  
&dA &d@                                     6. horiz. disp. from obj2  
&dA &d@                                     7. vert. disp. from obj1 
&dA &d@                                     8. length of right vertical hook 
&dA 
          tline = txt(line,[' '],lpt) 
          t2 = int(tline) 
          tline = txt(line,[' '],lpt) 
          x1 = int(tline) 
          tline = txt(line,[' '],lpt) 
          x2 = int(tline)     /* + superdata(f12,t1,3) 
          tline = txt(line,[' '],lpt) 
          y1 = int(tline)     /* + superdata(f12,t1,2) 
          tline = txt(line,[' '],lpt) 
          a1 = int(tline) 
          if superdata(f12,t1,5) = 0 
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] ~superline 
            end 
            x1 += superdata(f12,t1,1) 
          else 
            x1 = hxpar(8) - sp - notesize 
            if justflag < 2 
*      create mark at beginning of line (mindful of virtual staff possibility) 
              if superdata(f12,t1,2) > 700 and f(f12,12) = 2 
                ++mainyp 
                tput [Y,mainyp] J M 0 ~x1  1000 0 6913 0 1 ~supernum 
                y1 -= 1000 
              else 
                ++mainyp 
                tput [Y,mainyp] J M 0 ~x1  0 0 6913 0 1 ~supernum 
              end 
*      create "second half" of superobject (objects are out of order but will be reversed)
              ++mainyp 
              tput [Y,mainyp] H ~supernum  V ~t2  0 ~x2  ~y1  ~a1 
            end 
          end  
          return 
        end  
        if htype = "E" 
&dA 
&dA &d@  structure of ending super-object:  4. ending number (0 = none)  
&dA &d@                                     5. horiz. disp. from obj1  
&dA &d@                                     6. horiz. disp. from obj2  
&dA &d@                                     7. vert. disp. from staff lines  
&dA &d@                                     8. length of left vertical hook  
&dA &d@                                     9. length of right vertical hook 
&dA 
          tline = txt(line,[' '],lpt) 
          t2 = int(tline) 
          tline = txt(line,[' '],lpt) 
          x1 = int(tline) 
          tline = txt(line,[' '],lpt) 
          x2 = int(tline)       /* + superdata(f12,t1,3) 
          tline = txt(line,[' '],lpt) 
          y1 = int(tline) 
          tline = txt(line,[' '],lpt) 
          a1 = int(tline) 
          tline = txt(line,[' '],lpt) 
          a2 = int(tline) 
          if superdata(f12,t1,5) = 0 
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] ~superline 
            end 
            x1 += superdata(f12,t1,1) 
          else 
            x1 = hxpar(8) - sp - mvpar(f12,3) 
            if superdata(f12,t1,6) = 0 or superdata(f12,t1,5) = 3        /* New &dA05/06/08
              a1 = 0 
              if superdata(f12,t1,5) <> 3 
                t2 = 0 
              end 
            end  
            if justflag < 2 
*      create mark at beginning of line  
              ++mainyp 
              tput [Y,mainyp] J M 0 ~x1  0 0 6913 0 1 ~supernum 
*      create "second half" of superobject (objects are out of order but will be reversed)
              ++mainyp 
              tput [Y,mainyp] H ~supernum  E ~t2  0 ~x2  ~y1  ~a1  ~a2 
            end 
          end  
          superdata(f12,t1,5) = 0        /* New &dA05/06/08&d@   Clear these to make
          superdata(f12,t1,6) = 0        /*   sure they are not used elsewhere.
          superdata(f12,t1,7) = 0 

          return 
        end  
        if htype = "D" 
&dA 
&dA &d@  structure of dashes super-object:  4. horiz. disp. from obj1  
&dA &d@                                     5. horiz. disp. from obj2  
&dA &d@                                     6. vert. disp. from staff lines  
&dA &d@                                     7. spacing parameter 
&dA &d@                                     8. font designator 
&dA 
          tline = txt(line,[' '],lpt) 
          x1 = int(tline) 
          tline = txt(line,[' '],lpt) 
          x2 = int(tline)     /* + superdata(f12,t1,3) 
          tline = txt(line,[' '],lpt) 
          y1 = int(tline) 
          tline = txt(line,[' '],lpt) 
          a1 = int(tline) 
          tline = txt(line,[' '],lpt) 
          a2 = int(tline) 
          if superdata(f12,t1,5) = 0 
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] ~superline 
            end 
            x1 += superdata(f12,t1,1) 
          else 
            x1 = hxpar(8) - sp 
            if justflag < 2 
*      create mark at beginning of line (mindful of virtual staff possibility)
              if superdata(f12,t1,2) > 700 and f(f12,12) = 2 
                ++mainyp 
                tput [Y,mainyp] J M 0 ~x1  1000 0 6913 0 1 ~supernum 
              else 
                ++mainyp 
                tput [Y,mainyp] J M 0 ~x1  0 0 6913 0 1 ~supernum 
              end 
*      create "second half" of superobject (objects are out of order but will be reversed)
              ++mainyp 
              tput [Y,mainyp] H ~supernum  D 0 ~x2  ~y1  ~a1  ~a2 
            end 
          end 
          return 
        end 
        if htype = "R" 
&dA 
&dA &d@  structure of trill super-object:  4. situation: 1 = no trill, only ~~~~ 
&dA &d@                                                  2 = trill with ~~~~ 
&dA &d@                                                  3 = tr ~~~~ with sharp above
&dA &d@                                                  4 = tr ~~~~ with natural above
&dA &d@                                                  5 = tr ~~~~ with flat above
&dA &d@                                    5. horiz. disp. from object 1 
&dA &d@                                    6. horiz. disp. from object 2 
&dA &d@                                    7. vert. disp. from object 1 
&dA 
          tline = txt(line,[' '],lpt) 
          a1 = int(tline) 
          tline = txt(line,[' '],lpt) 
          tline = txt(line,[' '],lpt) 
          x2 = int(tline)     /* + superdata(f12,t1,3) 
          tline = txt(line,[' '],lpt) 
          y1 = int(tline) + superdata(f12,t1,2) 
          if superdata(f12,t1,5) = 0 
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] ~superline 
            end 
            x1 = int(tline) + superdata(f12,t1,1) 
          else 
            a1 = 1 
            x1 = hxpar(8) - sp - notesize 
            if justflag < 2 
*      create mark at beginning of line (mindful of virtual staff possibility)
              if superdata(f12,t1,2) > 700 and f(f12,12) = 2 
                ++mainyp 
                tput [Y,mainyp] J M 0 ~x1  1000 0 6913 0 1 ~supernum 
                y1 -= 1000 
              else 
                ++mainyp 
                tput [Y,mainyp] J M 0 ~x1  0 0 6913 0 1 ~supernum 
              end 
*      create "second half" of superobject (objects are out of order but will be reversed)
              ++mainyp 
              tput [Y,mainyp] H ~supernum  R ~a1  0 ~x2  ~y1 
            end 
          end 
          return 
        end 
        if htype = "W" 
&dA 
&dA &d@  structure of wedge super-object:  4. left spread 
&dA &d@                                    5. right spread 
&dA &d@                                    6. horiz. disp. from obj1 
&dA &d@                                    7. beg. vert. disp. from staff 
&dA &d@                                    8. horiz. disp. from obj2 
&dA &d@                                    9. end. vert. disp. from staff 
&dA 
          tline = txt(line,[' '],lpt) 
          c1 = int(tline) 
          tline = txt(line,[' '],lpt) 
          c2 = int(tline) 
          tline = txt(line,[' '],lpt) 
          tline = txt(line,[' '],lpt) 
          y1 = int(tline) 
          tline = txt(line,[' '],lpt) 
          x2 = int(tline)     /* + superdata(f12,t1,3) 
          tline = txt(line,[' '],lpt) 
          y2 = int(tline) 
          a1 = superdata(f12,t1,5) 
          if a1 = 0 
            if justflag < 2 
              ++mainyp 
              tput [Y,mainyp] ~superline 
            end 
          else 
            x1 = hxpar(8) - sp 
            c1 = a1 
            if justflag < 2 
*      create mark at beginning of line (mindful of virtual staff possibility)
              if superdata(f12,t1,2) > 700 and f(f12,12) = 2 
                ++mainyp 
                tput [Y,mainyp] J M 0 ~x1  1000 0 6913 0 1 ~supernum 
              else 
                ++mainyp 
                tput [Y,mainyp] J M 0 ~x1  0 0 6913 0 1 ~supernum 
              end 
*      create "second half" of superobject (objects are out of order but will be reversed)
              ++mainyp 
              tput [Y,mainyp] H ~supernum  W ~c1  ~c2  0 ~y1  ~x2  ~y2 
            end 
          end 
          return 
        end 
      return 
 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M* 12a. save3                                                     ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Execute a small segment of code that occures        ³ 
&dA &d@³                often                                             ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure save3 
        int t1 
        if rec > 400000 
          tmess = 66 
          perform dtalk (tmess) 
        end 
        cflag = 0 
        tget [Z,rec] line .t3 jtype ntype dvar1 oby z snode dincf 
*  dinct will be 10000 when there is a centered rest 
        if dincf = 10000                     
          dincf = 0 
          cflag = 1 
        end 
        if dincf = 10001 
          cflag = 1 
        end 
      return 
 
&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M* 12b. save4                                                     ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Execute a small segment of code that occures        ³ 
&dA &d@³                often                                             ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure save4 
        str line2.200 
S4:     tget [Z,crec] line2 .t3 cjtype cntype cdv coby cz csnode 
        if line2{1} <> "J" 
          ++crec 
          goto S4 
        end 
        if "CKTDBSFIM" con cjtype 
          if mpt < 6 
            cntype = 13 + mpt 
          else 
            cntype = 17 
          end 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M* 13. procedure parameter_init                                   ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Initialize parameters for mskpage module            ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure parameter_init 
        str mhparstr.23(5),mvparstr.27(5) 
        int sz,aa,bb,t1 

        aa = 0 
        bb = 0 

        mhparstr(1) = "9;%,)*(*,3*(%29&'(,'.*$" 
        mhparstr(2) = "W['712048I4.(FW)*/8->3%" 
        mhparstr(3) = "_c':3428;O70)K_*+1=0B6%" 
        mhparstr(4) = "fk(=553:>T91)Pf*,2?1E8%" 
        mhparstr(5) = "qw)A886<B\=4*Wq+.5C3K;&" 

        mvparstr(1) = ";5&.2%'%&%+->(1#'((#%M*+)&$" 
        mvparstr(2) = "[M*=2'-(*)6:b0D%+./$'…451+$" 
        mvparstr(3) = "cS+A2'/),*9>k2I%,01$(“783,$" 
        mvparstr(4) = "kY,D2(0)-*;At3M%-13$)¡9;5-%" 
        mvparstr(5) = "wb-J2)2*.,?F6T&/45%*¶=?8/&" 

        loop for f12 = 1 to f11 
          if f(f12,14) = 0 
            tmess = 67 
            perform dtalk (tmess) 
          end 
          if f(f12,14) <> aa 
            if aa <> 0 and f(f12,14) <> 0 
              bb = 1 
            end 
            if f(f12,14) > aa 
              aa = f(f12,14) 
            end 
          end 
        repeat 

        maxnotesize = aa 
&dA 
&dA &d@    Initializing horizontal parameters 
&dA &d@         
&dA &d@      1. Fixed horizontal parameters 
&dA 
        hxpar(1) = 30 
        hxpar(2) =  0 
        if maxnotesize = 14 
          hxpar(3)  =  200 
          hxpar(4)  = 2250 
          hxpar(6)  =  175 
          hxpar(9)  =  300 
          hxpar(16) =    6 
          hxpar(17) =    7 
          hxpar(19) =   21 
          hxpar(20) =   10 
        end 
        if maxnotesize = 21 
          hxpar(3)  =  200 
          hxpar(4)  = 2250 
          hxpar(6)  =  250 
          hxpar(9)  =  300 
          hxpar(16) =    9 
          hxpar(17) =   11 
          hxpar(19) =   32 
          hxpar(20) =   16 
        end 
        if maxnotesize = 6 
          hxpar(3)  =   85 
          hxpar(4)  =  970                   /* &dA12-04-00&d@ changed from 1050 
          hxpar(6)  =   75 
          hxpar(9)  =  130 
          hxpar(16) =    3 
          hxpar(17) =    4 
          hxpar(19) =    9 
          hxpar(20) =    4 
        end 
        if maxnotesize = 18                        /* New size-18  &dA12/18/04&d@ 
          hxpar(3)  =  200 
          hxpar(4)  = 2250 
          hxpar(6)  =  225    /*    75   175   250 
          hxpar(9)  =  300    /*   130   300   300 
          hxpar(16) =    7    /*     3     6     9 
          hxpar(17) =    9    /*     4     7    11 
          hxpar(19) =   28    /*     9    21    32 
          hxpar(20) =   14    /*     4    10    16 
        end 
        if maxnotesize = 16                        /* New size-16  &dA01/01/09&d@ 
          hxpar(3)  =  200 
          hxpar(4)  = 2250 
          hxpar(6)  =  200    /*    75   175   &dC200&d@   225   250 
          hxpar(9)  =  300    /*   130   300   &dC300&d@   300   300 
          hxpar(16) =    7    /*     3     6   &dC  7&d@     7     9 
          hxpar(17) =    9    /*     4     7   &dC  9&d@     9    11 
          hxpar(19) =   26    /*     9    21   &dC 26&d@    28    32 
          hxpar(20) =   13    /*     4    10   &dC 13&d@    14    16 
        end 

        hxpar(5)  = 26 * maxnotesize / 16 
        hxpar(7)  = 24 * maxnotesize / 16 
        hxpar(10) =  6 * maxnotesize / 16 
        hxpar(11) = 20 * maxnotesize / 16 
        hxpar(12) =  4 * maxnotesize / 16 
        hxpar(13) = 18 * maxnotesize / 16 
        hxpar(14) =  5 * maxnotesize / 16 
        hxpar(15) = 60 * maxnotesize / 16 
        hxpar(18) = 14 * maxnotesize / 16 
        hxpar(21) = 31 * maxnotesize / 16 
        hxpar(22) = 19 * maxnotesize / 16 

        if f11 = 1                                 /* for parts 
          hxpar(9) /= 3 
        end 
&dA 
&dA &d@    Variable Horizontal parameters 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        loop for f12 = 1 to f11 
          t1 = f(f12,14) + 96        /*   6, 14, 16, 18, 21    which one?  
          if "fnpru" con chr(t1)     /*   f   n   p   r   u 
            sz = mpt 
          end 
          loop for t1 = 1 to 23 
            mhpar(f12,t1) = ors(mhparstr(sz){t1}) 
            mhpar(f12,t1) -= 35 
          repeat 
        repeat 
&dA 
&dA &d@    Variable Vertical parameters 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        loop for f12 = 1 to f11 
          notesize = f(f12,14) 
          loop for t1 = 1 to 10 
            mvpar(f12,t1) = notesize * t1 / 2 
          repeat 
          mvpar(f12,11) = 200 * notesize / 16 
          mvpar(f12,12) = 4 * notesize / 16 
          mvpar(f12,13) = 0                    /* not used, formerly 8 
          mvpar(f12,14) = 160 * notesize / 16 
          mvpar20(f12) = 10 * notesize 
        repeat 

        loop for f12 = 1 to f11 
          t1 = f(f12,14) + 96        /*   6, 14, 16, 18, 21    which one?  
          if "fnpru" con chr(t1)     /*   f   n   p   r   u 
            sz = mpt 
          end 
          loop for t1 = 15 to 41 
            mvpar(f12,t1) = ors(mvparstr(sz){t1-14}) 
            mvpar(f12,t1) -= 35 
          repeat 
        repeat 
&dA 
&dA &d@    Other parameters and variables 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        aa = 4 
        bb = 3 

        zak(1,1) = bb 
        zak(1,2) = 0 - aa 
        zak(1,3) = bb 
        zak(1,4) = bb 
        zak(1,5) = 0 - aa 
        zak(1,6) = bb 
        zak(2,1) = 0 - bb 
        zak(2,2) = aa 
        zak(2,3) = 0 - bb 
        zak(2,4) = aa 
        zak(2,5) = 0 - bb 
        zak(2,6) = aa 

        ttext = "" 
        curfont = 0 
&dA 
&dA &d@ &dE                                        
&dA &d@ &dE  End of Initialization of parameters   
&dA &d@ &dE                                        
&dA 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M* 14. procedure pageform_init                                    ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Get parameters for page layout.                     ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure pageform_init 
        str savesyscode.80 
        int t1,t2,t3,t4,t5 

        toplim = Top_of_page 
        lowerlim = toplim + Length_of_page 
        psq(1) = toplim

        tacetline = "" 

        justflag = Just_flag * 2 
        hxpar(3) = Marg_left 
        hxpar(4) = hxpar(3) + Sys_width 
&dA 
&dA &d@    Check the format of syscode 
&dA 
        syscode = Syscode 

        t1 = 0 
        t2 = 0 
        loop for t4 = 1 to len(syscode) 
          if "[](){}" con syscode{t4} 
            t3 = mpt + 1 >> 1 
            ++tarr(t3) 
            ++t1 
            if bit(0,tarr(t3)) <> bit(0,mpt) 
              tmess = 68 
              perform dtalk (tmess) 
            end 
          end 
          if "x:" con syscode{t4} 
            f(t2+1,12) = mpt 
            syscode{t4} = "." 
          else 
            f(t2+1,12) = 0 
          end 
          if syscode{t4} = "." 
            ++t2 
            loop for t3 = 1 to 3 
              if bit(0,tarr(t3)) <> 0 
                goto SQ11 
              end 
            repeat 
            tmess = 68 
            perform dtalk (tmess) 
          end 
SQ11:   repeat 
        if t2 <> f11 
          tmess = 68 
          perform dtalk (tmess) 
        end 
        if bit(0,t1) = 1 
          tmess = 68 
          perform dtalk (tmess) 
        end 
&dA 
&dA &d@    Get and check spacings 
&dA 
        if W(1) = 0 
&dA 
&dA &d@    Construct default spacings 
&dA 
          t2 = 0 
          t3 = 0 
          loop for t1 = 1 to Nparts 
            w(t1) = 0 
          repeat 
          loop for t1 = 1 to len(Syscode) 
            if ".:" con Syscode{t1} 
              if t2 = 0 
                t2 = 1 
              else 
                ++t3 
                w(t3) += 10 
              end 
            else 
              if t1 < len(Syscode) 
                if ")]" con Syscode{t1} 
                  w(t3+1) += 2 
                end 
              end 
            end 
          repeat 
          ++t3 
          if t3 = Nparts 
            w(t3) = 15 
          else 
            w(t3) = 10 
          end 
          loop for t4 = 1 to Nparts 
            W(t4) = w(t4) * notesize 
          repeat 
        end 
        loop for t4 = 1 to Nparts 
          w(t4) = W(t4) 
        repeat 

        loop for t4 = 2 to f11 
          if w(1) = 0 
            if f(t4-1,9) = 0 
              psq(t4) = psq(t4-1) + mvpar(t4-1,14) 
            else 
              psq(t4) = psq(t4-1) + mvpar(t4-1,11) 
            end 
          else 
            psq(t4) = psq(t4-1) + w(t4-1) 
          end 
          if f(t4-1,12) = 2 
            if vst(t4-1) = 0 
              vst(t4-1) = mvpar(t4-1,14) 
            end 
            psq(t4) += vst(t4-1) 
          else 
            vst(t4-1) = 0 
          end 
        repeat 
        if f(f11,12) = 2 
          if vst(f11) = 0 
            vst(f11) = mvpar(f11,14) 
          end 
        end 
      
        no_action = 0 
        psysnum = 0 
        start_look = 1 
        pn_left = 0 
&dA 
&dA &d@   This code added &dA12/24/03&d@ to set new variables intersys and firstsys 
&dA 
        if w(1) = 0 
          intersys = mvpar(f11,14) * 3 / 2 
        else 
          intersys = w(f11) 
        end 
        firstsys = TRUE 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³M* 15. procedure output_page (size)                               ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose:  Transfer Y-table to output file                     ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Note:  This procedure must be rewritten at some point         ³ 
&dA &d@³                                                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure output_page (size) 
        str line2.200 

        int t1,t2,t3,t4,t5,t6,t7,t8,t9 
        int p1,p2,p3 
        int size 
        int next_obx,prior_obx,current_obx 
        int next_t6 
        int gap,minspace,gap2,length,shift 
        int flag 
        int old_t2 

        getvalue size 
&dA 
&dA &d@    This procedure is written to handle both parts and scores.  
&dA &d@    In the case of parts (f11 = 1), an adjustment needs to be 
&dA &d@    made for the multiple rests.  In the case of scores (f11 > 1), 
&dA &d@    adjustments may be required in the vertical spacings.  
&dA 
        if job_type = "p" 
          goto M_OUT_PAGE1 
        end 
&dA 
&dA &d@    This section deals with scores 
&dA 
&dA &d@    Step 1: Determine space at the bottom 
&dA 
        t3 = 0 
        t8 = 0 
        loop for t1 = 1 to size  
          tget [Y,t1] line 
          if "Ll" con line{1} 
            ++t3 
          end 
          if line{1} = "S" 
            ++t8 
          end 
        repeat 
        --t3 
        --t8 

        if old_sys_bottom = 0 
          t2 = lowerlim - (sys_bottom + (4 * notesize)) 
        else 
          t2 = lowerlim - (old_sys_bottom + (4 * notesize)) 
        end 
&dA 
&dA &d@    Step 2: Determine space to add or subtract 
&dA 
        if t2 < 0 and t3 > 0   /* contraction is mandatory.  Just do it.  
          t2 = 0 - t2 
          t2 /= t3 
          old_t2 = 0 

          t6 = 0         /* space change counter 
          loop for t1 = 1 to size 
            tget [Y,t1] line
            if line{1} = "S" 
              p1 = int(line{3..}) 
              p2 = int(line{sub..}) 
              p3 = int(line{sub..}) 
              line = line{sub..} 
              if t6 > 0 
                p3 -= (t6 * t2) 
                line = "S 0 " // chs(p2) // " " // chs(p3) // line 
                tput [Y,t1] ~line 
              end 
              ++t6 
              t3 = t6    /* t3 = system "anchor" 
            end 
            if "Ll" con line{1} 
              t4 = int(line{3..}) 
              t5 = sub 
              t7 = t6 - t3 
              if t7 > 0 
                t4 -= (t2 * t7) 
                line = line{1} // " " // chs(t4) // line{t5..} 
                tput [Y,t1] ~line 
              end 
              ++t6 
            end 
          repeat 
          t2 = 0 
        else 
          if Vspace_flag = 0
            t2 = 0 
          end 
          if t2 > 0 
            if Vspace_flag = 1 
              if t3 = 0 
                t2 = 0 
              else 
                t2 /= t3 
              end 
            else 
              if t8 > 0 
                t2 /= t8 
              else 
                t2 = 0 
              end 
            end 
          end 
        end 
&dA 
&dA &d@    Step 3:  if t2 > 0, perform expansion 
&dA 
        if t2 > 0 
          if old_sys_bottom = 0 
            if t2 > (old_t2 * 3 / 2)      /* to keep the last page from looking funny
              t2 = old_t2 
            end 
          end 
          old_t2 = t2                     /* record this spacing for future pages

          if Vspace_flag = 1 
            t6 = 0         /* space change counter 
            loop for t1 = 1 to size 
              tget [Y,t1] line 
              if line{1} = "S" 
                p1 = int(line{3..}) 
                p2 = int(line{sub..}) 
                p3 = int(line{sub..}) 
                line = line{sub..} 
                if t6 > 0 
                  p3 += (t6 * t2) 
                  line = "S 0 " // chs(p2) // " " // chs(p3) // line 
                  tput [Y,t1] ~line 
                end 
&dK &d@               ++t6       /* error.  Use music lines only to advance t6 
                t3 = t6    /* t3 = system "anchor" 
              end 
              if "Ll" con line{1} 
                t4 = int(line{3..}) 
                t5 = sub 
                t7 = t6 - t3 
                if t7 > 0 
                  t4 += (t2 * t7) 
                  line = line{1} // " " // chs(t4) // line{t5..} 
                  tput [Y,t1] ~line 
                end 
                ++t6 
              end 
            repeat 
          else 
            t6 = 0         /* space change counter 
            loop for t1 = 1 to size 
              tget [Y,t1] line 
              if line{1} = "S" 
                p1 = int(line{3..}) 
                p2 = int(line{sub..}) 
                p3 = int(line{sub..}) 
                line = line{sub..} 
                if t6 > 0 
                  p3 += (t6 * t2) 
                  line = "S 0 " // chs(p2) // " " // chs(p3) // line 
                  tput [Y,t1] ~line 
                end 
                ++t6 
              end 
            repeat 
          end 
        end 
&dA 
&dA &d@    Step 4:  Put out (optional) Work_name, Work_number, and Composer 
&dA 
        t9 = 0 
        if Work_name <> "" or Work_number <> "" 
          ++if_cnt 
          tput [IF,if_cnt] X 14
          if Work_name <> "" 
            ++if_cnt 
            tput [IF,if_cnt] X 46 1200C ~t9  ~Work_name 
            t9 += 44 
          end 
          if Work_number <> "" 
            ++if_cnt 
            tput [IF,if_cnt] X 37 1200C ~t9  ~Work_number 
          end 
        end 
        if if_cnt < 5 and Composer <> "" 
          tget [Y,1] line .t3 p1 p1 p2 p3 
          if line{1} = "S" 
            p3 += p1 
            p2 -= (4 * notesize) 
            ++if_cnt 
            tput [IF,if_cnt] X ~notesize 
            ++if_cnt 
            tput [IF,if_cnt] X 31 ~p3 R ~p2  ~Composer 
          end 
        end 
&dA 
&dA &d@    Step 5:  Put out the lines to the page 
&dA 
        ++if_cnt                        /* need to communicate notesize here
        tput [IF,if_cnt] X ~notesize 
        loop for t6 = 1 to size 
          tget [Y,t6] line 
          line = trm(line) 
          ++if_cnt 
          tput [IF,if_cnt] ~line 
        repeat 
        ++if_cnt 
        tput [IF,if_cnt] P
        return 
        
&dA 
&dA &d@    This section deals with parts 
&dA 
M_OUT_PAGE1: 
        gap = maxnotesize * 2 
        minspace = gap * 2 + 90 
&dA 
&dA &d@    Step 1:  Put out (optional) Work_name, Work_number, and Composer 
&dA 
        t9 = 0 
        if Work_name <> "" or Work_number <> "" 
          ++if_cnt 
          tput [IF,if_cnt] X 14
          if Work_name <> "" 
            ++if_cnt 
            tput [IF,if_cnt] X 46 1200C ~t9  ~Work_name 
            t9 += 44 
          end 
          if Work_number <> "" 
            ++if_cnt 
            tput [IF,if_cnt] X 37 1200C ~t9  ~Work_number 
          end 
        end 
        if if_cnt < 5 and Composer <> "" 
          tget [Y,1] line .t3 p1 p1 p2 p3 
          if line{1} = "S" 
            p3 += p1 
            p2 -= (4 * notesize) 
            ++if_cnt 
            tput [IF,if_cnt] X ~notesize 
            ++if_cnt 
            tput [IF,if_cnt] X 31 ~p3 R ~p2  ~Composer 
          end 
        end 

        ++if_cnt                        /* need to communicate notesize here
        tput [IF,if_cnt] X ~notesize 
        loop for t6 = 1 to size 
          tget [Y,t6] line 
          line = line // pad(6) 
          if line{1,5} = "J S 4" 
            current_obx = int(line{7..}) 
            line = line{sub..} 
            line = mrt(line) 
            loop for t7 = t6 + 1 to size 
              tget [Y,t7] line2 
              if line2{1} = "J" 
                t2 = int(line2{5..}) 
                next_obx = int(line2{sub..})       /* next obx 
                next_t6 = t7 - 1 
                t7 = size 
              end 
            repeat 
            loop for t7 = t6 - 1 to 1 step -1 
              tget [Y,t7] line2 
              if line2{1} = "J" and line2{3} <> "D" and line2{3} <> "M"   /* New &dA02/13/09
                t2 = int(line2{5..}) 
                prior_obx = int(line2{sub..})      /* prior obx 
&dA 
&dA &d@          New &dA02/13/09&d@ 
&dA 
                if line2{3} = "K"   
                  t8 = int(line2{5..}) 
                  if t8 > 0 
                    prior_obx += (t8 * mhpar(f12,6)) 
                  end 
                  if t8 < 0 
                    prior_obx -= (t8 * mhpar(f12,7)) 
                  end 
                end 
&dA     
                t7 = 1 
              end 
            repeat 
            t8 = next_obx - prior_obx 
            if t8 > minspace 
              flag = 0 
              t5 = t8 / minspace 
              gap2 = gap * t5 
              t5 = prior_obx + gap2 
              length = next_obx - t5 - gap2 
              shift = length - 90 / 2 

              line = "J S 4 " // chs(t5) // " " // line 
              ++if_cnt 
              tput [IF,if_cnt] ~line 
              loop for t7 = t6 + 1 to next_t6 
                tget [Y,t7] line2 
                if line2{1} = "K" 
                  t1 = int(line2{3..}) 
                  t2 = int(line2{sub..}) 
                  t3 = int(line2{sub..}) 
                  if t3 > 70 and t3 < 81 
                    t1 += shift 
                    ++if_cnt 
                    tput [IF,if_cnt] K ~t1  ~t2  ~t3 
                  end 
                  if t3 = 62 
                    if t1 = 0 
                      ++if_cnt 
                      tput [IF,if_cnt] K 0 ~t2  62 
                    else 
                      ++if_cnt 
                      tput [IF,if_cnt] K ~length  ~t2  62 
                    end  
                  end 
                  if t3 = 92 and flag = 0 
                    flag = 1 
                    t1 = length 
                    loop while t1 > 30 
                      t4 = t1 - 30 
                      ++if_cnt 
                      tput [IF,if_cnt] K ~t4  ~t2  92 
                      t1 -= 30 
                    repeat 
                    ++if_cnt 
                    tput [IF,if_cnt] K 0 ~t2  92 
                  end 
                end 
              repeat 
              t6 = next_t6 
            end 
          else 
            line = trm(line) 
            ++if_cnt 
            tput [IF,if_cnt] ~line 
          end 
        repeat 
        ++if_cnt 
        tput [IF,if_cnt] P 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  1. my_pspage                                                ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Input: from source library (at the moment)                  ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Output: .ps pages to the same source library                ³ 
&dA &d@³                                                                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure my_pspage 
        str file.280
        str temp2.400,temp3.200 
        str tline.480,ttext.480,htype.1,save_jtype.1 
        str quote.1 
        str xystring_out.100 
        str FAdata.610 
        str recon.6400 
        str Beamincstr.255 
        str Wedgincstr.255 
        str Tieincstr.50 

        int saverec,textlen 
        int buxstop(10) 
        int t1,t2,t3,t4,t5,t6,t7,t8 
        int q(12) 
        int a1,a2,a3,a4,a5,a6,a7,a8,a9 
        int c1,c2,c3,c4,c5,c6,c7,c8,c9 
        int f4,f(32,10) 
        int ps_superdata(SUPERMAX,SUPERSIZE),supermap(SUPERMAX),superpnt(SUPERMAX)
        int sysy,sysh,syslen,sysflag,sysnum,sysright 
        int ntext,tlevel 
        int govstaff 
        int savensz 
        int savesub 
        int stave_type 
        int active_font 
        int lastx,lasty 
        int top_limit 
        int bottom_limit 
        int left_limit 
        int right_limit 
        int mpgfile_start(300) 
        int sys_left_limit(300) 
        int sys_right_limit(300) 
        int sys_top_limit(300) 
        int sys_bottom_limit(300) 
        int box_left_limit(300) 
        int box_right_limit(300) 
        int box_top_limit(300) 
        int box_bottom_limit(300) 
        int beambig(5220) 
        int page_cnt 
        int ii 
&dA 
&dA &d@    &dA12/31/08&d@ Initializing the hookbackshift array         
&dA 
        hookbackshift(1)  =  7 
        hookbackshift(2)  =  8 
        hookbackshift(3)  =  8   /* for size 6 regular 
        hookbackshift(4)  = 11 
        hookbackshift(5)  = 12 
        hookbackshift(6)  = 14 
        hookbackshift(7)  = 15 
        hookbackshift(8)  = 17   /* for size 14 regular 
        hookbackshift(9)  = 18 
        hookbackshift(10) = 19   /* for size 18 regular 
        hookbackshift(11) = 21 
        hookbackshift(12) = 22   /* for size 21 regular 
        hookbackshift(13) = 24 
        hookbackshift(14) = 25 

&dA   &d@   End of &dA12/31/08&d@ addition 

        perform not_very_messy 

        notesize = 14 
        sizenum = 8
        mtfont = 31 
&dA 
&dA &d@  get shift parameters for music font 
&dA 
        line = "3/0/102.2.2.2.0/0/0.0!.0(3/0/101/1/2/2/1/0/0A"

        t5 = len(line) 
        t6 = 0 
        loop for t1 = 1 to t5 step 2 
          t2 = ors(line{t1}) - 48 
          t3 = ors(line{t1+1}) 
          loop for t4 = 1 to t3 
            ++t6 
            urpos(t6) = t2 
          repeat 
        repeat 

        perform ps_init_par 

&dA &d@     Outputs:  pvpar(.)
&dA &d@               phpar(.) 
&dA &d@               pvpar20 
&dA &d@               expar(.) 
&dA &d@               revmap(.) 
&dA &d@               sizenum 

        wak(1) = 140 
        wak(2) = 156      /* works for ‡. but not for ó 
        wak(3) = 131 
        wak(4) = 156 
        wak(5) = 128 
        wak(6) = 140 
        wak(7) = 128 
        wak(8) = 129 
        wak(9) = 130 
 
        quote = chr(34) 
        ttext = "" 

        loop for t3 = 1 to 255 
          music_con(t3) = t3 
        repeat 
        music_con(102) = 110            /* forte 
        music_con(109) = 109            /* mezzo 
        music_con(112) = 108            /* piano 
        music_con(114) = 113            /* r 
        music_con(115) = 111            /* s 
        music_con(122) = 112            /* z 
&dA 
&dA &d@   &dA03/04/05&d@  Need screen fonts for line length code, even when PRINTING 
&dA 
&dA &d@   Get screen fonts 
&dA 
        FAdata = "~CC~C«C®~CÉCÌ~CçCê~CC~C#C&~CšC"
        FAdata = FAdata // "~CC~CˆC‹~CC~C¨C«~C[C^CC Cô"
        FAdata = FAdata // " CÿCÿCÿCÿCÿCC Cô CÿCÿCÿCÿCÿCC Cô C"
        FAdata = FAdata // "ÿCÿCÿCÿCÿCC Cô CÿCÿCÿCÿCÿCC Cô CÿC"
        FAdata = FAdata // "ÿCÿCÿCÿCC9@Cä@CÿhCÿhCÿhCÿhCÿCC9@Cä@CÿhCÿhC"
        FAdata = FAdata // "ÿhCÿhCÿCC9@Cä@CÿhCÿhCÿhCÿhCÿCCA@Cà@CÿxCÿxCÿxC"
        FAdata = FAdata // "ÿxCÿC(CJ@CÜ@Cî»€Cî»€Cî»€Cî»€Cî»C-CW@CÖ@CÿCÿ"
        FAdata = FAdata // "CÿCÿCÿC-CW@CÖ@CÿCÿCÿCÿCÿ"

        a3 = len(FAdata) 
        loop for a1 = 1 to a3 
          a2 = ors(FAdata{a1}) 
          if a2 = 67 
            a2 = 0 
          end 
          if a2 = 68 
            a2 = 10 
          end 
          if a2 = 69 
            a2 = 11 
          end 
          if a2 = 70 
            a2 = 27 
          end 
          FAdata{a1} = chr(a2) 
        repeat 

        gstr = "" 
        loop for a1 = 1 to a3 step 2 
          a2 = ors(FAdata{a1}) 
          loop for a4 = 1 to a2 
            gstr = gstr // FAdata{a1+1} 
          repeat 
        repeat 

        t4 = 1 
        loop for t3 = 1 to len(gstr) step 4 
          FA(t4) = ors(gstr{t3,4}) 
          ++t4 
        repeat 
&dA 
&dA &d@   Construct increments for beam characters 
&dA 
        Beamincstr = "22222222222222222222222222222222PPPPPPPPPPPPPPPPCCCCCCCCCCCCCCCC"
        Beamincstr = Beamincstr // "ABBBBBBBBBBBCCCC344555566666677777777788888888899999999:::;<2222"
        Beamincstr = Beamincstr // "22222222222222222222222222222222PPPPPPPPPPPPPPPPCCCCCCCCCCCCCCCC"
        Beamincstr = Beamincstr // "ABBBBBBBBBBBBBBB344555566666677777777788888888899999999:::;<222"

        loop for t3 = 1 to 255 
          Beaminc(t3) = ors(Beamincstr{t3}) - 50 
        repeat 
&dA 
&dA &d@   Construct increments for tie characters 
&dA 
        loop for t3 = 1 to 12 
          loop for t4 = 1 to 255 
            Tieinc(t3,t4) = 0 
          repeat 
        repeat 

        Tieincstr = "68:<>@BDFH4" 
        loop for t3 = 1 to 5                          /*    68:<>@BDFH4
          loop for t4 = 1 to 24                       /*                          
            Tieinc(t3,t4+90) = ors(Tieincstr{t4})     /*    91                     114
            Tieinc(t3,t4+218) = ors(Tieincstr{t4})    /*    219                    242
          repeat 
        repeat 

        Tieincstr = "|€„ˆŒ”˜œ x" 
        loop for t3 = 6 to 8                          /*    |€„ˆŒ”˜œ x
          loop for t4 = 1 to 24                       /*                          
            Tieinc(t3,t4+90) = ors(Tieincstr{t4})     /*    91                     114
            Tieinc(t3,t4+218) = ors(Tieincstr{t4})    /*    219                    242
          repeat 
        repeat 

        Tieincstr = "`einrw{€…‰’—› ¥©®²·‰" 
        loop for t4 = 1 to 44                      /* `einrw{€…‰’—› ¥©®²·‰
          Tieinc(9,t4+80) = ors(Tieincstr{t4})     /*                                           
          Tieinc(9,t4+208) = ors(Tieincstr{t4})    /* 81                                         124
        repeat                                     /* 209                                        252

        Tieincstr = "mrw|†‹‘–› ¥ª°µº¿ÄÊĞ›" 
        loop for t4 = 1 to 44                      /* mrw|†‹‘–› ¥ª°µº¿ÄÊĞ›
          Tieinc(10,t4+80) = ors(Tieincstr{t4})    /*                                           
          Tieinc(10,t4+208) = ors(Tieincstr{t4})   /* 81                                         124
        repeat                                     /* 209                                        252

        Tieincstr = "~„Š–œ¢¨®´ºÀÆÌÒØŞäêğ´" 
        loop for t3 = 11 to 12                     /* ~„Š–œ¢¨®´ºÀÆÌÒØŞäêğ´
          loop for t4 = 1 to 44                    /*                                           
            Tieinc(t3,t4+80) = ors(Tieincstr{t4})  /* 81                                         124
            Tieinc(t3,t4+208) = ors(Tieincstr{t4}) /* 209                                        252
          repeat 
        repeat 

        loop for t3 = 1 to 12 
          loop for t4 = 1 to 255 
            if Tieinc(t3,t4) = 6 
              Tieinc(t3,t4) = 0 
            end 
          repeat 
        repeat 
&dA 
&dA &d@   Construct increments for wedge characters 
&dA 
        Wedgincstr = "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<xdZTPMKIHGFEDCBA@?>=xdZTPMKIHGFE"
        Wedgincstr = Wedgincstr // "DCBA@?>=xZPKHFEDCBA@?>=<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
        Wedgincstr = Wedgincstr // "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<HEB?HHHHHEEEEEBBBBB?????HHHHHEEE"
        Wedgincstr = Wedgincstr // "EEBBBBB?????<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"

        loop for t3 = 1 to 255 
          Wedginc(t3) = ors(Wedgincstr{t3}) - 60 
        repeat 
&dA 
&dA &d@   &dA12/01/08&d@  Need postscript dictionary generator for POSTSCRIPT
&dA 
        open [8,8] postdict 
        len(gstr) = sze 
        read [8] gstr 
        close [8] 
                
        temp2 = chr(13) // chr(10) 
        a1 = 0 
        a2 = 1 
        loop while gstr{a2..} con temp2 
          ++a1 
          tput [XX,a1] ~gstr{a2..sub-1} 
          a2 = sub + 2 
        repeat 
&dA 
&dA &d@  get spacing parameters for hyphon and underline characters (text font) 
&dA 
        loop for a1 = 1 to 12 
          a2 = mtfont - 29                   /* 1 <= a2 <= 19 
          a3 = XFonts(a1,a2) - 50            /* 1 <= a3 <= 90 (text font) 
          a3 = (a3 - 1) * 200 + 1 

          loop for a4 = 32 to 45 
            hyphspc(a1) = ors(fontspac{a3}) 
            ++a3 
          repeat 
          loop for a4 = 46 to 95 
            underspc(a1) = ors(fontspac{a3}) 
            ++a3 
          repeat 
        repeat 
&dA 
&dA &d@  get beam generation parameters (5220 total) 
&dA 
        out = "1¼2¼3¹4¶5º1¶2¼3»4¼5¸1¾2¾3½1»2»3¼4»1¹2º3º4º5º1¸2¹3¹4¹5¹6¹1¹2¹3¼4¹5º1»2¸3»4¹5º1»2º"
        out = out // "3»4»5¶1º2º3º4º5¹1º2º3¹4º5º1¹2¹3¹4¹5¹6¸1¹2»3º4¹5º1º2¹3º4»5¹1º2º3º4º5¹QµSµVµ\µcµkµ"
        out = out // "tµyÊQµSĞQµÓµÖµÛµáµéµòµøµ{µ|ÈQµSµWµ]µdµlµuËQµSµWµ]µdÍQµSµWµ]ÎQµSµVµ\µcÍQµRµTµXµ^µ"
        out = out // "gµpËQµRµTµYµ_µhµqËQµRµTµYµ_µhÌQµRµTµYµ_µhÌQµRµTµYµ_ÍQµRµUµZµ`ÍQµRµUµZµfµoÌQµRµUµ"
        out = out // "ZµfµoÌ0¼1É0¶1Ï0¾1Ç0»2Ê0¹2Ì0¸2Í0¹2Ì0»1Ê0»2Ê0º2Ë0º2Ë0¹2Ì0¹2Ì0º3Ë0º3Ë0¼QµÓµÖµÛµáµéµ"
        out = out // "òµøÂ0¶QµÓµÖµÛµáµéµòµøÈ0¾QµÓµÖµÛµáµéµòµøµ{µ|¾0»QµÓµÖµÛµáµéµòÄ0¹QµÓµÖµÛµáµéÇ0¸QµÓµ"
        out = out // "ÖµÛµáÉ0¹QµÓµÖµÛµáÈ0»QµSµWµ]Ç0»QµRµTµYµ_µhÅ0ºQµRµTµYµ_µhÆ0ºQµRµUµZµ`µnÆ0¹QµRµTµYµ"
        out = out // "_È0¹QµRµUµZµfµoµwÆ0ºQµRµTµYµ_Ç0ºQµRµUµZµfµoÆ0M1½0Â1Ã0¿1Æ0½1È0¾1Ç0¿2Æ0Á2Ä0À2Å0À2Å"
        out = out // "0¾2Ç0À3Å0¿2Æ0À3Å0ÄQµRµTµXµ^½0¾QµSµVµ[µbµjµsÁ0ÈQµÓµÖµÛµáµéµòµøµ{µ0ÂQµÓµÖµÛµáµéµòµ"
        out = out // "ø¼0¿QµÓµÖµÛµáµéÁ0½QµÓµÖµÛµáÄ0¾QµÓµÖµÛµeµmµvµzÀ0¿QµRµTµXµ^µgµpÀ0ÁQµRµTµXµ^µgµp¾0À"
        out = out // "QµRµTµYµ_µhÀ0ÀQµRµUµZµ`Á0¾QµRµTµYµ_Ã0ÀQµRµUµZµfµoÀ0¿QµRµUµZµfµoÁ0ÀQµRµUµZµfµoÀ0-"
        out = out // "1À021»0Å1À0Â1Ã0Æ2¿0Æ1¿0È2½0Æ2¿0Å2À0Ã2Â0Æ3¿0Å3À0Æ3¿0ÉQµR»0ÅQµÓµÖµÛµáµéµòµø¹02QµÓµ"
        out = out // "ÖµÛµáµéµòµ0ÅQµÓµÖµÛµáµé»0ÂQµÓµÖµÛµá¿0ÆQµÓµÖµÛµá»0ÆQµSµWµ]µd»0ÈQµRµTµYµ_µhµq·0ÆQµ"
        out = out // "RµTµYµ_µhº0ÅQµRµUµZµ`µn»0ÃQµRµTµYµ_¾0ÆQµRµTµYµ_»0ÅQµRµUµZµfµoµwº0ÆQµRµUµZµfµoº0Š"
        out = out // "1º0Ç1¾0Ë1º0Ë2º0Ï2¶0Ì2¹0Ë2º0È2½0Ë2º0Ì3¹0Ì3¹0ËQµSµVµ[µbµjµ0ÍQµSµVµ[µ0PQµÓµÖµÛµáµéµ"
        out = out // "0ÇQµÓµÖµÛµáº0ËQµÓµÖµÛµeµmµ0ËQµRµTµYµ_µhµ0ÏQµRµ0ÌQµRµTµYµ_µ0ËQµRµUµZµfµoµ0ÈQµRµTµ"
        out = out // "Yµ_¹0ËQµRµUµZµ`µnµ0ÌQµRµUµZµfµ0ÌQµRµUµZµfµ0¨1¹0©2¸0ÿQµÓµÖµÛµáµ0©QµRµTµYµ0V"

        t5 = 0 
        loop for t1 = 1 to len(out) step 2 
          t2 = ors(out{t1}) 
          if t2 < 80 
            t2 -= 48 
          end 
          t3 = ors(out{t1+1}) 
          if t3 >= 180 and t3 < 220 
            t3 -= 180 
          else 
            ++t3 
          end 
          loop for t4 = 1 to t3 
            ++t5 
            beambig(t5) = t2 
          repeat 
        repeat 

        t1 = 0 
        loop for t7 = 1 to 12 
          loop for t8 = 1 to 435 
            ++t1 
            beamext(t8,t7) = beambig(t1) 
          repeat 
        repeat 
&dA 
&dA &d@   Set parameters for circular slur generation 
&dA 
        slpara(1,1)  =   20.60 
        slpara(1,2)  =   27.00 
        slpara(1,3)  =   33.70 
        slpara(1,4)  =   40.70 
        slpara(1,5)  =   48.10 
        slpara(1,6)  =   55.80 
        slpara(1,7)  =   63.70 
        slpara(1,8)  =   72.40 
        slpara(1,9)  =   81.70 
        slpara(1,10) =   91.90 
        slpara(1,11) =  105.40 
        slpara(1,12) =  122.70 
        slpara(1,13) =  134.70 
        slpara(1,14) =  153.00 
        slpara(1,15) =  173.50 
        slpara(1,16) =  198.00 
        slpara(1,17) =  230.40 
        slpara(1,18) =  259.10 
        slpara(1,19) =  300.00 
        slpara(1,20) =  800.00 
* 
        slpara(2,1)  =   13.90 
        slpara(2,2)  =   19.80 
        slpara(2,3)  =   25.70 
        slpara(2,4)  =   31.80 
        slpara(2,5)  =   38.10 
        slpara(2,6)  =   44.70 
        slpara(2,7)  =   51.40 
        slpara(2,8)  =   58.40 
        slpara(2,9)  =   65.80 
        slpara(2,10) =   73.60 
        slpara(2,11) =   82.00 
        slpara(2,12) =   93.20 
        slpara(2,13) =  107.70 
        slpara(2,14) =  116.00 
        slpara(2,15) =  129.90 
        slpara(2,16) =  145.50 
        slpara(2,17) =  164.40 
        slpara(2,18) =  188.70 
        slpara(2,19) =  206.00 
        slpara(2,20) =  800.00 
        slpara(2,21) =  800.00 
        slpara(2,22) =  800.00 
* 
        slpara(3,1)  =    7.00 
        slpara(3,2)  =   13.20 
        slpara(3,3)  =   18.80 
        slpara(3,4)  =   24.40 
        slpara(3,5)  =   30.20 
        slpara(3,6)  =   36.20 
        slpara(3,7)  =   42.40 
        slpara(3,8)  =   48.80 
        slpara(3,9)  =   55.40 
        slpara(3,10) =   62.40 
        slpara(3,11) =   69.40 
        slpara(3,12) =   77.40 
        slpara(3,13) =   86.20 
        slpara(3,14) =   95.80 
        slpara(3,15) =  106.00 
        slpara(3,16) =  117.20 
        slpara(3,17) =  129.80 
        slpara(3,18) =  144.40 
        slpara(3,19) =  162.20 
        slpara(3,20) =  187.60 
        slpara(3,21) =  225.40 
        slpara(3,22) =  800.00 
        slpara(3,23) =  800.00 
        slpara(3,24) =  800.00 
        slpara(3,25) =  800.00 
        slpara(3,26) =  800.00 
        slpara(3,27) =  800.00 
        slpara(3,28) =  800.00 
* 
        slpara(4,1)  =    7.00 
        slpara(4,2)  =   10.00 
        slpara(4,3)  =   13.20 
        slpara(4,4)  =   18.80 
        slpara(4,5)  =   24.40 
        slpara(4,6)  =   30.20 
        slpara(4,7)  =   36.20 
        slpara(4,8)  =   42.40 
        slpara(4,9)  =   48.80 
        slpara(4,10) =   55.40 
        slpara(4,11) =   62.40 
        slpara(4,12) =   69.40 
        slpara(4,13) =   77.00 
        slpara(4,14) =   84.80 
        slpara(4,15) =   93.20 
        slpara(4,16) =  102.00 
        slpara(4,17) =  111.40 
        slpara(4,18) =  121.60 
        slpara(4,19) =  132.80 
        slpara(4,20) =  145.40 
        slpara(4,21) =  159.80 
        slpara(4,22) =  177.60 
        slpara(4,23) =  202.00 
        slpara(4,24) =  227.80 
        slpara(4,25) =  275.00 
        slpara(4,26) =  375.00 
        slpara(4,27) =  575.00 
        slpara(4,28) =  800.00 
        slpara(4,29) =  800.00 
        slpara(4,30) =  800.00 
        slpara(4,31) =  800.00 
        slpara(4,32) =  800.00 
* 
        slpara(5,1)  =    7.00 
        slpara(5,2)  =    7.00 
        slpara(5,3)  =   10.00 
        slpara(5,4)  =   13.20 
        slpara(5,5)  =   18.80 
        slpara(5,6)  =   24.40 
        slpara(5,7)  =   30.20 
        slpara(5,8)  =   36.20 
        slpara(5,9)  =   42.40 
        slpara(5,10) =   48.80 
        slpara(5,11) =   55.40 
        slpara(5,12) =   62.40 
        slpara(5,13) =   69.40 
        slpara(5,14) =   76.40 
        slpara(5,15) =   83.60 
        slpara(5,16) =   91.00 
        slpara(5,17) =   98.80 
        slpara(5,18) =  107.00 
        slpara(5,19) =  115.60 
        slpara(5,20) =  125.00 
        slpara(5,21) =  135.00 
        slpara(5,22) =  145.80 
        slpara(5,23) =  158.00 
        slpara(5,24) =  171.80 
        slpara(5,25) =  188.60 
        slpara(5,26) =  207.80 
        slpara(5,27) =  228.20 
        slpara(5,28) =  258.40 
        slpara(5,29) =  320.00 
        slpara(5,30) =  440.00 
        slpara(5,31) =  680.00 
        slpara(5,32) =  800.00 
        slpara(5,33) =  800.00 
        slpara(5,34) =  800.00 
        slpara(5,35) =  800.00 
        slpara(5,36) =  800.00 
* 
        slpara(6,1)  =    7.00 
        slpara(6,2)  =    7.00 
        slpara(6,3)  =    7.00 
        slpara(6,4)  =   11.00 
        slpara(6,5)  =   15.00 
        slpara(6,6)  =   18.80 
        slpara(6,7)  =   24.40 
        slpara(6,8)  =   30.20 
        slpara(6,9)  =   36.20 
        slpara(6,10) =   42.40 
        slpara(6,11) =   48.80 
        slpara(6,12) =   55.40 
        slpara(6,13) =   62.40 
        slpara(6,14) =   68.60 
        slpara(6,15) =   74.60 
        slpara(6,16) =   80.80 
        slpara(6,17) =   87.40 
        slpara(6,18) =   94.20 
        slpara(6,19) =  101.20 
        slpara(6,20) =  108.60 
        slpara(6,21) =  116.20 
        slpara(6,22) =  124.40 
        slpara(6,23) =  132.80 
        slpara(6,24) =  142.00 
        slpara(6,25) =  151.80 
        slpara(6,26) =  162.60 
        slpara(6,27) =  174.40 
        slpara(6,28) =  188.00 
        slpara(6,29) =  203.20 
        slpara(6,30) =  217.80 
        slpara(6,31) =  234.80 
        slpara(6,32) =  256.40 
        slpara(6,33) =  291.00 
        slpara(6,34) =  350.00 
        slpara(6,35) =  500.00 
        slpara(6,36) =  800.00 
        slpara(6,37) =  800.00 
        slpara(6,38) =  800.00 
        slpara(6,39) =  800.00 
        slpara(6,40) =  800.00 
        slpara(6,41) =  800.00 
* 
        slpara(7,1)  =    7.00 
        slpara(7,2)  =    7.00 
        slpara(7,3)  =    7.00 
        slpara(7,4)  =    7.00 
        slpara(7,5)  =   11.00 
        slpara(7,6)  =   18.00 
        slpara(7,7)  =   21.00 
        slpara(7,8)  =   24.40 
        slpara(7,9)  =   30.20 
        slpara(7,10) =   36.20 
        slpara(7,11) =   42.40 
        slpara(7,12) =   48.80 
        slpara(7,13) =   55.40 
        slpara(7,14) =   60.60 
        slpara(7,15) =   65.80 
        slpara(7,16) =   71.20 
        slpara(7,17) =   76.60 
        slpara(7,18) =   82.20 
        slpara(7,19) =   88.00 
        slpara(7,20) =   94.00 
        slpara(7,21) =  100.00 
        slpara(7,22) =  106.40 
        slpara(7,23) =  113.00 
        slpara(7,24) =  119.80 
        slpara(7,25) =  126.80 
        slpara(7,26) =  134.20 
        slpara(7,27) =  142.00 
        slpara(7,28) =  150.40 
        slpara(7,29) =  159.00 
        slpara(7,30) =  168.40 
        slpara(7,31) =  178.40 
        slpara(7,32) =  189.60 
        slpara(7,33) =  201.60 
        slpara(7,34) =  212.80 
        slpara(7,35) =  225.00 
        slpara(7,36) =  238.40 
        slpara(7,37) =  256.40 
        slpara(7,38) =  291.00 
        slpara(7,39) =  350.00 
        slpara(7,40) =  500.00 
        slpara(7,41) =  800.00 
        slpara(7,42) =  800.00 
        slpara(7,43) =  800.00 
        slpara(7,44) =  800.00 
        slpara(7,45) =  800.00 
        slpara(7,46) =  800.00 
* 
        slpara(8,1)  =    7.00 
        slpara(8,2)  =    7.00 
        slpara(8,3)  =    7.00 
        slpara(8,4)  =    7.00 
        slpara(8,5)  =    9.00 
        slpara(8,6)  =   16.00 
        slpara(8,7)  =   21.00 
        slpara(8,8)  =   24.00 
        slpara(8,9)  =   27.00 
        slpara(8,10) =   30.20 
        slpara(8,11) =   36.20 
        slpara(8,12) =   42.40 
        slpara(8,13) =   48.80 
        slpara(8,14) =   53.80 
        slpara(8,15) =   58.10 
        slpara(8,16) =   62.80 
        slpara(8,17) =   67.50 
        slpara(8,18) =   72.00 
        slpara(8,19) =   76.80 
        slpara(8,20) =   81.70 
        slpara(8,21) =   86.60 
        slpara(8,22) =   91.60 
        slpara(8,23) =   96.70 
        slpara(8,24) =  101.90 
        slpara(8,25) =  107.00 
        slpara(8,26) =  112.10 
        slpara(8,27) =  117.20 
        slpara(8,28) =  122.50 
        slpara(8,29) =  127.80 
        slpara(8,30) =  135.20 
        slpara(8,31) =  143.10 
        slpara(8,32) =  151.60 
        slpara(8,33) =  161.20 
        slpara(8,34) =  171.40 
        slpara(8,35) =  180.90 
        slpara(8,36) =  191.30 
        slpara(8,37) =  202.60 
        slpara(8,38) =  212.80 
        slpara(8,39) =  224.00 
        slpara(8,40) =  238.40 
        slpara(8,41) =  255.40 
        slpara(8,42) =  280.00 
        slpara(8,43) =  311.00 
        slpara(8,44) =  350.00 
        slpara(8,45) =  500.00 
        slpara(8,46) =  800.00 
        slpara(8,47) =  800.00 
        slpara(8,48) =  800.00 
        slpara(8,49) =  800.00 
        slpara(8,50) =  800.00 
&dA 
&dA &d@ &dE                                        
&dA &d@ &dE  End of Initialization of parameters   
&dA &d@ &dE                                        
&dA 
        if Source_type = 1 
          loop for ii = 1 to 1000000 
            if ii > urcnt 
              goto PEOS 
            end 
            tget [UR,ii] line 
            tput [IF,ii] ~line 
          repeat 
PEOS: 
          if_cnt = ii 
        end 

#if DMUSE 
        putc Output file?  
        getc file 
        file = trm(file) 
        outfile = file 
        line = rev(file) 
        if line{1,3} <> "sp." 
          outfile = outfile // ".ps" 
        end 
#endif 
&dA 
&dA &d@   Setup for display 
&dA 
        setup gstr,300,3100,3 

        treset [SD] 
        treset [Y] 
        treset [ST] 
        treset [CT] 
        treset [CT2]                    /* New &dA12/26/10&d@ 
        treset [CT3]                    /* New &dA01/17/11&d@ 
        treset [CT4]                    /* New &dA01/17/11&d@ 
        treset [SST] 
        treset [PD] 
        treset [PT] 
        treset [PT2] 
        treset [PT3]                    /* New &dA12/26/10&d@ 
        treset [PT4]                    /* New &dA01/17/11&d@ 
        treset [PT5]                    /* New &dA01/17/11&d@ 
        treset [ZZ] 

        ycnt    = 0 

        sd_cnt  = 0 
        st_cnt  = 0 
        ct_cnt  = 0 
        ct_cnt2 = 0                     /* New &dA12/26/10&d@ 
        ct_cnt3 = 0                     /* New &dA01/17/11&d@ 
        ct_cnt4 = 0                     /* New &dA01/17/11&d@ 
        sst_cnt = 0 

        pd_cnt  = 0 
        pt_cnt  = 0 
        pt_cnt2 = 0 
        pt_cnt3 = 0                     /* New &dA12/26/10&d@ 
        pt_cnt4 = 0                     /* New &dA01/17/11&d@ 
        pt_cnt5 = 0                     /* New &dA01/17/11&d@ 
        ppt_cnt = 0 

        active_font = 0 
&dA 
&dA &d@  Transfer source file to X table 
&dA 
        loop for t5 = 1 to 300 
          sys_right_limit(t5)  = 0 
          sys_left_limit(t5)  = 10000 
          sys_top_limit(t5)  = 10000 
          sys_bottom_limit(t5)  = 0 
          box_top_limit(t5)  = 10000 
          box_bottom_limit(t5)  = 0 
        repeat 

        page_cnt = 1 
        a5 = 0 
&dK &d@       open [1,1] file 
        treset [X] 
        mpgfile_start(1) = 1 

        loop for t5 = 1 to if_cnt 
          tget [IF,t5] line 
          line = line // "    " 
&dA     
&dA 
&dA &d@    New code &dA01/05/09&d@ to ascertain the left and right limits of a system 
&dA 
          if line{1} = "S" 
            tput [NC,1] ~line 
            tget [NC,1] .t3 a1 a1 a2 a3 a4 
            if a1 < sys_left_limit(page_cnt) 
              sys_left_limit(page_cnt) = a1 
              box_left_limit(page_cnt) = a1 
            end 
            if a2 < sys_top_limit(page_cnt) 
              sys_top_limit(page_cnt) = a2 
            end 
            if (a2 + a4) > sys_bottom_limit(page_cnt) 
              sys_bottom_limit(page_cnt) = a2 + a4 
            end 
            a3 += a1 
            if a3 > sys_right_limit(page_cnt) 
              sys_right_limit(page_cnt) = a3 
              box_right_limit(page_cnt) = a3 
            end 
            a9 = a1 
          end 
          if a5 = 1 
            if line{1,3} = "J D" 
              tput [NC,1] ~line 
              tget [NC,1] .t5 a1 a2 
              if (a9 + a2) < box_left_limit(page_cnt) 
                box_left_limit(page_cnt) = (a9 + a2) 
              end 
              a5 = 0 
            end 
            if box_left_limit(page_cnt) < 0 
              box_left_limit(page_cnt) = 0 
            end 
          end 
          if line{1} = "L" 
            a5 = 1 
          end 
&dA 
&dA     
          tput [X,t5] ~line 
          if line{1} = "P" 
            line = line // pad(4) 
            if line{3} = " " or line{1,4} = "Page"         /* this is a "page" change
              ++page_cnt 
              mpgfile_start(page_cnt) = t5 + 1 
            end 
          end 
        repeat 
        --page_cnt 

        psfile_header(1) = "%%BoundingBox: (atend)" 
        psfile_header(2) = "%%HiResBoundingBox: (atend)" 
&dA 
&dA &d@    Construct the HiResSystemBox 
&dA 
        a5 = 10000 
        a6 = 0 
        a7 = 10000 
        a8 = 0 
        loop for t5 = 1 to page_cnt 
          if sys_top_limit(t5) < a5 
            a5 = sys_top_limit(t5) 
          end 
          if sys_bottom_limit(t5) > a6 
            a6 = sys_bottom_limit(t5) 
          end 
          if sys_left_limit(t5) < a7 
            a7 = sys_left_limit(t5) 
          end 
          if sys_right_limit(t5) > a8 
            a8 = sys_right_limit(t5) 
          end 
        repeat 

        a7 -= 1 
        a5 -= 1 
        a7 += 50 
        a8 += 50 
        a5 = 3150 - a5 
        a6 = 3150 - a6 

        temp = "" 
        a1 = a7 * 24 
        a2 = a1 / 100 
        a3 = rem 
        temp = temp // chs(a2) // "." 
        if a3 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a3) 

        temp = temp // " " 
        a1 = a6 * 24 
        a2 = a1 / 100 
        a3 = rem 
        temp = temp // chs(a2) // "." 
        if a3 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a3) 

        temp = temp // " " 
        a1 = a8 * 24 
        a2 = a1 / 100 
        a3 = rem 
        temp = temp // chs(a2) // "." 
        if a3 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a3) 

        temp = temp // " " 
        a1 = a5 * 24 
        a2 = a1 / 100 
        a3 = rem 
        temp = temp // chs(a2) // "." 
        if a3 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a3)

        psfile_header(3) = "%%HiResSystemBox: " // temp 
&dA      
        psfile_header(5) = "%%Creator: muse2ps 1.0" 
&dA 
&dA &d@    Get the creation data 
&dA 
        getd temp 
        psfile_header(6) = "%%CreationDate: " // temp 
&dA      
        psfile_header(7) = "%%Orientation: Portrait" 
        psfile_header(8) = "%%Pages: " // chs(page_cnt) 
        psfile_header(9) = "%%PageOrder: Ascend" 
        psfile_header(10) = "%%DocumentPaperSizes: Letter" 

        f4 = if_cnt 
        sysnum = 0 
        rec = 1 
        f12 = 0 
        scf = notesize 
        page_cnt = 1 
TOP2: 
        if rec > f4 
          goto TASK_DONE 
        end 

        tget [X,rec] line 
        ++rec 
        line = line // pad(3) 
        if line{1} = "P" 
          if line{3} = " " or line{1,3} = "Pag"          /* this is a "page" change
            line{1,3} = "Pag" 
          end 
        end 
        if line{1,3} = "Pag" 
&dA 
&dA &d@    Step 0:  We need to compute the coordinates of the high-res 
&dA &d@               system box 
&dA 
          left_limit   = sys_left_limit(page_cnt) 
          right_limit  = sys_right_limit(page_cnt) 
          top_limit    = sys_top_limit(page_cnt) 
          bottom_limit = sys_bottom_limit(page_cnt) 

          left_limit -= 1 
          top_limit  -= 1 

          left_limit += 50 
          right_limit += 50 
          top_limit = 3150 - top_limit 
          bottom_limit = 3150 - bottom_limit 

          temp3 = "" 
          a1 = left_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          temp3 = temp3 // chs(a2) // "." 
          if a3 < 10 
            temp3 = temp3 // "0" 
          end 
          temp3 = temp3 // chs(a3) // " " 

          a1 = bottom_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          temp3 = temp3 // chs(a2) // "." 
          if a3 < 10 
            temp3 = temp3 // "0" 
          end 
          temp3 = temp3 // chs(a3) // " " 

          a1 = right_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          temp3 = temp3 // chs(a2) // "." 
          if a3 < 10 
            temp3 = temp3 // "0" 
          end 
          temp3 = temp3 // chs(a3) // " " 

          a1 = top_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          temp3 = temp3 // chs(a2) // "." 
          if a3 < 10 
            temp3 = temp3 // "0" 
          end 
          temp3 = temp3 // chs(a3)
&dA 
&dA &d@    Step 1: Put out the bounding box for this page 
&dA 
          if sys_left_limit(page_cnt) < 10000 
            left_limit = box_left_limit(page_cnt) 
            right_limit = box_right_limit(page_cnt) + notesize 
          else 
            perform hpage_limits (left_limit,right_limit) 
          end 
          perform vpage_limits (top_limit,bottom_limit) 
          if box_top_limit(page_cnt) > top_limit 
            box_top_limit(page_cnt) = top_limit 
          end 
          if box_bottom_limit(page_cnt) < bottom_limit 
            box_bottom_limit(page_cnt) = bottom_limit 
          end 
&dA 
&dA &d@       Shift and transform coordinate system based on the 
&dA &d@       notion that: 
&dA 
&dA &d@         The position of a dot in my system is actually the 
&dA &d@         position of the lower-right corner of a dot.  
&dA 
&dA &d@       and that: 
&dA 
&dA &d@         (0,0) -> (12,756) which in dots is (50,3150) 
&dA 
&dA &d@       and that:  the top/bottom system is reversed 
&dA 
          left_limit -= 1 
          top_limit  -= 2 

          left_limit += 50 
          right_limit += 50 
          top_limit = 3150 - top_limit 
          bottom_limit = 3150 - bottom_limit 
&dA 
&dA &d@       Convert dots to points, using 300 dpi 
&dA &d@       Format = llx lly ulx uly 
&dA 
          temp = "" 
          temp2 = "" 
          a1 = left_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          if rem < 50 
            temp2 = temp2 // chs(a2) // " " 
          else 
            temp2 = temp2 // chs(a2+1) // " " 
          end 
          temp = temp // chs(a2) // "." 
          if a3 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a3) // " " 

          a1 = bottom_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          if rem < 50 
            temp2 = temp2 // chs(a2) // " " 
          else 
            temp2 = temp2 // chs(a2+1) // " " 
          end 
          temp = temp // chs(a2) // "." 
          if a3 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a3) // " " 

          a1 = right_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          if rem < 50 
            temp2 = temp2 // chs(a2) // " " 
          else 
            temp2 = temp2 // chs(a2+1) // " " 
          end 
          temp = temp // chs(a2) // "." 
          if a3 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a3) // " " 

          a1 = top_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          if rem < 50 
            temp2 = temp2 // chs(a2)
          else 
            temp2 = temp2 // chs(a2+1)
          end 
          temp = temp // chs(a2) // "." 
          if a3 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a3)

          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%Page ~page_cnt  ~page_cnt 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%BeginPageSetup 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%PageBoundingBox: ~temp2 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%PageHiResBoundingBox: ~temp 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%PageHiResSystemBox: ~temp3 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%EndPageSetup 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
&dA 
&dA &d@    Step 2: Generate the PT table from the CT table 
&dA &d@            Generate the PT3 table from the CT2 table 
&dA 
          xystring_out = "" 
          ycnt = 0 
          pt_cnt = 0 

          loop for t3 = 1 to ct_cnt 
            tget [CT,t3] out 
&dA &d@            
&dA &d@      Loop for special case of beginning of staff lines 
&dA 
            a1 = 0 
            a2 = len(out) 
            if out{a2-2,3} = " 81" 
              if active_font < 1013    /* music font 
                a3 = len(xystring_out) 
                if a3 > 0 
                  if xystring_out{a3} <> "Q" 
                    a1 = 1             /* new staff lines 
                  end 
                end 
              end 
            end 

            if out con "charout" 
              temp = out{25..} 
              tput [Y,1] ~temp 
              tget [Y,1] t5 
              t5 += 1000 
              if t5 <> active_font or len(xystring_out) > 60 or a1 = 1 
                if len(xystring_out) > 0 
                  xystring_out = xystring_out // ")" 
                  ++pt_cnt 
                  tput [PT,pt_cnt] ~xystring_out 
                  loop for t4 = 2 to ycnt - 1 
                    tget [Y,t4] temp 
                    ++pt_cnt 
                    tput [PT,pt_cnt] ~temp 
                  repeat 
                  tget [Y,ycnt] temp 
                  temp = temp // " 0 0 ] xyshow" 
                  ++pt_cnt 
                  tput [PT,pt_cnt] ~temp 
                  ycnt = 0 
                  xystring_out = "" 
                end 

                if t5 <> active_font 
                  active_font = t5 
                  ++pt_cnt 
                  tput [PT,pt_cnt] /Bitfont~t5  findfont 24 scalefont setfont
                end 

                if out con "loc =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                end 
                tput [Y,1] ~temp 
                tget [Y,1] t1 t5 
                lastx = t1 
                lasty = t5 

                perform move_to_loc (t1,t5) 
                ++pt_cnt 
                tput [PT,pt_cnt] ~mtloc 

                if t3 = ct_cnt 
                  if out con "char =" 
                    t1 = mpt 
                    temp = out{t1+7..} 
                    t5 = int(temp) 
                    temp = oct(t5) 
                    ++pt_cnt 
                    tput [PT,pt_cnt] (\~temp ) show 
                  end 
                  goto CMP_DONE 
                else 
                  tget [CT,t3+1] temp 
                  if temp con "charout" 
                    temp = temp{25..} 
                    tput [Y,1] ~temp 
                    tget [Y,1] t5 
                    t5 += 1000 
                    if t5 <> active_font 
                      if out con "char =" 
                        t1 = mpt 
                        temp = out{t1+7..} 
                        t5 = int(temp) 
                        temp = oct(t5) 
                        ++pt_cnt 
                        tput [PT,pt_cnt] (\~temp ) show 
                      end 
                      goto NXT_CHAR 
                    end 
                  end 
                end 
&dA 
&dA &d@          At this point, you have called for a new font and/or 
&dA &d@          you are restarting the xystring_out and 
&dA &d@          there is more than one character in this new font.  
&dA &d@          Time to setup the xyshow macro.  
&dA 
                if out con "char =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                  t5 = int(temp) 
                  if t5 > 31 and t5 < 127 and t5 <> 40 and t5 <> 41 and t5 <> 92
                    xystring_out = "(" // chr(t5) 
                  else 
                    temp = oct(t5) 
                    if len(temp) < 3 
                      temp = "0" // oct(t5) 
                    end 
                    xystring_out = "(\" // temp 
                  end 
                  ycnt = 2 
                  temp = "[ " 
                  tput [Y,ycnt] ~temp 
                end 
&dA 
&dA &d@          Otherwise, you are adding to the xyshow macro 
&dA 
              else 
                if out con "loc =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                end 
                tput [Y,1] ~temp 
                tget [Y,1] t1 t5 

                perform compute_delta_move (lastx, lasty, t1, t5) 

                lastx = t1 
                lasty = t5 

                if out con "char =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                  t5 = int(temp) 
                  if t5 > 31 and t5 < 127 and t5 <> 40 and t5 <> 41 and t5 <> 92
                    xystring_out = xystring_out // chr(t5) 
                  else 
                    temp = oct(t5) 
                    if len(temp) < 3 
                      temp = "0" // oct(t5) 
                    end 
                    xystring_out = xystring_out // "\" // temp 
                  end 
                end 
                tget [Y,ycnt] temp 
                temp = temp // " " // mtloc 
                tput [Y,ycnt] ~temp 
                if len(temp) > 60 
                  ++ycnt 
                  temp = "  " 
                  tput [Y,ycnt] ~temp 
                end 

                if t3 = ct_cnt 
                  if len(xystring_out) > 0 
                    xystring_out = xystring_out // ")" 
                    ++pt_cnt 
                    tput [PT,pt_cnt] ~xystring_out 

                    loop for t4 = 2 to ycnt - 1 
                      tget [Y,t4] temp 
                      ++pt_cnt 
                      tput [PT,pt_cnt] ~temp 
                    repeat 
                    tget [Y,ycnt] temp 
                    temp = temp // " 0 0 ] xyshow" 
                    ++pt_cnt 
                    tput [PT,pt_cnt] ~temp 
                    ycnt = 0 
                    xystring_out = "" 
                  end 
                end 
              end 
            end 
NXT_CHAR: 
          repeat 

CMP_DONE: 

&dA                                                
&dA 
&dA &d@    Here is where we deal with RED color (&dA12/26/10&d@) 
&dA 
          xystring_out = "" 
          ycnt = 0 
          pt_cnt3 = 0 
          active_font = 0 

          loop for t3 = 1 to ct_cnt2 
            tget [CT2,t3] out 
&dA &d@            
&dA &d@      Loop for special case of beginning of staff lines 
&dA 
            a1 = 0 
            if out con "charout" 
              temp = out{25..} 
              tput [Y,1] ~temp 
              tget [Y,1] t5 
              t5 += 1000 
              if t5 <> active_font or len(xystring_out) > 60 or a1 = 1 
                if len(xystring_out) > 0 
                  xystring_out = xystring_out // ")" 
                  ++pt_cnt3 
                  tput [PT3,pt_cnt3] ~xystring_out 
                  loop for t4 = 2 to ycnt - 1 
                    tget [Y,t4] temp 
                    ++pt_cnt3 
                    tput [PT3,pt_cnt3] ~temp 
                  repeat 
                  tget [Y,ycnt] temp 
                  temp = temp // " 0 0 ] xyshow" 
                  ++pt_cnt3 
                  tput [PT3,pt_cnt3] ~temp 
                  ycnt = 0 
                  xystring_out = "" 
                end 

                if t5 <> active_font 
                  active_font = t5 
                  ++pt_cnt3 
                  tput [PT3,pt_cnt3] /Bitfont~t5  findfont 24 scalefont setfont
                end 

                if out con "loc =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                end 
                tput [Y,1] ~temp 
                tget [Y,1] t1 t5 
                lastx = t1 
                lasty = t5 

                perform move_to_loc (t1,t5) 
                ++pt_cnt3 
                tput [PT3,pt_cnt3] ~mtloc 

                if t3 = ct_cnt2 
                  if out con "char =" 
                    t1 = mpt 
                    temp = out{t1+7..} 
                    t5 = int(temp) 
                    temp = oct(t5) 
                    ++pt_cnt3 
                    tput [PT3,pt_cnt3] (\~temp ) show 
                  end 
                  goto CMP_DONE2 
                else 
                  tget [CT2,t3+1] temp 
                  if temp con "charout" 
                    temp = temp{25..} 
                    tput [Y,1] ~temp 
                    tget [Y,1] t5 
                    t5 += 1000 
                    if t5 <> active_font 
                      if out con "char =" 
                        t1 = mpt 
                        temp = out{t1+7..} 
                        t5 = int(temp) 
                        temp = oct(t5) 
                        ++pt_cnt3 
                        tput [PT3,pt_cnt3] (\~temp ) show 
                      end 
                      goto NXT_CHAR2 
                    end 
                  end 
                end 
&dA 
&dA &d@          At this point, you have called for a new font and/or 
&dA &d@          you are restarting the xystring_out and 
&dA &d@          there is more than one character in this new font.  
&dA &d@          Time to setup the xyshow macro.  
&dA 
                if out con "char =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                  t5 = int(temp) 
                  if t5 > 31 and t5 < 127 and t5 <> 40 and t5 <> 41 and t5 <> 92
                    xystring_out = "(" // chr(t5) 
                  else 
                    temp = oct(t5) 
                    if len(temp) < 3 
                      temp = "0" // oct(t5) 
                    end 
                    xystring_out = "(\" // temp 
                  end 
                  ycnt = 2 
                  temp = "[ " 
                  tput [Y,ycnt] ~temp 
                end 
&dA 
&dA &d@          Otherwise, you are adding to the xyshow macro 
&dA 
              else 
                if out con "loc =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                end 
                tput [Y,1] ~temp 
                tget [Y,1] t1 t5 

                perform compute_delta_move (lastx, lasty, t1, t5) 

                lastx = t1 
                lasty = t5 

                if out con "char =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                  t5 = int(temp) 
                  if t5 > 31 and t5 < 127 and t5 <> 40 and t5 <> 41 and t5 <> 92
                    xystring_out = xystring_out // chr(t5) 
                  else 
                    temp = oct(t5) 
                    if len(temp) < 3 
                      temp = "0" // oct(t5) 
                    end 
                    xystring_out = xystring_out // "\" // temp 
                  end 
                end 
                tget [Y,ycnt] temp 
                temp = temp // " " // mtloc 
                tput [Y,ycnt] ~temp 
                if len(temp) > 60 
                  ++ycnt 
                  temp = "  " 
                  tput [Y,ycnt] ~temp 
                end 

                if t3 = ct_cnt2 
                  if len(xystring_out) > 0 
                    xystring_out = xystring_out // ")" 
                    ++pt_cnt3 
                    tput [PT3,pt_cnt3] ~xystring_out 

                    loop for t4 = 2 to ycnt - 1 
                      tget [Y,t4] temp 
                      ++pt_cnt3 
                      tput [PT3,pt_cnt3] ~temp 
                    repeat 
                    tget [Y,ycnt] temp 
                    temp = temp // " 0 0 ] xyshow" 
                    ++pt_cnt3 
                    tput [PT3,pt_cnt3] ~temp 
                    ycnt = 0 
                    xystring_out = "" 
                  end 
                end 
              end 
            end 
NXT_CHAR2: 
          repeat 

&dA &d@    End of RED color &dA12/26/10&d@ 
&dA                                                

CMP_DONE2: 

&dI                                                
&dI 
&dI &d@    Here is where we deal with GREEN color (&dA01/17/11&d@) 
&dI 
          xystring_out = "" 
          ycnt = 0 
          pt_cnt4 = 0 
          active_font = 0 

          loop for t3 = 1 to ct_cnt3 
            tget [CT3,t3] out 
&dA &d@            
&dA &d@      Loop for special case of beginning of staff lines 
&dA 
            a1 = 0 
            if out con "charout" 
              temp = out{25..} 
              tput [Y,1] ~temp 
              tget [Y,1] t5 
              t5 += 1000 
              if t5 <> active_font or len(xystring_out) > 60 or a1 = 1 
                if len(xystring_out) > 0 
                  xystring_out = xystring_out // ")" 
                  ++pt_cnt4 
                  tput [PT4,pt_cnt4] ~xystring_out 
                  loop for t4 = 2 to ycnt - 1 
                    tget [Y,t4] temp 
                    ++pt_cnt4 
                    tput [PT4,pt_cnt4] ~temp 
                  repeat 
                  tget [Y,ycnt] temp 
                  temp = temp // " 0 0 ] xyshow" 
                  ++pt_cnt4 
                  tput [PT4,pt_cnt4] ~temp 
                  ycnt = 0 
                  xystring_out = "" 
                end 

                if t5 <> active_font 
                  active_font = t5 
                  ++pt_cnt4 
                  tput [PT4,pt_cnt4] /Bitfont~t5  findfont 24 scalefont setfont
                end 

                if out con "loc =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                end 
                tput [Y,1] ~temp 
                tget [Y,1] t1 t5 
                lastx = t1 
                lasty = t5 

                perform move_to_loc (t1,t5) 
                ++pt_cnt4 
                tput [PT4,pt_cnt4] ~mtloc 

                if t3 = ct_cnt3 
                  if out con "char =" 
                    t1 = mpt 
                    temp = out{t1+7..} 
                    t5 = int(temp) 
                    temp = oct(t5) 
                    ++pt_cnt4 
                    tput [PT4,pt_cnt4] (\~temp ) show 
                  end 
                  goto CMP_DONE3 
                else 
                  tget [CT3,t3+1] temp 
                  if temp con "charout" 
                    temp = temp{25..} 
                    tput [Y,1] ~temp 
                    tget [Y,1] t5 
                    t5 += 1000 
                    if t5 <> active_font 
                      if out con "char =" 
                        t1 = mpt 
                        temp = out{t1+7..} 
                        t5 = int(temp) 
                        temp = oct(t5) 
                        ++pt_cnt4 
                        tput [PT4,pt_cnt4] (\~temp ) show 
                      end 
                      goto NXT_CHAR3 
                    end 
                  end 
                end 
&dA 
&dA &d@          At this point, you have called for a new font and/or 
&dA &d@          you are restarting the xystring_out and 
&dA &d@          there is more than one character in this new font.  
&dA &d@          Time to setup the xyshow macro.  
&dA 
                if out con "char =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                  t5 = int(temp) 
                  if t5 > 31 and t5 < 127 and t5 <> 40 and t5 <> 41 and t5 <> 92
                    xystring_out = "(" // chr(t5) 
                  else 
                    temp = oct(t5) 
                    if len(temp) < 3 
                      temp = "0" // oct(t5) 
                    end 
                    xystring_out = "(\" // temp 
                  end 
                  ycnt = 2 
                  temp = "[ " 
                  tput [Y,ycnt] ~temp 
                end 
&dA 
&dA &d@          Otherwise, you are adding to the xyshow macro 
&dA 
              else 
                if out con "loc =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                end 
                tput [Y,1] ~temp 
                tget [Y,1] t1 t5 

                perform compute_delta_move (lastx, lasty, t1, t5) 

                lastx = t1 
                lasty = t5 

                if out con "char =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                  t5 = int(temp) 
                  if t5 > 31 and t5 < 127 and t5 <> 40 and t5 <> 41 and t5 <> 92
                    xystring_out = xystring_out // chr(t5) 
                  else 
                    temp = oct(t5) 
                    if len(temp) < 3 
                      temp = "0" // oct(t5) 
                    end 
                    xystring_out = xystring_out // "\" // temp 
                  end 
                end 
                tget [Y,ycnt] temp 
                temp = temp // " " // mtloc 
                tput [Y,ycnt] ~temp 
                if len(temp) > 60 
                  ++ycnt 
                  temp = "  " 
                  tput [Y,ycnt] ~temp 
                end 

                if t3 = ct_cnt3 
                  if len(xystring_out) > 0 
                    xystring_out = xystring_out // ")" 
                    ++pt_cnt4 
                    tput [PT4,pt_cnt4] ~xystring_out 

                    loop for t4 = 2 to ycnt - 1 
                      tget [Y,t4] temp 
                      ++pt_cnt4 
                      tput [PT4,pt_cnt4] ~temp 
                    repeat 
                    tget [Y,ycnt] temp 
                    temp = temp // " 0 0 ] xyshow" 
                    ++pt_cnt4 
                    tput [PT4,pt_cnt4] ~temp 
                    ycnt = 0 
                    xystring_out = "" 
                  end 
                end 
              end 
            end 
NXT_CHAR3: 
          repeat 

&dI &d@    End of GREEN color (&dA01/17/11&d@) 
&dI                                                

CMP_DONE3: 

&dL                                                
&dL 
&dL &d@    Here is where we deal with BLUE color (&dA01/17/11&d@) 
&dL 
          xystring_out = "" 
          ycnt = 0 
          pt_cnt5 = 0 
          active_font = 0 

          loop for t3 = 1 to ct_cnt4 
            tget [CT4,t3] out 
&dA &d@            
&dA &d@      Loop for special case of beginning of staff lines 
&dA 
            a1 = 0 
            if out con "charout" 
              temp = out{25..} 
              tput [Y,1] ~temp 
              tget [Y,1] t5 
              t5 += 1000 
              if t5 <> active_font or len(xystring_out) > 60 or a1 = 1 
                if len(xystring_out) > 0 
                  xystring_out = xystring_out // ")" 
                  ++pt_cnt5 
                  tput [PT5,pt_cnt5] ~xystring_out 
                  loop for t4 = 2 to ycnt - 1 
                    tget [Y,t4] temp 
                    ++pt_cnt5 
                    tput [PT5,pt_cnt5] ~temp 
                  repeat 
                  tget [Y,ycnt] temp 
                  temp = temp // " 0 0 ] xyshow" 
                  ++pt_cnt5 
                  tput [PT5,pt_cnt5] ~temp 
                  ycnt = 0 
                  xystring_out = "" 
                end 

                if t5 <> active_font 
                  active_font = t5 
                  ++pt_cnt5 
                  tput [PT5,pt_cnt5] /Bitfont~t5  findfont 24 scalefont setfont
                end 

                if out con "loc =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                end 
                tput [Y,1] ~temp 
                tget [Y,1] t1 t5 
                lastx = t1 
                lasty = t5 

                perform move_to_loc (t1,t5) 
                ++pt_cnt5 
                tput [PT5,pt_cnt5] ~mtloc 

                if t3 = ct_cnt4 
                  if out con "char =" 
                    t1 = mpt 
                    temp = out{t1+7..} 
                    t5 = int(temp) 
                    temp = oct(t5) 
                    ++pt_cnt5 
                    tput [PT5,pt_cnt5] (\~temp ) show 
                  end 
                  goto CMP_DONE4 
                else 
                  tget [CT4,t3+1] temp 
                  if temp con "charout" 
                    temp = temp{25..} 
                    tput [Y,1] ~temp 
                    tget [Y,1] t5 
                    t5 += 1000 
                    if t5 <> active_font 
                      if out con "char =" 
                        t1 = mpt 
                        temp = out{t1+7..} 
                        t5 = int(temp) 
                        temp = oct(t5) 
                        ++pt_cnt5 
                        tput [PT5,pt_cnt5] (\~temp ) show 
                      end 
                      goto NXT_CHAR4 
                    end 
                  end 
                end 
&dA 
&dA &d@          At this point, you have called for a new font and/or 
&dA &d@          you are restarting the xystring_out and 
&dA &d@          there is more than one character in this new font.  
&dA &d@          Time to setup the xyshow macro.  
&dA 
                if out con "char =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                  t5 = int(temp) 
                  if t5 > 31 and t5 < 127 and t5 <> 40 and t5 <> 41 and t5 <> 92
                    xystring_out = "(" // chr(t5) 
                  else 
                    temp = oct(t5) 
                    if len(temp) < 3 
                      temp = "0" // oct(t5) 
                    end 
                    xystring_out = "(\" // temp 
                  end 
                  ycnt = 2 
                  temp = "[ " 
                  tput [Y,ycnt] ~temp 
                end 
&dA 
&dA &d@          Otherwise, you are adding to the xyshow macro 
&dA 
              else 
                if out con "loc =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                end 
                tput [Y,1] ~temp 
                tget [Y,1] t1 t5 

                perform compute_delta_move (lastx, lasty, t1, t5) 

                lastx = t1 
                lasty = t5 

                if out con "char =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                  t5 = int(temp) 
                  if t5 > 31 and t5 < 127 and t5 <> 40 and t5 <> 41 and t5 <> 92
                    xystring_out = xystring_out // chr(t5) 
                  else 
                    temp = oct(t5) 
                    if len(temp) < 3 
                      temp = "0" // oct(t5) 
                    end 
                    xystring_out = xystring_out // "\" // temp 
                  end 
                end 
                tget [Y,ycnt] temp 
                temp = temp // " " // mtloc 
                tput [Y,ycnt] ~temp 
                if len(temp) > 60 
                  ++ycnt 
                  temp = "  " 
                  tput [Y,ycnt] ~temp 
                end 

                if t3 = ct_cnt4 
                  if len(xystring_out) > 0 
                    xystring_out = xystring_out // ")" 
                    ++pt_cnt5 
                    tput [PT5,pt_cnt5] ~xystring_out 

                    loop for t4 = 2 to ycnt - 1 
                      tget [Y,t4] temp 
                      ++pt_cnt5 
                      tput [PT5,pt_cnt5] ~temp 
                    repeat 
                    tget [Y,ycnt] temp 
                    temp = temp // " 0 0 ] xyshow" 
                    ++pt_cnt5 
                    tput [PT5,pt_cnt5] ~temp 
                    ycnt = 0 
                    xystring_out = "" 
                  end 
                end 
              end 
            end 
NXT_CHAR4: 
          repeat 

&dL &d@    End of BLUE color (&dA01/17/11&d@) 
&dL                                                

CMP_DONE4: 

&dE                                                                          
&dE                                                                          

&dA 
&dA &d@    Step 3: Add the regular slur dictionaries to the SD table 
&dA &d@              and generate the PT2 table 
&dA 
          pt_cnt2 = 0 
          t6 = 0 
          a1 = 0 
          a4 = 0                /* stores maximum height 
          a5 = 0                /* stores maximum width 
          loop for t3 = 1 to st_cnt 
            tget [ST,t3] out 
            out = trm(out) 
            if out con "Calling" 
              a6 = 0            /* height counter 
              ++t6 
              if t6 = 193 
                a1 = t3 - 1      /* last ":" in regular dictionary 
                t3 = st_cnt      /* exit loop 
              end 
            else 
              if out{1} <> ":" 
                ++a6            /* increment height 
                a7 = len(out) 
                if a7 > a5 
                  a5 = a7       /* new maximum width 
                end 
              else 
                if a6 = 0       /* this is the first ":" 
                else 
                  if a6 > a4 
                    a4 = a6     /* new maximum height 
                  end 
                  a6 = 0        /* redundant, but safe 
                end 
              end 
            end 
          repeat 

          if a1 = 0 
            a1 = st_cnt 
          else 
            t6 = 192 
          end 
&dA 
&dA &d@      The meaning of a1 is as follows: 
&dA &d@         Normally (almost always) the number of regular slurs on a 
&dA &d@         page will not exceed 192.  In this case, a1 = st_cnt, and 
&dA &d@         all regular slurs will fit into one dictionary.  
&dA &d@         When a1 < st_cnt, this means that there are regular slurs 
&dA &d@         which did not fit into the primary slur dictionary and 
&dA &d@         will need to be included in subsequent dictionaries.  
&dA &d@      The meaning of t6: 
&dA &d@         t6 is the number of slurs in the primary slur dictionary 
&dA 
          a2 = 1 
          a3 = 1 

          if a1 > 0 
            perform build_regular_slur_dict (t6, a2, a1, a4, a5, a3, page_cnt)
          end 
&dA 
&dA &d@      For the moment, this code assumes a maximum of two regular 
&dA &d@        slur dictionaries, and will fail otherwise.  
&dA 
          if a1 < st_cnt 
            t6 = 0 
            a2 = a1 + 1              /* next entry 
            a1 = 0 
            a4 = 0                /* stores maximum height 
            a5 = 0                /* stores maximum width 
            loop for t3 = a2 to st_cnt 
              tget [ST,t3] out 
              if out con "Calling" 
                a6 = 0            /* height counter 
                ++t6 
                if t6 = 193 
                  if (Debugg & 0x12) > 0 
                    pute For the moment, this code assumes a maximum of 
                    pute two regular slur dictionaries.  No provision is 
                    pute made for overflow; extra slurs will be discarded.  
                  end 
                  a1 = t3 - 1      /* last ":" in regular dictionary 
                  t6 = 192 
                  t3 = st_cnt      /* exit loop 
                end 
              else 
                if out{1} <> ":" 
                  ++a6            /* increment height 
                  a7 = len(out) 
                  if a7 > a5 
                    a5 = a7       /* new maximum width 
                  end 
                else 
                  if a6 = 0       /* this is the first ":" 
                  else 
                    if a6 > a4 
                      a4 = a6     /* new maximum height 
                    end 
                    a6 = 0        /* redundant, but safe 
                  end 
                end 
              end 
            repeat 
            if a1 = 0 
              a1 = st_cnt 
            end 
            a3 = 2 
            perform build_regular_slur_dict (t6, a2, a1, a4, a5, a3, page_cnt)
          end 
&dA 
&dA &d@      Build long slur dictionaries 
&dA 
          if sst_cnt > 0 
            a1 = 0 
            a2 = 0 
            a3 = 3 
            loop for t3 = 1 to sst_cnt 
              tget [SST,t3] out 
              out = out // pad(4) 
              if out{1,4} = "Call" 
                a1 = t3 
                ++t3                /* skip ":" 
              else 
                if out{1} = ":" 
                  a2 = t3 
                  perform build_long_slur_dict (a1, a2, a3, page_cnt) 
                  ++a3 
                end 
              end 
            repeat 
          end 
&dA 
&dA &d@    Step 4: Write the PT and PT2 tables for this page to the PPT table 
&dA 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % This is the PT table for page ~page_cnt 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % ==================== 
          loop for t3 = 1 to pt_cnt 
            tget [PT,t3] temp 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] ~temp 
          repeat 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % =========================== 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % This is the PT2 table for page ~page_cnt 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % ===================== 
          loop for t3 = 1 to pt_cnt2 
            tget [PT2,t3] temp 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] ~temp 
          repeat 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % =========================== 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
&dA 
&dA &d@      New code &dA12/26/10&d@ and &dA01/17/11&d@ adding "color" highlight 
&dA 
&dA &d@     &dARED&d@ 
&dA 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] gsave            % save current graphics settings
          ++ppt_cnt 
          tput [PPT,ppt_cnt] 1 0 0 setrgbcolor 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % This is the PT3 table for page ~page_cnt 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % ==================== 
          loop for t3 = 1 to pt_cnt3 
            tget [PT3,t3] temp 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] ~temp 
          repeat 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % =========================== 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] grestore         % restore previous graphics settings
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
&dI 
&dI &d@     &dIGREEN&d@ 
&dI 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] gsave            % save current graphics settings
          ++ppt_cnt 
          tput [PPT,ppt_cnt] 0 1 0 setrgbcolor 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % This is the PT4 table for page ~page_cnt 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % ==================== 
          loop for t3 = 1 to pt_cnt4 
            tget [PT4,t3] temp 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] ~temp 
          repeat 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % =========================== 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] grestore         % restore previous graphics settings
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
&dL 
&dL &d@     &dLBLUE&d@ 
&dL 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] gsave            % save current graphics settings
          ++ppt_cnt 
          tput [PPT,ppt_cnt] 0 0 1 setrgbcolor 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % This is the PT5 table for page ~page_cnt 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % ==================== 
          loop for t3 = 1 to pt_cnt5 
            tget [PT5,t3] temp 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] ~temp 
          repeat 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % =========================== 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] grestore         % restore previous graphics settings
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
&dA 
&dA &d@      End of New Code &dA12/26/10&d@ and &dA01/17/11&d@ 
&dA 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] showpage 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%PageTrailer 
          if (Addfiles & 0x02) = 0x02 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] %=BeginMPGData: ~page_cnt 
            loop for t3 = mpgfile_start(page_cnt) to 1000000 
              tget [X,t3] line 
              ++ppt_cnt 
              tput [PPT,ppt_cnt] %=~line 
              if line{1} = "P" 
                line = line // pad(4) 
                if line{3} = " " or line{1,4} = "Page"   /* this is a "page" change
                  t3 = 1000000                           /* end of loop 
                end 
              end 
            repeat 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] %=EndMPGData: ~page_cnt 
          end 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
&dA 
&dA &d@    Step 5: Initialize for the next page
&dA 
          setup gstr,300,3100,3 
          ++page_cnt 

          active_font = 0 

          treset [PT] 
          treset [PT2] 
          treset [PT3]               /* New &dA12/26/10&d@ 
          treset [PT4]               /* New &dA01/17/11&d@ 
          treset [PT5]               /* New &dA01/17/11&d@ 
          treset [SST] 
          treset [ST] 
          treset [CT] 
          treset [CT2]               /* New &dA12/26/10&d@ 
          treset [CT3]               /* New &dA01/17/11&d@ 
          treset [CT4]               /* New &dA01/17/11&d@ 

          st_cnt  = 0 
          ct_cnt  = 0 
          ct_cnt2 = 0                /* New &dA12/26/10&d@ 
          ct_cnt3 = 0                /* New &dA01/17/11&d@ 
          ct_cnt4 = 0                /* New &dA01/17/11&d@ 
          sst_cnt = 0 

          pt_cnt  = 0 
          pt_cnt2 = 0 
          pt_cnt3 = 0                /* New &dA12/26/10&d@ 
          pt_cnt4 = 0                /* New &dA01/17/11&d@ 
          pt_cnt5 = 0                /* New &dA01/17/11&d@ 

          sysnum = 0 
          f12 = 0 
          scf = notesize 

          goto TOP2 
        end 
        line = trm(line) 

        if line{1} = "E" 
          line = line // pad(12) 
          loop for t5 = 1 to SUPERMAX 
            if supermap(t5) <> 0 
              if (Debugg & 0x12) > 0 
                pute Outstanding superobject at end of line 
              end 
              return 
            end 
          repeat 
          loop for c8 = 1 to ntext 
            if line{c8+2} <> " " 
              if line{c8+2} <> "*" 
                if line{c8+2} <> xbyte(c8) 
                  if (Debugg & 0x12) > 0 
                    pute Current xbyte different from xbyte at end of line 
                  end 
                  return 
                end 
                y = psq(f12) + f(f12,c8) 
                if xbyte(c8) = "-" 
                  x = sp + syslen 
                  perform sethyph (c8,sysright) 
                end 
                if "_,.;:!?" con xbyte(c8) 
                  uxstop(c8) = sp + syslen - phpar(56) 
                  underflag = 2 
                  perform setunder (c8) 
                end 
                xbyte(c8) = "*" 
              else 
                if "_,.;:!?" con xbyte(c8) 
                  y = psq(f12) + f(f12,c8) 
                  underflag = 1 
                  if uxstop(c8) > sp + syslen - phpar(57) 
                    uxstop(c8) = sp + syslen - phpar(57) 
                  end 
                  perform setunder (c8) 
                end 
              end 
            end 
          repeat 
          goto TOP2 
        end 
        if line{1} = "S" 
&dA 
&dA &d@         S Y S T E M  (recoded &dA05/26/03&d@) &dIOK&d@ 
&dA &d@         ÄÄÄÄÄÄÄÄÄÄÄ  
&dA 
          f12 = 0 
          sysnum  = sysnum + 1 
          sub = 5 
          sp = int(line{sub..}) 

          sysy = int(line{sub..}) 
          syslen = int(line{sub..}) 
          sysright = sysy + syslen              /* added &dA12/31/08&d@ 
          sysh = int(line{sub..}) 
          f11 = int(line{sub..}) 
          line = line // "  " 
          tline = line{sub..} 
          tline = mrt(tline) 
          syscode = tline{2..} 
          if syscode con quote 
            syscode = syscode{1,mpt-1} 
          end 
&dA 
&dA &d@    Code to check number of parts in syscode (modified &dA11/13/03&d@) &dIOK&d@ 
&dA 
          a2 = 0 
          loop for c8 = 1 to len(syscode) 
            if ".:,;" con syscode{c8} 
              ++a2 
            end 
          repeat 
          if a2 <> f11 and syscode <> "" 
            if (Debugg & 0x12) > 0 
#if DMUSE 
              putc &dASyscode Warning&d@: Incorrect number of parts in syscode.  rec = ~(rec - 1)
#else 
              pute Syscode Warning: Incorrect number of parts in syscode.  rec = ~(rec - 1)
#endif 
            end 
          end 
&dA   
          sysflag = 0 
          goto TOP2 
        end 
        if line{1} = "L" or line{1} = "l"        /* New &dA11/11/05&d@ 
&dA 
&dA &d@         L I N E  
&dA &d@         ÄÄÄÄÄÄÄ  
&dA 
          stave_type = 0 
          if line{1} = "l" 
            line{1} = "L" 
            stave_type = 1 
          end 
          loop for c8 = 1 to 10 
            dyoff(c8) = 0 
            uxstart(c8) = 0 
            backloc(c8) = 0 
            ibackloc(c8) = 0 
          repeat 

          line = line // "            " 
          f12 = f12 + 1 
&dA 
&dA &d@    Field 2: y off-set in system  
&dA 
          psq(f12) = int(line{3..}) 
          psq(f12) += sysy 
&dA 
&dA &d@    Field 3: text off-set(s) from line   (separated by |) 
&dA 
          ntext = 0 
NSR1: 
          ++ntext 
          f(f12,ntext) = int(line{sub..}) 
          if line{sub} = "|" 
            ++sub 
            goto NSR1 
          end 
&dA 
&dA &d@    Field 4: dyoff(s)   separated by | 
&dA 
          c8 = 0 
NSR2: 
          ++c8 
          dyoff(c8) = int(line{sub..}) 
          if line{sub} = "|" 
            ++sub 
            goto NSR2 
          end 
&dA 
&dA &d@    Field 5: uxstart(s) separated by | 
&dA 
          c8 = 0 
NSR3: 
          ++c8 
          uxstart(c8) = int(line{sub..}) 
          if line{sub} = "|" 
            ++sub 
            goto NSR3 
          end 
&dA 
&dA &d@    Field 6: backloc(s) separated by | 
&dA 
          c8 = 0 
NSR4: 
          ++c8 
          backloc(c8) = int(line{sub..}) 
          ibackloc(c8) = backloc(c8)            /* New &dA08/26/03&d@ &dIOK&d@ 
          if line{sub} = "|" 
            ++sub 
            goto NSR4 
          end 

          tline = line{sub+1..} 
          tline = mrt(tline) 
&dA 
&dA &d@    Field 7: xbyte(s)   (length of field = number of bytes) 
&dA 
          if tline con " " 
            c8 = mpt - 1 
            if ntext < c8 
              loop for ntext = ntext + 1 to c8 
                f(f12,ntext) = f(f12,ntext-1) + pvpar(41) 
              repeat 
            end 
            loop for c8 = 1 to ntext 
              xbyte(c8) = tline{c8} 
            repeat 
          end 
&dA 
&dA &d@                New &dA08/28/03&d@ &dIOK&d@ 
&dA 
          loop for c8 = 1 to ntext 
            if dyoff(c8) = 0 
              dyoff(c8) = dyoff(1) 
            end 
            if uxstart(c8) = 0 
              uxstart(c8) = uxstart(1) 
            end 
            if backloc(c8) = 0 
              backloc(c8) = backloc(1) 
            end 
            if ibackloc(c8) = 0 
              ibackloc(c8) = ibackloc(1) 
            end 
          repeat 
&dA 
&dA &d@    Field 8: y off-set to virtual staff line (0 = none) 
&dA 
          vst(f12) = 0 
          if tline con " " 
            tline = tline{mpt..} 
            vst(f12) = int(tline) 
            tline = tline // " " 
            tline = tline{sub..} 
          end 
&dA 
&dA &d@    Field 9: notesize (0 = not specified; i.e., no change) 
&dA 
          if tline con " " 
            tline = tline{mpt..} 
            c8 = int(tline) 

            tline = tline // " "            /* New code &dA09/14/03&d@ &dIOK&d@ 
            tline = tline{sub..}            /*  "    "      " 

            if chr(c8) in [6,14,16,18,21]   /* New: notesize 16 added &dA12/31/08&d@ &dNnot OK
              if c8 <> notesize 
                notesize = c8 
                perform ps_init_par 
              end 
            end 
          end 
          nsz(f12) = notesize               /* New code &dA11/13/03&d@ &dIOK&d@ 
&dA 
&dA &d@    Field 10: additional off-set for figured harmony   New &dA09/14/03&d@ &dIOK&d@ 
&dA 
          figoff(f12) = 0 
          if tline con " " 
            tline = tline{mpt..} 
            figoff(f12) = int(tline) 

            tline = tline // " "            /* New code &dA09/14/03&d@ &dIOK&d@ 
            tline = tline{sub..}            /*  "    "      " 
          end 

          y = psq(f12) 
          perform staff (syslen,stave_type) 
          if vst(f12) > 0 
            y = psq(f12) + vst(f12) 
            perform staff (syslen,stave_type) 
          end 
          loop for c8 = 1 to ntext 
            buxstop(c8) = 1000000 
          repeat 
          goto TOP2 
        end 
        if line{1} = "@" 
&dA 
&dA &d@          @ - L I N E 
&dA &d@          ÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          goto TOP2 
        end 
        if line{1} = "Y" 
&dA 
&dA &d@          Y - L I N E 
&dA &d@          ÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          sub = 3 
          z = int(line{sub..}) 
          if z = 0                             /* New &dA03/26/05&d@ 
            goto TOP2 
          end 
          x = int(line{sub..}) 
          ttext = " " 
          if line{sub} = "C" or line{sub} = "R" 
            ttext = line{sub} // " " 
            ++sub 
          end 

          y = int(line{sub..}) 
          tline = line{sub..} 
          tline = mrt(tline) 
          line = "X " // chs(z) // " " // chs(x) // ttext // chs(y) // " " 
          if tline <> "" 
            loop for t3 = 1 to len(tline) 
              if tline{t3} = "\" 
                if t3 < len(tline) 
                  if ">]" con tline{t3+1} 
                    ++t3                      /* skip \> and \] 
                  else 
                    if "<[" con tline{t3+1} 
                      loop while t3 < len(tline) and tline{t3} <> "|" 
                        ++t3                  /* skip up to "|" character 
                      repeat 
                    else 
                      line = line // tline{t3} 
                    end 
                  end 
                else 
                  line = line // tline{t3} 
                end 
              else 
                line = line // tline{t3} 
              end 
            repeat 
          end 
        end 

        if line{1} = "X" 
&dA 
&dA &d@          X - L I N E 
&dA &d@          ÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          lpt = 3 
          tline = txt(line,[' '],lpt) 
          z = int(tline) 
          if lpt > len(line) 
            if z = 6 or z = 14 or z = 21 or z = 18 or z = 16 
              notesize = z 
              perform ps_init_par 
              scf = notesize 
            end 
            goto TOP2 
          end 

          tline = txt(line,[' '],lpt) 
          tline = tline // "  " 
          x = int(tline) 
          ttext = tline{sub} 

          tline = txt(line,[' '],lpt) 
          y = int(tline) 
          if lpt > len(line) 
            line = "" 
          else 
            line = line{lpt+1..} 
            line = trm(line) 
          end 
&dA 
&dA &d@    Code added &dA03/04/05&d@ to deal with "C" and "R" options 
&dA 
          if ttext = "C" or ttext = "R" 
            perform line_length (a1) 
            if ttext = "C" 
              a1 >>= 1 
            end 
            x -= a1 
          end 
          a1 = 0 
          perform setwords (a1) 

          goto TOP2 
        end 
        if line{1} = "J" 
&dA 
&dA &d@         O B J E C T S  
&dA &d@         ÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          tget [X,rec-1] line .t3 jtype ntype obx oby z t3 t3 supcnt 
          if jtype = "F" 
            oby += figoff(f12) 
          end 

          save_jtype = jtype 
          if jtype = "N" 
            loop for c8 = 1 to ntext 
              uxstop(c8) = sp + obx + phpar(7) 
              buxstop(c8) = 1000000 
            repeat 
          end 
*  
          if jtype = "D" 
            if ntype = 0 
              goto CZ4 
            end 
            if bit(1,ntype) = 1 
              goto CZ4 
            end 
            if bit(2,ntype) = 1 and f12 = 1 
              goto CZ4 
            end 
            if bit(3,ntype) = 1 and f12 = f11 
              goto CZ4 
            end 

        /* skip over directives 
SKD3: 
            tget [X,rec] line2 
            if line2{1} = "W" 
              ++rec 
              goto SKD3 
            end 

            goto TOP2 
          end 
&dA 
&dA &d@   Collect super-object information 
&dA 
CZ4: 
          if supcnt > 0 
        /*  This was the old strip8 code 
            loop for t3 = 1 to 7 
              if line con " " 
                line{mpt} = "." 
              end 
            repeat 
            if line con " " 
              line = line{mpt+1..} 
            else 
              line = "" 
            end 

            if int(line) <> supcnt       /* TEMP 
              if (Debugg & 0x12) > 0 
                pute Error reading an object record 
              end 
              return 
            end 
            lpt = 0 
            tline = txt(line,[' '],lpt) 
            loop for t3 = 1 to supcnt 
              tline = txt(line,[' '],lpt) 
              t4 = int(tline) 
*     look for previous reference to this superobject  
              loop for t5 = 1 to SUPERMAX 
                if supermap(t5) = t4 
                  goto WD 
                end 
              repeat 
              t1 = 0 
              loop for t5 = 1 to SUPERMAX 
                if supermap(t5) = 0 
                  t1 = t5 
                  t5 = SUPERMAX 
                end 
              repeat 
              if t1 = 0 
                if (Debugg & 0x12) > 0 
                  pute No more superobject capacity 
                end 
                return 
              end 
&dA 
&dA &d@     if not found, then set up reference to this superobject. 
&dA 
              t5 = t1 
              supermap(t5) = t4 
              superpnt(t5) = 1 
*       t5 (value 1 to SUPERMAX) = pointer into ps_superdata for this superobject
WD: 
              t1 = superpnt(t5) 
*       store object information in ps_superdata and increment superpnt 
              superpnt(t5) = t1 + 3       /* New increment in ps_superdata pointer &dA12/21/10
              ps_superdata(t5,t1) = obx 
              ps_superdata(t5,t1+1) = oby 
&dA 
&dA &d@   New code &dA12/21/10&d@.  We need to determine whether there is "color" in this
&dA &d@            object.  If there is, we need to store the "color flag" in 
&dA &d@            ps_superdata(t5,t1+2), a new element of ps_superdata.  The value
&dA &d@            matters only for dskpage and pspage.  
&dA 
              a2 = 0 
              a1 = rec 
              loop 
                tget [X,a1] line2 
                ++a1 
                if line2{1} = "C" 
                  a2 = 1 
                end 
              repeat while line2{1} = "K" or line2{1} = "C" or line2{1} = "T"
              ps_superdata(t5,t1+2) = a2 
            repeat 
          end 
&dA 
&dA &d@     if no sub-objects, then typeset object 
&dA 
          if vst(f12) > 0 and oby > 700 
            oby -= 1000 
            oby += vst(f12) 
          end 

          if z > 32 
            x = sp + obx 
            if jtype <> "B" 
              y = psq(f12) + oby 
              perform setmus 
            end 
          end 
&dA 
&dA &d@   typeset underline (if unset) 
&dA 
          saverec = rec 
          if jtype = "R" 
            loop for c8 = 1 to ntext 
              if "_,.;:!?" con xbyte(c8) 
&dA 
&dA &d@   check next note for new syllable 
&dA 
YR4: 
                tget [X,rec] line 
                ++rec 
                line = line // pad(12) 
                if line{1} = "E" 
                  if line{c8+2} = "*" 
                    goto YR2 
                  end 
                  goto YR3 
                end 
                if line{1,3} = "J N" 
YR1: 
                  tget [X,rec] line 
                  ++rec 
                  if "kKCA" con line{1}        /* Added &dA11-11-93&d@ "C" added &dA01/17/11
                    goto YR1 
                  end 
                  if line{1} = "T" 
                    c9 = int(line{3..}) 
                    c9 = int(line{sub..})     /* text line number 
                    if c8 = c9 
                      goto YR2 
                    end 
                    goto YR1 
                  end 
                  goto YR3 
                end 
                goto YR4 
* 
YR2: 
                y = psq(f12) + f(f12,c8) 
                underflag = 1 
                if mpt > 1 
                  uxstop(c8) -= phpar(20) 
                end 
                if buxstop(c8) < uxstop(c8) 
                  uxstop(c8) = buxstop(c8) 
                end 
                perform setunder (c8) 
                xbyte(c8) = "*" 
                buxstop(c8) = 1000000 
              end 
YR3: 
              rec = saverec 
            repeat 
          end 

          if jtype = "B" 
            oby = 0 
            loop for c8 = 1 to ntext 
              buxstop(c8) = sp + obx - phpar(57) 
            repeat 
          end 
          goto TOP2 
        end 
        if line{1} = "k" 
&dA 
&dA &d@      "Silent" S U B - O B J E C T S 
&dA &d@      ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          goto TOP2 
        end 
        if line{1} = "K" or line{1} = "C"     /* "C" added &dA12/17/10&d@ 
&dA 
&dA &d@       S U B - O B J E C T S 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          if line{1} = "C"                    /* New &dA12/17/10&d@ and &dA01/17/11&d@ 
            lpt = 3 
            tline = txt(line,[' '],lpt) 
*  line structure = 0xcccccc sobx soby z 
            if tline{1,2} = "0x" 
              tline = tline // pad(8) 
              color_line = tline{1,8} 
              if tline{3,2} >= tline{5,2} 
                if tline{3,2} >= tline{7,2} 
                  color_flag = 1 
                else 
                  color_flag = 3 
                end 
              else 
                if tline{5,2} >= tline{7,2} 
                  color_flag = 2 
                else 
                  color_flag = 3 
                end 
              end 
              tline = txt(line,[' '],lpt) 
              sobx = int(tline) 
              tline = txt(line,[' '],lpt) 
              soby = int(tline) 
              tline = txt(line,[' '],lpt) 
              z = int(tline) 
            else 
              color_flag = 1 
              color_line = "0xff0000" 
              tget [X,rec-1] .t3 sobx soby z 
            end 
          else 
            color_flag = 0 
            tget [X,rec-1] .t3 sobx soby z 
          end 
          x = sp + obx + sobx 
          y = psq(f12) + oby + soby 
          perform setmus 
          if save_jtype = "B" and z = DOT_CHAR 
            y += vst(f12) 
            perform setmus 
          end 
          color_flag = 0 

          goto TOP2 
        end 
        if line{1} = "A"                   /* Added &dA11-11-93&d@ 
&dA 
&dA &d@       A T T R I B U T E S  
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  
&dA 
          goto TOP2 
        end 
        if line{1} = "W" or line{1} = "w"    /* New &dA11/29/09&d@ 
&dA 
&dA &d@       W O R D S 
&dA &d@       ÄÄÄÄÄÄÄÄÄ 
&dA 
          lpt = 3 
          tline = txt(line,[' '],lpt) 
*  line structure = sobx soby font# text 
          sobx = int(tline) 
          tline = txt(line,[' '],lpt) 
          soby = int(tline) 
          tline = txt(line,[' '],lpt) 
          z = int(tline) 
          if len(line) > lpt and z <> 0         /* &dA10/01/03&d@ adding condition z <> 0  &dIOK
            line = line{lpt+1..} 
            x = sp + obx + sobx 
            y = psq(f12) + oby + soby 
            a1 = 0 
            perform setwords (a1) 
          end 
          goto TOP2 
        end 
        if line{1} = "T" 
&dA 
&dA &d@       T E X T 
&dA &d@       ÄÄÄÄÄÄÄ 
&dA 
          line = line // "  " 
*  line structure = sobx tlevel[|soby] ttext xbyte textlen 
          sobx = int(line{3..}) 
          tlevel = int(line{sub..}) 
          if tlevel < 1 or tlevel > 10 
            if (Debugg & 0x12) > 0 
              pute Error: Invalid tlevel in Text record ~(rec - 1) 
            end 
            return    
          end 
          soby = 0 
          if line{sub} = "|" 
            ++sub 
            soby = int(line{sub..}) 
          end 
          line = line{sub..} 
          line = mrt(line)           /* ttext is next in line 
          if line con " " 
            ttext = line{1,mpt-1} 
            line = line{mpt..} 
            line = mrt(line) 
          end 
&dA 
&dA &d@  typeset back hyphons or underlines (if they exist) 
&dA 
          if xbyte(tlevel) = "-" 
            y = psq(f12) + f(f12,tlevel) 
            x = sp + obx + sobx 
            perform sethyph (tlevel,sysright) 
          end 

          if "_,.;:!?" con xbyte(tlevel) 
            x = sp + obx + sobx - phpar(20) 
            if mpt > 1 
              x -= phpar(20) 
            end 
            if uxstop(tlevel) > x 
              uxstop(tlevel) = x 
            end 
            y = psq(f12) + f(f12,tlevel) 
            if ttext = "~" 
              underflag = 2 
            else 
              underflag = 1 
            end 
            perform setunder (tlevel) 
          end 
&dA 
&dA &d@  typeset underline if terminator (~) is found  (Code added &dA02-24-95&d@) 
&dA 
          if ttext = "~" 
            x = sp + obx + sobx + phpar(20) + phpar(20) 
            uxstop(tlevel) = x 
            y = psq(f12) + f(f12,tlevel) 
            underflag = 1 
            perform setunder (tlevel) 
            xbyte(tlevel) = " " 
            goto TOP2 
          end 

          sub = 1 
          loop while ttext con "_" 
            ttext{mpt} = " " 
          repeat 

          textlen = 0 
          xbyte(tlevel) = "*" 
          if line <> "" 
            line = line // " " 
            xbyte(tlevel) = line{1} 
            textlen = int(line{2..}) 
          end 

          x = sp + obx + sobx 
          y = psq(f12) + f(f12,tlevel) + soby 
          backloc(tlevel) = x + textlen 
          uxstart(tlevel) = x + textlen + phpar(19) 
          z = mtfont 
          line = ttext 
          a1 = 1 
          perform setwords (a1) 
          goto TOP2 
        end 
        if line{1} = "P" 
          line = line // pad(3) 
        end 
        if line{1} = "H" or (line{1} = "P" and line{3} <> " ")    /* "P" added &dA12/17/10
&dA 
&dA &d@       S U P E R - O B J E C T S 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
&dA &d@    Look for color New &dA12/17/10&d@ and &dA01/17/11&d@ 
&dA 
          color_flag = 0                          /* New &dA12/17/10&d@ 
          if line{1} = "P" 
            lpt = 3 
            tline = txt(line,[' '],lpt) 
*  line structure = 0xcccccc supernum htype . . .  
            if tline{1,2} = "0x" 
              tline = tline // pad(8) 
              color_line = tline{1,8} 
              if tline{3,2} >= tline{5,2} 
                if tline{3,2} >= tline{7,2} 
                  color_flag = 1 
                else 
                  color_flag = 3 
                end 
              else 
                if tline{5,2} >= tline{7,2} 
                  color_flag = 2 
                else 
                  color_flag = 3 
                end 
              end 
              tline = txt(line,[' '],lpt) 
            else 
              color_flag = 1 
              color_line = "0xff0000" 
            end 
          else 
*  line structure = supernum htype . . .  
            lpt = 3 
            tline = txt(line,[' '],lpt) 
          end 
&dA     
          supernum = int(tline) 
*  get ps_superdata for this superobject 
          loop for t5 = 1 to SUPERMAX 
            if supermap(t5) = supernum 
              goto WE 
            end 
          repeat 
          if (Debugg & 0x12) > 0 
            pute Error: No refererce to superobject ~supernum  in previous objects
          end    
          return 
&dA 
&dA &d@  t5 = index into ps_superdata.  WE is the continuation point 
&dA 
WE: 
          htype = txt(line,[' '],lpt) 
          if line{1} = "P" 
            if htype = "B" or htype = "T" 
            else 
              color_flag = 0 
            end 
          end 
&dA 
&dA &d@  compensate for out-of-order objects 
&dA 
&dA &d@  Code changes &dA12/21/10&d@: New index for second obx element 
&dA &d@                         Switching 3 superdata elements instead of 2 
&dA 
          if ps_superdata(t5,1) > ps_superdata(t5,4) 
            x1 = ps_superdata(t5,4) 
            y1 = ps_superdata(t5,5) 
            a1 = ps_superdata(t5,6) 
            ps_superdata(t5,4) = ps_superdata(t5,1) 
            ps_superdata(t5,5) = ps_superdata(t5,2) 
            ps_superdata(t5,6) = ps_superdata(t5,3) 
            ps_superdata(t5,1) = x1 
            ps_superdata(t5,2) = y1 
            ps_superdata(t5,3) = a1 
          end 
&dA      
          if htype = "T" 
&dA 
&dA &d@  structure of &dDtie superobject&d@:  4. vertical position of tied note 
&dA &d@                                 5. horiz. displacement from 1st note 
&dA &d@                                 6. horiz. displacement from 2nd note 
&dA &d@                                 7. post adjustment of calculated left x position  &dA04/20/03&d@ &dIOK
&dA &d@                                 8. post adjustment of calculated y position          "
&dA &d@                                 9. post adjustment of calculated right x position    "
&dA &d@                                10. sitflag 
&dA &d@                                11. recalc flag 
&dA 
            tline = txt(line,[' '],lpt) 
            y1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) 
            tline = txt(line,[' '],lpt) 
            a2 = int(tline)                          /* tpost_x 
            tline = txt(line,[' '],lpt) 
            a3 = int(tline)                          /* tpost_y 
            tline = txt(line,[' '],lpt) 
            a4 = int(tline)                          /* tpost_leng 
            tline = txt(line,[' '],lpt) 
            sitflag = int(tline) 
            a1 = ps_superdata(t5,4) + x2 - x1        /* New index for second element &dA12/21/10
            perform settie (a1,a2,a3,a4) 
            color_flag = 0                           /* New &dA12/17/10&d@ 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "B" 
&dA 
&dA &d@  structure of &dDbeam superobject&d@: slope vertoff font# #obs bc(1) ...  
&dA 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline)                         /* @k 
            tline = txt(line,[' '],lpt) 
            a2 = int(tline)                         /* @m 
            tline = txt(line,[' '],lpt) 
            beamfont = int(tline) 
            t3 = ors("ffffgghiijjkkllmmnoopprr"{notesize})    /* old "Mbeamfont()"
            if beamfont = t3 
              stemchar = 59 
              beamt = pvpar(32) 
              qwid = phpar(3) 
            else 
              stemchar = 187 
              beamt = pvpar(32) * 4 + 3 / 5 
              qwid = phpar(5) 
            end 
            tline = txt(line,[' '],lpt) 
            bcount = int(tline) 
            t4 = 1 
            loop for t3 = 1 to bcount 
              ps_beamdata(t3,1) = ps_superdata(t5,t4) + sp 
              ps_beamdata(t3,2) = ps_superdata(t5,t4+1) + psq(f12) 
              ps_beamdata(t3,3) = ps_superdata(t5,t4+2) + psq(f12)   /* New data &dA12/21/10
              temp = txt(line,[' '],lpt) 
              temp = rev(temp) 
              t1 = 6 - len(temp) 
              msk_beamcode(t3) = temp // "00000"{1,t1} 
              t4 += 3                                    /* New increment in superdata &dA12/21/10
            repeat 
*   print beam 
            tbflag = 0 
            if tupldata(1) > 0 and tupldata(5) = supernum 
              tbflag = bit(4,tupldata(1)) 
              ++tbflag 
            end 
            perform ps_setbeam (a1,a2) 
            tupldata(1) = 0 
            supermap(t5) = 0 
            color_flag = 0                                 /* New &dA12/17/10&d@ 
            goto TOP2 
          end 
          if htype = "S" 
&dA 
&dA &d@  structure of &dDslur superobject&d@:  4. sitflag 
&dA &d@                                  5. extra horiz. displ. from obj-1 
&dA &d@                                  6. extra vert. displ. from obj-1 
&dA &d@                                  7. extra horiz. displ. from obj-2 
&dA &d@                                  8. extra vert. displ. from obj-2 
&dA &d@                                  9. extra curvature     (new 6-30-93) 
&dA &d@                                 10. beam flag        
&dA &d@                                 11. post adjustment to x co-ordinate 
&dA &d@                                 12. post adjustment to y co-ordinate 
&dA 
            slur_edit_flag = 0 
            tline = txt(line,[' '],lpt) 
            sitflag = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            y1 = int(tline) 
            if y1 <> 0 
              slur_edit_flag = 1 
            end 
            y1 += ps_superdata(t5,2) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)       /* New index for second obx &dA12/21/10
            tline = txt(line,[' '],lpt) 
            y2 = int(tline) 
            if y2 <> 0 
              slur_edit_flag = 1 
            end 
            y2 += ps_superdata(t5,5)                   /* New index for second oby &dA12/21/10
            if y1 > 700 
              y1 -= 1000 
              y1 += vst(f12) 
            end 
            if y2 > 700 
              y2 -= 1000 
              y2 += vst(f12) 
            end 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline)               /* addcurve 
            tline = txt(line,[' '],lpt) 
            t4 = int(tline) 
            postx = 0 
            posty = 0 
            if lpt < len(line) 
              tline = txt(line,[' '],lpt) 
              postx = int(tline) 
            end 
            if lpt < len(line) 
              tline = txt(line,[' '],lpt) 
              posty = int(tline) 
            end 
            if bit(5,sitflag) = 0           /* This condition added &dA04/26/05
              perform putslur (a1) 
            end 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "F" 
&dA 
&dA &d@  structure of &dDfigcon super-object&d@:  4. figure level 
&dA &d@                                     5. horiz. disp. from obj1 
&dA &d@                                     6. horiz. disp. from obj2 
&dA &d@                                     7. (optional) additional vert. disp.  &dANew 11/06/03
&dA &d@                                          from default height 
&dA 
            tline = txt(line,[' '],lpt) 
            a3 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)      /* New index for second obx &dA12/21/10
            y1 = 0 
            if lpt < len(line) 
              tline = txt(line,[' '],lpt) 
              y1 = int(tline) 
            end 
            perform putfigcon (a3) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "X" 
&dA 
&dA &d@  structure of &dDtuplet super-object&d@:  4. situation flag 
&dA &d@                                     5. tuplet number 
&dA &d@                                     6. horiz. disp. from obj1 
&dA &d@                                     7. vert. disp. from obj1 
&dA &d@                                     8. horiz. disp. from obj2 
&dA &d@                                     9. vert. disp. from obj2 
&dA &d@                                    10. associated beam super-number 
&dA 
            tline = txt(line,[' '],lpt) 
            sitflag = int(tline) 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            y1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) 
            tline = txt(line,[' '],lpt) 
            y2 = int(tline) 
            tline = txt(line,[' '],lpt) 
            a2 = int(tline) 
            if bit(3,sitflag) = 1 
              tupldata(1) = sitflag 
              tupldata(2) = a1 
              tupldata(3) = x1 
              tupldata(4) = x2 
              tupldata(5) = a2 
              tupldata(6) = y1 
              tupldata(7) = y2 
            else 
              x1 += ps_superdata(t5,1) 
              y1 += ps_superdata(t5,2) 
              x2 += ps_superdata(t5,4)         /* New index for second obx &dA12/21/10
              y2 += ps_superdata(t5,5)         /* New index for second oby &dA12/21/10
              if y1 > 700 
                y1 -= 1000 
                y1 += vst(f12) 
              end 
              if y2 > 700 
                y2 -= 1000 
                y2 += vst(f12) 
              end 
              perform puttuplet (a1) 
            end 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "V" 
&dA 
&dA &d@  structure of &dDtransp super-object&d@:  4. situation: 0=8av up, 1=8av down 
&dA &d@                                     5. horiz. disp. from obj1  
&dA &d@                                     6. horiz. disp. from obj2  
&dA &d@                                     7. vert. disp. from obj1 
&dA &d@                                     8. length of right vertical hook 
&dA 
            tline = txt(line,[' '],lpt) 
            a3 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)    /* New index for second obx &dA12/21/10
            tline = txt(line,[' '],lpt) 
            y1 = int(tline)                    /*   + ps_superdata(t5,2) 
            if y1 > 700 
              y1 -= 1000 
              y1 += vst(f12) 
            end 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline) 
            perform puttrans (a1,a3) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "E" 
&dA 
&dA &d@  structure of &dDending super-object&d@:  4. ending number (0 = none)  
&dA &d@                                     5. horiz. disp. from obj1  
&dA &d@                                     6. horiz. disp. from obj2  
&dA &d@                                     7. vert. disp. from staff lines  
&dA &d@                                     8. length of left vertical hook  
&dA &d@                                     9. length of right vertical hook 
&dA 
            tline = txt(line,[' '],lpt) 
            a3 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)    /* New index for second obx &dA12/21/10
            tline = txt(line,[' '],lpt) 
            y1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            a2 = int(tline) 
            perform putending (a1,a2,a3) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "D" 
&dA 
&dA &d@  structure of &dDdashes super-object&d@:  4. horiz. disp. from obj1  
&dA &d@                                     5. horiz. disp. from obj2  
&dA &d@                                     6. vert. disp. from staff lines  
&dA &d@                                     7. spacing parameter 
&dA &d@                                     8. font designator 
&dA 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)    /* New index for second obx &dA12/21/10
            tline = txt(line,[' '],lpt) 
            y1 = ps_superdata(t5,2) 
            if y1 > 700 
              y1 = vst(f12) 
            else 
              y1 = 0 
            end 
            y1 += int(tline) 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            a2 = int(tline) 
            perform putdashes (a1,a2) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "R" 
&dA 
&dA &d@  structure of &dDtrill super-object&d@:  4. situation: 1 = no trill, only ~~~~ 
&dA &d@                                                  2 = trill with ~~~~ 
&dA &d@                                                  3 = tr ~~~~ with sharp above
&dA &d@                                                  4 = tr ~~~~ with natural above
&dA &d@                                                  5 = tr ~~~~ with flat above
&dA &d@                                    5. horiz. disp. from object 1 
&dA &d@                                    6. horiz. disp. from object 2 
&dA &d@                                    7. vert. disp. from object 1 
&dA 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)    /* New index for second obx &dA12/21/10
            tline = txt(line,[' '],lpt) 
            y1 = int(tline) + ps_superdata(t5,2) 
            if y1 > 700 
              y1 -= 1000 
              y1 += vst(f12) 
            end 
            perform puttrill (a1) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "W" 
&dA 
&dA &d@  structure of &dDwedge super-object&d@:  4. left spread  
&dA &d@                                    5. right spread 
&dA &d@                                    6. horiz. disp. from obj1 
&dA &d@                                    7. beg. vert. disp. from staff  
&dA &d@                                    8. horiz. disp. from obj2 
&dA &d@                                    9. end. vert. disp. from staff  
&dA 
            tline = txt(line,[' '],lpt) 
            c1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            c2 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            c3 = ps_superdata(t5,2) 
            if c3 > 700 
              c3 = vst(f12) 
            else 
              c3 = 0 
            end 
            y1 = int(tline) + c3 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)    /* New index for second obx &dA12/21/10
            a1 = x2 - x1 
            if a1 < phpar(39) 
              x2 = x1 + phpar(39) 
            end 
            tline = txt(line,[' '],lpt) 
            y2 = int(tline) + c3 
            perform putwedge (c1,c2) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "N" 
            supermap(t5) = 0 
            goto TOP2 
          end 
        end 
        if line{1} = "B" 
&dA 
&dA &d@       B A R    L I N E  (section recoded &dA05/26/03&d@)  &dIOK&d@ 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          sub = 3 
          a7 = int(line{sub..}) 
          if a7 = 99 
            if sysflag = 0 
              sysflag = 1 
            end 
            goto TOP2 
          end 
&dA 
&dA &d@    First make sure that the system line is printed.  
&dA &d@    (this code moved here and revised &dA11/13/03&d@) &dIOK&d@ 
&dA 
          savesub = sub 
          savensz = notesize 
          if sysflag = 0 
&dA 
&dA &d@    Code added here &dA11/13/03&d@ to set govstaff for printing sysline, etc. &dIOK&d@ 
&dA 
            govstaff = 0 
            a2 = 0 
            loop for c8 = 1 to len(syscode) 
              if ".:,;" con syscode{c8} 
                ++a2 
                if mpt > 2 
                  if govstaff = 0 
                    govstaff = a2 
                  else 
                    if nsz(a2) > nsz(govstaff) 
                      govstaff = a2 
                    end 
                  end 
                end 
              end 
            repeat 
            if govstaff = 0 
              govstaff = f11                   /* default for govstaff 
            end 

            a2 = nsz(govstaff) 
            if a2 <> notesize 
              notesize = a2 
              perform ps_init_par 
            end 

            perform sysline 
            sysflag = 1 
          end 
          sub = savesub 
&dA    
          a8 = a7 & 0x0f 
          x = int(line{sub..}) 
          brkcnt = int(line{sub..}) 
          loop for t3 = 1 to brkcnt 
            a6 = int(line{sub..}) 
            barbreak(t3,1) = a6 + sysy 
            a6 = int(line{sub..}) 
            barbreak(t3,2) = a6 + sysy 
          repeat 
*    sort breaks in ascending order of offset  
          if brkcnt > 1 
            c5 = brkcnt - 1 
            loop for c1 = 1 to c5 
              c6 = c1 + 1 
              loop for c2 = c6 to brkcnt 
                if barbreak(c2,1) < barbreak(c1,1) 
                  c3 = barbreak(c1,1) 
                  c4 = barbreak(c1,2) 
                  barbreak(c1,1) = barbreak(c2,1) 
                  barbreak(c1,2) = barbreak(c2,2) 
                  barbreak(c2,1) = c3 
                  barbreak(c2,2) = c4 
                end 
              repeat 
            repeat 
          end 
* 
          x = x + sp 
          if a8 < 2 
            z = 82 
            perform barline 
          end 
          if a8 = 2 
            x = x - phpar(33)     /* phpar(33) = heavy - light + 1 
            z = 84 
            perform barline 
          end 
          if a8 = 3 
            z = 86 
            perform barline 
          end 
          if a8 = 5 
            z = 82 
            perform barline 
            x = x - phpar(48)     /* phpar(48) = light + delta-light (auto hpar(44))
            perform barline 
          end 
          if a8 = 6 
            z = 84 
            x = x - phpar(33) 
            perform barline 
            z = 82 
            x = x - phpar(34)     /* phpar(34) = light + delta-heavy (auto hpar(45))
            perform barline 
          end 
          if a8 = 9 
            z = 84 
            perform barline 
            z = 82 
            x = x + phpar(33) + phpar(34) - 1 
            perform barline 
            if a7 > 15 
              x = x + phpar(36) 
              loop for f12 = 1 to f11 
                y = psq(f12) + pvpar(3) 
                z = 44 
                perform setmus 
                y = y + pvpar(2) 
                perform setmus 
&dA 
&dA &d@        Adding code &dA05/26/03&d@ for print second set of dots in case of grandstaff   &dIOK
&dA &d@ 
                if vst(f12) > 0 
                  y = y - pvpar(2) + vst(f12) 
                  z = 44 
                  perform setmus 
                  y = y + pvpar(2) 
                  perform setmus 
                end 

              repeat 
            end 
          end 
          if a8 = 10 
            z = 84 
            perform barline 
            x = x - phpar(33) - phpar(34) + 1 
            perform barline 
          end 
&dA 
&dA &d@    Code added &dA11/13/03&d@ to reset notesize to local value &dIOK&d@ 
&dA 
          if notesize <> savensz 
            notesize = savensz 
            perform ps_init_par 
          end 
&dA   
          goto TOP2 
        end 
        goto TOP2 

TASK_DONE: 

        --page_cnt 
        zpnt = 0 
        loop for t3 = 1 to 140 
          t5 = 0 
          loop for t4 = 1 to 256 
            if glyph_record(t3,t4) > 0 
              if t5 = 0 
                ++zpnt 
                tput [ZZ,zpnt] font .w4 ~t3 
                ++zpnt 
                tput [ZZ,zpnt] ============== 
                t5 = 1 
              end 
              ++zpnt 
              tput [ZZ,zpnt] .t4 char .w4 ~t4 
            end 
          repeat 
        repeat 
        ++zpnt 
        tput [ZZ,zpnt] $ 

        perform build_page_pdict 

        a5 = 10000 
        a6 = 0 
        a7 = 10000 
        a8 = 0 
        loop for t5 = 1 to page_cnt 
          if box_top_limit(t5) < a5 
            a5 = box_top_limit(t5) 
          end 
          if box_bottom_limit(t5) > a6 
            a6 = box_bottom_limit(t5) 
          end 
          if box_left_limit(t5) < a7 
            a7 = box_left_limit(t5) 
          end 
          if box_right_limit(t5) > a8 
            a8 = box_right_limit(t5) 
          end 
        repeat 
&dA 
&dA &d@    Now construct the global box limits 
&dA 
&dA 
        left_limit = a7 
        right_limit = a8 
        top_limit = a5 
        bottom_limit = a6 

        left_limit -= 1 
        top_limit  -= 1 

        left_limit += 50 
        right_limit += 50 
        top_limit = 3150 - top_limit 
        bottom_limit = 3150 - bottom_limit 
&dA 
&dA &d@       Convert dots to points, using 300 dpi 
&dA &d@       Format = llx lly ulx uly 
&dA 
        temp3 = "" 
        temp2 = "" 
        a1 = left_limit * 24 
        a2 = a1 / 100 
        a3 = rem 
        if rem < 50 
          temp2 = temp2 // chs(a2) // " " 
        else 
          temp2 = temp2 // chs(a2+1) // " " 
        end 
        temp3 = temp3 // chs(a2) // "." 
        if a3 < 10 
          temp3 = temp3 // "0" 
        end 
        temp3 = temp3 // chs(a3) // " " 

        a1 = bottom_limit * 24 
        a2 = a1 / 100 
        a3 = rem 
        if rem < 50 
          temp2 = temp2 // chs(a2) // " " 
        else 
          temp2 = temp2 // chs(a2+1) // " " 
        end 
        temp3 = temp3 // chs(a2) // "." 
        if a3 < 10 
          temp3 = temp3 // "0" 
        end 
        temp3 = temp3 // chs(a3) // " " 

        a1 = right_limit * 24 
        a2 = a1 / 100 
        a3 = rem 
        if rem < 50 
          temp2 = temp2 // chs(a2) // " " 
        else 
          temp2 = temp2 // chs(a2+1) // " " 
        end 
        temp3 = temp3 // chs(a2) // "." 
        if a3 < 10 
          temp3 = temp3 // "0" 
        end 
        temp3 = temp3 // chs(a3) // " " 

        a1 = top_limit * 24 
        a2 = a1 / 100 
        a3 = rem 
        if rem < 50 
          temp2 = temp2 // chs(a2) 
        else 
          temp2 = temp2 // chs(a2+1) 
        end 
        temp3 = temp3 // chs(a2) // "." 
        if a3 < 10 
          temp3 = temp3 // "0" 
        end 
        temp3 = temp3 // chs(a3)
&dA 
&dA            

&dK &d@       putc %!PS 
&dK &d@       putc 
&dK &d@       putc % This is the PD dictionary 
&dK &d@       putc % ========================= 
&dK &d@       loop for t3 = 1 to pd_cnt 
&dK &d@         tget [PD,t3] temp 
&dK &d@         putc ~temp 
&dK &d@       repeat 
&dK &d@       putc % =========================== 
&dK &d@       putc 
&dK &d@       putc % This is the SD dictionary 
&dK &d@       putc % ========================= 
&dK &d@       loop for t3 = 1 to sd_cnt 
&dK &d@         tget [SD,t3] temp 
&dK &d@         putc ~temp 
&dK &d@       repeat 
&dK &d@       putc % =========================== 
&dK &d@       putc 
&dK &d@       putc % This is the PT table 
&dK &d@       putc % ==================== 
&dK &d@       loop for t3 = 1 to pt_cnt 
&dK &d@         tget [PT,t3] temp 
&dK &d@         putc ~temp 
&dK &d@       repeat 
&dK &d@       putc % =========================== 
&dK &d@       putc 
&dK &d@       putc % This is the PT2 table 
&dK &d@       putc % ===================== 
&dK &d@       loop for t3 = 1 to pt_cnt2 
&dK &d@         tget [PT2,t3] temp 
&dK &d@         putc ~temp 
&dK &d@       repeat 
&dK &d@       putc % =========================== 
&dK &d@       putc 
&dK &d@       putc showpage 

#if DMUSE 
        open [2,2] outfile 

        putf [2] %!PS-Adobe-3.0 
        loop for t1 = 1 to 10 
          putf [2] ~psfile_header(t1) 
        repeat 
        loop for t1 = 1 to finums
          putf [2] %=~time_stamps(t1) 
        repeat 
        putf [2] %%EndComments 
        putf [2] 
        putf [2] %%BeginProlog 
        putf [2] %%EndProlog 
        putf [2] 
        putf [2] %%BeginSetup 
        putf [2] 
        putf [2] % This is the PD dictionary 
        putf [2] % ========================= 
        loop for t3 = 1 to pd_cnt 
          tget [PD,t3] temp 
          putf [2] ~temp 
        repeat 
        putf [2] % =========================== 
        putf [2] 
        putf [2] % This is the SD dictionary 
        putf [2] % ========================= 
        loop for t3 = 1 to sd_cnt 
          tget [SD,t3] temp 
          putf [2] ~temp 
        repeat 
        putf [2] % =========================== 
        putf [2] 
        putf [2] %%EndSetup 
        putf [2] 
        loop for t3 = 1 to ppt_cnt 
          tget [PPT,t3] temp 
          putf [2] ~temp 
        repeat 
        putf [2] 
        putf [2] %%Trailer 
        putf [2] %%BoundingBox: ~temp2 
        putf [2] %%HiResBoundingBox: ~temp3 
        putf [2] 
        if (Addfiles & 0x01) = 0x01 
          loop for t1 = 1 to finums 
            loop for t2 = 1 to finums 
              if part_order(t2) = t1 
                t3 = t2 
                t2 = finums 
              end 
            repeat 
            t4 = fioffs(t3) - 4 
            putf [2] %=BeginMuseData: ~t1 
            loop for t5 = 1 to 100000 
              tget [FI,t4] line 
              ++t4 
              line = line // pad(4) 
              if line = "/END" 
                t5 = 100000 
              end 
              line = trm(line) 
              putf [2] %=~line 
            repeat 
            putf [2] %=EndMuseData: ~t1 
          repeat 
        end 
        putf [2] 
        putf [2] %%EOF
        putf [2] 

        close [2] 
#else 
        putc %!PS-Adobe-3.0 
        loop for t1 = 1 to 10 
          putc ~psfile_header(t1) 
        repeat 
        loop for t1 = 1 to finums   
          putc %=~time_stamps(t1) 
        repeat 
        putc %%EndComments 
        putc 
        putc %%BeginProlog 
        putc %%EndProlog 
        putc 
        putc %%BeginSetup 
        putc 
        putc % This is the PD dictionary 
        putc % ========================= 
        loop for t3 = 1 to pd_cnt 
          tget [PD,t3] temp 
          putc ~temp 
        repeat 
        putc % =========================== 
        putc 
        putc % This is the SD dictionary 
        putc % ========================= 
        loop for t3 = 1 to sd_cnt 
          tget [SD,t3] temp 
          putc ~temp 
        repeat 
        putc % =========================== 
        putc 
        putc %%EndSetup 
        putc 
        loop for t3 = 1 to ppt_cnt 
          tget [PPT,t3] temp 
          putc ~temp 
        repeat 
        putc 
        putc %%Trailer 
        putc %%BoundingBox: ~temp2 
        putc %%HiResBoundingBox: ~temp3 
        putc 
        if (Addfiles & 0x01) = 0x01 
          loop for t1 = 1 to finums 
            loop for t2 = 1 to finums 
              if part_order(t2) = t1 
                t3 = t2 
                t2 = finums 
              end 
            repeat 
            t4 = fioffs(t3) - 4 
            putc %=BeginMuseData: ~t1 
            loop for t5 = 1 to 100000 
              tget [FI,t4] line 
              ++t4 
              line = line // pad(4) 
              if line = "/END" 
                t5 = 100000 
              end 
              line = trm(line) 
              putc %=~line 
            repeat 
            putc %=EndMuseData: ~t1 
          repeat 
        end 
        putc 
        putc %%EOF 
        putc 
#endif 
      return 
&dA 
&dA &d@   End of processing music data 
&dA 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³D*  2. ps_setbeam (@k,@m)                                                        ³
&dA &d@³                                                                                 ³
&dA &d@³    Purpose:  Typeset beams and accompanying notes and                           ³
&dA &d@³              stems.  Also typeset accompanying tuplet, if present               ³
&dA &d@³                                                                                 ³
&dA &d@³    Inputs:   bcount        = number of notes under beam                         ³
&dA &d@³              ps_beamdata(.,1) = x-position of note                              ³
&dA &d@³              ps_beamdata(.,2) = y-position of note                              ³
&dA &d@³              ps_beamdata(.,3) = color_flag                                      ³
&dA &d@³              msk_beamcode(.)   = beam code                                      ³
&dA &d@³                                                                                 ³
&dA &d@³                  beam code = 6 digit number (string)                            ³
&dA &d@³                                                                                 ³
&dA &d@³                          0 = no beam                                            ³
&dA &d@³                          1 = continue beam                                      ³
&dA &d@³                          2 = begin beam                                         ³
&dA &d@³                          3 = end beam                                           ³
&dA &d@³                          4 = forward hook                                       ³
&dA &d@³                          5 = backward hook                                      ³
&dA &d@³                          6 = single stem repeater                               ³
&dA &d@³                          7 = begin repeated beam                                ³
&dA &d@³                          8 = end repeated beam                                  ³
&dA &d@³                                                                                 ³
&dA &d@³                      100000's digit = eighth level beams                        ³
&dA &d@³                       10000's digit = 16th level beams                          ³
&dA &d@³                        1000's digit = 32nd level beams                          ³
&dA &d@³                         100's digit = 64th level beams                          ³
&dA &d@³                          10's digit = 128th level beams                         ³
&dA &d@³                           1's digit = 256th level beams                         ³
&dA &d@³                                                                                 ³
&dA &d@³                                                                                 ³
&dA &d@³                       @k   = distance from first object (oby of                 ³
&dA &d@³                              note group) to top of top beam (for                ³
&dA &d@³                              stems up) or bottom of bottom beam                 ³
&dA &d@³                              (for stems down).  @k > 0 means                    ³
&dA &d@³                              stem up.                                           ³
&dA &d@³                       @m   = number of dots the beam falls                      ³
&dA &d@³                              (rises = negative) in a distance                   ³
&dA &d@³                              of 30 horizontal dots.  (i.e.                      ³
&dA &d@³                              slope * 30)                                        ³
&dA &d@³                 beamfont   = font for printing beam                             ³
&dA &d@³                 stemchar   = character number for stem                          ³
&dA &d@³                    beamt   = vertical space between beams (normally pvpar(32))  ³
&dA &d@³                     qwid   = width of quarter note (normally phpar(3))          ³
&dA &d@³              tupldata(1)   = tuplet situation flag                              ³
&dA &d@³              tupldata(2)   = tuplet number                                      ³
&dA &d@³              tupldata(3)   = x1 offset                                          ³
&dA &d@³              tupldata(4)   = x2 offset                                          ³
&dA &d@³              tupldata(6)   = y1 offset   / For case where tuple goes over       ³
&dA &d@³              tupldata(7)   = y2 offset   \ note heads &dAand&d@ there are chords.     ³
&dA &d@³                   tbflag   = print tuplet flag                                  ³
&dA &d@³                                                                                 ³
&dA &d@³    Outputs:  prints out beams, stems and notes by means of                      ³
&dA &d@³              procedures, printbeam, hook and revset.                            ³
&dA &d@³                                                                                 ³
&dA &d@³    Internal variables:                                                          ³
&dA &d@³                         @b = y-intercept of beam                                ³
&dA &d@³                         @f = temporary variable                                 ³
&dA &d@³                         @g = temporary variable (related to @@g)                ³
&dA &d@³                         @h = temporary variable                                 ³
&dA &d@³                         @i = temporary variable                                 ³
&dA &d@³                         @j = temporary counter                                  ³
&dA &d@³                         @k = |@m|                                               ³
&dA &d@³                         @n = temporary variable                                 ³
&dA &d@³                         @q = temporary counter                                  ³
&dA &d@³                         @s = temporary variable                                 ³
&dA &d@³                         @t = temporary variable                                 ³
&dA &d@³                        @@b = vertical range of note set                         ³
&dA &d@³                        @@g = top of staff line                                  ³
&dA &d@³                        @@n = temporary variable                                 ³
&dA &d@³                        @@q = temporary variable                                 ³
&dA &d@³                     bthick = thickness of beam - 1                              ³
&dA &d@³                    (x1,y1) = temporary coordinates                              ³
&dA &d@³                    (x2,y2) = temporary coordinates                              ³
&dA &d@³                      z1,z2 = temporary character numbers                        ³
&dA &d@³                stemdir(80) = stem directions for mixed direction case           ³
&dA &d@³               stemends(80) = stem endpoints for mixed direction case            ³
&dA &d@³                 beampos(8) = position of beam (mixed stem dir)                  ³
&dA &d@³                  beamlevel = index into beampos(for each note belonging to beam)³
&dA &d@³                                                                                 ³
&dA &d@³    Global variables used to communicate                                         ³
&dA &d@³                                                                                 ³
&dA &d@³                         z3 = character number for revset                        ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure ps_setbeam (@k,@m) 
        int @b,@f,@g,@h,@i,@j,@k,@m,@n,@q,@s,@t 
        int @@b,@@g,@@n,@@q 
        int z1,z2,mixflag 
        int stemends(80),stemdir(80),beampos(8),beamlevel(MAX_BNOTES) 
        int savex1 
        int staff_height 
        int t1,t2,t3                   /* NEW 
        int a4 
        int bshflg 
        int cc,color_flag2             /* New &dA12/21/10&d@ 
        int dv3 
        int a1 
        getvalue @k,@m 
&dA 
&dA &d@  check for errors in beam repeaters 
&dA 
&dA &d@  And &dA12/21/10&d@, determine the finel color for the beam 
&dA 
        color_flag2 = color_flag           /* New &dA12/21/10&d@ 
        cc = color_flag                    /* New &dA12/21/10&d@ 
        t1 = 0                             /* New &dA12/21/10&d@ 
        loop for @j = 1 to bcount 
          if ps_beamdata(@j,3) = 0         /* New &dA12/21/10&d@ 
            ++t1 
            if t1 > (bcount / 2) 
              cc = 0 
            end 
          end 
          if msk_beamcode(@j) con "7" or msk_beamcode(@j) con "8" 
            if bcount <> 2 
              if (Debugg & 0x12) > 0 
                pute Improper use of beam repeaters 
              end 
              goto BERR 
            end 
            loop for @j = 1 to 6 
              if "270" con msk_beamcode(1){@j} 
                if msk_beamcode(1){@j} = "2" 
                  if msk_beamcode(2){@j} <> "3" 
                    if (Debugg & 0x12) > 0 
                      pute Mismatching beamcodes 
                    end 
                    goto BERR 
                  end 
                end 
                if msk_beamcode(1){@j} = "7" 
                  if msk_beamcode(2){@j} <> "8" 
                    if (Debugg & 0x12) > 0 
                      pute Mismatching beamcodes 
                    end 
                    goto BERR 
                  end 
                end 
                if msk_beamcode(1){@j} = "0" 
                  if msk_beamcode(2){@j} <> "0" 
                    if (Debugg & 0x12) > 0 
                      pute Mismatching beamcodes 
                    end 
                    goto BERR 
                  end 
                end 
              else 
                if (Debugg & 0x12) > 0 
                  pute Improper use of beam repeaters 
                end 
                goto BERR 
              end 
            repeat 
            @j = 10000 
          end 
        repeat 

        if @k > 0 
          stem = UP 
        else 
          stem = DOWN 
        end 
&dA 
&dA &d@    Check for situation where notes span two staves (grand staff) 
&dA 
        staff_height = 0 

        if vst(f12) > 0 
          @g = ps_beamdata(1,2) 
          loop for @j = 2 to bcount 
            if abs(ps_beamdata(@j,2) - @g) > 500 
              staff_height = 10000 
              @j = 10000 
            end 
          repeat 
        end 
&dA 
&dA &d@    Adjust all y coordinates be relative to the top staff 
&dA 
        loop for @j = 1 to bcount 
          if ps_beamdata(@j,2) - psq(f12) > 700 
            ps_beamdata(@j,2) -= 1000 
            ps_beamdata(@j,2) += vst(f12) 
            if staff_height <> 10000 
              staff_height = vst(f12) 
            end 
          end 
        repeat 
&dA 
&dA &d@    Check for mixed stem directions 
&dA 
        mixflag = 0 
        loop for @j = 2 to bcount 
          @h = ps_beamdata(@j,1) - ps_beamdata(1,1) * @m / 30 
          @h = @h + ps_beamdata(1,2) - @k - ps_beamdata(@j,2) 
          if @h < 0 
            if stem = DOWN 
              mixflag = 1 
              @j = 10000 
            end 
          else 
            if stem = UP 
              mixflag = 1 
              @j = 10000 
            end 
          end 
        repeat 
&dA 
&dA &d@    Deal with tuplets attached to &dAnote heads&d@ 
&dA 
        if tbflag = 1  
          @f = ps_beamdata(bcount,1) - ps_beamdata(1,1) 
          @g = ps_beamdata(bcount,2) - ps_beamdata(1,2) * 30 
          @t = @g / @f 
          @s = 0 
          @n = bcount - 1  
          loop for @i = 2 to @n  
            @h = ps_beamdata(@i,1) - ps_beamdata(1,1) * @t / 30 + ps_beamdata(1,2)
            @q = ps_beamdata(@i,2) - @h 
            if stem = DOWN
              @q = 0 - @q  
            end  
            if @q > @s 
              @s = @q  
            end  
          repeat 

          if stem = DOWN 
            @j = pvpar(39) + @s + psq(f12)     
            y1 = ps_beamdata(1,2) - @j 
            y2 = ps_beamdata(bcount,2) - @j 
          else 
            @j = pvpar(39) + pvpar(38) + @s - psq(f12)    
            y1 = ps_beamdata(1,2) + @j 
            y2 = ps_beamdata(bcount,2) + @j 
          end  
&dA 
&dA &d@    Adding code &dA05/09/03&d@ to make space for numbers inside brackets  &dIOK&d@ 
&dA 
          sitflag = tupldata(1)  
          @s = pvpar(1) 
          if bit(0,sitflag) = 1               /* number present 
            if bit(1,sitflag) = 1               /* bracket present 
              if bit(4,sitflag) = 0               /* number near note head 
                if bit(5,sitflag) = 1               /* continuous bracket     
                  if bit(6,sitflag) = 1               /* number inside        
                    if bit(2,sitflag) = 0               /* tips down       
                      y1 -= pvpar(2)                       /* raise bracket 
                      y2 -= pvpar(2) 
                      @s = pvpar(3) 
                    else                                /* tips up 
                      y1 += pvpar(2)                       /* lower bracket 
                      y2 += pvpar(2) 
                      @s = pvpar(2) 
                    end 
                  end 
                end 
              end 
            end 
          end 

          if stem = DOWN 
            if staff_height <> 10000 
              @h = 0 - notesize * 2 / 3 + staff_height      
              if (y1 + tupldata(6)) > @h 
                y1 = @h - tupldata(6) 
              end 
              if (y2 + tupldata(6)) > @h 
                y2 = @h - tupldata(6) 
              end 
            end 
          else 
            if staff_height <> 10000 
              @h = 11 * notesize / 2 + staff_height 
              if (y1 + tupldata(6)) < @h 
                y1 = @h - tupldata(6) 
              end 
              if (y2 + tupldata(6)) < @h 
                y2 = @h - tupldata(6) 
              end 
            end 
          end  
          a1 = tupldata(2) 
          x1 = tupldata(3) + ps_beamdata(1,1) - sp 
          x2 = tupldata(4) + ps_beamdata(bcount,1) - sp 
          y1 += tupldata(6) 
          y2 += tupldata(7) 
          perform puttuplet (a1) 
        end  

        bthick = beamfont - 101  
&dA 
&dA &d@    Reverse all y co-ordinates if first stem is down 
&dA 
        @g = psq(f12)   
        if stem = DOWN 
          @g = pvpar(2) * 500  - pvpar(8) - @g 
          loop for @j = 1 to bcount  
            ps_beamdata(@j,2) = pvpar(2) * 500  - ps_beamdata(@j,2) 
          repeat 
        end  
        @@g = @g 

        if stem = 1 
          @m = 0 - @m 
          @k = 0 - @k 
        end 
        dv3 = @m * ps_beamdata(1,1) 
        dv3 = ps_beamdata(1,2) - @k * phpar(1) - dv3 
        @k = abs(@m) 
        @@q = 0 
        loop for @j = 1 to bcount 
          @n = 5 
          if msk_beamcode(@j) con "0" 
            @n = mpt - 2       /* number of additional beams on this note 
          end 
          if @n > @@q 
            @@q = @n           /* max number of additional beams 
          end 
        repeat 
        ++@@q 
        if @@q > 3 
          beamt = pvpar(33) 
        end 

&dA                                                            
&dA &d@                                                          &dA 
&dA &d@    This is the printout portion of the procedure         &dA 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ         &dA 
&dA &d@       @m = phpar(1) * slope of beam                      &dA 
&dA &d@       @k = |@m|                                          &dA 
&dA &d@       dv3 = y-intercept of top of beam (times phpar(1))  &dA 
&dA &d@                                                          &dA 
&dA                                                            

&dA 
&dA &d@  identify beam characters  
&dA 
        z1 = @k + 33 
        if @m > 0  
          z1 += 128 
        end  
        z2 = @k + 49   
        if @m > 0  
          z2 += 128 
        end  
&dA 
&dA &d@  check for tuplet over beam 
&dA 
        if tbflag = 2  
          sitflag = tupldata(1)  
          if bit(7,sitflag) = 1             /* curved bracket &dA03/15/97&d@  &dIOK&d@ 
            a4 = 0 - 2 * qwid / 3 
            if stem = UP 
              a4 = qwid / 3 
            end 
          else 
            a4 = 0 - qwid / 3 
            if stem = UP 
              a4 = 2 * qwid / 3 
            end 
          end 

          a1 = tupldata(2) 
          x1 = ps_beamdata(1,1) + a4 - sp                 + tupldata(3) 
          x2 = ps_beamdata(bcount,1) + a4 - sp            + tupldata(4) 
          y1 = @m * ps_beamdata(1,1) + dv3 / phpar(1) 
          y2 = @m * ps_beamdata(bcount,1) + dv3 / phpar(1) 
          if stem = DOWN 
            y1 = pvpar(2) * 500  - y1 - bthick - psq(f12) + pvpar(39) + pvpar(38)
            y2 = pvpar(2) * 500  - y2 - bthick - psq(f12) + pvpar(39) + pvpar(38)
          else 
            y1 = y1 - pvpar(39) - psq(f12)     
            y2 = y2 - pvpar(39) - psq(f12)     
          end  
          y1 += tupldata(6) 
          y2 += tupldata(7) 
          perform puttuplet (a1) 
        end  
&dA 
&dA &d@   Here the situation diverges 
&dA 
&dA &d@     Case I:  all stems go in the same direction 
&dA &d@     Case II: stem directions are mixed 
&dA 
        if mixflag = 0     /*  Case I: all stems go in the same direction 
&dA 
&dA &d@  put in first beam 
&dA 
          x1 = ps_beamdata(1,1) 
          x2 = ps_beamdata(bcount,1) 
          if msk_beamcode(1){1} = "7" 
            x1 += phpar(59) 
            x2 -= phpar(59) 
          end 
          color_flag = cc                      /* New &dA12/21/10&d@ 
          perform printbeam (z1,dv3,@m) 
          color_flag = color_flag2             /* New &dA12/21/10&d@ 
&dA 
&dA &d@  put in vertical stems 
&dA 
          loop for @j = 1 to bcount 
            if ps_beamdata(@j,3) = 0           /* New &dA12/21/10&d@ 
              color_flag = 0     
            end 
            x1 = ps_beamdata(@j,1) 
            y1 = @m * x1 + dv3 / phpar(1) + pvpar(42) 
            y1 += pvpar(4) 
            y2 = ps_beamdata(@j,2) 
            z3 = stemchar 
            if y1 >= y2 
              z3 += 2 
              y1 -= pvpar(2) 
              loop while y1 < y2 
                perform revset 
                y1 += pvpar(2) 
              repeat 
            else 
              loop while y1 < y2 
                perform revset 
                y1 += pvpar(4) 
              repeat 
            end 
            y1 = y2 
            perform revset 
            color_flag = color_flag2           /* New &dA12/21/10&d@ 
          repeat 
&dA &d@    
&dA &d@  put in other beams  
&dA 
          loop for @q = 2 to @@q 
            if msk_beamcode(1){@q} = "7" 
              dv3 = (pvpar(2) + beamt) * phpar(1) / 2 + dv3 
            else 
              if msk_beamcode(1){@q} = "6" 
                dv3 = pvpar(2) * phpar(1) + dv3 
              else 
                dv3 = beamt * phpar(1) + dv3 
              end 
            end 
            bshflg = 0 
            loop for @j = 1 to bcount 
              if "123456780" con msk_beamcode(@j){@q} 
                if mpt = 2 
                  @i = @j 
BB1:              ++@j 
                  if @j > bcount 
                    if (Debugg & 0x12) > 0 
                      pute @j (~@j ) exceeds bcount (~bcount ) 
                    end 
                    goto BERR 
                  end 
                  if "1234560" con msk_beamcode(@j){@q} 
                    if mpt = 1 
                      goto BB1 
                    else 
                      if mpt = 3 
                        if @i > 1 and bshflg = 0 
                          dv3 += (3 * phpar(1) / 8) 
                          bshflg = 1 
                        end 
                        x1 = ps_beamdata(@i,1) 
                        x2 = ps_beamdata(@j,1) 
                        color_flag = cc                      /* New &dA12/21/10
                        perform printbeam (z1,dv3,@m) 
                        color_flag = color_flag2             /* New &dA12/21/10
                        goto BBR 
                      else 
                        if (Debugg & 0x12) > 0 
                          pute expecting a "1" or a "3" here (got a ~msk_beamcode(@j){@q} )
                          pute msk_beamcode(~@j ) = ~msk_beamcode(@j) 
                        end 
                        goto BERR 
                      end 
                    end 
                  end 
                end 
                if mpt = 7 
                  x1 = ps_beamdata(1,1) + phpar(59) 
                  x2 = ps_beamdata(2,1) - phpar(59) 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform printbeam (z1,dv3,@m) 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                  goto BBR 
                end 
                if mpt = 1 
                  if (Debugg & 0x12) > 0 
                    pute "1" not allowed in this position 
                  end 
                  goto BERR 
                end 
                if mpt = 3 
                  if (Debugg & 0x12) > 0 
                    pute "3" not allowed in this position 
                  end 
                  goto BERR 
                end 
                t1 = phpar(1) >> 1 
                if mpt = 4                               /* print forward hook
                  x1 = ps_beamdata(@j,1) + phpar(29) 
                  y  = @m * x1 + dv3 + t1 / phpar(1) 
                  z  = z2 + 16 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
                if mpt = 5                               /* print backward hook
                  x1 = ps_beamdata(@j,1) 
                  y  = @m * x1 + dv3 + t1 / phpar(1) 
                  x1 -= hookbackshift(beamfont-100)      /* New &dA12/31/08&d@ 
                  z = z2 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
                if mpt = 6                               /* make cross piece
                  x1 = ps_beamdata(@j,1) 
                  t3 = int("0001122344567"{beamfont-100})  /* magic number 
                  t3 += 3 
                  x1 -= t3 
                  y1 = @m * x1 + dv3 + t1 / phpar(1) 
                  y  = y1 
                  z  = z2 + 16 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
              end 
BBR:        repeat 
          repeat 

        else          /*  Case II: stem directions are mixed 
&dA 
&dA &d@    1. Determine definitive stem directions and end points 
&dA &d@         on main staff.  
&dA 
          loop for @j = 1 to bcount 
            x1 = ps_beamdata(@j,1) 
            y1 = @m * x1 + dv3 / phpar(1) + 4   /* middle of main beam 
            y2 = ps_beamdata(@j,2)                /* oby of note 
            if y1 < y2 
              stemdir(@j) = UP 
            else 
              stemdir(@j) = DOWN               /* different x intersection 
              if stem = UP                     /* direction of &dAfirst&d@ stem 
                x1 -= qwid - phpar(29) 
              else 
                x1 += qwid - phpar(29) 
              end 
              y1 = @m * x1 + dv3 / phpar(1) + 4 
            end 
            stemends(@j) = y1 
          repeat 
&dA 
&dA &d@    2. Put in first beam 
&dA 
          x1 = ps_beamdata(1,1)         /* stemdir(1) is always UP 
          x2 = ps_beamdata(bcount,1) 
          if stemdir(bcount) = DOWN 
            if stem = UP 
              x2 -= qwid - phpar(29) 
            else 
              x2 += qwid - phpar(29) 
            end 
          end 
          color_flag = cc                      /* New &dA12/21/10&d@ 
          perform printbeam (z1,dv3,@m) 
          color_flag = color_flag2             /* New &dA12/21/10&d@ 
          beampos(1) = dv3 
&dA 
&dA &d@    2a. Set beamlevel = 1 for all notes.  beamlevel for notes will change 
&dA &d@        as we move through the beam.  Basically, if notes A and B start 
&dA &d@        and end a beam respectively, then beamlevel will be given the 
&dA &d@        same value for all of these notes and any that might be in between.  
&dA &d@        If another beam extends between notes C and B, then beamlevel 
&dA &d@        for these notes will be increased.  In the end, beamlevel for each 
&dA &d@        note will be the number of beams connecting or going through the 
&dA &d@        stem for that note.  
&dA 
          loop for @j = 1 to bcount 
            beamlevel(@j) = 1 
          repeat 
&dA 
&dA &d@     NEW &dA05/19/03&d@  I am going to attempt a rewrite of this section.  The problem
&dA &d@     with the old code was that it sometimes didn't give asthetically pleasing 
&dA &d@     solutions.  In particular, the problem arises when a secondary beam is
&dA &d@     to be drawn between endpoints whose stems are in different directions.
&dA &d@     The old code made the arbitrary decision to draw the secondary beam according
&dA &d@     to the direction of the stem of the initial note.  This had the additional
&dA &d@     advantage that stems could be drawn as notes were processed, i.e., we would
&dA &d@     not have to go back and "lengthen" a stem because a secondary beam was 
&dA &d@     drawn on the other side of the primary.  
&dA 
&dA &d@     With this rewrite, I must change this, i.e., stems cannot be drawn until 
&dA &d@     all beams are set.  Secondly, I need to come up with a set of rules as to
&dA &d@     how to deal with the situation where the endpoints of a secondary connect
&dA &d@     to stems of different directions.  I propose to generate these rules from
&dA &d@     experience, and by trial and error.  As we encounter situations where the
&dA &d@     result seems to violate common sense, then we can consider adding a new 
&dA &d@     rule.  It should be pointed out that at the moment &dEthere is no provision
&dA &d@     &dEmade for editing the decision made by this program&d@ as regards the placing
&dA &d@     of secondary beams.  To add this feature, we would need to expand the 
&dA &d@     contents of the beam super-object record.  
&dA 
&dA &d@     As of this date &dA05/19/03&d@, I have only one rule to propose for cases where  
&dA &d@     the endpoints have stems that go in different directions.  
&dA &d@                              
&dA &d@        1. If there is a stem that follows the terminating stem, then use 
&dA &d@           use this stem direction to "arbitrate" between the directions of  
&dA &d@           the endpoint stems.  If no stem follows, then the stem direction
&dA &d@           of the initial note wins.  
&dA 

&dA 
&dA &d@    3. Loop through notes, one at a time 
&dA 
          loop for @j = 1 to bcount 
            x1 = ps_beamdata(@j,1) 
            if stemdir(@j) = DOWN 
              if stem = UP 
                x1 -= qwid - phpar(29) 
              else 
                x1 += qwid - phpar(29) 
              end 
            end 
            savex1 = x1 
&dA 
&dA &d@      a. add &dAall&d@ extra beams starting at this note (and increase beamlevel accordingly)
&dA 
            loop for @h = beamlevel(@j) + 1 to 6 
              if msk_beamcode(@j){@h} = "2"          /* begin beam 
                ++beamlevel(@j)                  /* increment beamlevel for starting point
                loop for @g = @j + 1 to bcount 
                  if msk_beamcode(@g){@h} = "3"      /* end beam 
                    x1 = savex1                  /* x1 needs to be reset for each beam
                    x2 = ps_beamdata(@g,1) 
                    if stemdir(@g) = DOWN        
                      if stem = UP 
                        x2 -= qwid - phpar(29) 
                      else 
                        x2 += qwid - phpar(29) 
                      end 
                    end 
                    dv3 = beampos(1) 
&dA 
&dA &d@       Here is where the rules take effect.  
&dA 
&dA &d@         Case I: Use stem direction of first note to determine secondary beam position
&dA 
&dA &d@                cases:  1) Normal:  stemdir(@g) = stemdir(@j) 
&dA 
&dA &d@                        2) stemdir(@g) <> stemdir(@j) but 
&dA &d@                            either  @g = bcount 
&dA &d@                            or  stemdir(@g+1) = stemdir(@j) 
&dA 
                    t2 = 0 
                    if stemdir(@g) <> stemdir(@j) 
                      if @g < bcount 
                        if stemdir(@g+1) <> stemdir(@j) 
                          t2 = 1 
                        end 
                      end 
                    end 

                    if t2 = 0
                      loop for @f = 1 to beamlevel(@g) 
                        if stemdir(@j) = UP 
                          if beampos(@f) > dv3 
                            dv3 = beampos(@f) 
                          end 
                        else 
                          if beampos(@f) < dv3 
                            dv3 = beampos(@f) 
                          end 
                        end 
                      repeat 
                      ++beamlevel(@g)           /* increment beamlevel for endpoint
                      if stemdir(@j) = UP              
                        dv3 += (beamt * phpar(1)) 
                      else 
                        dv3 -= (beamt * phpar(1)) 
                      end 
                      beampos(beamlevel(@g)) = dv3 
                       
                      color_flag = cc                      /* New &dA12/21/10&d@ 
                      perform printbeam (z1,dv3,@m) 
                      color_flag = color_flag2             /* New &dA12/21/10&d@ 
&dA 
&dA &d@      b. adjust stem ends for notes under (over) this beam 
&dA 
                      loop for @f = @j + 1 to @g 
                        if stemdir(@j) = UP 
                          if stemdir(@f) = DOWN 
                            stemends(@f) += beamt 
                          end 
                        else 
                          if stemdir(@f) = UP 
                            stemends(@f) -= beamt 
                          end 
                        end 
                      repeat 
                    else  
&dA 
&dA &d@         Case II: Use stem direction of last note to determine secondary beam position
&dA 
&dA &d@                cases:  1) stemdir(@g) <> stemdir(@j), and 
&dA &d@                            @g < bcount, and 
&dA &d@                            stemdir(@g+1) = stemdir(@g) 
&dA 
                      loop for @f = 1 to beamlevel(@g) 
                        if stemdir(@g) = UP                 /* changing @j to @g
                          if beampos(@f) > dv3 
                            dv3 = beampos(@f) 
                          end 
                        else 
                          if beampos(@f) < dv3 
                            dv3 = beampos(@f) 
                          end 
                        end 
                      repeat 
                      ++beamlevel(@g)           /* increment beamlevel for endpoint
                      if stemdir(@g) = UP                   /* changing @j to @g
                        dv3 += (beamt * phpar(1)) 
                      else 
                        dv3 -= (beamt * phpar(1)) 
                      end 
                      beampos(beamlevel(@g)) = dv3 

                      color_flag = cc                      /* New &dA12/21/10&d@ 
                      perform printbeam (z1,dv3,@m) 
                      color_flag = color_flag2             /* New &dA12/21/10&d@ 
&dA 
&dA &d@      b. adjust stem ends for notes under (over) this beam 
&dA 
                      loop for @f = @j to @g 
                        if stemdir(@g) = UP                 /* changing @j to @g
                          if stemdir(@f) = DOWN 
                            stemends(@f) += beamt 
                          end 
                        else 
                          if stemdir(@f) = UP 
                            stemends(@f) -= beamt 
                          end 
                        end 
                      repeat 
                    end 

                    @g = 10000 
                  else 
&dA 
&dA &d@                   Increment beamlevel for all notes between endpoints of this beam
&dA 
                    ++beamlevel(@g)                                           
                  end 
                repeat 
                if @g <> 10000 
                  if (Debugg & 0x12) > 0 
                    pute No termination found for beam 
                  end 
                  goto BERR 
                end 
              else 
                @h = 6 
              end 
            repeat 
&dA 
&dA &d@      c. put in any hooks that might go with this note 
&dA 
            loop for @h = beamlevel(@j) + 1 to 6 
              if "456" con msk_beamcode(@j){@h}         /* begin beam 
                @g = mpt 
                loop for @f = 1 to beamlevel(@j) 
                  if stemdir(@j) = UP 
                    if beampos(@f) > dv3 
                      dv3 = beampos(@f) 
                    end 
                  else 
                    if beampos(@f) < dv3 
                      dv3 = beampos(@f) 
                    end 
                  end 
                repeat 
                if @g = 3 
                  t1 = pvpar(2) * phpar(1) 
                else 
                  t1 = beamt * phpar(1) 
                end 
                if stemdir(@j) = UP 
                  dv3 += t1
                else 
                  dv3 -= t1
                end 
                t1 = phpar(1) >> 1 
                if @g = 1                                /* print forward hook
                  x1 = savex1 + phpar(29) 
                  y  = @m * x1 + dv3 + t1 / phpar(1) 
                  z  = z2 + 16 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
                if @g = 2                                /* print backward hook
                  x1 = savex1          
                  y  = @m * x1 + dv3 + t1 / phpar(1) 
                  x1 -= hookbackshift(beamfont-100)      /* New &dA12/31/08&d@ 
                  z = z2 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
                if @g = 3                                /* make cross piece
                  x1 = savex1 
                  y1 = @m * x1 + dv3 + t1 / phpar(1) 
                  x1 -= 5 
                  y  = y1 
                  if @m > 0 
                    y -= int("111111222222233"{@m}) 
                  end 
                  if @m < 0 
                    y += int("111111222222233"{0-@m}) 
                  end 
                  z  = z2 + 16 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                  x1 -= phpar(30) - phpar(29) - 10  /* = 7 
                  y  = y1 
                  if @m > 0 
                    y += int("000111111222222"{@m}) 
                  end 
                  if @m < 0 
                    y -= int("000111111222222"{0-@m}) 
                  end 
                  z = z2 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
              else 
                @h = 6 
              end 
            repeat 
          repeat 
&dA 
&dA &d@    4. Loop again through notes, one at a time, and now draw the stems (&dA05/19/03&d@)
&dA 
          loop for @j = 1 to bcount 
&dA 
&dA &d@      a. put in stem 
&dA 
            if ps_beamdata(@j,3) = 0           /* New &dA12/21/10&d@ 
              color_flag = 0     
            end 
            x1 = ps_beamdata(@j,1) 
            if stemdir(@j) = DOWN 
              if stem = UP 
                x1 -= qwid - phpar(29) 
              else 
                x1 += qwid - phpar(29) 
              end 
            end 
            savex1 = x1 
            if stemdir(@j) = UP 
              y1 = stemends(@j) 
              y2 = ps_beamdata(@j,2) 
            else 
              y2 = stemends(@j) 
              y1 = ps_beamdata(@j,2) + 2          /* I think this is needed 
            end 
            y1 += pvpar(4) 
            z3 = stemchar 
            if y1 >= y2 
              z3 += 2 
              y1 -= pvpar(2) 
              loop while y1 < y2 
                perform revset 
                y1 += pvpar(2) 
              repeat 
            else 
              loop while y1 < y2 
                perform revset 
                y1 += pvpar(4) 
              repeat 
            end 
            y1 = y2 
            perform revset 
            color_flag = color_flag2           /* New &dA12/21/10&d@ 
          repeat 
&dA 
&dA &d@    End of &dA05/19/03&d@ rewrite &dIOK&d@ 
&dA 
        end 

        return 
BERR: 
        if (Debugg & 0x12) > 0 
          pute Beam format error, printbeam aborted 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  3. hook                                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset hook beam                                ³ 
&dA &d@³                                                               ³ 
&dA &d@³             x1       = horizontal position of note            ³ 
&dA &d@³             y        = vertical position of hook attachment   ³ 
&dA &d@³             stem     = stem direction                         ³ 
&dA &d@³             z        = hook character                         ³ 
&dA &d@³             beamfont = type of font for beam                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure hook 
        x = x1 
        if stem = 1  
          y = pvpar(2) * 500  - y - bthick  
          z += 128 
          z &= 0xff 
        else 
          x += qwid - phpar(29) 
        end  
        scf = beamfont 
        scx = x 
        scy = y 
        scb = z 
        perform charout 
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  4. printbeam (z1,dv3,@@m)                                  ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset beam                                     ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  @@m = slope * phpar(1)                            ³ 
&dA &d@³             x1  = starting point of beam                      ³ 
&dA &d@³             x2  = end point of beam                           ³ 
&dA &d@³             dv3 = y intercept of beam (times phpar(1))        ³ 
&dA &d@³             stem = stem direction                             ³ 
&dA &d@³             z1 = beam character number for this slope         ³ 
&dA &d@³                                                               ³ 
&dA &d@³             @@k = |@@m|                                       ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure printbeam (z1,dv3,@@m) 
        int x3,z1,dv3,@@k,@@m 
        getvalue z1,dv3,@@m 

        @@k = abs(@@m) 
        x = x1 
        if stem = UP 
          x += qwid - phpar(29) 
        end  
        scx = x 
        scf = beamfont 

        x2 = x2 + phpar(29) - phpar(1) 
        y1 = @@m * x1 + dv3 / phpar(1) 
        if x2 < x1 and @@k = 0 
          x2 = phpar(1) - 4 + x2              /* no beam shorter than 4 dots  
          y = y1                            /* put out <n> "overlapping" 4 dot lengths
          if stem = DOWN 
            y = pvpar(2) * 500  - y - bthick 
          else 
            x2 += qwid - phpar(29) 
          end 
PBEAM01: 
          scy = y 
          scb = 88 
          perform charout 

          x += 4          
          if x < x2 
            goto PBEAM01 
          end 
          scx = x2 
          scb = 88 
          perform charout 
          scf = notesize 
          return 
        end  
        z = z1   
        if stem = DOWN 
          z += 128
          z &= 0xff 
        end  
        loop while x1 <= x2  
          y = y1 
          if stem = DOWN 
            y = pvpar(2) * 500  - y - bthick  
          end  
          scy = y 
          scb = z
          perform charout 
          x1 += phpar(1) 
          y1 += @@m 
        repeat 
        y2 = x2 + phpar(1) - x1   
&dA 
&dA &d@  print fraction of beam 
&dA &d@   y2 = extra length needed to complete beam 
&dA 
        if y2 = 0  
          scf = notesize 
          return 
        end  
        y = y1 
        if stem = DOWN 
          y = pvpar(2) * 500  - y - bthick  
        end  
&dA &d@   y = starting point   
        if @@k = 0  
          x = x1 - 30 + y2   
          if stem = UP 
            x += qwid - phpar(29) 
          end  
          scx = x 
          scy = y 
          scb = 33 
          perform charout 
          scf = notesize 
          return 
        end  
        scy = y 

        x3 = @@k - 1 * 29 + y2  
        if x3 < 1 or x3 > 435             /* added &dA11/29/09&d@ 
          return 
        end 

        x2 = beamext(x3,1)
        y1 = 2 
        loop for y2 = 1 to x2  
          z = beamext(x3,y1)
          if @@m > 0  
            z += 128 
            z &= 0xff 
          end  
          if stem = 1  
            z += 128 
            z &= 0xff 
          end  
          scb = z 
          perform charout 
          if y2 < x2 
            ++y1
            x1 = beamext(x3,y1)
            if stem = 1  
              x1 = 0 - x1  
            end  
            if @@m > 0  
              x1 = 0 - x1  
            end  
            y -= x1 
            scy = y 
            ++y1
          end  
        repeat 
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  5. revset                                                  ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Check for reversal of page and correct x y and z ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  x1 = horizontal position of note                  ³ 
&dA &d@³             y1 = vertical position of note                    ³ 
&dA &d@³             z3 = character to typeset                         ³ 
&dA &d@³             stem = stem direction                             ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Note: Called only by ps_setbeam                            ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure revset
        int cc                       /* New &dA12/17/10&d@ 

        cc = color_flag              /* New &dA12/17/10&d@ 
        x = x1 
        y = y1 
        z = z3 
        if stem = DOWN 
          if z = 59 or z = 61 or z = 187 or z = 189 
            ++z       
          end  
          y = pvpar(2) * 500  - y   
        end      
        perform setmus 
        color_flag = cc              /* New &dA12/17/10&d@ 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  6. setmus                                                  ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset character                                ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  x = horizontal position of note                   ³ 
&dA &d@³             y = vertical position of note                     ³ 
&dA &d@³             z = character to typeset                          ³ 
&dA &d@³       sizenum = current scale size (1 to 12)                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setmus     
        int sy,pz 

        if z = 0 
          return  
        end 
&dA 
&dA &d@    Implementing back ties as a character   &dA04/22/08&d@ 
&dA 
        if z > 1999 
          if z < 2032                
            return 
          end 
          if z > 2090 and z < 2160 
            return 
          end 
          if z > 2218 
            return 
          end 
          z -= 2000                 /* z is now a legal single tie character

          scf = 300 
          scx = x 
          scy = y 
          scb = z          
          perform charout 
          scf = notesize 

          return 
        end 
&dA 
&dA &d@    Implementing extended music font  &dA02/19/06&d@ 
&dA 
        if z > 999 

          pz = ors("000011112222"{sizenum})     /* old "dummy()" 
          sy = y 

          z += ors(" P Ğ P Ğ P Ğ"{sizenum})     /* old "extendoff()" 
          z -= 1001 

          scx = x 
          scy = sy 
          scb = z 
          scf = pz + 50      /* scf is index into revmap producing fonts 48,49,50
          perform charout 
          scf = notesize 

          return 
        end 
&dA 
&dA      &d@   End of &dA02/19/06&d@ addition 

        sy = y - pos(z-32) 
        scx = x 
        scy = sy 
        scb = z 
        perform charout 
      return   

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  7. setwords (t1)                                           ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset words                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  t1   = flag: 0 = regular setwords call            ³ 
&dA &d@³                          1 = setwords called from TEXT sub-obj³ 
&dA &d@³             x    = horizontal position of words               ³ 
&dA &d@³             y    = vertical position of words                 ³ 
&dA &d@³             z    = font number for words                      ³ 
&dA &d@³             line = words to set                               ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setwords (t1) 
        str textline.300 
        int t1,t2 
        int d1 

        getvalue t1 
        if t1 = 1 and line = "&" 
          return 
        end 

        if x < 0 
          if (Debugg & 0x12) > 0 
#if DMUSE 
            putc &dAWARNING&d@:  Attempting to typeset a word with a (net) negative x position
#else 
            pute WARNING:  Attempting to typeset a word with a (net) negative x position
#endif 
          end 
          x = 0
        end 

        scx = x 
        scy = y 

        if z = 1 
          scf = notesize 
        else 
          scf = z 
        end 
        textline = line // "  " 

A11:    if textline con "\" 
          if mpt > 1   
            t2 = mpt 
            line2  = textline{1,mpt-1}   
            perform lineout 
            textline = textline{t2..} 
            goto A11 
          end  
          if textline{2} = "\" 
            line2 = "\" 
            perform lineout 
            textline = textline{3..} 
            goto A11 
          end 
&dA 
&dA &d@     This coded added &dA03/05/04&d@ to implement "in-line" space commands 
&dA 
          if "!@#$%^&*(-=" con textline{2}              
            textline = chr(130+mpt) // textline{3..} 
            goto A11 
          end 
&dA 
&dA &d@     This coded added &dA02/02/09&d@ to implement in-line "space" character 
&dA 
          if textline{2} = "+" 
            textline = " " // textline{3..} 
            goto A11 
          end 
&dA   
          if textline{2} = "0" 
            t2 = ors(textline{3}) + 128 
            if chr(t2) in [160,206,212,224] 
            else 
              line2 = chr(t2) 
              perform lineout 
            end 
            textline = textline{4..} 
            goto A11 
          end 
               
          if textline{2} in ['a'..'z','A'..'Z'] 
            d1 = ors(textline{2}) 
            if textline{3} = "1" 
              if "ANOano" con textline{2} 
                t2 = d1 + 140                                 /* 140 = wak(1)
              else 
                if textline{2} in ['A'..'Z'] 
                  t2 = 205 
                else 
                  t2 = 237 
                end 
              end 
              line2 = chr(t2) // textline{2} 
            else 
              if textline{3} = "5" 
                if textline{2} in ['A'..'Z'] 
                  t2 = 211                                    /* 211 = wak(5)(=128) + 83(S)
                else 
                  t2 = 243 
                end 
                line2 = chr(t2) // textline{2} 
              else 
                if textline{3} = "2" 
                  if "CcOos" con textline{2} 
                    if mpt < 3 
                      line2 = chr(d1+156) // textline{2}      /* 156 = wak(2)
                    else 
                      if mpt < 5 
                        line2 = chr(d1+143) // textline{2}    /* 79(O) + 143 = 222  etc.
                      else 
                        line2 = chr(244)                      /* German ss 
                      end 
                    end 
                  else 
                    line2 = textline{2} 
                  end 
                else 
                  if textline{3} = "4" 
                    if "Aa" con textline{2} 
                      line2 = chr(d1+156) // textline{2}      /* 156 = wak(4)
                    else 
                      line2 = textline{2} 
                    end 
                  else 
                    if "7893" con textline{3} 
                      t2 = mpt + 127                          /* wak(3,7,8,9)
                      if ("73" con textline{3} and "Yy" con textline{2}) or "AEIOUaeiou" con textline{2}
                        if textline{2} = "i" 
                          line2 = chr(d1+t2) // chr(238)      /* 238 = dotless i
                        else 
                          line2 = chr(d1+t2) // textline{2} 
                        end 
                      else 
                        line2 = textline{2} 
                      end 
                    else 
                      line2 = "\"              
                      perform lineout 
                      textline = textline{2..} 
                      goto A11 
                    end 
                  end 
                end 
              end 
            end 
            perform lineout 
            textline = textline{4..} 
            goto A11 
          else 
            line2 = "\" 
            perform lineout 
            textline = textline{2..} 
            goto A11 
          end 
        else 
          t2 = len(textline) - 2 
          if t2 > 0 
            line2 = textline{1,t2} 
            perform lineout 
          end 
        end    

        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  8. lineout                                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Send a line of text to output device             ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  line2                                             ³ 
&dA &d@³             z = font number for words                         ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Side effects: value of z   may be changed                  ³ 
&dA &d@³                  value of scf may be changed                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure lineout    
        int t1,t2,t3 
        str textline.300 

AAA111: if line2 con "!" 
          t1 = mpt 
          if t1 > 1 
            if z <> notesize and z <> 1           /* z <> 1 added &dA01/13/04&d@ 
              textline = line2{1,t1-1} 
            else 
              textline = "" 
              loop for t2 = 1 to t1 - 1 
                t3 = ors(line2{t2}) 
                t3 = music_con(t3) 
                textline = textline // chr(t3) 
              repeat 
            end 
            perform stringout (textline) 

            line2 = line2{t1..} 
          end 
          if len(line2) > 1     
            if "0123456789" con line2{2} 
              z = int(line2{2..}) 
              if z = 1                       /* added &dA03/15/04&d@ 
                scf = notesize 
              else 
                scf = z 
              end 

              if sub <= len(line2) 
                line2 = line2{sub..} 
&dA 
&dA &d@       Code added &dA01/17/04&d@ to remove terminator to font designation field 
&dA 
                if line2{1} = "|" 
                  if len(line2) = 1 
                    return 
                  end 
                  line2 = line2{2..} 
                end 
&dA   
                goto AAA111 
              else 
                return 
              end 
            else 
              if z <> notesize and z <> 1         /* z <> 1 added &dA01/13/04&d@ 
                textline = "!"
              else 
                t3 = ors("!") 
                t3 = music_con(t3) 
                textline = chr(t3) 
              end 
              perform stringout (textline) 

              line2 = line2{2..} 
              goto AAA111 
            end 
          end 
        end  
        if z <> notesize and z <> 1               /* z <> 1 added &dA01/13/04&d@ &dIOK
          textline = line2 
        else 
          textline = "" 
          loop for t2 = 1 to len(line2)
            t3 = ors(line2{t2}) 
            t3 = music_con(t3) 
            textline = textline // chr(t3) 
          repeat 
        end 
        perform stringout (textline) 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  9. line_length (xtot)                                      ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Determine the length (in dots) of a line of      ³ 
&dA &d@³              text before it is typeset.                       ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   line = line whose length is to be determined     ³ 
&dA &d@³              z    = font active at time of call               ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure line_length (xtot) 
        str textline.400 
        str ngline2.400 
        int xtot,xinc 
        int tscf 
        int t1,t2,t3 

        xtot = 0 

        if z = 1
          tscf = notesize 
        else 
          tscf = z 
        end 
        textline = line // "   " 
LLL1: 
        if textline con "!" 
          t1 = mpt 
          if t1 > 1 
            ngline2 = textline{1,t1-1} 
            perform lineout_length (ngline2, tscf, xinc) 
            xtot += xinc 
            textline = textline{t1..} 
            goto LLL1 
          end 
          if "0123456789" con textline{2} 
            t1 = int(textline{2..}) 
            t2 = sub 
            if textline{t2} = "|" 
              ++t2 
            end 

            if t1 = 1 
              tscf = notesize 
            else 
              tscf = t1 
            end 

            textline = textline{t2..} 
            goto LLL1 
          end 
          t3 = 33                     /* ! character 
          perform get_xinc (tscf, t3, xinc) 
          xtot += xinc 
          textline = textline{2..} 
          goto LLL1 
        end 
        ngline2 = trm(textline) 
        if ngline2 <> "" 
          perform lineout_length (ngline2, tscf, xinc) 
          xtot += xinc 
        end 
        passback xtot 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 10. lineout_length (thline2, tscf, xtot)                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Determine the length (in dots) of a line of      ³ 
&dA &d@³              text which has no font changes in it             ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   thline2 = line whose length is to be determined  ³ 
&dA &d@³              tscf    = font active at time of call            ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Output:   xtot                                             ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure lineout_length (thline2, tscf, xtot) 
        str thline2.400,out.400 
        int tscf, xtot 
        int xinc 
        int t1,t2,t3 

        getvalue thline2, tscf 

        xtot = 0 
        thline2 = thline2 // "   " 
LLL2: 
        if thline2 con "\" 
          if mpt > 1 
            t1 = mpt 
            out = thline2{1,t1-1} 
            perform string_length (out, tscf, xinc) 
            xtot += xinc 
            thline2 = thline2{t1..} 
            goto LLL2 
          end 
          if thline2{2} = "\" 
            t3 = 92                     /* \ character 
            perform get_xinc (tscf, t3, xinc) 
            xtot += xinc 
            thline2 = thline2{3..} 
            goto LLL2 
          end 
          if "!@#$%^&*(-=" con thline2{2} 
            t1 = mpt 
            if t1 < 10 
              xtot += t1 
            else 
              xtot -= (t1 - 9) 
            end 
            thline2 = thline2{3..} 
            goto LLL2 
          end 
          if thline2{2} = "0" 
            t3 = ors(thline2{3}) + 128 
            if chr(t3) in [160,206,212,224] 
            else 
              perform get_xinc (tscf, t3, xinc) 
              xtot += xinc 
            end 
            thline2 = thline2{4..} 
            goto LLL2 
          end 
          if thline2{2} in ['a'..'z','A'..'Z'] 
            t3 = ors(thline2{2}) 
            if thline2{2,2} = "s2" 
              t3 = 244                                        /* German ss 
              perform get_xinc (tscf, t3, xinc) 
              xtot += xinc 
              thline2 = thline2{4..} 
              goto LLL2 
            else 
              if "12345789" con thline2{3} 
                if ("73" con thline2{3} and "Yy" con thline2{2}) or "AEIOUaeiou" con thline2{2}
                  perform get_xinc (tscf, t3, xinc) 
                  xtot += xinc 
                  thline2 = thline2{4..} 
                  goto LLL2 
                end 
              end 
            end 
          end 
          t3 = 92                     /* \ character 
          perform get_xinc (tscf, t3, xinc) 
          xtot += xinc 
          thline2 = thline2{2..} 
          goto LLL2 
        end 
        out = trm(thline2) 
        if out <> "" 
          perform string_length (out, tscf, xinc) 
          xtot += xinc 
        end 
        passback xtot 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 11. string_length (out, tscf, xtot)                             ³ 
&dA &d@³                                                                   ³ 
&dA &d@³    Purpose:  Determine the length (in dots) of a line of          ³ 
&dA &d@³              text which has no font changes and no "\" character  ³ 
&dA &d@³                                                                   ³ 
&dA &d@³    Inputs:   out   = line whose length is to be determined        ³ 
&dA &d@³              tscf  = font active at time of call                  ³ 
&dA &d@³                                                                   ³ 
&dA &d@³    Output:   xtot                                                 ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure string_length (out, tscf, xtot) 
        str out.500 
        int t1,t2 
        int xinc,xtot,tscf 
        getvalue out, tscf 

        xtot = 0 
        loop for t1 = 1 to len(out) 
          t2 = ors(out{t1}) 
          if tscf = notesize 
            t2 = music_con(t2) 
          end 
          perform get_xinc (tscf, t2, xinc) 
          xtot += xinc 
        repeat 
        passback xtot 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 12. get_xinc (z,kk,xinc)                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Determine the x increment to printing a glyph    ³ 
&dA &d@³              from a particular font.                          ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   z    = font active (not the "real" font)         ³ 
&dA &d@³              kk   = glyph number                              ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Output:   xinc = increment                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Note:  This is not the code contained in pspage.z          ³ 
&dA &d@³           That code is precise; this code is a cluge.         ³ 
&dA &d@³           The difference is that for music glyphs,            ³ 
&dA &d@³           xinc is only an estimate.                           ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure get_xinc (z,kk,xinc) 
        int z,kk,xinc 
        int font 
        int t1

        getvalue z,kk 

        z = revmap(z)              /*   get "real" font number 
        if z < 51                  /*   1,3,4,4,5 -> 51..80 (1..30) + 50 
          z = notesize / 4 * 5     /*   5,15,20,20,25 
          if z > 25 
            z = 25 
          end 
          z += 50 
          kk = 65                  /*   The letter "A" takes space of music note
        end 
        font = z 
        t1 = font - 50                     /* 1 <= t1 <= 90 (text font) 
        t1 = (t1 - 1) * 200 + 1 

        if kk > 128 
          t1 += 100 
          kk -= 128 
        end 
        kk -= 32 
        xinc = ors(fontspac{t1+kk}) 

        passback xinc 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 13. staff (syslength,stv_type)                              ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset staff                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  y          = absolute vertical location           ³ 
&dA &d@³             sp         = starting point of staff lines        ³ 
&dA &d@³             syslength  = length of staff lines                ³ 
&dA &d@³             stv_type   = type of staff   0 = 5-line           ³ 
&dA &d@³                                          1 = single line      ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure staff (syslength,stv_type) 
        int slen,syslength,stv_type 
        int d2 
        getvalue syslength,stv_type 

        if notesize >= 10 
          slen = 64 
        else 
          slen = 32 
        end 
&dA 
&dA &d@     New &dA11/11/05&d@:  Single line stave 
&dA 
        if stv_type = 1 
          y += pvpar(4) 
          d2 = sp + syslength - phpar(1) 
          z = 90 
          loop for x = sp to d2 step phpar(1) 
            perform setmus 
          repeat 
          x = d2 
          perform setmus 
          y -= pvpar(4) 
          return 
        end 
&dA 
&dA       &d@   End of &dA11/11/05&d@ addition 

        if notesize >= 18           /* Added &dA11/18/03&d@ to fill holes in lines &dIOK
          d2 = sp + syslength - slen 
          z = 81 
          loop for x = sp to d2 step slen - 1 
            perform setmus 
            ++x 
          repeat 
          x = d2 
          perform setmus 
        else 
          d2 = sp + syslength - slen 
          z = 81 
          loop for x = sp to d2 step slen 
            perform setmus 
          repeat 
          x = d2 
          perform setmus 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 14. settie (tspan,tpost_x,tpost_y,tpost_leng)               ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset typeset tie                              ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs: x1         = x-object coordinate of first note     ³ 
&dA &d@³            y1         = y-object coordinate of first note     ³ 
&dA &d@³                             (+1000 if on virtual staff)       ³ 
&dA &d@³            tspan      = distance spanned by tie               ³ 
&dA &d@³            sitflag    = situation flag                        ³ 
&dA &d@³            f12        = staff number                          ³ 
&dA &d@³            tpost_x    = post adjustment to left x position    ³ 
&dA &d@³            tpost_y    = post adjustment to y position         ³ 
&dA &d@³            tpost_leng = post adjustment to right x position   ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Internal varibles:  d1 = temporary variable                ³ 
&dA &d@³                        d2 = temporary variable                ³ 
&dA &d@³                        tiechar = first tie character          ³ 
&dA &d@³                        textend = tie extention character      ³ 
&dA &d@³                        hd = horizontal displacement           ³ 
&dA &d@³                        vd = vertical displacement             ³ 
&dA &d@³                        out = output string                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure settie (tspan,tpost_x,tpost_y,tpost_leng) 
        int tpost_x,tpost_y,tpost_leng 
        int d1,d2,d3,d4,d5 
        int virtoff 
        int hd,vd,tiechar,textend,tspan,tcnt 
        label STL(4) 

        getvalue tspan,tpost_x,tpost_y,tpost_leng 
&dA 
&dA &d@ 1) decode y-object coordinate of first note 
&dA 
        virtoff = 0 
        if y1 > 700 
          y1 -= 1000 
          virtoff = vst(f12) 
        end 
&dA 
&dA &d@ 2) complete sitflag  
&dA 

        d5 = phpar(60) 

        d1 = sitflag - 1 & 0x0c >> 2 + 1 
        goto STL(d1) 
STL(1):                     /* tips down, space 
        if y1 < pvpar(2) 
          ++sitflag 
        else 
          if y1 = pvpar(3) and tspan > d5     /* e.g., C5 
            ++sitflag 
          end 
        end 
        goto STLE 
STL(2):                     /* tips down, line 
        if y1 < pvpar(1) 
          ++sitflag 
        else 
          if y1 = pvpar(2) and tspan > d5 
            ++sitflag 
          end 
        end 
        goto STLE 
STL(3):                     /* tips up, space 
        if y1 > pvpar(6) 
          ++sitflag 
        else 
          if y1 = pvpar(7) and tspan > d5 
            ++sitflag 
          end 
        end 
        goto STLE 
STL(4):                     /* tips up, line 
        if y1 > pvpar(5) 
          ++sitflag 
        else 
          if y1 = pvpar(6) and tspan > d5 
            ++sitflag 
          end 
        end 
STLE: 
&dA 
&dA &d@ 3) from sitflag and tspan, get tiechar, hd and vd  
&dA 
        tspan -= tpost_x         
        tspan += tpost_leng      

        if tspan < phpar(61)    /* minimum length depends on notesize 
          if (Debugg & 0x12) > 0 
            pute Error: Tie too short to print 
            pute SETTIE, x1 = ~x1  y1 = ~y1  tspan = ~tspan  sitf = ~sitflag
          end 
          return 
        end  

        d1 = sitflag + 3 / 4
        d3 = rem * 3 + 1
        d2 = ( TIE_DISTS ) 
        if tspan < ( (TIE_DISTS - 1) * phpar(62) + phpar(61) ) 
          d2 = tspan - phpar(61)  
          if phpar(62) = 3 
            ++d2 
          end 
          d2 = d2 / phpar(62) + 1         /* row number for tie parameters 
        end 

        tiechar = tiearr(sizenum,d1,d2,d3)
        hd = tiearr(sizenum,d1,d2,d3+1) 
        vd = tiearr(sizenum,d1,d2,d3+2) 
        if sitflag > 8 
          vd = 0 - vd  
        end  
&dA 
&dA &d@ 4) typeset tie 
&dA &d@    
        x = x1 + hd + sp + tpost_x                         /* modified &dA04/20/03&d@  etc.  &dIOK
        y = y1 - vd + psq(f12) + virtoff 
        if tpost_y < 1000 
          y += tpost_y 
        else 
          tpost_y -= 10000 
          y = y1 + tpost_y + psq(f12) + virtoff 
        end 

        scf = 300
        scx = x 
        scy = y 
        scb = tiechar 
        perform charout 

        d1 = tiechar & 0x7f 
        if d1 = tiearr(sizenum,1,TIE_DISTS,4)  /* staff free general long glyph
          textend = tiechar + 5 
          ++tiechar 
          goto EXT 
        end 
        if d1 = tiearr(sizenum,1,TIE_DISTS,1)  /* staff constrained general long glphy
          textend = tiechar + 1 
          tiechar += 2 
          goto EXT 
        end 

        if d1 > phpar(63)     /* above glyph phpar(63), tie is compound 
          ++tiechar 
          scb = tiechar 
          perform charout 
        end 
        goto EXTa  
*  
EXT:    vd = sitflag - 1 / 8 
        sitflag = rem + 1  
        hd = tspan   
        vd = hd - expar(sitflag) + 32 / 8        /* was + 8 / 8 

        scb = textend 
        loop for tcnt = 1 to vd  
          perform charout 
        repeat 
        vd = hd - expar(sitflag) + 32 / 8        /* was + 16 / 8 
        vd = 40 - rem                            /* was 16 - rem 
        scx -= vd 
        scb = tiechar 
        perform charout 
*  
EXTa:   
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 15. sethyph (level,syshit)                                          ³ 
&dA &d@³                                                                       ³ 
&dA &d@³    Purpose:  Typeset hyphons                                          ³ 
&dA &d@³                                                                       ³ 
&dA &d@³    Inputs: level        = level of text line (usually 1)              ³ 
&dA &d@³            x            = absolute coordinate of terminating syllable ³ 
&dA &d@³            y            = absolute coordinate text line               ³ 
&dA &d@³            backloc(.)   = location first space beyond last syllable   ³ 
&dA &d@³                            or location of first hyphon on next line   ³ 
&dA &d@³            syshit       = value of sysright                           ³ 
&dA &d@³                                                                       ³ 
&dA &d@³    Internal varibles:  a,b,c,d                                        ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure sethyph (level,syshit) 
        int level,syshit 
        int t1,t2,t3,t4                        
        getvalue level,syshit 

        scy = y 
        scf = mtfont 

        t1 = x - backloc(level)              /*  t1 = distance over which to set hyphons
        t2 = 3 * phpar(6)  
        if t1 < t2 
          if t1 >= phpar(17) 
            if backloc(level) = ibackloc(level)      
              scx = backloc(level) 
              scb = ors("-") 
              perform charout 
              if t1 < phpar(6) 
                goto CM  
              end  
            end  
            t2 /= 2 
            if t1 > t2 
              t2 = t1 - phpar(17) + 3 * 2 / 5 
              t1 = t2 + backloc(level) 
              scx = t1 
              scb = ors("-") 
              perform charout 
              t1 += t2 
            else 
              t1 = t1 - phpar(17) + 3 / 2 + backloc(level) 
            end  
            scx = t1 
            scb = ors("-") 
            perform charout 
          else 
            if x = syshit       /* sysright (from i-file) replaces phpar(9) &dA12/31/08
              scx = backloc(level) 
              scb = ors("-") 
              perform charout 
              goto CM  
            end  
          end  
        else 
          if backloc(level) = ibackloc(level)     
            t2 = 2 * t1 / phpar(6) + 1  
            t3 = t1 / t2 
            backloc(level) -= t3 
            t1 += t3 
          end  
          t2 = t1 / phpar(6)  
          t3 = t1 / t2 
          --t2 
          backloc(level) += t3 / 2 
          scx = backloc(level) 
          scb = ors("-") 
          perform charout 
          loop for t4 = 1 to t2 
            backloc(level) += t3 
            scx = backloc(level) 
            scb = ors("-") 
            perform charout 
          repeat 
        end  
CM: 
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 16. setunder (level)                                                 ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Purpose:  Typeset underline                                         ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Inputs: level       = level of text line (usually 1)                ³ 
&dA &d@³            uxstop(.)   = x-coordinate of end of line                   ³ 
&dA &d@³            uxstart(.)  = x-coord. of first space beyond last syllable  ³ 
&dA &d@³                            or location of first hyphon on next line    ³ 
&dA &d@³            y           = y-coordinate for text line                    ³ 
&dA &d@³            underflag   = execution flag, currently set for ties and    ³ 
&dA &d@³                            melismas                                    ³ 
&dA &d@³            xbyte(.)    = ending punctuation                            ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Internal varibles:  a,b,c,d                                         ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setunder (level) 
        int t1,t2,t3,t4                   
        int level 

        getvalue level 

        if underflag = 0 
          return 
        end  
        x = uxstart(level) - phpar(19) 
        scx = x 
        scy = y 
        scf = mtfont 

        t1 = uxstop(level) - uxstart(level)    /*  t1 = distance over which to set hyphons
        if t1 >= phpar(18) 
          y -= pvpar(13) 
          scx = uxstart(level) 
          scy = y 
          scb = ors("_") 
          t2 = uxstop(level) - underspc(sizenum) 
          t4 = underspc(sizenum) 
          loop for t3 = uxstart(level) to t2 step t4 
            perform charout 
          repeat 
          scx = t2     
          perform charout 
          scx += 5 
          scy += pvpar(13) 
        end  
        if underflag = 1 and xbyte(level) <> "_" 
          scb = ors(xbyte(level)) 
          perform charout 
        end  

        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³D* 17. putslur (addcurve)                                                           ³
&dA &d@³                                                                                    ³
&dA &d@³                                                                                    ³
&dA &d@³    Purpose:  Typeset slur                                                          ³
&dA &d@³                                                                                    ³
&dA &d@³    Inputs:   (x1,y1)        = starting note head                                   ³
&dA &d@³              (x2,y2)        = terminating note head                                ³
&dA &d@³              slur_edit_flag = flag indicating that y1 and/or y2 have been altered  ³
&dA &d@³              postx          = horiz. movement of slur after it has been chosen     ³
&dA &d@³              posty          = vert.  movement of slur after it has been chosen     ³
&dA &d@³              addcurve       = flag indicating the curvature should be added        ³
&dA &d@³              sitflag        = situation flag                                       ³
&dA &d@³                                                                                    ³
&dA &d@³                     bit clear            bit set                                   ³
&dA &d@³                   --------------       -------------                               ³
&dA &d@³          bit 0:   full slur            dotted slur                                 ³
&dA &d@³          bit 1:   stock slur           custom slur                                 ³
&dA &d@³          bit 2:   first tip down       first tip up                                ³
&dA &d@³     (*)  bit 3:   second tip down      second tip up                               ³
&dA &d@³     (+)  bit 4:   compute stock slur   hold stock slur                             ³
&dA &d@³                                                                                    ³
&dA &d@³          (*) used on custom slurs only                                             ³
&dA &d@³          (+) used on stock slurs only                                              ³
&dA &d@³                                                                                    ³
&dA &d@³          bit 5:   continuous slur      broken slur                                 ³
&dA &d@³                                                                                    ³
&dA &d@³          bits 8-15:  size of break (0 to 255 dots, centered)                       ³
&dA &d@³                                                                                    ³
&dA &d@³                                                                                    ³
&dA &d@³    Internal variables:  a1,a3,a5,a6,a7,a8,a9,a10,a11,a12                           ³
&dA &d@³                         c1,c2,c3,c4,c5,c6,c7                                       ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure putslur (addcurve) 
        str sbt1.2500 
        str sbt2.2500 
        str temp.600(3) 
        str ptline2.480 

        bstr tbt.2500                  /* added &dA01/26/05&d@ 
        bstr tbt2.2500                 /* added &dA01/26/05&d@ 

        int t1,t2,t3,t4,t5,t6,t7,t8,t9 
        int c1,c2,c3,c4,c5,c6,c7 
        int a1,a3,a5,a6,a7,a8,a9,a10,a11,a12 
        int aa(3),cc(3),dd(3) 
        int save_y1,save_y2 
        int save_x1,save_x2 
        int addcurve 

        getvalue addcurve 

        save_y1 = y1                  /* added &dA01/03/05&d@, etc.  
        save_y2 = y2 
        save_x1 = x1 
        save_x2 = x2 
&dA 
&dA &d@  determine case  
&dA 
        a9 = bit(2,sitflag) 
        a1 = a9 * 2 + 1          /* 1,1,3,3 
        if y1 < y2 
          ++a1                   /* 1,2,3,4 = tips down rising, tips down falling, etc.
        end  
&dA 
&dA &d@  determine method of dealing with slurs   stock vs. custom 
&dA 
        if notesize = 14 
          a5 = 800               /* changed from 801 on &dA9-12-97&d@ 
        end 
        if notesize = 6                    
          a5 = 400               /* changed from 801 on &dA9-12-97&d@ 
        end 
        if notesize = 21 
          a5 = 600               /* changed from 601 on &dA9-12-97&d@ 
        end 

        if notesize = 18 
          a5 = 800 
        end 

        if notesize = 16 
          a5 = 800               
        end 
        if x2 - x1 < a5   /* stock slurs 
SR5:       
          a5 = pvpar(10) + pvpar20 - y1 * 2 + 1 / pvpar(2) - 20 
          a6 = pvpar(10) + pvpar20 - y2 * 2 + 1 / pvpar(2) - 20 
          a7 = abs(a5-a6) 
&dA 
&dA &d@  determine whether to use the parametric method of slur placement 
&dA 
          if a7 < 11 or (x2 - x1 < 100 and slur_edit_flag = 0)    /* protopar file specific

            if a7 > 10 
              a7 -= 10 
              a7 = a7 + 20 * pvpar(2) / 2 - pvpar20 
              if a1 = 1 
                y1 -= a7 
              else 
                if a1 = 2 
                  y2 -= a7 
                else 
                  if a1 = 3 
                    y2 += a7 
                  else              /* a1 = 4 
                    y1 += a7 
                  end 
                end 
              end 
              goto SR5 
            end 
            if a5 < 1 or a6 < 1 
              goto SR1 
            end 
            if a5 > 11 or a6 > 11 
              goto SR2 
            end 
            goto SR3 
*                            adjust parameters upward 
SR1:        a10 = a5 
            a11 = a6 
            if a6 < a5 
              a10 = a6 
              a11 = a5 
            end 
            a10 = 1 - a10        /* minimum amount to raise pars 
            if a7 < 10 
              a12 = a10 / 2 
              if a9 = 0          /* convex slur 
                a10 += rem 
              else 
                if a11 + a10 > 3 
                  a10 += rem 
                end 
              end 
            end 
            a5 += a10 
            a6 += a10 
            goto SR3 
*                              adjust parameters downward
SR2:        a10 = a5 
            a11 = a6 
            if a6 > a5 
              a10 = a6 
              a11 = a5 
            end 
            a10 -= 11            /* minimum amount to lower pars 
            if a7 < 10 
              a12 = a10 / 2 
              if a9 = 1          /* concave slur 
                a10 += rem 
              else 
                if a11 - a10 < 9 
                  a10 += rem 
                end 
              end 
            end 
            a5 -= a10 
            a6 -= a10 
SR3: 
&dA 
&dA &d@  get stock slur number and location  
&dA 
SR4:        a7 = x2 - x1 
            if notesize = 14 or notesize = 18 or notesize = 16   /* Modified (size-16) &dA12/31/08&d@ &dNnot OK
              if a7 < 10 
                --x1 
                ++x2 
                goto SR4 
              end 
            end 
            if notesize = 21      
              if a7 < 15 
                --x1 
                ++x2 
                goto SR4 
              end 
            end 
            if notesize = 6 
              if a7 < 5 
                --x1 
                ++x2 
                goto SR4 
              end 
            end 

            if notesize = 14 or notesize = 18 or notesize = 16   /* Modified (size-16) &dA12/31/08&d@ &dNnot OK
              a7 = x2 - x1 / 2 - 2         /* a7 should be less than 399 
            end 
            if notesize = 21 
              a7 = x2 - x1 + 1 / 3 - 2     /* a7 should be less than 199 
            end 
            if notesize = 6 
              a7 = x2 - x1 - 2             /* a7 should be less than 399 
            end 

            if notesize = 6 
              if a1 < 3 
                temp(1) = slurpar06(a5,a6,1) 
                temp(2) = slurpar06(a5,a6,2) 
                temp(3) = slurpar06(a5,a6,3) 
              else 
                temp(1) = slurpar06(a5,a6,4) 
                temp(2) = slurpar06(a5,a6,5) 
                temp(3) = slurpar06(a5,a6,6) 
              end 
            end 
            if notesize = 14 
              if a1 < 3 
                temp(1) = slurpar14(a5,a6,1) 
                temp(2) = slurpar14(a5,a6,2) 
                temp(3) = slurpar14(a5,a6,3) 
              else 
                temp(1) = slurpar14(a5,a6,4) 
                temp(2) = slurpar14(a5,a6,5) 
                temp(3) = slurpar14(a5,a6,6) 
              end 
            end 
            if notesize = 16 
              if a1 < 3 
                temp(1) = slurpar16(a5,a6,1) 
                temp(2) = slurpar16(a5,a6,2) 
                temp(3) = slurpar16(a5,a6,3) 
              else 
                temp(1) = slurpar16(a5,a6,4) 
                temp(2) = slurpar16(a5,a6,5) 
                temp(3) = slurpar16(a5,a6,6) 
              end 
            end 
            if notesize = 18 
              if a1 < 3 
                temp(1) = slurpar18(a5,a6,1) 
                temp(2) = slurpar18(a5,a6,2) 
                temp(3) = slurpar18(a5,a6,3) 
              else 
                temp(1) = slurpar18(a5,a6,4) 
                temp(2) = slurpar18(a5,a6,5) 
                temp(3) = slurpar18(a5,a6,6) 
              end 
            end 
            if notesize = 21 
              if a1 < 3 
                temp(1) = slurpar21(a5,a6,1) 
                temp(2) = slurpar21(a5,a6,2) 
                temp(3) = slurpar21(a5,a6,3) 
              else 
                temp(1) = slurpar21(a5,a6,4) 
                temp(2) = slurpar21(a5,a6,5) 
                temp(3) = slurpar21(a5,a6,6) 
              end 
            end 
            loop for t5 = 1 to 3 
              cc(t5) = 0 
              dd(t5) = 1 
            repeat 
            loop for t4 = 1 to (a7-2) 
              loop for t5 = 1 to 3 
                t6 = dd(t5) 
                if "zyxwvutsrqponmlkjihgfedcba@ABCDEFGHIJKLMNOPQRSTUVWXYZ" con temp(t5){t6}
                  aa(t5) = mpt - 27 
                  ++t6 
                else 
                  if temp(t5){t6} <> "+" and temp(t5){t6} <> "-" 
                    if (Debugg & 0x12) > 0 
                      pute Slur Coding Error 
                    end 
                  end 
                  if temp(t5){t6} = "+" 
                    t7 = 1 
                  else 
                    t7 = -1 
                  end 
                  ++t6 
                  t8 = 0 
SR6: 
                  if "0123456789" con temp(t5){t6} 
                    --mpt 
                    t8 *= 10 
                    t8 += mpt 
                    ++t6 
                    goto SR6 
                  end 
                  aa(t5) = t8 * t7 
                end 
                cc(t5) += aa(t5) 
                dd(t5) = t6 
              repeat 
            repeat 

            if a1 < 3 
              x1 += cc(1) 
              y1 -= cc(2) 
              a3 =  cc(3) 
            else 
              x1 += cc(1) 
              y1 += cc(2) 
              a3 =  cc(3) 
            end 
            x = x1 + sp 
            y = y1 + psq(f12) 
          else                    /* we don't use parametric method 
            if a1 < 3          /* tips down 
              c1 = y1 / pvpar(2) 
              if y1 > pvpar(1) and rem = 0 
                y1 = (c1 - 1) * pvpar(2) + pvpar(1) 
              end 
              c1 = y2 / pvpar(2) 
              if y2 > pvpar(1) and rem = 0 
                y2 = (c1 - 1) * pvpar(2) + pvpar(1) 
              end 
              a3 = abs(y1 - y2)        /* rise 
              y1 -= pvpar(2) 
            else 
              c1 = y1 / pvpar(2) 
              if y1 < pvpar(8) and rem = 0 
                y1 += pvpar(1)              /* OK 04-24-95 
              end 
              c1 = y2 / pvpar(2) 
              if y2 < pvpar(8) and rem = 0 
                y2 += pvpar(1)              /* OK 04-24-95 
              end 
              a3 = abs(y1 - y2)        /* rise 
              y1 += pvpar(2) 
            end 
            x = x1 + sp + pvpar(2) 
            y = y1 + psq(f12) 
            a7 = x2 - x1 - pvpar(1)        /* length 

            if notesize = 14 or notesize = 18 or notesize = 16   /* Modified (size-16) &dA12/31/08&d@ &dNnot OK
&dA 
&dA &d@      For 14-dot slurs, the distribution of length for stock slurs is a follows
&dA 
&dA &d@            Lengths        Length        Rise       Number 
&dA &d@            in dots      increments   increments   of types (possible)
&dA &d@          ÄÄÄÄÄÄÄÄÄÄ     ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄ 
&dA &d@            8 to 18           2            2           6 
&dA &d@           20 to 196          4            2          12 
&dA &d@          200 to 392          8            2          24 
&dA &d@          400 to 784         16            2          48 
&dA 
              if a7 < 8 
                a7 = 8 
              end 
              if a7 < 20 
                c1 = a7 / 2 
                if rem > 0          /* Fixing error: was &dEif rem > 1&d@  &dA12/18/04&d@ &dIOK
                  ++a7 
                end 
              else 
                if a7 < 200 
                  c1 = a7 / 4 
                  if rem > 1 
                    ++x 
                  end 
                  a7 -= rem 
                else 
                  if a7 < 400 
                    c1 = a7 / 8 
                    x += (rem >> 1) 
                    a7 -= rem 
                  else 
                    c1 = a7 / 16 
                    x += (rem >> 1) 
                    a7 -= rem 
                    if rem > 11 
                      x -= 8 
                      a7 += 16 
                    end 
                    if a7 >= 784 
                      a7 = 784 
                    end 
                  end 
                end 
              end 
&dA 
&dA &d@      For 14-dot slurs, 16-dot slurs and 18-dot slurs,  (Comment modified (size-16) &dA12/31/08&d@) &dNnot OK
&dA 
&dA &d@          Slur number = (rise * 1200) + (length * 3) + type number 
&dA &d@              number ranges from 8 to 143999 
&dA 
              c1 = a3 / 4 
              a3 -= rem 
              if a1 > 2 
                y += rem 
              end 
              a3 = a3 * 1200 + (a7 * 3) + 1 
            end 

            if notesize = 21 
&dA 
&dA &d@      For 21-dot slurs, the distribution of length for stock slurs is a follows
&dA 
&dA &d@            Lengths        Length        Rise       Number 
&dA &d@            in dots      increments   increments   of types (possible)
&dA &d@          ÄÄÄÄÄÄÄÄÄÄ     ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄ 
&dA &d@           12 to 27           3            2           6 
&dA &d@           30 to 294          6            2          12 
&dA &d@          300 to 600         12            2          24 
&dA 
              if a7 < 12 
                a7 = 12 
              end 
              if a7 < 30 
                a7 = a7 + 1 / 3 * 3 
              else 
                if a7 < 300 
                  a7 = a7 + 1 / 6 * 6 
                  rem >>= 1 
                  x += rem 
                else 
                  if a7 < 600 
                    a7 = a7 + 3 / 12 * 12 
                    rem >>= 1 
                    x += rem 
                  else 
                    a7 = 600 
                  end 
                end 
              end 
&dA 
&dA &d@      For 21-dot slurs,
&dA 
&dA &d@          Slur number = (rise * 600) + (length * 2) + type number 
&dA &d@              number ranges from 8 to 143999 
&dA 
              c1 = a3 / 4 
              a3 -= rem 
              if a1 > 2 
                y += rem 
              end 
              a3 = a3 * 600 + (a7 * 2) + 1 
            end 

            if notesize = 6 
&dA 
&dA &d@      For 6-dot slurs, the distribution of length for stock slurs is a follows
&dA 
&dA &d@            Lengths        Length        Rise       Number 
&dA &d@            in dots      increments   increments   of types (possible)
&dA &d@          ÄÄÄÄÄÄÄÄÄÄ     ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄ 
&dA &d@            4 to 9            1            1           6 
&dA &d@           10 to 98           2            1          12 
&dA &d@          100 to 396          4            1          24 
&dA 
              if a7 < 4 
                a7 = 4 
              end 
              if a7 > 9 
                if a7 < 100 
                  c1 = a7 / 2 
                  a7 -= rem 
                else 
                  if a7 < 396 
                    c1 = a7 / 4 
                    x += (rem >> 1) 
                    a7 -= rem 
                  else 
                    a7 = 396 
                  end 
                end 
              end 
&dA 
&dA &d@      For 6-dot slurs, 
&dA 
&dA &d@          Slur number = (rise * 2400) + (length * 6) + type number 
&dA &d@              number ranges from 8 to 143999 
&dA 
              c1 = a3 / 2 
              a3 -= rem 
              y += rem 
              a3 = a3 * 2400 + (a7 * 6) + 1 
            end 
          end 
          x += postx 
          y += posty 
          a3 += addcurve    /* new 6-30-93 

          if notesize = 14 
            if a3 > 120000                       /* max rise = 96 
              goto NOSTOCK 
            end 
          end 
          if notesize = 16 
            if a3 > 120000                       /* max rise = 96 &dA12/31/08&d@ &dNnot OK
              goto NOSTOCK 
            end 
          end 
          if notesize = 18                       /* New (size-18) &dA12/18/04&d@ &dIOK
            if a3 > 115200                       /* max rise = 92 
              goto NOSTOCK 
            end 
          end 
          if notesize = 21 
            if a3 > 70000 
              goto NOSTOCK 
            end 
          end 
&dA 
&dA &d@   a1 = case number   
&dA &d@   a3 = stock slur number   
&dA &d@   x = horizontal position    
&dA &d@   y = vertical position    
&dA 
&dA &d@   Enter new code for acquiring and printing slur 
&dA 
          a5 = 1 
          perform printslur_screen (a1, a3, x, y, a5, sitflag) 
          if a3 = 1000000 
            goto NOSTOCK 
          end 
          return 
        end 

NOSTOCK:                /* long slurs 

        y1 = save_y1                       /* added &dA01/03/05&d@, etc.  
        y2 = save_y2 
        x1 = save_x1 
        x2 = save_x2 

        if a1 < 3          /* tips down 
          c1 = y1 / pvpar(2) 
          if y1 > pvpar(1) and rem = 0 
            y1 = (c1 - 1) * pvpar(2) + pvpar(1) 
          end 
          c1 = y2 / pvpar(2) 
          if y2 > pvpar(1) and rem = 0 
            y2 = (c1 - 1) * pvpar(2) + pvpar(1) 
          end 
          a3 = abs(y1 - y2)        /* rise 
          y1 -= pvpar(2) 
        else 
          c1 = y1 / pvpar(2) 
          if y1 < pvpar(8) and rem = 0 
            y1 += pvpar(1)                /* OK 04-24-95 
          end 
          c1 = y2 / pvpar(2) 
          if y2 < pvpar(8) and rem = 0 
            y2 += pvpar(1)                /* OK 04-24-95 
          end 
          a3 = abs(y1 - y2)        /* rise 
          y1 += pvpar(2) 
        end 
        x = x1 + sp + pvpar(2) + postx 
        y = y1 + psq(f12) + posty 
        a7 = x2 - x1 - pvpar(1)        /* length 

        perform make_longslur (a7,a3,a1)     /* length,rise,smode 
                                             /* return: a7 = offset, a3 = height
        y = y - a7 
&dA 
&dA &d@    Code added &dA01/26/05&d@ to implement dotted slurs in NOSTOCK situation 
&dA &d@      1) Determine a5 = maximum length of slur 
&dA &d@      2) Construct tbt = dotted mask for this slur 
&dA 
        if sitflag = 1 
          a5 = 0 
          loop for t3 = 1 to a3 
            tbt = cbi(longslur(t3)) 
            a6 = bln(tbt) 
            if a6 > a5 
              a5 = a6 
            end 
          repeat 
          if a5 = 0 
            a5 = 100 
          end 
          a6 = a5 / gapsize 
          if bit(0,a6) = 0 
            --a6 
          end 
&dA 
&dA &d@           xxxxxxxxxxx....xxxx....xxxx....xxxx....xxxx....xxxxxxxxxxx 
&dA &d@                  |               odd number                 | 
&dA &d@          a6 = largest odd number of intervals that will fit inside a5   
&dA 
          a6 *= gapsize 
          a7 = a5 - a6 
          a7 >>= 1             /* initial correction 
          tbt = dup("1",a7) // dotted{1,a6} // dup("1",a7+10)   /* mask 
        end 
&dA                  &d@ End of this &dA01/26/05&d@ addition 

        scx = x 
        scy = y 

        c2 = 0 
        loop for t3 = 1 to a3 
&dA 
&dA &d@    Code added &dA01/26/05&d@ to implement dotted slurs in NOSTOCK situation 
&dA 
          if sitflag = 1 
            tbt2 = cbi(longslur(t3))      /* bit equivalent of longslur(t3) 
            tbt2 = bnd(tbt2,tbt)          /* &dEand&d@ this with mask 
            tbt2 = trm(tbt2)              /* and trm to length 
            longslur(t3) = cby(tbt2)      /* put this back in longslur(t3) 
          end 
&dA                  &d@ End of this &dA01/26/05&d@ addition 

          bt(t3) = cbi(longslur(t3)) 
          c1 = bln(bt(t3)) 
          if c1 > c2 
            c2 = c1 
          end 
        repeat 
*  
        ++sst_cnt 
        tput [SST,sst_cnt] Calling longslur at location <~scx ,~scy > 
        ++sst_cnt 
        tput [SST,sst_cnt] : 

        t1 = c2 + 7 / 8 * 8 

        loop for t3 = 1 to a3 
          sbt1 = upk(bt(t3)) 
          sbt1 = sbt1 // pad(t1) 
                         
          sbt2 = "" 
          t4 = 0 
          loop for t5 = 1 to t1 
            if t4 = 0 
              t4 = 0x04 
              if sbt1{t5} = "x" 
                t2 = 0x08 
              else 
                t2 = 0 
              end 
            else 
              if sbt1{t5} = "x" 
                t2 += t4 
              end 
              t4 >>= 1 
              if t4 = 0 
                if t2 < 10 
                  sbt2 = sbt2 // chs(t2) 
                else 
                  sbt2 = sbt2 // chr(55 + t2) 
                end 
              end 
            end 
          repeat 
          ++sst_cnt 
          tput [SST,sst_cnt] ~sbt2 
        repeat 
        ++sst_cnt 
        tput [SST,sst_cnt] : 
&dA 
&dA &d@     display slur contained in bt(a3) 
&dA 
        setb gstr,bt,scx,scy,a3,c2,1,3 
      return 
 
&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 18. puttuplet (a1)                                          ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset tuplet and/or bracket                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of tuplet/bracket ³ 
&dA &d@³              x2 = horizontal stopping point of tuplet/bracket ³ 
&dA &d@³              y1 = vertical starting point                     ³ 
&dA &d@³              y2 = vertical stopping point                     ³ 
&dA &d@³              a1 = tuplet number                               ³ 
&dA &d@³         sitflag = situation flag                              ³ 
&dA &d@³                                                               ³ 
&dA &d@³                         bit clear        bit set              ³ 
&dA &d@³                        ÄÄÄÄÄÄÄÄÄÄÄ      ÄÄÄÄÄÄÄÄÄ             ³ 
&dA &d@³               bit 0    no tuplet        tuplet                ³ 
&dA &d@³               bit 1    no bracket       bracket               ³ 
&dA &d@³               bit 2    tips down        tips up               ³ 
&dA &d@³                                                               ³ 
&dA &d@³               bit 5    broken bracket   continuous bracket    ³ 
&dA &d@³               bit 6    number outside   number inside         ³ 
&dA &d@³               bit 7    square bracket   curved bracket        ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Calling variables to internal procedures:  a1,a4,a5        ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure puttuplet (a1) 
        int xav,yav 
        int t1,t2,t3,t4,t5,savex2 
        int a1,a2,a3,a4,a5,a6 

        getvalue a1 
        savex2 = x2 
        x2 += notesize 
        if bit(1,sitflag) = 1 
          x2 = pvpar(2) / 3 + x2 
        end  
        a4 = x2 - x1 
        a4 = y2 - y1 * 60 / a4 
        xav = x1 + x2 / 2 
        yav = xav - x1 * a4 / 60 + y1  
&dA &d@   xav = x at center of tuplet/bracket 
&dA &d@   a4  = slope * 60 
&dA &d@   yav = y at center of tuplet/bracket 
&dA 
&dA &d@   Part I: tuplet present 
&dA 
        if bit(0,sitflag) = 1 
          x = xav 
          y = yav + psq(f12)   
          a3 = x - phpar(45) + (notesize / 3) 
          a6 = x + phpar(45) - (notesize / 7) 
          x = 0 - phpar(45) / 2 + x + sp  
&dA 
&dA &d@   New code (12/01/94) to deal with complex tuples 
&dA 
          t4 = a1 
          t1 = t4 / 1000 
          t2 = rem 

          if t1 > 0 
            t3 = 2 
            if t2 > 9 
              ++t3 
            end 
            if t1 > 9 
              ++t3 
            end 
            t4 = phpar(45) * t3 + 1 >> 1 
            x -= t4                /* create space for colon + double digits 
            a3 -= t4 
            a6 += t4 
          else 
            t3 = 0 
            if t2 > 9 
              ++t3 
            end 
            t4 = phpar(45) * t3 + 1 >> 1 
            x -= t4                /* create space for double digits 
            a3 -= t4 
            a6 += t4 
          end 

          if bit(1,sitflag) = 1             /* bracket present 
            if bit(7,sitflag) = 1             /* curved bracket 
              if bit(2,sitflag) = 0             /* tips down 
                y -= (pvpar(1) + 1 / 2) 
              else                              /* tips up 
                y += (pvpar(1) + 1 / 2) 
              end 
              if bit(5,sitflag) = 0             /* broken bracket 
                y -= (pvpar(3) >> 2) 
              end 
            end 
&dA 
&dA &d@                 &dA03/15/97&d@ numbers below or above  &dIOK&d@ 
&dA 
            if bit(5,sitflag) = 1             /* continuous bracket 
              if bit(7,sitflag) = 1             /* curved bracket 
                if bit(6,sitflag) = 0             /* number outside 
                  if bit(2,sitflag) = 1             /* tips up 
                    y += pvpar(2) 
                  else                              /* tips down 
                    y -= (pvpar(5) + 1 / 2) 
                  end 
                else                              /* number inside 
                  if bit(2,sitflag) = 1             /* tips up 
                    y -= pvpar(3) 
                  else                              /* tips down 
                    y += (pvpar(5) + 1 / 2) 
                  end 
                end 
              else                              /* square bracket 
                if bit(6,sitflag) = 0             /* number outside 
                  if bit(2,sitflag) = 1             /* tips up 
                    y += pvpar(3) 
                  else                              /* tips down 
                    y -= pvpar(2) 
                  end 
                else                              /* number inside 
                  if bit(2,sitflag) = 1             /* tips up 
                    y -= pvpar(2) 
                  else                              /* tips down 
                    y += pvpar(3) 
                  end 
                end 
              end 
              a3 = xav + 2                  /* eliminate space in bracket line
              a6 = xav - 2 
            end 
          end 
          scx = x 
          scy = y 
&dA 
&dA &d@     Put out numerator of tuple 
&dA 
          t3 = t2 / 10 
          t2 = rem 
          if t3 > 0 
            scb = t3 + 221 
            perform charout 
          end 
          scb = t2 + 221 
          perform charout 
&dA 
&dA &d@     Put out denominator of tuple (if present) 
&dA 
          if t1 > 0 
            scb = 249           /* colon 
            perform charout 
            t3 = t1 / 10 
            t1 = rem 
            if t3 > 0 
              scb = t3 + 221 
              perform charout 
            end 
            scb = t1 + 221 
            perform charout 
          end 

        end  
&dA 
&dA &d@   Part II: bracket present 
&dA 
        if bit(1,sitflag) = 1               /* bracket present 
&dA 
&dA &d@     Square brackets 
&dA 
          if bit(7,sitflag) = 0               /* square bracket 
&dA 
&dA &d@   1) compute slope 
&dA 
            a5 = abs(a4) 
            a5 = a5 + 3 / 5 
            if a5 > 6 
              a5 = 6 
            end 
            if a5 = 5 
              a5 = 4 
            end 
            if a5 = 6 
              a5 = 5 
            end 
            if a4 > 0 
              a4 = a5 
            else 
              a4 = 0 - a5 
            end 
            yav -= pvpar(40) 
&dA 
&dA &d@   2) case 1: broken bracket 
&dA 
            if bit(5,sitflag) = 0        
              a1 = a3 - x1 + 2 / 3 * 3 
              x1 = a3 - a1 
              a2 = 6 
              if a4 < 0 
                a2 = -6 
              end 
              y1 = x1 - xav * a4 + 6 / 12 + yav 
              x = x1 + sp 
              y = y1 + psq(f12) 
              perform brackethook 
              perform bracketline (a1,a4,a5) 
              a1 = x2 - a6 + 2 / 3 * 3 
              y1 = a6 - x1 * a4 + a2 / 12 + y1 
              x1 = a6 
              perform bracketline (a1,a4,a5) 
              perform brackethook 
            else 
&dA 
&dA &d@   3) case 2: continuous bracket 
&dA 
              a1 = x2 - x1 + 2 / 3 * 3 
              x1 = 0 - a1 - 1 / 2 + xav 
              y1 = x1 - xav * a4 + 6 / 12 + yav 
              x = x1 + sp 
              y = y1 + psq(f12) 
              perform brackethook 
              perform bracketline (a1,a4,a5) 
              perform brackethook 
            end 
          else 
&dA 
&dA &d@      Curved brackets (slurs)      /* &dA03/15/97&d@  &dIOK&d@ 
&dA 
&dA &d@     Inputs:   (x1,y1)        = starting note head 
&dA &d@               (x2,y2)        = terminating note head 
&dA &d@               slur_edit_flag = flag indicating that y1 and/or y2 have been altered
&dA &d@               postx          = horiz. movement of slur after it has been chosen
&dA &d@               posty          = vert.  movement of slur after it has been chosen
&dA &d@               addcurve (t5)  = flag indicating the curvature should be added 
&dA &d@               sitflag        = situation flag 
&dA &d@  
&dA &d@                      bit clear            bit set 
&dA &d@                    --------------       ------------- 
&dA &d@           bit 0:   full slur            dotted slur 
&dA &d@           bit 1:   stock slur           custom slur 
&dA &d@           bit 2:   first tip down       first tip up  
&dA &d@      (*)  bit 3:   second tip down      second tip up     
&dA &d@      (+)  bit 4:   compute stock slur   hold stock slur 
&dA &d@          
&dA &d@           (*) used on custom slurs only  
&dA &d@           (+) used on stock slurs only 
&dA 
&dA &d@           bit 5:   continuous slur      broken slur             /* &dA03/15/97&d@  &dIOK
&dA &d@    
&dA &d@           bits 8-15:  size of break (0 to 255 dots, centered) 
&dA &d@    
            t1 = sitflag 
            x2 = savex2               /* restore x2 to original 
            if bit(2,t1) = 1          /* tips up 
              sitflag = 12 
              posty = 0 - pvpar(5)     /* reason: y1 and y2 were supplied as endpoints
            else                      /* for square brackets, not the notes themselves
              sitflag = 0             /* this code is a cludge to correct for this
              posty = pvpar(5) / 2     /* approximately.  Rigorous solution would be
            end                       /* to set through the original oby's 
            slur_edit_flag = 1 
            postx = 0 
            t5 = 0 

            if bit(5,t1) = 0          /* broken slur 
              t2 = a6 - a3 << 8 + 0x20 
              sitflag += t2 
            end 
            perform putslur (t5) 
          end 
        end  
      return 
*  
&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 18a. brackethook                                            ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset vertical hook for bracket                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure brackethook  
        if bit(2,sitflag) = 1 
          y = y - notesize + 2 
        end  
        scx = x 
        scy = y 
        scb = 89 
        perform charout 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 19. bracketline (t1,t2,t3)                                  ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  typeset bracket line                             ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   t1 = length                                      ³ 
&dA &d@³              t2 = slope                                       ³ 
&dA &d@³              t3 = slope type  0,1,2,3,4,5                     ³ 
&dA &d@³              x1 = x starting point                            ³ 
&dA &d@³              y1 = y starting point                            ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Outputs:  x = x coordinate of end of line                  ³ 
&dA &d@³              y = y coordinate of end of line                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure bracketline (t1,t2,t3) 
        int a1,a2,a3 
        int t1,t2,t3 

        getvalue t1,t2,t3 
        if t1 = 0  
          return 
        end  
        x = x1 + sp  
        y = y1 + psq(f12)   
        scx = x 
        scy = y 
        scf = 400 

        if t2 > 0  
          z = 184 + t3   
        end  
        if t2 < 0  
          z = 164 + t3   
        end  
        if t2 = 0  
          z = 161  
        end  
        a1 = t1 / 12 
        a3 = rem 
        if t2 = 0 
          loop for a2 = 1 to a1 
            x += 12 
            scb = z 
            perform charout 
          repeat 
        else 
          loop for a2 = 1 to a1 
            scb = z 
            perform charout 
            if t2 > 0 
              scy += t2 
            else 
              a1 = 0 - t2 
              scy -= a1 
            end 
            x += 12 
            y += t2 
          repeat 
        end 
        if a3 > 0 
          if a3 = 9 
            if t2 < 0  
              a1 = t2 - 1 * 2 / 3 
              z += 5 
            end  
            if t2 > 0  
              a1 = t2 + 1 * 2 / 3 
              z += 5 
            end  
            if t2 = 0  
              a1 = 0 
              ++z
            end  
          end  
          if a3 = 6 
            if t2 < 0  
              a1 = t2 - 1 / 2 
              z += 10 
            end  
            if t2 > 0  
              a1 = t2 + 1 / 2 
              z += 10 
            end  
            if t2 = 0  
              a1 = 0 
              z += 2 
            end  
          end  
          if a3 = 3 
            if t2 < 0  
              a1 = t2 - 1 / 3 
              z += 15 
            end  
            if t2 > 0  
              a1 = t2 + 1 / 3 
              z += 15 
            end  
            if t2 = 0  
              a1 = 0 
              z += 3 
            end  
          end  
          scb = z 
          perform charout 
          x += a3 
          y += a1 
        end  
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 20. putwedge (t1,t2)                                        ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset wedge                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of wedge          ³ 
&dA &d@³              x2 = horizontal stopping point of wedge          ³ 
&dA &d@³              y1 = vertical starting point                     ³ 
&dA &d@³              y2 = vertical stopping point                     ³ 
&dA &d@³              t1 = starting spread of wedge                    ³ 
&dA &d@³              t2 = stopping spread of wedge                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putwedge (t1,t2) 
        int t1,t2,t3 
        int leng,slope,z1,clen,fullcnt 
        int nex

        getvalue t1,t2 
        y1 -= pvpar(1) 
        y2 -= pvpar(1) 
        leng = x2 - x1   
        x = x1 + sp  

        scx = x 
        scf = 400 
*   compute slope  
        slope = t2 - t1 * 240 / leng 
        slope = abs(slope) 
        if slope < 8 
          slope = 8 
        end  
        if t2 > t1 
          slope = slope + 2 / 4 
        else 
          slope = slope + 3 / 4 
        end  
        if slope > 20 
          slope = 20 
        end  
        z1 = slope 
        if t2 < t1 
          slope = 0 - slope 
        end  
*   compute character  
        if z1 > 12 
          z1 = z1 - 13 / 2 + 13  
        end  
*   compute length of character  
        if z1 < 11 
          clen = 120 / z1 
        else 
          clen = 128 / z1 
        end  
*   compute number of full characters  
        fullcnt = leng / clen 
*   compute extension set  
        nex = 0 
        t3 = rem - 30 
        if t3 > 0 
          ++nex 
          tarr(nex) = 74 
          rem = t3 
        end  
        t3 = rem - 20 
        if t3 > 0 
          ++nex 
          tarr(nex) = 75 
          rem = t3 
        end  
        t3 = rem - 10 
        if t3 > 0 
          ++nex 
          tarr(nex) = 78 
          rem = t3 
        end  
        if rem > 0 
          ++nex 
          tarr(nex) = 88 - rem 
        end  
*   write out wedge . . .  
        if slope > 0                    /* cresc.  
          t3 = t1 / 2 
          y2 += t3 
          y1 -= t3 
          z = z1 + 31  
*   -- top 
          y = y1 + psq(f12)   
          loop for t3 = 1 to fullcnt 
            scy = y 
            scb = z 
            perform charout 
            --y
          repeat 
          loop for t3 = 1 to nex 
            z = tarr(t3) 
            scy = y 
            scb = z 
            perform charout 
          repeat 
*   -- bottom  
          scx = x 
          z = z1 + 51  
          y = y2 + psq(f12)   
          loop for t3 = 1 to fullcnt 
            scy = y 
            scb = z 
            perform charout 
            ++y
          repeat 
          loop for t3 = 1 to nex 
            z = tarr(t3) 
            scy = y 
            scb = z 
            perform charout 
          repeat 
        else                            /* decresc.  
          t3 = t2 / 2 
          y1 = y1 - t3 - fullcnt 
          y2 = y2 + t3 + fullcnt 
*   -- top 
          y = y1 + psq(f12)   
          loop for t3 = 1 to nex 
            z = tarr(t3) 
            scy = y 
            scb = z 
            perform charout 
          repeat 
          z = z1 + 51  
          loop for t3 = 1 to fullcnt 
            scy = y 
            scb = z 
            perform charout 
            ++y
          repeat 
          scx = x 
*   -- bottom  
          y = y2 + psq(f12)   
          loop for t3 = 1 to nex 
            z = tarr(t3) 
            scy = y 
            scb = z 
            perform charout 
          repeat 
          z = z1 + 31  
          loop for t3 = 1 to fullcnt 
            scy = y 
            scb = z 
            perform charout 
            --y 
          repeat 
        end  
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 21. putfigcon (t3)                                                   ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Purpose:  Typeset figure continuation line                          ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of line                    ³ 
&dA &d@³              x2 = horizontal stopping point of line                    ³ 
&dA &d@³              t3 = vertical level of line                               ³ 
&dA &d@³              y1 = additional vertical displacement from default height ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putfigcon (t3) 
        int t1,t3 

        getvalue t3 
        x = x1 + sp  
        --t3 
&dA 
&dA &d@    New code &dA11/06/03&d@ adding figoff(.) and y1 
&dA 
        y = pvpar(37) * t3 + pvpar(36) + psq(f12) + figoff(f12) + y1 
        scx = x 
        scy = y 
        t1 = x2 - phpar(44) 
        scb = 220 
        loop while x1 <= t1 
          perform charout 
          x1 += phpar(44) 
        repeat 
        x = t1 + sp 
        scx = x 
        perform charout 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 22. puttrans (t1,t2)                                        ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset octave transposition                     ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of transposition  ³ 
&dA &d@³              x2 = horizontal stopping point of transposition  ³ 
&dA &d@³              y1 = vertical level of transposition             ³ 
&dA &d@³              t1 = length of ending hook                       ³ 
&dA &d@³              t2 = situation, 0 = 8av up, 1 = 8av down         ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure puttrans (t1,t2) 
        int a1,a2,a3 
        int t1,t2 

        getvalue t1,t2 
        x = x1 + sp  
        y = y1 + psq(f12)   
        scx = x 
        scy = y 
        scb = 233 
        perform charout 
        x += phpar(42) 
        scx = x 
        x1 += phpar(42) 
        a2 = x2 - (phpar(43) >> 1) 
        a3 = 0 
        scb = 91 
        loop while x1 <= a2 
          a3 = 1 
          perform charout 
          x1 += phpar(43) 
        repeat 
        a1 = phpar(43) >> 1 
        x1 -= a1 
        if a3 = 1 
          if x1 <= a2 
            scx -= a1 
            perform charout 
          end  
          if t1 > 0  
            a2 = phpar(43) >> 2      
            scx -= a2 
            if t1 < notesize 
              t1 = notesize 
            end 
            if t2 = 1 
              a3 = t1 - 2 
              scy -= a3 
            end  
            loop while t1 > notesize 
              scb = 89 
              perform charout 
              scy += notesize 
              t1 -= notesize 
            repeat 
            a3 = notesize - t1 
            scy -= a3 
            scb = 89 
            perform charout 
          end  
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 23. putending (t1,t2,t3)                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset ending                                   ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of ending         ³ 
&dA &d@³              x2 = horizontal stopping point of ending         ³ 
&dA &d@³              y1 = vertical level of ending                    ³ 
&dA &d@³              t1 = length of start hook                        ³ 
&dA &d@³              t2 = length of ending hook                       ³ 
&dA &d@³              t3 = ending number, 0 = none                     ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putending (t1,t2,t3) 
        int a1,a2 
        int t1,t2,t3 

        getvalue t1,t2,t3 
        if f12 > 1 
          if t3 > 9                       /* New condition &dA04/25/09&d@ 
            t3 -= 10 
          else 
            return 
          end 
        end  
        x = x1 + sp  
        y = y1 + psq(f12)   
        scx = x 
        scy = y 
        if t1 > 0  
          if t1 < notesize 
            t1 = notesize 
          end 
          loop while t1 > notesize 
            scb = 89 
            perform charout 
            scy += notesize 
            t1 -= notesize 
          repeat 
          a2 = notesize - t1 
          scy -= a2 
          scb = 89 
          perform charout 
        end  
        if t3 > 0  
          scx = x + pvpar(1) 
          scy = y + pvpar(4) 
          scf = mtfont 
          out = chs(t3) 
          perform stringout (out) 
          scb = 46 
          perform charout 
          scf = notesize 
        end  
        scx = x 
        scy = y 
        a1 = x2 - phpar(1) 
        scb = 90 
        loop while x1 <= a1 
          perform charout 
          x1 += phpar(1) 
        repeat 
        x = a1 + sp 
        scx = x 
        perform charout 
        if t2 > 0  
          if t2 < notesize 
            t2 = notesize 
          end 
          loop while t2 > notesize 
            scb = 89 
            perform charout 
            scy += notesize 
            t2 -= notesize 
          repeat 
          a2 = notesize - t2 
          scy -= a2 
          scb = 89 
          perform charout 
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 24. putdashes (t1,t2)                                       ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset dashes                                   ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of dashes         ³ 
&dA &d@³              x2 = horizontal stopping point of dashes         ³ 
&dA &d@³              y1 = vertical level of dashes                    ³ 
&dA &d@³              t1 = spacing parameter                           ³ 
&dA &d@³              t2 = font designator                             ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putdashes (t1,t2) 
        int t1,t2 
        int a1,a2,a3,a4,a5 

        getvalue t1,t2 
        a2 = x2 - x1 
        if a2 < 0 
          return 
        end 
        x = x1 + sp + hyphspc(sizenum) 
        y = y1 + psq(f12)   

        scf = t2 
        scx = x 
        scy = y 
        scb = 173 
        perform charout 
        if t1 = 0  
          a1 = hyphspc(sizenum) * 5 
          a3 = a2 / a1 
          if a3 = 0 
            t1 = x2 - x1 
            a3 = 2 
          else 
            if rem > hyphspc(sizenum) * 2 
              ++a3 
            end 
            t1 = a2 / a3              
          end 
          a4 = 1 
        else 
          a1 = t1              
          a3 = a2 / a1 
          a4 = 0 
        end  

        loop for a5 = 1 to a3 - 1 
          x += t1 
          scx = x 
          perform charout 
          if a4 = 1 
            a2 -= t1 
            --a3 
            if a3 > 0 
              t1 = a2 / a3 
            end 
          end 
        repeat 
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 25. puttrill (t1)                                           ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset long trill                               ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of trill          ³ 
&dA &d@³              x2 = horizontal stopping point of trill          ³ 
&dA &d@³              y1 = vertical level of trill                     ³ 
&dA &d@³              t1 = situation  1 = no trill                     ³ 
&dA &d@³                              2 = trill with no accidental     ³ 
&dA &d@³                              3 = trill with sharp             ³ 
&dA &d@³                              4 = trill with natural           ³ 
&dA &d@³                              5 = trill with flat              ³ 
&dA &d@³                              6 = trill with sharp following   ³ 
&dA &d@³                              7 = trill with natural following ³ 
&dA &d@³                              8 = trill with flat following    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure puttrill (t1) 
        int hh,k1                                      /* k1 is new &dA11/05/05
        int t1 

        getvalue t1 
        x = x1 + sp  
        y = y1 + psq(f12)   
        k1 = x1                 /* localize x1            /* New &dA11/05/05&d@ 
        hh  = k1                                          /* New &dA11/05/05&d@ 
        scx = x 
        scy = y 
        if t1 > 1 
          if t1 > 2 and t1 < 6 
            scb = int("..389"{t1}) + 210     /* music font 
            scy = y - pvpar(45) 
            perform charout 
            scy = y 
          end 
          x += phpar(41) 
          scb = 236 
          perform charout 
          scx = x 
&dA 
&dA &d@      New code added to implement accidentals following a trill sign  &dA11/05/05
&dA 
          if t1 > 5 and t1 < 9 
            x -= pvpar(1) 

            k1 += pvpar(2) 
            scx = x         
            scy = y - pvpar(2) 
            scb = t1 + 185                   /* music font (cue size) 
            perform charout 
            x += pvpar(3)                      
            scx = x 
            scy = y 
          end 
&dA 
&dA        &d@    End of &dA11/05/05&d@ New Code 

          hh = k1 + phpar(41)                              /* k1 replaces x1  &dA11/05/05
        end  
        scb = 237 
        loop while hh < x2 
          perform charout 
          hh += phpar(40) 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 26. sysline                                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset left-hand system line                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   f11 = number of parts                            ³ 
&dA &d@³              psq(1) = y coordinate of first part              ³ 
&dA &d@³              psq(f11) = y coordinate of last part             ³ 
&dA &d@³              sp = x-coordinate of beginning of line           ³ 
&dA &d@³              syscode = format for brace/bracket               ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure sysline  
        int a1,a2,a3,a4,a5,a6,a7 
        int a8,a9,a10,a11,a12             /* added &dA03/11/06&d@ 

        if syscode = ""  
          return 
        end  
&dA 
&dA &d@  1. typeset left-hand bar  
&dA 
        x = sp 
        z = 82 
        y1 = psq(1) 
&dA 
&dA &d@     Adding code &dA11/13/03&d@ to deal with mixed staff sizes &dIOK&d@ 
&dA 
        a4 = notesize 
        a3 = nsz(f11)                /* notesize of staff for this termination
        a5 = a4 - a3 * 4             /* length correction 
        if notesize <> a3 
          notesize = a3              /* set font size for computing pvpar(44)
          perform ps_init_par 
        end 
        y2 = psq(f11) + pvpar(44)      /* line thickness added &dA04-25-95&d@ 
        y2 -= a5 

        if notesize <> a4 
          notesize = a4              /* return to original font size 
          perform ps_init_par 
        end 
&dA   
        brkcnt = 0 
        if f11 > 1 or vst(1) > 0 
          perform putbar (f11)
        end 
&dA 
&dA &d@  2. typeset braces 
&dA 
        a2 = 0 
        loop for a1 = 1 to len(syscode)  
          if syscode{a1} = "[" 
            x = sp - phpar(46)  
            y1 = psq(a2+1)  
          end  
          if syscode{a1} = "]" 
            y2 = psq(a2) 
&dA 
&dA &d@     Adding code &dA11/13/03&d@ to deal with mixed staff sizes  &dIOK&d@ 
&dA 
            a4 = notesize 
            a3 = nsz(a2)             /* notesize of staff for this termination
            a5 = a4 - a3 * 4         /* length correction 
            y2 -= a5 
&dA   
            z = 84 
            brkcnt = 0 
            perform putbar (a2)
            y = y1 
            z = 87 
            perform setmus 
            y = y2 + pvpar(8) + vst(a2) 
            z = 88 
            perform setmus 
          end  
          if ".:,;" con syscode{a1}            /* changed &dA11/13/03&d@  &dIOK&d@ 
            ++a2
          end  
        repeat 
&dA 
&dA &d@  3. typeset brackets 
&dA 
        x1 = x - phpar(47)
        a2 = 0 
        loop for a1 = 1 to len(syscode)  
          if syscode{a1} = "{" 
            y1 = psq(a2+1)  
          end  
          if syscode{a1} = "}" 
            x = x1 
            y2 = psq(a2) + pvpar(8) + vst(a2) 
&dA 
&dA &d@     Adding code &dA11/13/03&d@ to deal with mixed staff sizes  &dIOK&d@ 
&dA 
            a4 = notesize 
            a3 = nsz(a2)             /* notesize of staff for this termination
            a5 = a4 - a3 * 4         /* length correction 
            y2 -= a5 
&dA   
            if notesize < 10 
              a7  = 66 
              a8  = 100 
              a9  = 3 
              a10 = 6 
              a11 = 96 
            else 
              a7  = 132 
              a8  = 201 
              a9  = 6 
              a10 = 12 
              a11 = 192 
            end 
            a3 = y2 - y1   
&dA 
&dA &d@      There are three cases:         a3 <= 201 (one glyph)    granularity = 6 
&dA &d@                              202 <= a3 <= 402 (two glyphs)   granularity = 12
&dA &d@                              403 <= a3 <= 570 (three glyphs) granularity = 12
&dA 
            if a3 <= a8                     /*                 New &dA03/11/06&d@ 
              a4 = a3 + 2 / a9 * a9         /* actual length   New &dA03/11/06&d@ 
              a5 = a4 - a3 / 2              /* delta / 2 
              y  = y1 - a5                  /* corrected value of y 
              a5 = a4 / a9 + 20             /* font number     New &dA03/11/06&d@ 
              scx = x 
              scy = y 
              scb = a5 
              if scb < 33 
                if (Debugg & 0x12) > 0 
#if DMUSE 
                  putc &dAWARNING&d@: You are trying to typeset a bracket which is too short.
                  putc          This is sometimes the result of a faulty system code.
                  putc          If other problems occur as well, check system code first.
#else 
                  pute WARNING: You are trying to typeset a bracket which is too short.
                  pute          This is sometimes the result of a faulty system code.
                  pute          If other problems occur as well, check system code first.
#endif 
                end 
                scb = 33 
              end 

              scf = 320 
              perform charout 
              scf = notesize 
            else 
              if a3 <= (a8 * 2)             /*                 New &dA03/11/06&d@ 
                a4 = a3 + 5 / a10 * a10     /* actual length   New &dA03/11/06&d@ 
                a5 = a4 - a3 / 2            /* delta / 2 
                y  = y1 - a5                /* corrected value of y 
                a5 = a4 / a10 + 10 * 2      /* font number     New &dA03/11/06&d@ 
                a6 = a4 / 2                 /* y increment to second glyph 
                scx = x 
                scy = y 
                scb = a5 
                scf = 320 
                perform charout 
                scy += a6 
                ++scb 
                perform charout 
                scf = notesize       
              else 
                a4 = a3 + 5 / a10 * a10     /* actual length   New &dA03/11/06&d@ 
                a5 = a4 - a3 / 2            /* delta / 2 
                y  = y1 - a5                /* corrected value of y 
                a5 = a4 / a10 - 5 * 3 + 1   /* font number     New &dA03/11/06&d@ 
                a6 = a4 - (a11 * 2)         /* y increment to third glyph    New &dA03/11/06
                scx = x 
                scy = y 
&dA 
&dA &d@           New code &dA01/31/10&d@ to enable display of extra-tall brackets.  
&dA &d@             Code uses new glyph 124 in the bracket font.  
&dA 
                if a5 > 121 
                  a5 = 115 
                   
                  scb = 115 
                  scf = 320 
                  perform charout                          /*  New &dA03/11/06&d@ 
                  scy += a11 
                  a12 = scy + (a6 - a7 / 2 )
                  scb = 124 
                  loop 
                    perform charout 
                    scy += 6 
                  repeat while scy < a12 
                  scy = a12 
                  scb = 116 
                  perform charout 
                  a12 = scy + a6 - (a6 - a7 / 2 ) 
                  scb = 124 
                  scy += a7 
                  loop 
                    perform charout 
                    scy += 6 
                  repeat while scy < a12 
                  scy = a12 
                  scb = 117 
                  perform charout 
                  scf = notesize 
               else 
                  scb = a5 
                  scf = 320 
                  perform charout 
                  scy += a11                               /*  New &dA03/11/06&d@ 
                  ++scb 
                  perform charout 
                  scy += a6 
                  ++scb 
                  perform charout 
                  scf = notesize 
                end 
              end 
            end 
          end  
          if ".:,;" con syscode{a1}            
            ++a2
          end  
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 27. putbar (t1)                                             ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset bar line                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   t1 = staff number of last line                   ³ 
&dA &d@³              y1 = coordinate of top of line                   ³ 
&dA &d@³              y2 = coordinate of last bar character            ³ 
&dA &d@³              brkcnt = number of breaks in bar                 ³ 
&dA &d@³              barbreak(.,1) = y coordinate of top of break     ³ 
&dA &d@³              barbreak(.,2) = y coordinage of bottom of break  ³ 
&dA &d@³              x = x-coordinat of line                          ³ 
&dA &d@³              z = font character                               ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putbar (t1)
        int t1,t2 
        int c1,c3,c4 
        getvalue t1

        if brkcnt = 0  
          t2 = y2 + vst(t1) 
          loop for y = y1 to t2 step pvpar(8) 
            perform setmus 
          repeat 
          y = t2 
          perform setmus 
          return 
        end  
        c3 = y1  
        loop for c1 = 1 to brkcnt  
          c4 = barbreak(c1,1) - pvpar(8)  
          if c4 > c3 
            if c4 < y2   
              loop for y = c3 to c4 step pvpar(8) 
                perform setmus 
              repeat 
              y = c4 
              perform setmus 
              c3 = barbreak(c1,2)  
            end  
          end  
        repeat 
        c4 = y2 + vst(t1) 
        if c4 >= c3  
          loop for y = c3 to c4 step pvpar(8) 
            perform setmus 
          repeat 
          y = c4 
          perform setmus 
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 28. printslur_screen (ori,snum,x,y,mode,sitflag)            ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose: read slur data from bigslur, compile and          ³ 
&dA &d@³                send slur to screen                            ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Input:  ori    case: 1,2,3 or 4                             ³ 
&dA &d@³           snum   slur number                                  ³ 
&dA &d@³           x      x location                                   ³ 
&dA &d@³           y      y location                                   ³ 
&dA &d@³           mode   1 = display, 0 = clear (cancel)              ³ 
&dA &d@³        sitflag   situation flag                               ³ 
&dA &d@³                                                               ³ 
&dA &d@³          bit 5:   continuous slur      broken slur            ³ 
&dA &d@³                                                               ³ 
&dA &d@³          bits 8-15:  size of break (0 to 255 dots, centered)  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure printslur_screen (ori,snum,x,y,mode,sitflag) 
        str pfile.100,pointer.6,data.500
&dA &d@       bstr bt.2500(250)                  &dAThis is now global&d@ 
        int snum,ori 
        int offset,datalen,nrows 
        int slen,srise 
        int bulge 
        int t1,t2 
        int x,y,maxn 
        int dpnt,sdpnt 
        int code,cnt,ndata(2),kdata(2) 
        int mode,sitflag 
        int broksize                                /* &dA03/15/97&d@  &dIOK&d@ 
        real rx 
        int scx2                                    /* added &dA11/29/09&d@ 

        str sbt.800
* 
        getvalue ori,snum,x,y,mode,sitflag 
        if bit(5,sitflag) = 1                       /* &dA03/15/97&d@  &dIOK&d@ 
          broksize = sitflag >> 8 
        else 
          broksize = 0 
        end 
        sitflag &= 0x01 

        if snum < 24 or snum >= 144000 
          snum = 1000000 
          passback snum 
          return 
        end 

        perform construct_bigslur_element (ori,notesize,snum,srise,nrows,slen,bulge)
        maxn = slen 

        if bulge > 127                 /* added &dA01/03/05&d@ 
          bulge = 0 
        end 

        slen += bulge                  /* added &dA11-19-92&d@ 
        if bulge > 0 
          x -= bulge 
        end 

        t1 = 0                         /* look for vert shift 
        if ori = 1
          t1 = nrows - 1
        else 
          if ori = 2
            t1 = nrows - 1 - srise
          else
            if ori = 3
              t1 = srise
            end
          end
        end
        y = y - t1   

    /* move screen cursor to point <x,y> 

        scx = x 
        scy = y 

        if sitflag = 1 
          t2 = maxn / gapsize 
          if bit(0,t2) = 0 
            --t2 
          end 
&dA 
&dA &d@           xxxxxxxxxxx....xxxx....xxxx....xxxx....xxxx....xxxxxxxxxxx 
&dA &d@                  |               odd number                 | 
&dA &d@          t2 = largest odd number of intervals that will fit inside maxn 
&dA 
          t2 *= gapsize 
          t1 = maxn - t2 
          t1 >>= 1             /* initial correction 
          bt(250) = dup("1",t1) // dotted{1,t2} // dup("1",t1+10)   /* mask 

          loop for t1 = 1 to nrows 
            bt(t1) = bnd(bt(t1),bt(250)) 
          repeat 
        end 

        if broksize > 0                               /* &dA03/15/97&d@  &dIOK&d@ 
          t2 = maxn - broksize >> 1 
          if t2 < 0 
            t2 = 0 
          end 
          t1 = maxn - t2 - t2 
          bt(250) = dup("1",t2) // dup("0",t1) // dup("1",t2) 
          loop for t1 = 1 to nrows 
            bt(t1) = bnd(bt(t1),bt(250)) 
          repeat 
        end 

        ++st_cnt 
        tput [ST,st_cnt] Calling for a slur at <~scx ,~scy > 
        ++st_cnt 
        tput [ST,st_cnt] : 

        loop for t1 = 1 to nrows 
          sbt = upk(bt(t1)) 
          ++st_cnt 
          tput [ST,st_cnt] ~sbt 
        repeat 
        ++st_cnt 
        tput [ST,st_cnt] : 
&dA 
&dA &d@   &dA01/05/09&d@ Code below added back to POSTSCRIPT case, because we need the 
&dA &d@            "dots" to determine the bounding box.  mode is always = 1 
&dA 
        setb gstr,bt,scx,scy,nrows,maxn,1,3 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 29. barline                                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset bar line                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   f11 = number of parts                            ³ 
&dA &d@³              psq(1) = y coordinate of first part              ³ 
&dA &d@³              psq(f11) = y coordinate of last part             ³ 
&dA &d@³              x = x-coordinate of line                         ³ 
&dA &d@³              z = bar character                                ³ 
&dA &d@³              syscode = format for bar                         ³ 
&dA &d@³              nsz(.)  = notesizes for each staff in the system ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure barline  
        int a1,a2,a3,a4,a5   

        if z = 86                          /* Case: dotted bar line cannot connect staff lines
          loop for a1 = 1 to f11 
            y = psq(a1) 
            a4 = nsz(a1) 
            if notesize <> a4 
              notesize = a4                /* set font size for segment 
              perform ps_init_par 
            end 
            perform setmus 
          repeat 
        else 
          a2 = 0 
          loop for a1 = 1 to len(syscode) 
            if "[(" con syscode{a1} 
              a4 = 0                       /* this will become the font size for this segment
              y1 = psq(a2+1) 
            end 
            if "])" con syscode{a1} 
&dA 
&dA &d@    If a4 is not determined at this point, set it to the default 
&dA 
              if a4 = 0 
                a4 = nsz(a2)               /* font size of bottom staff in this segment
              end 
              a3 = nsz(a2)                 /* notesize of staff for this termination
              a5 = a4 - a3 * 4             /* length correction 
              if notesize <> a3 
                notesize = a3              /* set font size for computing pvpar(44)
                perform ps_init_par 
              end 
              y2 = psq(a2) + pvpar(44)       /* line thickness added &dA04-25-95
              y2 -= a5 

              if notesize <> a4 
                notesize = a4              /* set font size for segment 
                perform ps_init_par 
              end 

              perform putbar (a2)
            end 
            if ".:,;" con syscode{a1}        
              ++a2
              if mpt > 2 
                if a4 = 0 
                  a4 = nsz(a2) 
                else 
                  if nsz(a2) > a4 
                    a4 = nsz(a2) 
                  end 
                end 
              end 
            end  
          repeat 
        end  
      return 
 
&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³D* 30. construct_bigslur_element (case,nsize,snum,rise,height,maxlen,bulge)  ³
&dA &d@³                                                                             ³
&dA &d@³    Operation:  This procedure is a replacement for the set of               ³
&dA &d@³                bigslur files used by the dskpage family of programs.        ³
&dA &d@³                Given a case (1 to 4), a notesize (6,14,16,18,21) and        ³
&dA &d@³                a slur number (from the slurpar data), this procedure        ³
&dA &d@³                constructs the requested slur on the fly.  Code for          ³
&dA &d@³                this procedure (and its two satalites) was lifted            ³
&dA &d@³                directly from the create programs                            ³
&dA &d@³                                                                             ³
&dA &d@³    Inputs:     int case:   1 = rising,convex                                ³
&dA &d@³                            2 = falling,convex                               ³
&dA &d@³                            3 = rising,concave                               ³
&dA &d@³                            4 = falling,concave                              ³
&dA &d@³                int nsize   [6,14,16,18,21]                                  ³
&dA &d@³                int snum    1200 < ... < 144000  from slurpars               ³
&dA &d@³                                                                             ³
&dA &d@³    Output:     bstr bt.2500(250)                                            ³
&dA &d@³                                                                             ³
&dA &d@³    There are also the following outputs:                                    ³
&dA &d@³                                                                             ³
&dA &d@³                int rise                                                     ³
&dA &d@³                int height  number of rows of data                           ³
&dA &d@³                int maxlen  actual length of slur generated                  ³
&dA &d@³                int bulge   the amount of left bulge in a vertical           ³
&dA &d@³                              convex rising, or concave falling slur         ³
&dA &d@³                                                                             ³
&dA &d@³    Calling procedure:  &dCprintslur_screen&d@  We need to do this because         ³
&dA &d@³                        there may be a dotted mask, and because that         ³
&dA &d@³                        procudure writes to the postscript dictionary        ³
&dA &d@³                                                                             ³
&dA &d@³    Procedures called:  &dCcircular&d@  and  &dCasymetric&d@                             ³
&dA &d@³                                                               (possible)    ³
&dA &d@³           Lengths                      Length        Rise       Number      ³
&dA &d@³           in dots                    increments   increments   of types     ³
&dA &d@³         ÄÄÄÄÄÄÄÄÄÄ                   ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄ     ³
&dA &d@³&dE  4 to 9  &d@  &dI  8 to 18 &d@  &dA 12 to 27 &d@    &dE1&d@  &dI 2&d@  &dA 3&d@    &dE1&d@   &dI2&d@   &dA2&d@    &dE 6&d@  &dI 6&d@  &dA 6&d@   ³
&dA &d@³&dE 10 to 98 &d@  &dI 20 to 196&d@  &dA 30 to 294&d@    &dE2&d@  &dI 4&d@  &dA 6&d@    &dE1&d@   &dI2&d@   &dA2&d@    &dE12&d@  &dI12&d@  &dA12&d@   ³
&dA &d@³&dE100 to 396&d@  &dI200 to 392&d@  &dA300 to 588&d@    &dE4&d@  &dI 8&d@  &dA12&d@    &dE1&d@   &dI2&d@   &dA2&d@    &dE24&d@  &dI24&d@  &dA24&d@   ³
&dA &d@³            &dI400 to 784&d@                   &dI16&d@            &dI2&d@            &dI48&d@       ³
&dA &d@³                                                                             ³
&dA &d@³                &dE(rise * 2400) + (length * 6)&d@                 &dEmax rise = 58 &d@  ³
&dA &d@³  Slur number = &dI(rise * 1200) + (length * 3)&d@  + type number  &dImax rise = 116&d@  ³
&dA &d@³                &dA(rise * 600) + (length * 2)&d@                  &dAmax rise = 236&d@  ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure construct_bigslur_element (case,nsize,snum,rise,height,maxlen,bulge)
        str out.1000 
        str newout.1000 

        bstr zeros.4500, temp.4500 
        int t1,t2,t3,t4,t5,t6,t7 
        int ii,jj
        int rise,type,length 
        int acc(1200) 
        int version 

        real X,Y,YY 
        real tenX,tenY 

        int xpnt,maxlen 
        int trycnt 
        int toplead(200),toptrail(200) 
        int topdiff(200) 
        str tstr.1000 
        int nsize,snum,case 
        int height,bulge 
        int h2l_ratio 

        table TTT(10000) 

&dA*   I. Set parameters                       

        zeros = zpd(4500) 

        getvalue case,nsize,snum 

        if nsize = 21 
          rise = snum / 1200        /* rem = 0 ... 1199 
          rise *= 2                 /* max is 238 
          if rise = 238 
            rise = 236 
          end 
        else 
          rise = snum / 2400        /* rem = 0 ... 2399  max rise = 59 
          if nsize = 6 
            if rise = 59 
              rise = 58 
            end 
          else 
            rise *= 2               /* max is 118 
            if rise = 118 
              rise = 116 
            end 
          end 
        end 
        snum = rem 
        if nsize = 6 
          length = snum / 6         /* rem = 0 ... 5 
          type = rem 
          if length > 9 
            length = snum / 12      /* rem = 0 ... 11 
            type = rem 
            length *= 2 
            if length > 98 
              length = snum / 24    /* rem = 0 ... 23 
              type = rem 
              length *= 4 
            end 
          end 
        else 
          if nsize < 21 
            length = snum / 6         /* rem = 0 ... 5 
            type = rem 
            length *= 2               /* max = 798 
            if length > 18 
              length = snum / 12      /* rem = 0 ... 11 
              type = rem 
              length *= 4             /* max = 796 
              if length > 196 
                length = snum / 24    /* rem = 0 ... 23 
                type = rem 
                length *= 8           /* max = 792 
                if length > 392 
                  length = snum / 48  /* rem = 0 ... 47 
                  type = rem 
                  length *= 16        /* max = 784 
                end 
              end 
            end 
          else 
            length = snum / 6         /* rem = 0 ... 5 
            type = rem 
            length *= 3               /* max = 597 
            if length > 27 
              length = snum / 12      /* rem = 0 ... 11 
              type = rem 
              length *= 6             /* max = 594 
              if length > 294 
                length = snum / 24    /* rem = 0 ... 23 
                type = rem 
                length *= 12          /* max = 588 
              end 
            end 
          end 
        end 

        if nsize = 6 
          if rise > 31 
            t3 = rise / 2 
            if rem > 0 
              rise += 1 
            end 
          end 
        else 
          if rise > 62 
            t3 = rise / 4 
            if rem > 0 
              rise += 2 
            end 
          end 
        end 
* 

&dA*   III. Beginning of Construction            

        h2l_ratio = rise / length 
        YY = flt(rise) 
        t3 = length - 1 
        X = flt(t3) 

        Y = YY 

  /* Set version and type numbers 

        if nsize = 6 
          if length < 10 
            version = 0              /* circular only 
            if type > 2 
              type -= 2 
            end 
            type += 2                /* type = 2, 3, or 4 
            ++type                   /* &dATemporary "fix"&d@ to accommodate the older slurpar files
          else 
            if length < 60 
              version = 0            /* circular only 
              if type > 5 
                type -= 6 
              end 
              ++type                 /* type = 1, 2, 3, 4, 5, or 6 
              if type < 6 
                ++type               /* &dATemporary "fix"&d@ to accommodate the older slurpar files
              end 
            else 
              if length < 100 
                if type < 6 
                  version = 0          /* circular 
                  ++type               /* type = 1, 2, 3, 4, 5, or 6 
                else 
                  if type < 9 
                    version = 1        /* high right 
                  else 
                    version = 2        /* symmetric 
                  end 
                  t3 = type / 3 
                  if version = 1 
                    rem <<= 1            /* rem = 0, 2, or 4 
                    type = rem + 1       /* type = 2, 4 or 6 
                  else 
                    type = rem + 2       /* type = 2, 3 or 4 
                  end 
                end 
                if type < 6 and version = 0 
                  ++type             /* &dATemporary "fix"&d@ to accommodate the older slurpar files
                end 
              else 
                if length < 200 
                  version = type  / 8  /* version = 0, 1, or 2 
                  type = rem + 1       /* type = 1 -> 8 
                else 
                  if type > 9 
                    type = 9 
                  end 
                  if type < 5 
                    version = 1        /* high right 
                  else 
                    version = 2        /* symmetric 
                  end 
                  t3 = type / 5 
                  type = rem + 2       /* type = 2,3,4,5,6 
                  if type < 6 
                    --type             /* type = 1,2,3,4,6 
                  end 
                end 
                if type < 8 and version = 0 
                  ++type             /* &dATemporary "fix"&d@ to accommodate the older slurpar files
                end 
              end 
            end 
          end 
        else 
          if nsize = 21 
            if length < 30 
              if type > 5              /* only six types 
                type -= 6 
              end 
              version = 0              /* circular only 
              t3 = type / 3 
              type = rem + 2           /* type = 2, 3, 4  (5,6,7) 
              if type > 4 
                type -= 3 
                ++rise 
                Y += 1.0 
              end 
            else 
              if length < 180 
                if type > 5 
                  type -= 6 
                end 
                version = 0            /* circular only 
                t3 = type / 6 
                type = rem + 1         /* type = 1, 2, 3, 4, 5, or 6 
              else 
                if length < 300 
                  if type > 11 
                    type -= 12 
                  end 
                  if type < 6 
                    version = 0          /* circular 
                    t3 = type / 6 
                    type = rem + 1       /* type = 1, 2, 3, 4, 5, or 6 
                  else 
                    if type < 9 
                      version = 1        /* high right 
                    else 
                      version = 2        /* symmetric 
                    end 
                    t3 = type / 3 
                    if version = 1 
                      rem <<= 1            /* rem = 0, 2, or 4 
                      type = rem + 1       /* type = 2, 4 or 6 
                    else 
                      type = rem + 2       /* type = 2, 3 or 4 
                    end 
                  end 
                else 
                  version = type / 8   /* version = 0, 1, or 2 
                  type = rem + 1       /* type = 1 -> 8 
                end 
              end 
            end 
          else 
            if length < 20 
              if type > 5              /* only six types 
                type -= 6 
              end 
              version = 0              /* circular only 
              t3 = type / 3 
              type = rem + 2           /* type = 2, 3, or 4  (5,6,7) 
              if type > 4 
                type -= 3 
                ++rise 
                Y += 1.0 
              end 
              if type < 6 and nsize = 14 
                ++type                 /* &dATemporary "fix"&d@ to accommodate the older slurpar files
              end 
            else 
              if length < 120 
                if type > 5 
                  type -= 6 
                end 
                version = 0            /* circular only 
                t3 = type / 6 
                type = rem + 1         /* type = 1, 2, 3, 4, 5, or 6 
                if type < 6 and nsize = 14 
                  ++type               /* &dATemporary "fix"&d@ to accommodate the older slurpar files
                end 
              else 
                if length < 200 
                  if type > 11 
                    type -= 12 
                  end 
                  if type < 6 
                    version = 0          /* circular 
                    t3 = type / 6 
                    type = rem + 1       /* type = 1, 2, 3, 4, 5, or 6 
                    if type < 6 and nsize = 14 
                      ++type             /* &dATemporary "fix"&d@ to accommodate the older slurpar files
                    end 
                  else 
                    if type < 9 
                      version = 1        /* high right 
                    else 
                      version = 2        /* symmetric 
                    end 
                    t3 = type / 3 
                    if version = 1 
                      rem <<= 1            /* rem = 0, 2, or 4 
                      type = rem + 1       /* type = 2, 4 or 6 
                    else 
                      type = rem + 2       /* type = 2, 3 or 4 
                    end 
                  end 
                else 
                  if length < 400 
                    version = type / 8   /* version = 0, 1, or 2 
                    type = rem + 1       /* type = 1 -> 8 
                  else 
                    if type > 9 
                      type = 9 
                    end 
                    if type < 6 
                      version = 1        /* high right 
                    else 
                      version = 2        /* symmetric 
                    end 
                    t3 = type / 5 
                    type = rem + 2       /* type = 2,3,4,5,6 
                  end 
                  if type < 6 and nsize = 14 and version = 0 
                    ++type               /* &dATemporary "fix"&d@ to accommodate the older slurpar files
                  end 
                end 
              end 
            end 
          end 
        end 
&dA 
&dA &d@   clear slur array 
&dA 
        tenX = X 
        tenY = Y 
        trycnt = 0 
CBE_RETRY: 

        loop for t3 = 1 to 750 
          slmap(t3) = zpd(4500) 
        repeat 

        if version = 0 
          perform circular (tenX,tenY,type,nsize) 
        else 
          perform asymetric (tenX,tenY,type,length,version,nsize)  /* magic 
        end 
&dA 
&dA &d@   determine size of slmap display 
&dA 
        loop for t3 = 1 to 750 
          if slmap(t3) <> zeros 
            goto CBE_CE 
          end 
        repeat 
        pute all Zeros 
        stop 
CBE_CE: 
        y1 = t3 - 1 
        loop for t4 = t3 to 750 
          if slmap(t4) = zeros and slmap(t4+1) = zeros 
            goto CBE_CF 
          end 
        repeat 
CBE_CF: 
        y2 = t4 - 1 
        loop for t4 = 1 to 4500 
          loop for t3 = y1 to y2 
            if slmap(t3){t4} = "1" 
              goto CBE_CH 
            end 
          repeat 
        repeat 
CBE_CH: 
        if nsize = 16 or nsize = 18 
          x1 = t4                      /* try this &dA10-31-04&d@ 
        else 
          x1 = t4 - 1 
        end 
        x2 = 0 
        loop for t3 = y1 to y2 
          temp = trm(slmap(t3)) 
          if x2 < bln(temp) 
            x2 = bln(temp) 
          end 
        repeat 
&dA 
&dA &d@   write slur to screen    (New &dA10-31-04&d@:  writing of slur delayed) 
&dA 
        x2 = x2 - x1 + 3 / 3 * 3        /* x range 
        loop for t3 = y1 to y2 
          slmap(t3) = slmap(t3){x1,x2} 
        repeat 
        t2 = y2 - y1 + 3 / 3 * 3        /* y range 

        t2 = t2 / 3                     /* t2 = number of vert rows 
        t1 = x2 / 3                     /* t1 = number of horiz cols 

        treset [TTT]                    /* New &dA10-31-04&d@ 

        xpnt = 0                        /* New &dA10-31-04&d@ 
        maxlen = 0                      /* New &dA10-31-04&d@ 

        loop for t3 = 1 to t2 
          loop for t5 = 1 to t1 
            acc(t5) = 0                 /* clear accumulators 
          repeat 
          loop for t4 = 1 to 3 
            t7 = 1                      /* t7 = column counter 
            loop for t5 = 1 to t1 
              loop for t6 = 1 to 3 
                if slmap(y1){t7} = "1" 
                  ++acc(t5) 
                end 
                ++t7                    /* advance column 
              repeat 
            repeat 
            ++y1                        /* advance row 
          repeat 
          out = pad(t1) 
          loop for t5 = 1 to t1 
            if acc(t5) > 3 
              out{t5} = "x" 
            end 
          repeat 
          out = trm(out) 

          ii = len(out) 
          if ii > maxlen 
            maxlen = ii 
          end 
&dA 
&dA &d@     New &dA10-31-04&d@:  Slur compaction and writing is delayed 
&dA &d@                    Send output temporarily - TTT table.  
&dA 
          if out = "" and (t3 = 1 or t3 = t2) 
          else 
            newout = out 
            ++xpnt 
            tput [TTT,xpnt] ~newout 
          end 
        repeat 
&dA 
&dA &d@    New Code &dA10-31-04&d@:  If the actual length is different than the requested
&dA &d@                        (planned) length, then adjust tenX and try again.  
&dA 
        if h2l_ratio > 1 
          goto CBE_NO_CHANGE 
        end 

        if trycnt = 0 
          if maxlen > length 
            tenX -= .9 
            --trycnt 
            goto CBE_RETRY 
          end 
          if maxlen < length 
            tenX += .9 
            ++trycnt 
            goto CBE_RETRY 
          end 
        end 
        if trycnt > 0 
          if maxlen < length 
            tenX += .9 
            ++trycnt 
            goto CBE_RETRY 
          end 
        end 
        if trycnt < 0 
          if maxlen > length 
            tenX -= .9 
            if tenX < 0.0 
              tenX = 0.0 
              trycnt = 1000 
            end 
            --trycnt 
            goto CBE_RETRY 
          end 
        end 
&dA 
&dA &d@     New Code &dA10-31-04&d@:  Make adjustments to slur shape (important code) 
&dA 
        if rise > 3 * length / 2 
          goto CBE_NO_CHANGE 
        end 

        loop for t3 = 1 to 200 
          toplead(t3)     = 0 
          toptrail(t3)    = 1000 
        repeat 

        loop for t3 = 1 to xpnt 
          tget [TTT,t3] out 
          tstr = mrt(out) 
          toplead(xpnt - t3 + 1) = len(out) - len(tstr) + 1 
          tstr = trm(out) 
          if t3 = 1 
            t4 = len(tstr) 
          end 
          t5 = len(tstr) 
          if t5 >= t4 
            toptrail(xpnt - t3 + 1) = t5 
          end 
        repeat 
&dA 
&dA &d@   1. Fix top of slur 
&dA 
        if toptrail(xpnt-1) < 1000 
          t4 = toptrail(xpnt) - toplead(xpnt) + 1 
          t5 = toptrail(xpnt-1) - toplead(xpnt-1) + 1 

          loop while t4 <= (2 * t5 / 5) 
            ++toptrail(xpnt) 
            --toplead(xpnt) 
            t4 += 2 
          repeat 
          tget [TTT,1] out 
          out = out // pad(999) 

          t5 = toplead(xpnt) 
          loop while out{t5} = " " 
            out{t5} = "x" 
            ++t5 
          repeat 
          loop while t5 <= toptrail(xpnt) 
            if out{t5} = " " 
              out{t5} = "x" 
            end 
            ++t5 
          repeat 
          out = out{1,length} 
          out = trm(out) 

          tput [TTT,1] ~out 
        end 
&dA 
&dA &d@   2. Fix outside rising part of slur (left side) 
&dA 
        loop for t3 = 1 to xpnt - 1 
          t4 = toplead(t3) 
          t5 = toplead(t3+1) 
          topdiff(t3) = t5 - t4 
        repeat 

        loop for t3 = 1 to xpnt - 4 
          if topdiff(t3) <> topdiff(t3+1) 
            t5 = topdiff(t3) + topdiff(t3+1) 
            t5 = t5 / 2 
            t4 = rem 
            topdiff(t3) = t5 
            topdiff(t3+1) = t5 
            if t4 = 1 
              ++topdiff(t3+1) 
            end 
            if t3 < xpnt - 5 
              ++t3 
            end 
          end 
        repeat 

        loop for t3 = 1 to xpnt - 4 
          if topdiff(t3) > topdiff(t3+1) + 1 
            --topdiff(t3) 
            ++topdiff(t3+1) 
          end 
        repeat 

        loop for t3 = 1 to xpnt - 1 
          toplead(t3+1) = toplead(t3) + topdiff(t3) 
        repeat 
        loop for t3 = 1 to xpnt 
          t4 = xpnt + 1 - t3 
          tget [TTT,t4] out 
          t5 = toplead(t3) 
          if t5 > 1 and t5 <= len(out) 
            out{1,t5-1} = pad(t5-1) 
            loop while out{t5} = " " 
              out{t5} = "x" 
              ++t5 
            repeat 
          end 
          tput [TTT,t4] ~out 
        repeat 
&dA 
&dA &d@   3. Fix outside decending side (right side) 
&dA 
        loop for t3 = 1 to xpnt - 1 
          t4 = toptrail(t3) 
          t5 = toptrail(t3+1) 
          if t5 < 1000 and t4 < 1000 
            topdiff(t3) = t4 - t5 
          else 
            topdiff(t3) = 1000 
          end 
        repeat 

        loop for t3 = 1 to xpnt - 4 
          if topdiff(t3) < 1000 
            if topdiff(t3) <> topdiff(t3+1) 
              t5 = topdiff(t3) + topdiff(t3+1) 
              t5 = t5 / 2 
              t4 = rem 
              topdiff(t3) = t5 
              topdiff(t3+1) = t5 
              if t4 = 1 
                ++topdiff(t3+1) 
              end 
              if t3 < xpnt - 5 
                ++t3 
              end 
            end 
          end 
        repeat 

        loop for t3 = 1 to xpnt - 4 
          if topdiff(t3) < 1000 
            if topdiff(t3) > topdiff(t3+1) + 1 
              --topdiff(t3) 
              ++topdiff(t3+1) 
            end 
          end 
        repeat 

        loop for t3 = xpnt - 1 to 1 step -1 
          if topdiff(t3) < 1000 
            toptrail(t3) = toptrail(t3+1) + topdiff(t3) 
          end 
        repeat 

        loop for t4 = 1 to xpnt 
          tget [TTT,t4] out 
          t5 = toptrail(xpnt + 1 - t4) 
          if t5 < 1000 
            out = out // pad(999) 
            if out{t5} = " " 
              out{t5} = "x" 
              if out{t5-1} = " " 
                out{t5-1} = "x" 
                if out{t5-2} = " " 
                  out{t5-2} = "x" 
                  if out{t5-3} = " " 
                    out{t5-3} = "x" 
                  end 
                end 
              end 
            end 
            if out{t5+1} = "x" 
              out{t5+1} = " " 
            end 
            if out{t5+2} = "x" 
              out{t5+2} = " " 
            end 
            if out{t5+3} = "x" 
              out{t5+3} = " " 
            end 
            out = trm(out) 
          end 

          tput [TTT,t4] ~out 
        repeat 

CBE_NO_CHANGE: 

&dA 
&dA &d@  Here is where the slur is processed 
&dA 
&dA &d@   4. Store slur in bstr bt.2500(250) 
&dA 
        if case < 3 
          jj = 1 
        else 
          jj = xpnt 
        end 
        loop for t4 = 1 to xpnt 
          tget [TTT,t4] out 
          out = out // pad(length) 
          out = out{1,length} 
          if case = 2 or case = 3 
            out = rev(out) 
          end 
          bt(jj) = pak(out) 
          if case < 3 
            ++jj 
          else 
            --jj 
          end 
        repeat 
&dA 
&dA &d@   5. Now display the slur on the screen 
&dA 
        height = xpnt 
        passback rise,height,maxlen,bulge 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 31. circular (X,Y,type,nsize)                                        ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Operation:  Construct a circular type slur of length X and rise Y   ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Inputs:     real X          length                                  ³ 
&dA &d@³                real Y          rise                                    ³ 
&dA &d@³                int  type       curvature                               ³ 
&dA &d@³                int  nsize      [6,14,16,18,21]                         ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Output:     bstr slmap.4500(750)                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure circular (X,Y,type,nsize) 
        real X,Y 
        real treal1,treal2
        int cir_leng 
        int t1,t2,t3,t4,t5 
        int type,nsize 
        int pc,pd,pe,pf,pg
        int scnt 
        real delta,alpha,beta
        real x,y,L,H,Cx,Cy,R,D
        real z,aa,bb,cc 
        real xx 
        real inpx,outpx,inpy,outpy,ind,outd 
        real sx(6000),sy(6000) 
        real flpd,flpc 

        getvalue X,Y,type,nsize 
&dA 
&dA &d@   compute R,L,H,Cx,Cy,beta 
&dA 
&dA &d@   1. L = (X*X + Y*Y)^1/2 
&dA 
        x = X * X 
        y = Y * Y 
        xx = x + y 
        L = sqt(xx) 
        cir_leng = fix(L) 
&dA 
&dA &d@   2. H:  Find smallest t1 such that L < slpara(type,t1+1).   H = flt(t1) 
&dA 
        if nsize = 6 
          treal1 = 2.33   /*  14 / 6 
          treal2 = 1.0 
        else                            /*  14: 2.0          14 / 7 
          treal1 = 14.0 / flt(nsize)    /*  16: 2.2857       16 / 7 
          treal2 = flt(nsize) / 7.0     /*  18: 2.5714       18 / 7 
        end                             /*  21; 3.0          21 / 7 

        loop for t1 = 1 to 55 
          if slpara(type,t1) > L * treal1    /* Factors added for different sizes
            if t1 = 1 
              H = 1.0 
            else 
              if t1 = 2 
                x = 1.0 
                y = 1.8 
              else 
                x = flt(t1-1) 
                x -= .2 
                y = x + 1.0 
              end 
              aa = L * treal1 - slpara(type,t1-1) 
              bb = slpara(type,t1) - (L * treal1)      /* Factor added
              cc = slpara(type,t1) - slpara(type,t1-1) 
              aa /= cc 
              bb /= cc 
              H = (x * bb) + (y * aa) 

              H /= treal1        /* Factor added.  Now correct H 
              if H < 1.0 
                H = 1.0 
              end 

            end 
            goto CBE_CAA 
          end 
        repeat 
&dA 
&dA &d@   3. R = L*L/H/8 + H/2 
&dA 
CBE_CAA: 
        x = xx / H / 8.0 
        y = H / 2.0 
        R = x + y 
&dA 
&dA &d@   4. Cx = X/2 + Y*(R - H)/L 
&dA 
        z = R - H / L 
        y = Y * z 
        Cx = X / 2.0 + y 
&dA 
&dA &d@   5. Cy = Y/2 - X*(R - H)/L 
&dA 
        x = X * z 
        Cy = Y / 2.0 - x 
&dA 
&dA &d@   6. beta = 2 * sin-1(L/2/R) 
&dA 
        x = L / 2.0 / R 
        beta = 2.0 * ars(x) 
&dA 
&dA &d@   normalize D-function 
&dA 
        xx = L / treal2       /* &dA04-25-95&d@   changed from L / 2.0 
        D = sqt(xx) / 4.8 
        if D > 1.50 
          D -= .16         /* radical 
          if H / L > .200     /* &dA10-28-94&d@   This is a ratio; no change.  
            D -= .10 
          end 
        end 
        if D > 1.70 
          D = D - 1.70 * .2 + 1.70 
        end 
        if D > 1.95 
          D = D - 1.95 * .3 + 1.95 
        end 
        D /= treal1           /* &dA04-25-95&d@    Correction to D 

        if nsize > 14 
          if D > 2.0 
            D = D - 2.00 * .5 + 2.00  /* &dA05-16-95&d@    added to thin out the circular slurs
          end 
          if D < .9 
            D = .9 
          end 
        else 
          if nsize < 14 
            if D < .4 
              D = .4 
            end 
          end 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P            ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

        delta = beta / 4.0 / L         /* four samples per dot 
        alpha = 0.0 
        scnt = 0 

        loop while alpha < beta 
          ++scnt 
&dA 
&dA &d@   1. compute bb = sin(alpha), aa = 1 - cos(alpha) 
&dA 
          bb = sin(alpha) 
          aa = 1.0 - cos(alpha) 
&dA 
&dA &d@   2. compute (x,y) 
&dA 
          cc = Cy * bb 
          sx(scnt) = Cx * aa - cc 
          cc = Cx * bb 
          sy(scnt) = Cy * aa + cc 
&dA 
&dA &d@   3. increment alpha 
&dA 
          alpha += delta 
        repeat
        ++scnt 
        sx(scnt) = X 
        sy(scnt) = Y 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³  E N D   O F   S W E E P.    C O N S T R U C T   S L U R     ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

        if cir_leng < 200 
          if nsize < 16 
            pc = 14 * scnt / 100         /* left hand side of slur 
            pd = 42 * scnt / 1000        /* extreme left end 
            pe = 86 * scnt / 100         /* right hand side of slur 
            pf = 958 * scnt / 1000       /* extreme right end 
          else 
            if nsize < 21 
              pc = 11 * scnt / 100       /* left hand side of slur 
              pd = 33 * scnt / 1000      /* extreme left end 
              pe = 89 * scnt / 100       /* right hand side of slur 
              pf = 967 * scnt / 1000     /* extreme right end 
            else 
              pc = 12 * scnt / 100       /* left hand side of slur 
              pd = 100 * scnt / 1000     /* extreme left end 
              pe = 88 * scnt / 100       /* right hand side of slur 
              pf = 900 * scnt / 1000     /* extreme right end 
            end 
          end 
        else 
          if nsize < 16 
            t1 = 1000 - cir_leng         /* 800 times too big 
            pc = 14 * t1 
            pd = 42 * t1 
            pe = 80000 - pc 
            pf = 800000 - pd 
            pc = pc * scnt / 80000       /* left hand side of slur 
            pd = pd * scnt / 800000      /* extreme left end 
            pe = pe * scnt / 80000       /* right hand side of slur 
            pf = pf * scnt / 800000      /* extreme right end 
          else 
            pc = cir_leng * 100 / (cir_leng + 600) /* left hand side of slur
            pd = pc * 3 / 10                       /* extreme left end 
            pe = scnt - pc                         /* right hand side of slur
            pf = scnt - pd                         /* extreme right end 
          end 
        end 
        flpd = flt(pd) 
        flpc = flt(pc) 

        loop for t1 = 1 to scnt 
          x = sx(t1) 
          y = sy(t1) 
&dA 
&dA &d@   1. compute ind, outd 
&dA 
          if nsize < 16 
            if t1 < pc                   /* left hand side of slur 
              ind = 0.0 
              if t1 < pd                 /* extreme left end 
                if flpc = 0.0 
                  outd = .4                        /* &dEwas .1&d@ 
                else 
                  outd = flt(t1) / flpc + .4       /* &dEwas .1&d@ 
                end 
              else 
                outd = .4 
              end 
              goto CBE_CCD 
            end 
            if t1 > pe                   /* right hand side of slur 
              ind = 0.0 
              if t1 >= pf                /* extreme right end 
                t2 = scnt - t1 
                if flpc = 0.0 
                  outd = .4                        /* &dEwas .1&d@ 
                else 
                  outd = flt(t2) / flpc + .4       /* &dEwas .1&d@ 
                end 
              else 
                outd = 0.4 
              end 
              goto CBE_CCD 
            end 
          else 
            if nsize = 16 
              if t1 < pc                   /* left hand side of slur 
                ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                if t1 < pd                 /* extreme left end 
                  outd = .2 * flt(t1) / flpd + .0 
                else 
                  outd = .2 
                end 
                goto CBE_CCD 
              end 
              if t1 > pe                   /* right hand side of slur 
                ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                if t1 >= pf                /* extreme right end 
                  t2 = scnt - t1 
                  if flpd > 0.0 
                    outd = 0.2 * flt(t2) / flpd + .0 
                  else 
                    outd = 0.2 
                  end 
                else 
                  outd = 0.2 
                end 
                goto CBE_CCD 
              end 
            else 
              if nsize = 18 
                if t1 < pc                   /* left hand side of slur 
                  ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                  if t1 < pd                 /* extreme left end 
                    outd = .4 * flt(t1) / flpd + .3 
                  else 
                    outd = .7 
                  end 
                  goto CBE_CCD 
                end 
                if t1 > pe                   /* right hand side of slur 
                  ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                  if t1 >= pf                /* extreme right end 
                    t2 = scnt - t1 
                    if flpd > 0.0 
                      outd = 0.4 * flt(t2) / flpd + .3 
                    else 
                      outd = 0.7 
                    end 
                  else 
                    outd = 0.7 
                  end 
                  goto CBE_CCD 
                end 
              else 
                if t1 < pc                   /* left hand side of slur 
                  ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                  if t1 < pd                 /* extreme left end 
                    outd = .3 * flt(t1) / flpd + .0 
                  else 
                    outd = .3 
                  end 
                  outd -= .1 
                  goto CBE_CCD 
                end 
                if t1 > pe                   /* right hand side of slur 
                  ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                  if t1 >= pf                /* extreme right end 
                    t2 = scnt - t1 
                    outd = 0.3 * flt(t2) / flpd + .0 
                  else 
                    outd = 0.3 
                  end 
                  outd -= .1 
                  goto CBE_CCD 
                end 
              end 
            end 
          end 

    /* middle of slur 
          if t1 > scnt / 2             /* right side 
            t2 = pe - t1 
          else                         /* left side 
            t2 = t1 - pc 
          end 
          t5 = scnt / 2 - pc 
          bb = flt(t2) * ars(1.0) / flt(t5)  /* max(bb) = sin-1(1) 
          aa = sin(bb) 
          if nsize < 16 
            outd = D - 0.4 * aa + 0.4     
            ind = aa * D 
          else 
            if nsize = 16 
              outd = D - 0.1 * aa + 0.2 
            else 
              if nsize = 18 
                outd = D - 0.7 * aa + 0.7 
              else 
                outd = D - 0.2 * aa + 0.2 
              end 
            end 
            ind = D - 0.7 * aa + 0.7 
          end 
&dA 
&dA &d@   2. compute outside point, inside point 
&dA 
CBE_CCD: 
          if nsize > 10 
            if nsize < 15 
              outd += .49000            /* &dEwas .29000&d@ 
              ind  += .49000            /* &dEwas .29000&d@ 
            else 
              if nsize = 16 
                outd += 0.50000 
                ind  += 0.30000 
              else 
                if nsize = 18 
                  outd += 0.90000 
                  ind  += 0.90000 
                else 
                  outd += 0.99000 
                  ind  += 0.99000 
                end 
              end 
            end 
          else 
            outd += .19000 
            ind  += .19000 
          end 

          aa = x - Cx * outd / R 
          bb = y - Cy * outd / R 
          outpx = x + aa 
          outpy = y + bb 
          aa = x - Cx * ind / R 
          bb = y - Cy * ind / R 
          inpx = x - aa 
          inpy = y - bb 
&dA 
&dA &d@   3. compute box coordinates 
&dA 
          if outpx < inpx 
            aa = outpx 
            outpx = inpx 
            inpx = aa 
          end 
          if outpy < inpy 
            aa = outpy 
            outpy = inpy 
            inpy = aa 
          end 
          outpx = outpx + 30.0 * 3. - .5 
          inpx  = inpx  + 30.0 * 3. - .5 
          outpy = outpy + 20.0 * 3. - .5 
          inpy  = inpy  + 20.0 * 3. - .5 
          if nsize < 16 
            inpx -= .5 
            outpx -= .5 
          end 
          x1 = fix(inpx) 
          x2 = fix(outpx) 
          y1 = fix(inpy) 
          y2 = fix(outpy) 
          if x2 - x1 < 2 
            ++y2                  /* radical 
          end 
&dA 
&dA &d@   4. set points inside box to 1 (with inverted vertical axis) 
&dA 
          if x1 < 1                    /* New code &dA10-31-04&d@ 
            x1 = 1                     /* New code &dA10-31-04&d@ 
          end                          /* New code &dA10-31-04&d@ 
          loop for t2 = y1 to y2 
            t4 = 750 - t2 
            loop for t3 = x1 to x2 
              slmap(t4){t3} = "1" 
            repeat 
          repeat 
        repeat 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 32. asymetric (X,Y,type,length,version,nsize)                        ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Operation:  Construct a three curve slur of length X and rise Y     ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Inputs:     real X          length                                  ³ 
&dA &d@³                real Y          rise                                    ³ 
&dA &d@³                int  type       curvature                               ³ 
&dA &d@³                int  length     integer length (for setting height)     ³ 
&dA &d@³                int  version    1 = symmetric, 2 = asymmetric           ³ 
&dA &d@³                int  nsize      [6,14,16,18,21]                         ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Output:     bstr slmap.4500(750)                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure asymetric (X,Y,type,length,version,nsize) 
        real X,Y 
        real PP, QQ 
        real rtype 
        real treal1
        real delta,alpha,beta,delta2,beta2 
        real x,y,L,H,Cx,Cy,R,D
        real W,Q,P,A,B,Ca,Cb 
        real aa,bb,cc 
        real xx,yy,u,v 
        real inpx,outpx,inpy,outpy,ind,outd 
        real sx(6000),sy(6000) 
        real flpd,flpf 

        int truelen 
        int t1,t2,t3,t4,t5 
        int type,length,version,nsize 
        int pc,pd,pe,pf,pg,ph 
        int scnt 

        getvalue X,Y,type,length,version,nsize 
        if nsize = 6 
          treal1 = 2.0    /*  14 / 7 
        else                            /*  14: 2.0          14 / 7 
          treal1 = 14.0 / flt(nsize)    /*  16: 2.2857       16 / 7 
        end                             /*  21; 3.0          21 / 7 

        X *= treal1               /* &dA04-25-95&d@  all computations done 
        Y *= treal1               /* at original size.  
        truelen = length * 14 / nsize 

        rtype = flt(type) 
        L = flt(truelen)           
        if truelen < 600          
          H = L * .03  + (1.9 * rtype)  + 7.1     /* &dA05-16-95&d@   was + 7.1 (types shifted by 1)
        else 
          H = 25.1  + (1.9 * rtype)               /* &dA05-16-95&d@   was 27.0  (types shifted by 1)
        end 
        rtype -= 1.0 

        L = X * X + (Y * Y) 
        L = sqt(L) 

        aa = rtype / 75.  
        W = L * (.66 - aa)  /* experimental value 
&dA 
&dA &d@   compute R, P, A, B, Cx, Cy, Ca, Cb and check limitations 
&dA 
&dA &d@   1. Q:  
&dA 
        if length > 300 
          Q = 15.0 
        else 
          Q = 13.0 
        end 
CBE_PAA: 

&dA 
&dA &d@   2. R = L*L/Q/8 + Q/2 
&dA &d@                        
        x = L * L / Q / 8.0 
        y = Q / 2.0 
        R = x + y 
&dA 
&dA &d@   3. P = R - (R*R - (W*W/4))^1/2  component of height from 
&dA &d@                                      middle section 
        x = (R * R) - (W * W / 4.0) 
        P = R - sqt(x) 
        y = (L - W) / 2.0 + P 
        if H > y 
          H = y 
        end 
        if H < Q 
          H = dec(Q) + .5 
        end 
&dA 
&dA &d@   4. A = (L - W) / 2  B = H - P   <A,B> = transition point 
&dA 
        A = (L - W) / 2.0 
        B = H - P 
&dA 
&dA &d@   5. Cx = X/2  Cy = R - H       <Cx,Cy> = center of main arc 
&dA 
        Cx = L / 2.0 
        Cy = H - R                  /* a negative number 
&dA 
&dA &d@   6. Compute  <Ca,Cb> = center of starting arc 
&dA 
&dA &d@           [ B*(Cx-A)/(Cy-B) + (A*A + B*B)/2/A - A ] 
&dA &d@      Cb = ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@                   [ B/A + (Cx-A)/(Cy-B) ] 
&dA 
&dA &d@      Ca = (A*A + B*B)/2/A - B*(Cb)/ A 
&dA 
        aa = (Cx - A) / (Cy - B) 
        bb = (A * A) + (B * B) 
        bb = bb / 2.0 / A 

        Cb = (B * aa + bb - A) / (B / A + aa) 

        Ca = bb - (B * Cb / A) 
&dA 
&dA &d@   normalize D-function 
&dA 
        xx = L / 2.0
        D = sqt(xx) / 4.8 
        if D > 1.50 
          D -= .16         /* radical 
          if H / L > .200 
            D -= .10 
          end 
        end 
        if D > 1.70 
          D = D - 1.70 * .2 + 1.70 
        end 
        if D > 1.95 
          D = D - 1.95 * .3 + 1.95 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   1        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@                              º   sqt(A*A + B*B)    º 
&dA &d@   1. compute beta = 2 * sin-1ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº  sweep angle 
&dA &d@                              º 2*sqt(Ca*Ca + Cb*Cb)º 
&dA 
        aa = A * A + (B * B) 
        bb = Ca * Ca + (Cb * Cb) 

        cc = sqt(bb) 
        beta = rtype / 7.5 

        if L >= 400.  
          delta = L * .001                  
        else                                
          delta = L * .006 - 2.00           
        end                                 

        if R / cc > 3.00 - beta + delta 
          Q += .1 
          if Q < H - .5 
            goto CBE_PAA 
          end 
        end 

        cc = sqt(aa/bb) 

        beta = 2.0 * ars(cc/2.0) 
&dA 
&dA &d@   2. compute delta so that sweep hits every one-third dot 
&dA 
        aa = sqt(aa) * 3.0      /* thrice length of arc (approx) 
        delta = beta / aa 
        scnt = 0 
        alpha = 0.0 
&dA 
&dA &d@   3. begin sweep 
&dA 
CBE_SW1A: 
        aa = 1.0 - cos(alpha) 
        bb = sin(alpha) 

        x = Ca * aa - (Cb * bb) 
        y = Ca * bb + (Cb * aa) 
        if x < A 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha += delta 
          goto CBE_SW1A 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   2        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. compute beta2 = sin-1{ [(L/2)-A] / R } 
&dA 
        aa = L / 2.0 - A / R 
        beta2 = ars(aa) 
&dA 
&dA &d@   2. compute delta so that sweep hits every one-third dot 
&dA 
        delta2 = beta2 * 2.0 / 3.0 / W 
        alpha = 0.0 - beta2 
&dA 
&dA &d@   3. begin sweep 
&dA 
CBE_SW2A: 
        x = R * sin(alpha) + Cx 
        y = R * cos(alpha) + Cy 
        if x < L - A 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha += delta2 
          goto CBE_SW2A 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   3        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. beta and delta already computed 
&dA 
        alpha = beta 
&dA 
&dA &d@   2. begin sweep 
&dA 
CBE_SW3A: 
        aa = 1.0 - cos(alpha) 
        bb = sin(alpha) 

        x = L - (Ca * aa) + (Cb * bb) 
        y = Ca * bb + (Cb * aa) 
        if x < L 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha -= delta 
          goto CBE_SW3A 
        end 
        ++scnt 
        sx(scnt) = L 
        sy(scnt) = 0.0 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³  E N D   O F   S W E E P S.    C O N S T R U C T   S L U R   ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. rotate data to produce rise 
&dA 
        aa = X / L 
        bb = Y / L 
        loop for t1 = 1 to scnt 
          x = sx(t1) * aa - (sy(t1) * bb) 
          y = sx(t1) * bb + (sy(t1) * aa) 
          sx(t1) = x 
          sy(t1) = y 
        repeat 
&dA 
&dA &d@   2. setup thickness parameters 
&dA 
        if length < 200 
          if nsize < 21 
            pc = 12 * scnt / 100         /* left hand side of slur 
            pd = 36 * scnt / 1000        /* extreme left end 
            pe = 88 * scnt / 100         /* right hand side of slur 
            pf = 964 * scnt / 1000       /* extreme right end 
            if version = 1 
              pe = 93 * scnt / 100 
              pf = 979 * scnt / 1000 
            end 
          else 
            pc = 12 * scnt / 100         /* left hand side of slur 
            pd = 80 * scnt / 1000        /* extreme left end 
            pe = 88 * scnt / 100         /* right hand side of slur 
            pf = 930 * scnt / 1000       /* extreme right end 
            if version = 1 
              pe = 93 * scnt / 100 
              pf = 950 * scnt / 1000 
            end 
          end 
        else 
          if nsize < 16 
            t1 = 1000 - length           /* 800 times too big 
            pc = 10 * t1 
            pd = 30 * t1 
            pe = 80000 - pc 
            pf = 800000 - pd 
            pc = pc * scnt / 80000       /* left hand side of slur 
            pd = pd * scnt / 800000      /* extreme left end 
            pe = pe * scnt / 80000       /* right hand side of slur 
            pf = pf * scnt / 800000      /* extreme right end 
            if version = 1 
              pe = 80000 - (6 * t1) 
              pf = 800000 - (18 * t1) 
              pe = pe * scnt / 80000       /* right hand side of slur 
              pf = pf * scnt / 800000      /* extreme right end 
            end 
          else 
            if nsize < 21 
              pc = length * 90 / (length + 600)    /* left hand side of slur
              pd = pc * 3 / 10                     /* extreme left end 
              pe = scnt - pc                       /* right hand side of slur
              pf = scnt - pd                       /* extreme right end 
              if version = 1 
                pe = scnt - (pc * 6 / 10) 
                pf = scnt - (pd * 6 / 10) 
              end 
            else 
              pc = length * 90 / (length + 600)    /* left hand side of slur
              pd = pc * 8 / 10                     /* extreme left end 
              pe = scnt - pc                       /* right hand side of slur
              pf = scnt - pd                       /* extreme right end 
              if version = 1 
                pe = scnt - (pc * 8 / 10) 
                pf = scnt - (pd * 8 / 10) 
              end 
            end 
          end 
        end 
        flpd = flt(pd) 
        flpf = flt(scnt - pf) 

        if version = 1 
          pg = 53 * scnt / 100 
        end 
        if version = 2 
          pg = 50 * scnt / 100         /* make asym left slurs fat in middle 
        end 

        if length < 400 
          ph = 0 
        else 
          ph = (length - 400) * scnt * 4 / 40000 
        end 
&dA 
&dA &d@   3. compute ind, outd 
&dA 
        loop for t1 = 1 to scnt 
          if nsize < 16 
            if t1 < pc                   /* left hand side of slur 
              ind = 0.0 
              if t1 < pd                 /* extreme left end 
                outd = flt(t1) / flt(pc) + .1 
              else 
                outd = .4 
              end 
              goto CBE_PCD 
            end 
            if t1 > pe                   /* right hand side of slur 
              ind = 0.0 
              if t1 >= pf                /* extreme right end 
                t2 = scnt - t1 
                outd = flt(t2) / flt(pc) + .1 
              else 
                outd = 0.4 
              end 
              goto CBE_PCD 
            end 
          else 
            if nsize = 16 
              if t1 < pc                    
                ind = 0.6                  
                if t1 < pd                  
                  outd = .4 * flt(t1) / flpd + .0 
                else 
                  outd = .4 
                end 
                goto CBE_PCD 
              end 
              if t1 > pe                    
                ind = 0.6                  
                if t1 >= pf                 
                  t2 = scnt - t1 
                  outd = 0.4 * flt(t2) / flpf + .0 
                else 
                  outd = 0.4 
                end 
                goto CBE_PCD 
              end 
            else 
              if nsize = 18 
                if t1 < pc                    
                  ind = 0.6                  
                  if t1 < pd                  
                    outd = .4 * flt(t1) / flpd + .3 
                  else 
                    outd = .7 
                  end 
                  goto CBE_PCD 
                end 
                if t1 > pe                    
                  ind = 0.6                  
                  if t1 >= pf                 
                    t2 = scnt - t1 
                    outd = 0.4 * flt(t2) / flpf + .3 
                  else 
                    outd = 0.7 
                  end 
                  goto CBE_PCD 
                end 
              else 
                if t1 < pc                    
                  ind = 0.6                  
                  if t1 < pd                  
                    outd = .3 * flt(t1) / flpd + .0 
                  else 
                    outd = .3 
                  end 
                  outd -= .1 
                  goto CBE_PCD 
                end 
                if t1 > pe                    
                  ind = 0.6                  
                  if t1 >= pf                 
                    t2 = scnt - t1 
                    outd = 0.3 * flt(t2) / flpf + .0 
                  else 
                    outd = 0.3 
                  end 
                  outd -= .1 
                  goto CBE_PCD 
                end 
              end 
            end 
          end 

    /* middle of slur 
          if t1 > pg + ph              /* right side 
            t2 = pe - t1 
            t5 = pe - pg - ph 
          else                         /* left side 
            if t1 < pg - ph 
              t2 = t1 - pc 
              t5 = pg - pc - ph 
            else 
              t5 = 10000 
              t2 = 9999 
            end 
          end 
          bb = flt(t2) * ars(1.0) / flt(t5)  /* max(bb) = sin-1(1) 
          aa = sin(bb) 
          if nsize < 16 
            outd = D - 0.4 * aa + 0.4 
            ind = aa * D 
          else 
            if nsize = 16 
              outd = D - 0.1 * aa + 0.4 
              ind = D - 0.6 * aa + 0.6 
            else 
              if nsize = 18 
                outd = D - 0.7 * aa + 0.7 
                ind = D - 0.6 * aa + 0.6 
              else 
                outd = D - 0.2 * aa + 0.2 
                ind = D - 0.6 * aa + 0.6 
              end 
            end 
          end 
&dA 
&dA &d@   4. compute outside point, inside point 
&dA 
CBE_PCD: 
          if nsize > 10 
            if nsize < 18 
              outd += 0.29000 
              ind  += 0.29000 
            else 
              if nsize = 18 
                outd += 0.69000 
                ind  += 0.79000 
              else 
                outd += 0.45000 
                ind  += 0.59000 
              end 
            end 
          else 
            outd += 0.10000 
            ind  += 0.10000 
          end 
  
          x = sx(t1) 
&dA 
&dA &d@   asymetric weighting for y 
&dA 
          if type < 3 
            cc = flt(scnt-1) 
            if version = 1 
              aa =  .9  * flt(scnt-t1) / cc 
              bb = 1.05 * flt(t1-1) / cc 
              y = sy(t1) * (aa + bb) 
              y = y - (.05 * Y * flt(t1-1) / cc) 
            else 
              y = sy(t1) 
            end 
          else 
            if type < 5          /* types 3 and 4 have reduced asymmetry 
              cc = flt(scnt-1) 
              if version = 1 
                aa =  .92 * flt(scnt-t1) / cc 
                bb = 1.04 * flt(t1-1) / cc 
                y = sy(t1) * (aa + bb) 
                y = y - (.04 * Y * flt(t1-1) / cc) 
              else 
                y = sy(t1) 
              end 
            else 
              if type < 7    /* types 5 and 6 have further reduced asymmetry 
                cc = flt(scnt-1) 
                if version = 1 
                  aa =  .96 * flt(scnt-t1) / cc 
                  bb = 1.02 * flt(t1-1) / cc 
                  y = sy(t1) * (aa + bb) 
                  y = y - (.02 * Y * flt(t1-1) / cc) 
                else 
                  y = sy(t1) 
                end 
              else 
                y = sy(t1)      /* types 7 and 8 are not asymmetric 
              end 
            end 
          end 
&dA 
&dA &d@   give finite width to slur 
&dA 
          if t1 < scnt 
            u = sx(t1+1) 
            v = sy(t1+1) 
          else 
            u = x 
            v = y 
          end 
          if t1 > 1 
            xx = sx(t1-1) 
            yy = sy(t1-1) 
          else 
            xx = x 
            yy = y 
          end 
          u -= xx          /* delta x 
          v -= yy          /* delta y 
          cc = u * u + (v * v) 
          cc = sqt(cc)       /* delta hypotinus 
          aa = outd / cc 
          bb = ind / cc 
          outpx = x - (aa * v) 
          outpy = y + (aa * u) 
          inpx  = x + (bb * v) 
          inpy  = y - (bb * u) 
&dA 
&dA &d@   5. compute box coordinates 
&dA 
          if outpx < inpx 
            aa = outpx 
            outpx = inpx 
            inpx = aa 
          end 
          if outpy < inpy 
            aa = outpy 
            outpy = inpy 
            inpy = aa 
          end 
          outpx = outpx + 30.0 * 3. - .5 
          inpx  = inpx  + 30.0 * 3. - .5 
          outpy = outpy + 20.0 * 3. - .5 
          inpy  = inpy  + 20.0 * 3. - .5 
          x1 = fix(inpx) 
          x2 = fix(outpx) 
          y1 = fix(inpy) 
          y2 = fix(outpy) 
          if nsize = 6 
            x1 -= 1 
            y2 += 2 
          end 
          if nsize < 16 
            if x2 - x1 < 2 
              ++y2                /* radical 
            end 
          end 
&dA 
&dA &d@   6. set points inside box to 1 (with inverted vertical axis) 
&dA 
&dA &d@     Here is where you scale the size of the slur
&dA 
          if nsize = 6 
            x1 >>= 1 
            x2 >>= 1 
            y1 >>= 1 
            y2 >>= 1 
          end 
          if nsize > 14 
            x1 = x1 * nsize / 14 
            x2 = x2 * nsize / 14 
            y1 = y1 * nsize / 14 
            y2 = y2 * nsize / 14 
          end 
          loop for t2 = y1 to y2 
            t4 = 750 - t2 
            loop for t3 = x1 to x2 
              slmap(t4){t3} = "1" 
            repeat 
          repeat 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 33. make_longslur (length,rise,smode)                                ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Operation:  Construct a three curve longslur                        ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Inputs:     real X          length                                  ³ 
&dA &d@³                real Y          rise                                    ³ 
&dA &d@³                int  type       curvature                               ³ 
&dA &d@³                int  length     integer length (for setting height)     ³ 
&dA &d@³                int  version    1 = symmetric, 2 = asymmetric           ³ 
&dA &d@³                int  nsize      [6,14,16,18,21]                         ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Output:     bstr slmap.4500(750)                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 

#define MAPZ        2500 

      procedure make_longslur (length,rise,smode) 
        str out.MAPZ 
        str map.MAPZ(250),zeros.MAPZ 
        bstr temp.MAPZ 

        int t1,t2,t3,t4,t5
        int x1,x2,y1,y2 
        int length,rise,smode 
        int pc,pd,pe,pf,pg,ph 
        int scnt 

        real delta,alpha,beta,delta2,beta2 
        real X,x,Y,y,z,Cx,Cy,R,L,H,D,W,Q,P,A,B,Ca,Cb 
        real aa,bb,cc 
        real xx,yy,u,v 
        real inpx,outpx,inpy,outpy,ind,outd 
        real sx(8000),sy(8000) 
        real PP,QQ 
        real SCALE 
        real rtype 

        zeros = zpd(MAPZ) 

&dA*   I.  Determine scaling factor              

        if notesize = 14 
          SCALE = 1.0 
        else 
          SCALE = flt(notesize) / 14.0 
        end 

&dA*   II. Get rise and length limits            

        getvalue length,rise,smode 
        t1 = length - 1 
        X = flt(t1) 
        Y = flt(rise) 

        X = X / SCALE                  /* &dA05-12-95&d@  all computations done 
        Y = Y / SCALE                  /* at original size.  

        length = length * 14 / notesize 

  /* clear slur array 

        loop for t1 = 1 to 250 
          map(t1) = pad(MAPZ) 
        repeat 
&dA 
&dA &d@    &dEBeginning of slur generation&d@ 
&dA 
&dAÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dA³       P A R A M E T R I C    M A G I C         ³&d@ 
&dAÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

        rtype = 2.0        

        if X < 600.0 
          H = X * .03 + 9.0 + (1.9 * rtype) 
        else 
          H = 27.0  + (1.9 * rtype) 
        end 

        if X > 1200.0 
          H = H + (X - 1200.0 / 200.0) 
        end 

        rtype -= 1.0 

        L = X * X + (Y * Y) 
        L = sqt(L) 
        aa = rtype / 75.  
        W = L * (.66 - aa)  /* experimental value 
&dA 
&dA &d@   compute R, P, A, B, Cx, Cy, Ca, Cb and check limitations 
&dA 
&dA &d@   1. Q:  
&dA 
        if X > 300.0 
          Q = 15.0 
        else 
          Q = 13.0 
        end 

LS_PAA: 

&dA 
&dA &d@   2. R = L*L/Q/8 + Q/2 
&dA &d@                        
        x = L * L / Q / 8.0 
        y = Q / 2.0 
        R = x + y 
&dA 
&dA &d@   3. P = R - (R*R - (W*W/4))^1/2  component of height from 
&dA &d@                                      middle section 
        x = (R * R) - (W * W / 4.0) 
        P = R - sqt(x) 
        y = (L - W) / 2.0 + P 
        if H > y 
          H = y 
        end 
        if H < Q 
          H = dec(Q) + .5 
        end 
&dA 
&dA &d@   4. A = (L - W) / 2  B = H - P   <A,B> = transition point 
&dA 
        A = (L - W) / 2.0 
        B = H - P 
&dA 
&dA &d@   5. Cx = X/2  Cy = R - H       <Cx,Cy> = center of main arc 
&dA 
        Cx = L / 2.0 
        Cy = H - R                  /* a negative number 
&dA 
&dA &d@   6. Compute  <Ca,Cb> = center of starting arc 
&dA 
&dA &d@           [ B*(Cx-A)/(Cy-B) + (A*A + B*B)/2/A - A ] 
&dA &d@      Cb = ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@                   [ B/A + (Cx-A)/(Cy-B) ] 
&dA 
&dA &d@      Ca = (A*A + B*B)/2/A - B*(Cb)/ A 
&dA 
        aa = (Cx - A) / (Cy - B) 
        bb = (A * A) + (B * B) 
        bb = bb / 2.0 / A 

        Cb = (B * aa + bb - A) / (B / A + aa) 

        Ca = bb - (B * Cb / A) 
&dA 
&dA &d@   normalize D-function 
&dA 
        xx = L / 2.0 
        D = sqt(xx) / 4.8 
        if D > 1.50 
          D -= .16         /* radical 
          if H / L > .200 
            D -= .10 
          end 
        end 
        if D > 1.70 
          D = D - 1.70 * .2 + 1.70 
        end 
        if D > 1.95 
          D = D - 1.95 * .3 + 1.95 
        end 
        if D > 2.25 
          D = D - 2.25 * .4 + 2.25 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   1        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@                              º   sqt(A*A + B*B)    º 
&dA &d@   1. compute beta = 2 * sin-1ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº  sweep angle 
&dA &d@                              º 2*sqt(Ca*Ca + Cb*Cb)º 
&dA 
        aa = A * A + (B * B) 
        bb = Ca * Ca + (Cb * Cb) 

        cc = sqt(bb) 
        beta = rtype / 7.5 

        if L >= 400.  
          delta = L * .001                  
        else                                
          delta = L * .006 - 2.00           
        end                                 

        if R / cc > 3.00 - beta + delta 
          Q += .1 
          if Q < H - .5 
            goto LS_PAA 
          end 
        end 

        cc = sqt(aa/bb) 

        beta = 2.0 * ars(cc/2.0) 
&dA 
&dA &d@   2. compute delta so that sweep hits every dot 
&dA 
        aa = sqt(aa)          /* length of arc (approx)  
        delta = beta / aa / 2.0  
        scnt = 0 
        alpha = 0.0 
&dA 
&dA &d@   3. begin sweep 
&dA 
LS_SW1A: 
        aa = 1.0 - cos(alpha) 
        bb = sin(alpha) 

        x = Ca * aa - (Cb * bb) 
        y = Ca * bb + (Cb * aa) 
        if x < A 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha += delta 
          goto LS_SW1A 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   2        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. compute beta2 = sin-1{ [(L/2)-A] / R } 
&dA 
        aa = L / 2.0 - A / R 
        beta2 = ars(aa) 
&dA 
&dA &d@   2. compute delta so that sweep hits every dot 
&dA 
        delta2 = beta2 * 2.0 / W / 2.0    
        alpha = 0.0 - beta2 
&dA 
&dA &d@   3. begin sweep 
&dA 
LS_SW2A: 
        x = R * sin(alpha) + Cx 
        y = R * cos(alpha) + Cy 
        if x < L - A and scnt < 7999         /* added &dA11/29/09&d@ 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha += delta2 
          goto LS_SW2A 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   3        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. beta and delta already computed 
&dA 
        alpha = beta 
&dA 
&dA &d@   2. begin sweep 
&dA 
LS_SW3A: 
        aa = 1.0 - cos(alpha) 
        bb = sin(alpha) 

        x = L - (Ca * aa) + (Cb * bb) 
        y = Ca * bb + (Cb * aa) 
        if x < L and scnt < 7999             /* added &dA11/29/09&d@ 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha -= delta 
          goto LS_SW3A 
        end 
        ++scnt 
        sx(scnt) = L 
        sy(scnt) = 0.0 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³  E N D   O F   S W E E P S.    C O N S T R U C T   S L U R   ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. rotate data to produce rise 
&dA 
        aa = X / L 
        bb = Y / L 
        loop for t1 = 1 to scnt 
          x = sx(t1) * aa - (sy(t1) * bb) 
          y = sx(t1) * bb + (sy(t1) * aa) 
          sx(t1) = x 
          sy(t1) = y 
        repeat 
&dA 
&dA &d@   2. setup thickness parameters 
&dA 
        pc = length * 60 / (length + 400)   /* carefully worked out formula &dA05/13/95
        pd = pc * 3 / 10 

        pe = scnt - pc 
        pf = scnt - pd 

        if notesize = 21                    /* disable this feature for notesize = 21 &dA12/03/08
          pc = 1 
          pe = scnt 
        end 

        pg = 50 * scnt / 100         

        if length < 400 
          ph = 0 
        else 
          ph = (length - 400) * scnt * 4 / 40000 
        end 
&dA 
&dA &d@   3. compute ind, outd 
&dA 
        loop for t1 = 1 to scnt 
          if t1 < pc                   /* left hand side of slur 
            ind = 0.6 
            if notesize = 21 
              ind = 1.3 
            end 
            if t1 < pd                 /* extreme left end 
              if notesize = 16         /* New size-16  &dA12/31/08&d@ 
                outd = .4 * flt(t1) / flt(pc) 
              else 
                outd = flt(t1) / flt(pc) + .1 
              end 
            else 
              outd = 0.4 
            end 
            if notesize = 14 
              outd += .4 
            end 
            if notesize = 16           /* New size-16  &dA12/31/08&d@ 
              outd += .3 
            end 
            if notesize = 18           /* New size-18  &dA12/18/04&d@ 
              outd += .3 
            end 
            if notesize = 21 
              outd += .3 
            end 
            goto LS_PCD 
          end 
          if t1 > pe                   /* right hand side of slur 
            ind = 0.6 
            if t1 >= pf                /* extreme right end 
              t2 = scnt - t1 
              if notesize = 16         /* New size-16  &dA12/31/08&d@ 
                outd = 0.4 * flt(t2) / flt(pc) 
              else 
                outd = flt(t2) / flt(pc) + .1 
              end 
            else 
              outd = 0.4 
            end 
            if notesize = 14 
              outd += .4 
            end 
            if notesize = 16           /* New size-16  &dA12/31/08&d@ 
              outd += .3 
            end 
            if notesize = 18           /* New size-18  &dA12/18/04&d@ 
              outd += .3 
            end 
            goto LS_PCD 
          end 
    /* middle of slur 
          if t1 > pg + ph              /* right side 
            t2 = pe - t1 
            t5 = pe - pg - ph 
          else                         /* left side 
            if t1 < pg - ph 
              t2 = t1 - pc 
              t5 = pg - pc - ph 
            else 
              t5 = 10000 
              t2 = 9999 
            end 
          end 
          bb = flt(t2) * ars(1.0) / flt(t5)  /* max(bb) = sin-1(1) 
          aa = sin(bb) 
          if notesize = 14 
            outd = D - .8 * aa + .8 
            ind = D - .6 * aa + .6 
          end 
&dA 
&dA &d@    New &dA12/31/08&d@ parameters for notesize 16 (based on create16.z) 
&dA 
          if notesize = 16 
            outd = D - 0.1 * aa + 0.4 
            ind = D - 0.6 * aa + 0.6    
            outd += .29000 
            ind  += .29000 
          end 
&dA 
&dA &d@    New &dA12/18/04&d@ parameters for notesize 18 (based on create18.z) 
&dA 
          if notesize = 18 
            outd = D - 0.7 * aa + 0.7 
            ind = D - 0.6 * aa + 0.6    
            outd += .69000 
            ind  += .79000 
          end 
&dA 
&dA &d@    &dA01/26/06&d@ parameters added for notesize 6
&dA 
          if notesize = 6 
            outd = D - 0.8 * aa + 0.8 
            ind = D - 0.6 * aa + 0.6    
            outd += .39000 
            ind  += .49000 
          end 
&dA 
&dA &d@    &dA12/03/08&d@ parameters changed for notesize 21 
&dA 
          if notesize = 21 
            outd = D - 0.6 * aa + 0.6 
            ind = D - 1.0 * aa + 1.0    
            outd += .29000 
            ind  += .89000 
          end 
&dA 
&dA &d@   4. compute outside point, inside point 
&dA 
LS_PCD: 
          x = sx(t1) 
          y = sy(t1) 
&dA 
&dA &d@   give finite width to slur 
&dA 
          if t1 < scnt 
            u = sx(t1+1) 
            v = sy(t1+1) 
          else 
            u = x 
            v = y 
          end 
          if t1 > 1 
            xx = sx(t1-1) 
            yy = sy(t1-1) 
          else 
            xx = x 
            yy = y 
          end 
          u -= xx          /* delta x 
          v -= yy          /* delta y 
          cc = u * u + (v * v) 
          cc = sqt(cc)       /* delta hypotinus 
          aa = outd / cc 
          bb = ind / cc 
          outpx = x - (aa * v) 
          outpy = y + (aa * u) 
          inpx  = x + (bb * v) 
          inpy  = y - (bb * u) 
&dA 
&dA &d@   5. compute box coordinates 
&dA 
          if outpx < inpx 
            aa = outpx 
            outpx = inpx 
            inpx = aa 
          end 
          if outpy < inpy 
            aa = outpy 
            outpy = inpy 
            inpy = aa 
          end 
          outpx = outpx + 30.0           /*  - .5 
          inpx  = inpx  + 30.0           /*  - .5 
          outpy = outpy + 20.0 - 1.0 
          inpy  = inpy  + 20.0 + .5 
&dA 
&dA &d@    For notesize = 21, it appears that scaling here is better 
&dA 
          if notesize = 21 
            inpx = inpx * SCALE 
            outpx = outpx * SCALE 
            inpy = inpy * SCALE 
            outpy = outpy * SCALE 
          end 

          x1 = fix(inpx) 
          x2 = fix(outpx) 
          y1 = fix(inpy) 
          y2 = fix(outpy) 
          if x2 - x1 < 2 
            ++y2                  /* radical 
          end 
&dA 
&dA &d@   6. set points inside box to 1 (with inverted vertical axis) 
&dA 
&dA &d@     Here is where you scale the slur back to its original size    
&dA 
          if notesize <> 21 
            x1 = x1 * notesize / 14 
            x2 = x2 * notesize + 7 / 14 
            y1 = y1 * notesize / 14 
            y2 = y2 * notesize + 7 / 14 
          end 

          if y2 > 249 
            y2 = 249 
          end 

          if x2 > 2500                        /* added &dA11/29/09&d@ 
            x2 = 2500      
          end 

          loop for t2 = y1 to y2 
            t4 = 250 - t2 
            loop for t3 = x1 to x2 
              map(t4){t3} = "x" 
            repeat 
          repeat 

        repeat 
&dA 
&dA &d@    &dEEnd of slur generation&d@ 
&dA 

/* determine size of map display 

        loop for t1 = 1 to 250 
          map(t1) = trm(map(t1)) 
          if map(t1) <> "" 
            goto LS_CE 
          end 
        repeat 
LS_CE: 
        y1 = t1 
        loop for t2 = t1 to 249 
          map(t2+1) = trm(map(t2+1)) 
          if map(t2) = "" and map(t2+1) = "" 
            goto LS_CF 
          end 
        repeat 
LS_CF: 
        y2 = t2 - 1 
        loop for t2 = 1 to MAPZ 
          loop for t1 = y1 to y2 
            if map(t1){t2} = "x" 
              goto LS_CH 
            end 
          repeat 
        repeat 
LS_CH: 
        x1 = t2 
        x2 = 0 
        loop for t1 = y1 to y2 
          if x2 < len(map(t1)) 
            x2 = len(map(t1)) 
          end 
        repeat 

    /* write slur to longslur(.) 

        x2 = x2 - x1                /* x range 
        t2 = 0 
        if smode < 3 
          loop for t1 = y1 to y2 
            map(t1) = map(t1) // pad(MAPZ) 
            out = map(t1){x1,x2} 
            if smode = 2 
              out = rev(out) 
            end 
            out = trm(out) 

            if out = "" and (t1 = y1 or t1 = y2) 
            else 
              ++t2 
              temp = pak(out) 
              longslur(t2) = cby(temp) 
            end 
          repeat 
        else 
          loop for t1 = y2 to y1 step -1 
            map(t1) = map(t1) // pad(MAPZ) 
            out = map(t1){x1,x2} 
            if smode = 3 
              out = rev(out) 
            end 
            out = trm(out) 

            if out = "" and (t1 = y1 or t1 = y2) 
            else 
              ++t2 
              temp = pak(out) 
              longslur(t2) = cby(temp) 
            end 
          repeat 
        end 
        if smode = 1 
          length = t2 - 1 
        else 
          if smode = 2 
            length = t2 - 1 - rise 
          else 
            if smode = 3 
              length = rise 
            else 
              length = 0 
            end 
          end 
        end 

        rise = t2 
        passback length,rise          /* length = initial offset; rise = number of rows
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 34. stringout (out)                                         ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Operation:  Put out a string of characters                 ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure stringout (out) 
        str out.500 
        int font,kk 
        int t1 
        getvalue out 
        int scx2                    /* added &dA11/29/09&d@ 

        loop for t1 = 1 to len(out) 
          kk = ors(out{t1}) 
          if kk > 130 and kk < 142 
            if kk < 140 
              scx += (kk - 130) 
            else 
              scx -= (kk - 139) 
            end 
          else 
            scb = kk 
            perform charout 
          end 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 35. charout                                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Operation:  Put out a character (to the ps output table)   ³ 
&dA &d@³                Advance the scx pointer, which would normally  ³ 
&dA &d@³                be done by the setb instruction.  setb here    ³ 
&dA &d@³                simply puts out a dummy character for the      ³ 
&dA &d@³                sake of constructing the bounding box (later). ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure charout 
        int font,kk 
        font = revmap(scf) 
        int scx2 
        scx2 = scx 
&dA 
&dA &d@    Here, color_flag is important.  &dA12/26/10&d@ and &dA01/17/11&d@ 
&dA 
        if color_flag = 0 
          ++ct_cnt 
          tput [CT,ct_cnt] Calling charout: font = ~font   loc = <~scx ,~scy >  char = ~scb
        else 
          if color_flag = 1 
            ++ct_cnt2 
            tput [CT2,ct_cnt2] Calling charout: font = ~font   loc = <~scx ,~scy >  char = ~scb
          else 
            if color_flag = 2 
              ++ct_cnt3 
              tput [CT3,ct_cnt3] Calling charout: font = ~font   loc = <~scx ,~scy >  char = ~scb
            else 
              ++ct_cnt4 
              tput [CT4,ct_cnt4] Calling charout: font = ~font   loc = <~scx ,~scy >  char = ~scb
            end 
          end 
        end 
&dA      
        ++glyph_record(font,scb) 

        if font < 13 
          scx += Mfontinc(font,scb) 
        end 
        if font > 12 and font < 26    /* Beams 
          scx += Beaminc(scb) 
        end 
        if font > 25 and font < 38    /* Ties 
          kk = Tieinc(font-25,scb) 
          scx += kk 
        end 
        if font > 37 and font < 42    /* Wedges 
          scx += Wedginc(scb) 
        end 
        if font > 50 
          perform get_xinc (scf,scb,kk) 
          scx += kk 
        end 

        font = revmap(notesize) 
        font = font - 1 * 33 
        kk = 33 + font 
         
        setb gstr,FA,scx2,scy,kk,1 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 36. ps_init_par                                                    ³ 
&dA &d@³                                                                      ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Purpose:  Initialize Vertical and Horizontal Parameters           ³ 
&dA &d@³                also expar(.) parameters                              ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Inputs:   notesize                                                ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Outputs:  pvpar(.)                                                ³ 
&dA &d@³              phpar(.)                                                ³ 
&dA &d@³              pvpar20                                                 ³ 
&dA &d@³              expar(.)                                                ³ 
&dA &d@³              revmap(.)                                               ³ 
&dA &d@³              sizenum                                                 ³ 
&dA &d@³                                                                      ³ 
&dA &d@³     Other operations: In all cases, if scf = old notesize, then      ³ 
&dA &d@³                         scf reset to new notesize                    ³ 
&dA &d@³                       In the case of PRINT, changes the active font  ³ 
&dA &d@³                         to match the new size.                       ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure ps_init_par 
        int pz                            /* added &dA03/15/04&d@ 
        int t1 
        bstr cycle.200 

        sizenum = revsizes(notesize)       /* New &dA02/19/06&d@ 
&dA 
&dA &d@    Vertical parameters 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        if notesize = 14 
          pvpar(13) = 8 
          pvpar(42) = 4 
          pvpar(43) = 240 
          pvpar(44) = 1 
        end 
        if notesize = 6 
          pvpar(13) = 3                  /* Changed from 4 to 3 &dA01/30/05&d@ 
          pvpar(42) = 2 
          pvpar(43) = 80 
          pvpar(44) = 1 
        end 
        if notesize = 21 
          pvpar(13) = 12 
          pvpar(42) = 6 
          pvpar(43) = 240 
          pvpar(44) = 3 
        end 
        if notesize = 18                /* New size-18  &dA12/18/04&d@ 
          pvpar(13) = 10 
          pvpar(42) = 5 
          pvpar(43) = 240 
          pvpar(44) = 2 
        end 
        if notesize = 16                /* New size-16  &dA12/31/08&d@ 
          pvpar(13) = 9 
          pvpar(42) = 4 
          pvpar(43) = 240 
          pvpar(44) = 1 
        end 

        loop for t1 = 1 to 10 
          pvpar(t1) = notesize * t1 / 2 
        repeat 

        pvpar(11) = 200 * notesize / 16 
        pvpar(12) = 4 * notesize / 16 

        pvpar(14) = 160 * notesize / 16 
        pvpar(15) = 64 * notesize / 16 
        pvpar(16) = 3 * notesize 
        pvpar(17) = notesize / 2 
        pvpar(18) = 30 * notesize / 16 
        pvpar(19) = 15 
        pvpar(20) = notesize + 3 / 4 
        pvpar(21) = notesize - pvpar(20) 
        pvpar(22) = 6 * notesize / 16 
        pvpar(23) = 9 * notesize / 16 
        pvpar(24) = 7 * notesize / 16 
        pvpar(25) = 22 * notesize / 16 
        pvpar(26) = 27 * notesize / 16 
        pvpar(27) = 72 * notesize / 16 
        pvpar(28) = 15 * notesize / 16 
        pvpar(29) = 38 * notesize / 16 
        pvpar(30) = 3 * notesize - 8 / 16 
        pvpar(31) = notesize / 2 + 1 
        pvpar(32) = notesize * 8 + 4 / 10 
        pvpar(33) = notesize * 12 + 10 / 14 
        pvpar(34) = notesize - 3 / 9 
        pvpar(35) = notesize / 3 
        pvpar(36) = 7 * notesize 
        pvpar(37) = 5 * notesize / 4 
        pvpar(38) = 4 * notesize / 3 
        pvpar(39) = notesize 
        pvpar(40) = 3 * notesize / 5 
        pvpar(41) = pvpar(5) 
        pvpar(45) = 2 * notesize     
        pvpar20   = notesize * 10 
&dA 
&dA &d@    Horizontal parameters 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        if notesize = 14 
          phpar(2) =   15 
          phpar(3) =   19 
          phpar(5) =   13 
          phpar(6) =   80 
          phpar(7) =   56             /* &dA01/20/05&d@ made explicit 
          phpar(12) =  80 
          phpar(17) =  14 
          phpar(19) =   4 
          phpar(20) =  20 
          phpar(29) =   2 
          phpar(30) =  17 
          phpar(33) =   6 
          phpar(34) =   7 
          phpar(43) =  40 
          phpar(48) =   8 
          phpar(58) =  30 
          phpar(60) = 254 
          phpar(61) =  20 
          phpar(62) =   2 
          phpar(63) =  90 
        end 
        if notesize = 6 
          phpar(2) =    7 
          phpar(3) =    8 
          phpar(5) =    6 
          phpar(6) =   34 
          phpar(7) =   18             /* &dA01/20/05&d@ changed from 24 to 18 and made explicit
          phpar(12) =  35 
          phpar(17) =   7 
          phpar(19) =   2 
          phpar(20) =   9 
          phpar(29) =   1 
          phpar(30) =   8 
          phpar(33) =   3 
          phpar(34) =   4 
          phpar(43) =  30 
          phpar(48) =   4 
          phpar(58) =  10 
          phpar(60) = 110 
          phpar(61) =  10 
          phpar(62) =   1 
          phpar(63) =  90 
        end 
        if notesize = 21 
          phpar(2) =   19 
          phpar(3) =   28 
          phpar(5) =   18             /* &dA12/18/04&d@ changed from 19 to 18 
          phpar(6) =  110 
          phpar(7) =   88             /* &dA01/20/05&d@ made explicit 
          phpar(12) = 100 
          phpar(17) =  21 
          phpar(19) =   6 
          phpar(20) =  30 
          phpar(29) =   3 
          phpar(30) =  22 
          phpar(33) =   8             /* &dA12/18/04&d@ changed from 9 to 8 
          phpar(34) =  11 
          phpar(43) =  30 
          phpar(48) =  13 
          phpar(58) =  30 
          phpar(60) = 381 
          phpar(61) =  30 
          phpar(62) =   3 
          phpar(63) =  80 
        end 
&dA 
&dA &d@    New &dA12/31/08&d@   notesize 16 parameters added 
&dA 
        if notesize = 16 
          phpar(2) =   16 
          phpar(3) =   22 
          phpar(5) =   15 
          phpar(6) =   90 
          phpar(7) =   64 
          phpar(12) =  80 
          phpar(17) =  16 
          phpar(19) =   4 
          phpar(20) =  23 
          phpar(29) =   2 
          phpar(30) =  18 
          phpar(33) =   6 
          phpar(34) =   9 
          phpar(43) =  30 
          phpar(48) =   9 
          phpar(58) =  30 
          phpar(60) = 280 
          phpar(61) =  22 
          phpar(62) =   2 
          phpar(63) =  80 
          ++phpar(3) 

        end 
&dA 
&dA &d@    New &dA12/18/04&d@   notesize 18 parameters added 
&dA 
        if notesize = 18 
          phpar(2) =   17 
          phpar(3) =   26 
          phpar(5) =   17 
          phpar(6) =  100 
          phpar(7) =   72             /* &dA01/20/05&d@ made explicit 
          phpar(12) =  90 
          phpar(17) =  18 
          phpar(19) =   5 
          phpar(20) =  26 
          phpar(29) =   3 
          phpar(30) =  20 
          phpar(33) =   7 
          phpar(34) =   9 
          phpar(43) =  30 
          phpar(48) =  10 
          phpar(58) =  30 
          phpar(60) = 326 
          phpar(61) =  26 
          phpar(62) =   2 
          phpar(63) =  80 
        end 

        phpar(1) = 30 
&dA &d@       phpar(2) = 18 * notesize / 16 
&dA &d@       phpar(3) = 19 * notesize + 8 / 16 
&dA &d@       phpar(4) = 3 
&dA &d@       phpar(5) = 13 * notesize + 2 / 16 
&dA &d@       phpar(6) = 80 
&dA &d@       phpar(7) = 4 * notesize             /* &dA01/20/05&d@ made explicit 
&dA &d@       phpar(8) = 200 
&dA &d@       phpar(9) = 2250 
        phpar(10) = 26 * notesize / 16 
        phpar(11) = 200 * notesize / 16 
&dA &d@       phpar(12) = 80 
        phpar(14) = 40 * notesize / 16 
        phpar(16) = 24 * notesize / 16 
&dA &d@       phpar(17) = 14 
        phpar(18) = 2 * notesize 
&dA &d@       phpar(19) = 4 
&dA &d@       phpar(20) = 20 
&dA &d@       phpar(21) = 300 
&dA &d@       phpar(22) = 6 * notesize / 16       (not used) 
&dA &d@       phpar(23) = 60 * notesize / 16      (not used) 
&dA &d@       phpar(24) = 7 * notesize + 2 / 7    (not used) 
&dA &d@       phpar(25) = notesize + 1            (not used) 
&dA &d@       phpar(26) = 15 * notesize / 16      (not used) 
&dA &d@       phpar(27) = 0                       (not used) 
&dA &d@       phpar(28) = 0 - 32 * notesize / 16  (not used) 
&dA &d@       phpar(29) = 2 * notesize + 8 / 16 
&dA &d@       phpar(30) += phpar(29) 
        phpar(31) = 24 * notesize / 16 
        phpar(32) = 44 * notesize / 16 
&dA &d@       phpar(33) = 6 * notesize / 16 
&dA &d@       phpar(34) = 8 * notesize / 16 
        phpar(35) = 14 * notesize / 16 
        phpar(36) = 8 * notesize / 16 
        phpar(37) = 20 * notesize / 16 
        phpar(38) = 20 * notesize / 16 
        phpar(39) = 50 * notesize / 16 
        phpar(40) = 15 * notesize + 4 / 16 
        phpar(41) = pvpar(5) 
        phpar(42) = notesize * 4 
&dA &d@       phpar(43) = 40 
        phpar(44) = notesize 
        phpar(45) = notesize 
        phpar(46) = 13 * notesize / 16 
        phpar(47) = 2 * notesize / 5 
&dA &d@       phpar(48) = 10 * notesize / 16 
&dA &d@       phpar(49) = 24 * notesize / 16 
&dA &d@       phpar(50) = 12 * notesize / 16 
        phpar(51) = 31 * notesize / 16 
        phpar(52) = 19 * notesize / 16 
        phpar(53) = 4 * notesize / 16 
        phpar(54) = 18 * notesize / 16 
        phpar(55) = 6 * notesize / 16 
        phpar(56) = 12 * notesize / 16 
        phpar(57) = 2 * notesize 
        phpar(59) = 3 * notesize / 5 
&dA 
&dA &d@    New &dA12/31/08&d@ parameters added for notesize 16 
&dA 
        if notesize = 16 
          phpar(42) =  56 
        end 

&dA 
&dA &d@    New &dA12/18/04&d@ parameters added for notesize 18 
&dA 
        if notesize = 18 
          phpar(11) = 225 
          phpar(39) =  50 
          phpar(42) =  67 
        end 

        if notesize = 21 
          phpar(11) = 250 
          phpar(39) =  50 
          phpar(42) =  76 
        end 
&dA 
&dA &d@    Other parameters and variables 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        if notesize = 14 
          expar(1) = 240 
          expar(2) = 324 
          expar(3) = 254 
          expar(4) = 324 
          expar(5) = 256 
          expar(6) = 324 
          expar(7) = 260 
          expar(8) = 324 
        end 
        if notesize = 6 
          expar(1) = 102 
          expar(2) = 139 
          expar(3) = 106 
          expar(4) = 146 
          expar(5) = 107 
          expar(6) = 144 
          expar(7) = 109 
          expar(8) = 148 
        end 
        if notesize = 21 
          expar(1) = 360 
          expar(2) = 486 
          expar(3) = 381 
          expar(4) = 498 
          expar(5) = 386 
          expar(6) = 486 
          expar(7) = 390 
          expar(8) = 498 
        end 
&dA 
&dA &d@   notesize 16 added &dA12/31/08 
&dA 
        if notesize = 16 
          expar(1) = 278 
          expar(2) = 362 
          expar(3) = 290 
          expar(4) = 372 
          expar(5) = 296 
          expar(6) = 368 
          expar(7) = 298 
          expar(8) = 376 
        end 
&dA 
&dA &d@   notesize 18 added &dA12/18/04 
&dA 
        if notesize = 18 
          expar(1) = 308 
          expar(2) = 424 
          expar(3) = 326 
          expar(4) = 428 
          expar(5) = 330 
          expar(6) = 422 
          expar(7) = 334 
          expar(8) = 432 
        end 

        loop for t1 = 1 to 223 
          pos(t1) = urpos(t1) * notesize 
        repeat 
&dA 
&dA &d@   Dotted mask   (modified &dA10/23/03&d@)  &dIOK&d@ 
&dA 
        if notesize = 14 
          gapsize = 5 
          cycle = dup("1",7) // dup("0",3) 
        end 
        if notesize = 6 
          gapsize = 3 
          cycle = dup("1",4) // dup("0",2) 
        end 
        if notesize = 21 
          gapsize = 12 
          cycle = dup("1",15) // dup("0",9) 
        end 
        if notesize = 16                       /* New size-16 mask &dA12/31/08&d@ &dNnot OK
          gapsize = 9 
          cycle = dup("1",11) // dup("0",7) 
        end 
        if notesize = 18                       /* New size-18 mask &dA12/18/04&d@ &dIOK
          gapsize = 10 
          cycle = dup("1",12) // dup("0",8) 
        end 

        dotted = "" 
        t1 = 2500 - (2 * gapsize) 
        loop 
          dotted = dotted // cycle 
        repeat while len(dotted) < t1 
&dA 
&dA &d@   scf can be 
&dA &d@     (1) old notesize (4 to 24)   (requires change in scf) 
&dA &d@     (2) beamfont  (101 to 114)   (independent of notesize) 
&dA &d@     (3) text font (31 to 48)     (actual font depends on notesize) 
&dA &d@     (4) 300 (ties)                             " 
&dA &d@     (5) 320 (brackets)                         " 
&dA &d@     (6) 400 (wedges)                           " 
&dA &d@     (7) 30 (variable pitch screen fonts, display only) 
&dA &d@     (8) 200 (fixed pitch screen font, display only) 
&dA 

        if scf > 0 and scf < 25 
          scf = notesize 
        end 

        pz = revsizes(notesize) 
        loop for t1 = 30 to 48 
          revmap(t1) = XFonts(pz,t1-29) 
        repeat 
                    
        revmap(200) = ors(",,,,----....////////////"{notesize})   /* former scfont()
        revmap(300) = pz + TIE_OFFSET 
        if notesize < 10 
          revmap(320) = SMALL_BRACK 
        else 
          revmap(320) = LARGE_BRACK 
        end 
        revmap(400) = ors("&&&&&&&&''''''((((()))))"{notesize})   /* former wedgefont()

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 37. move_to_loc (hh,kk)                                     ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose: construct a Postscript moveto entry from          ³ 
&dA &d@³                PCL coordinates                                ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Input:  hh     x location                                   ³ 
&dA &d@³           kk     y location                                   ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Output  string mtloc                                        ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure move_to_loc (hh,kk)                          
        int t1,t2,t3,t4 
        int hh,kk 

        getvalue hh,kk 

        hh += 50                  /* magic number 
        t1 = hh * 10 * 24         /* in thousands of Postscript units 

        t3 = 3150 - kk            /* also a magic number 
        t2 = t3 * 10 * 24 

        mtloc = "" 
        if t1 < 0 
          mtloc = mtloc // "-" 
          t1 = 0 - t1 
        end 
        t4 = t1 / 1000 
        t3 = rem 
        mtloc = mtloc // chs(t4) // "." 
        if t3 < 100 
          mtloc = mtloc // "0" 
        end 
        if t3 < 10 
          mtloc = mtloc // "0" 
        end 
        mtloc = mtloc // chs(t3) 

        mtloc = mtloc // " " 

        if t2 < 0 
          mtloc = mtloc // "-" 
          t2 = 0 - t2 
        end 
        t4 = t2 / 1000 
        t3 = rem 
        mtloc = mtloc // chs(t4) // "." 
        if t3 < 100 
          mtloc = mtloc // "0" 
        end 
        if t3 < 10 
          mtloc = mtloc // "0" 
        end 
        mtloc = mtloc // chs(t3) 

        mtloc = mtloc // " moveto" 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 38. compute_delta_move (lastx,lasty,hh,kk)                  ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose: construct a Postscript delta move entry from      ³ 
&dA &d@³                PCL coordinates                                ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Input:  lastx  former  x location                           ³ 
&dA &d@³           lasty  former  y location                           ³ 
&dA &d@³           hh     current x location                           ³ 
&dA &d@³           kk     current y location                           ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Output  string mtloc                                        ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure compute_delta_move (lastx,lasty,hh,kk) 
        int hh,kk,lastx,lasty 
        int t1,t2,t3,t4 

        getvalue lastx,lasty,hh,kk 

        hh = hh - lastx 
        kk = lasty - kk 

        mtloc = "" 

        if hh < 0 
          hh = 0 - hh 
          mtloc = mtloc // "-" 
        end 
        t1 = hh * 10 * 24          /* in thousands of Postscript units 

        if t1 = 0 
          mtloc = mtloc // "0" 
        else 
          t4 = t1 / 1000 
          t3 = rem 
          if t4 > 0 
            mtloc = mtloc // chs(t4) // "." 
            if t3 < 100 
              mtloc = mtloc // "0" 
            end 
            if t3 < 10 
              mtloc = mtloc // "0" 
            end 
            mtloc = mtloc // chs(t3) 
          else 
            mtloc = mtloc // "0." 
            if t1 < 100 
              mtloc = mtloc // "0" 
            end 
            if t1 < 10 
              mtloc = mtloc // "0" 
            end 
            mtloc = mtloc // chs(t1) 
          end 
        end 

        mtloc = mtloc // " " 

        if kk < 0 
          kk = 0 - kk 
          mtloc = mtloc // "-" 
        end 
        t2 = kk * 10 * 24          /* in thousands of Postscript units 

        if t2 = 0 
          mtloc = mtloc // "0" 
        else 
          t4 = t2 / 1000 
          t3 = rem 
          if t4 > 0 
            mtloc = mtloc // chs(t4) // "." 
            if t3 < 100 
              mtloc = mtloc // "0" 
            end 
            if t3 < 10 
              mtloc = mtloc // "0" 
            end 
            mtloc = mtloc // chs(t3) 
          else 
            mtloc = mtloc // "0." 
            if t2 < 100 
              mtloc = mtloc // "0" 
            end 
            if t2 < 10 
              mtloc = mtloc // "0" 
            end 
            mtloc = mtloc // chs(t2) 
          end 
        end 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 39. build_page_pdict                                        ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose: construct a customized Postscript                 ³ 
&dA &d@³                dictionary for a page                          ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Input:  list of fonts and glyphs in table ZZ                ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Output  custormized Postscript dictionary                   ³ 
&dA &d@³             in table PD                                       ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure build_page_pdict 

        str data.100 
        str temp.10000 

        int font,glyph 
        int t1,t2,t3,t4,t5 
        int a(16) 
        int glyph_loc(256) 
        int gcount 
        int glyphs(256) 
        int font_loc 

        pd_cnt = 0 
        zpnt = 1 
BPD_A: 
        tget [ZZ,zpnt] data .t6 font .t9 glyph 
        if data{1} = "$" 
          goto BPD_END 
        end 
        if data{1} = "f" 
          ++pd_cnt 
          tput [PD,pd_cnt] 
          tget [XX,font] t1 
          ++pd_cnt 
          tput [PD,pd_cnt] 
          font_loc = t1 
          t5 = 0 
          loop for t3 = 1 to 16 
            tget [XX,t1] a(1) a(2) a(3) a(4) a(5) a(6) a(7) a(8) a(9) a(10) a(11) a(12) a(13) a(14) a(15) a(16)
            ++t1 
            loop for t4 = 1 to 16 
              ++t5 
              glyph_loc(t5) = a(t4) 
            repeat 
          repeat 
          loop for t3 = 1 to 7 
            tget [XX,t1] data 
            ++t1 
            ++pd_cnt 
            tput [PD,pd_cnt] ~data 
          repeat 

          zpnt2 = zpnt + 2 
          gcount = 1 
BPD_B: 
          tget [ZZ,zpnt2] data .t9 glyph 
          tget [ZZ,zpnt2+1] temp 
          temp = temp // pad(4) 
          glyphs(gcount) = glyph 
          ++gcount 
          if data{4} = "c" and temp{4} = "c" 
            ++pd_cnt 
            tput [PD,pd_cnt]     dup ~glyph  /mus_~glyph  put 
            ++zpnt2 
            goto BPD_B 
          else 
            ++pd_cnt 
            tput [PD,pd_cnt]     ~glyph  /mus_~glyph  put 
            zpnt = zpnt2 + 1 
          end 

          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]   /BuildChar 
          ++pd_cnt 
          tput [PD,pd_cnt]     {0 begin 
          ++pd_cnt 
          tput [PD,pd_cnt]       /char exch def 
          ++pd_cnt 
          tput [PD,pd_cnt]       /fontdict exch def 
          ++pd_cnt 
          tput [PD,pd_cnt]       /charname fontdict /Encoding get char get def
          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]       /charinfo fontdict /CharData get charname get def
          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]       /wx charinfo 0 get def 
          ++pd_cnt 
          tput [PD,pd_cnt]       /charbbox charinfo 1 4 getinterval def 
          ++pd_cnt 
          tput [PD,pd_cnt]       wx 0 charbbox aload pop setcachedevice 
          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]       charinfo 5 get charinfo 6 get true 
          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]       fontdict /imagemaskmatrix get 
          ++pd_cnt 
          tput [PD,pd_cnt]         dup 4 charinfo 7 get put 
          ++pd_cnt 
          tput [PD,pd_cnt]         dup 5 charinfo 8 get put 
          ++pd_cnt 
          tput [PD,pd_cnt]       charinfo 9 1 getinterval cvx 
          ++pd_cnt 
          tput [PD,pd_cnt]       imagemask 
          ++pd_cnt 
          tput [PD,pd_cnt]       end 
          ++pd_cnt 
          tput [PD,pd_cnt]     } def 
          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]   /BuildChar load 0 6 dict put 
          ++pd_cnt 
          tput [PD,pd_cnt] 

          tget [XX,t1] data 
          ++t1                      /* imagemask 
          ++pd_cnt 
          tput [PD,pd_cnt] ~data 

          tget [XX,t1] data 
          ++t1                      /* /CharData xxx dict def 
          ++pd_cnt 
          tput [PD,pd_cnt]   /CharData ~gcount  dict def 
          ++pd_cnt 
          tput [PD,pd_cnt]   CharData begin 

          loop for t3 = 1 to gcount - 1 
            t4 = glyphs(t3) 
            t5 = glyph_loc(t4) + font_loc 
            tget [XX,t5] data .t8 t2 
            if t2 <> t4 
              if (Debugg & 0x12) > 0 
                pute Logic Error ~data   in building a page 
                pute ~t2  ~t4 
              end 
              stop 
            end 
            ++pd_cnt 
            tput [PD,pd_cnt] ~data 
            loop 
              ++t5 
              tget [XX,t5] data 
              ++pd_cnt 
              tput [PD,pd_cnt] ~data 
            repeat while data{1} <> ">" 
          repeat 

          t5 = glyph_loc(256) + font_loc 
          loop for t3 = 1 to 5 
            tget [XX,t5] data 
            ++t5 
            ++pd_cnt 
            tput [PD,pd_cnt] ~data 
          repeat 

          goto BPD_A 

        end 
       
BPD_END: 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 40. build_regular_slur_dict (ns,t1,t2,t3,t4,t5,t6)               ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Purpose: construct a customized Postscript                      ³ 
&dA &d@³                dictionary for regular slurs on                     ³ 
&dA &d@³                a page                                              ³ 
&dA &d@³                                                                    ³ 
&dA &d@³   Inputs:  table ST  contains data for regular slurs               ³ 
&dA &d@³            int   ns      number of slurs in dictionary             ³ 
&dA &d@³            int   t1      table pointer to first entry              ³ 
&dA &d@³            int   t2      table pointer to last data entry          ³ 
&dA &d@³            int   t3      maximum height for all slurs              ³ 
&dA &d@³            int   t4      maximum width for all slurs               ³ 
&dA &d@³            int   t5      dictionary number (1 or 2, at the moment) ³ 
&dA &d@³            int   t6      page number                               ³ 
&dA &d@³            int   pt_cnt2 pointer to next available location        ³ 
&dA &d@³                            in auxillary PostScript output table    ³ 
&dA &d@³            int   sd_cnt  pointer to next available location        ³ 
&dA &d@³                            in the slur dictionary                  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³   Output:  table SD  custormized Postscript dictionaries           ³ 
&dA &d@³                        of slurs                                    ³ 
&dA &d@³            int   pt_cnt2 pointer to next available location        ³ 
&dA &d@³                            in auxillary PostScript output table    ³ 
&dA &d@³            int   sd_cnt  pointer to next available location        ³ 
&dA &d@³                            in the slur dictionary                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure build_regular_slur_dict (ns, t1, t2, t3, t4, t5, t6) 
        str data.100
        str temp.1000

        int ns 
        int font,glyph 
        int t1,t2,t3,t4,t5,t6,t7 
        int a1,a2,a3,a4,a5,a6,a7,a8 
        int hh,kk 

        getvalue ns,t1,t2,t3,t4,t5,t6 

        t4 = t4 + 7 / 8 * 8                 /* allign maximum width 
                                            /* on byte boundary 
&dA 
&dA &d@    Start up the auxiliary PostScript output table for this page number 
&dA 
        a6 = (t5 + 1) * 1000 + t6 
        ++pt_cnt2 
        tput [PT2,pt_cnt2] /Bitfont~a6  findfont 24 scalefont setfont 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt] 9 dict dup begin 
        ++sd_cnt 
        tput [SD,sd_cnt]   /FontType 3 def 
        ++sd_cnt 
        tput [SD,sd_cnt]   /FontMatrix [1 0 0 1 0 0] def 
&dA 
&dA &d@    Construct coordinates for font bounding box 
&dA 
        temp = "" 
        a1 = t4 / 100 
        a2 = rem 
        temp = temp // chs(a1) // "." 
        if a2 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a2) // " " 

        a1 = t3 / 100 
        a2 = rem 
        temp = temp // chs(a1) // "." 
        if a2 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a2) // " 0 0" 

        ++sd_cnt 
        tput [SD,sd_cnt]   /FontBBox [~temp ] def 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /Encoding 256 array def 
        ++sd_cnt 
        tput [SD,sd_cnt]   0 1 255 {Encoding exch /.b46 notdef put} for 
        ++sd_cnt 
        tput [SD,sd_cnt]   Encoding 

        a2 = 32 
        loop for a1 = 1 to ns 
          if a1 = ns 
            ++sd_cnt 
            tput [SD,sd_cnt]   ~a2  /mus_~a2  put 
          else 
            ++sd_cnt 
            tput [SD,sd_cnt]   dup ~a2  /mus_~a2  put 
          end 
          ++a2 
          if a2 = 128 
            a2 = 160 
          end 
        repeat 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /BuildChar 
        ++sd_cnt 
        tput [SD,sd_cnt]     {0 begin 
        ++sd_cnt 
        tput [SD,sd_cnt]       /char exch def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /fontdict exch def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charname fontdict /Encoding get char get def
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charinfo fontdict /CharData get charname get def
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       /wx charinfo 0 get def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charbbox charinfo 1 4 getinterval def 
        ++sd_cnt 
        tput [SD,sd_cnt]       wx 0 charbbox aload pop setcachedevice 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       charinfo 5 get charinfo 6 get true 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       fontdict /imagemaskmatrix get 
        ++sd_cnt 
        tput [SD,sd_cnt]         dup 4 charinfo 7 get put 
        ++sd_cnt 
        tput [SD,sd_cnt]         dup 5 charinfo 8 get put 
        ++sd_cnt 
        tput [SD,sd_cnt]       charinfo 9 1 getinterval cvx 
        ++sd_cnt 
        tput [SD,sd_cnt]       imagemask 
        ++sd_cnt 
        tput [SD,sd_cnt]       end 
        ++sd_cnt 
        tput [SD,sd_cnt]     } def 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /BuildChar load 0 6 dict put 
        ++sd_cnt 
        tput [SD,sd_cnt] 

        ++sd_cnt 
        tput [SD,sd_cnt]   /imagemaskmatrix [100 0 0 -100 0 0] def 
        ++sd_cnt 
        tput [SD,sd_cnt] 

        ++sd_cnt 
        tput [SD,sd_cnt]   /CharData ~(ns+1)  dict def 
        ++sd_cnt 
        tput [SD,sd_cnt]   CharData begin 

        a1 = t1 - 1 
        a8 = 32 
        loop for a2 = 1 to ns 
          ++a1 
          tget [ST,a1] temp 
          if temp con "slur at" 
            a3 = mpt 
            temp = temp{a3+9..} 
            tput [Y,1] ~temp 
            tget [Y,1] hh kk 
          end 
          ++a1 
          tget [ST,a1] temp 
&dA 
&dA &d@      Determine height and width of this slur 
&dA 
          a4 = 0                                 /* height counter 
          a5 = 0                                 /* max width 
          loop for a3 = a1+1 to t2               /* t2 is end of table 
            tget [ST,a3] temp 
            temp = trm(temp) 
            temp = temp // pad(1) 
            if temp{1} = ":"                     /* terminating ":" 
              a3 = t2                            /* exit loop 
            else 
              ++a4                               /* increment height 
              a6 = len(temp) 
              if a6 > a5 
                a5 = a6 
              end 
            end 
          repeat 
          a5 = a5 + 7 / 8 * 8                    /* allign width on byte boundary
&dA 
&dA &d@      With height now determined, you can now locate the slur 
&dA 
          t3 = hh + 50               /* magic number 
          t3 = t3 * 10 * 24 
             
          t4 = 3150 - kk             /* also a magic number 
          t4 -= a4                   /* position to bottom of image 
          t4 = t4 + 1                /* another magic number 
          t4 = t4 * 10 * 24 

          temp = oct(a8) 
          if len(temp) < 3 
            temp = "0" // temp 
          end 
&dA 
&dA &d@      Convert t3 and t4 to decimals (i.e., divide by 1000) 
&dA 
          data = "" 
          a6 = t3 / 1000 
          a7 = rem 
          data = data // chs(a6) // "." 
          if a7 < 100 
            data = data // "0" 
          end 
          if a7 < 10 
            data = data // "0" 
          end 
          data = data // chs(a7) // " " 

          a6 = t4 / 1000 
          a7 = rem 
          data = data // chs(a6) // "." 
          if a7 < 100 
            data = data // "0" 
          end 
          if a7 < 10 
            data = data // "0" 
          end 
          data = data // chs(a7) 

          ++pt_cnt2 
          tput [PT2,pt_cnt2] ~data   moveto (\~temp ) show 

&dA 
&dA &d@      Construct first 9 elements of def matrix 
&dA 
          temp = "[ 0 0 0 " 
          a6 = a5 / 100 
          a7 = rem 
          temp = temp // chs(a6) // "." 
          if a7 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a7) // " " 

          a6 = a4 / 100 
          a7 = rem 
          temp = temp // chs(a6) // "." 
          if a7 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a7) // " " 

          temp = temp // chs(a5) // " " // chs(a4) // " -0.5 " // chs(a4) // " "

          ++sd_cnt 
          tput [SD,sd_cnt]   /mus_~a8  ~temp  < 
          ++a8 
          if a8 = 128 
            a8 = 160 
          end 
              
&dA 
&dA &d@       Build the definition string 
&dA 
          data = "" 
          loop for a3 = 1 to a4 
            ++a1                                 /* next record
            tget [ST,a1] temp 
            temp = temp // pad(a5) 
&dA 
&dA &d@       Convert this to a hex string 
&dA 
            t7 = 0 
            loop for t4 = 1 to a5 
              if t7 = 0 
                t7 = 0x04 
                if temp{t4} = "x" 
                  t3 = 0x08 
                else 
                  t3 = 0 
                end 
              else 
                if temp{t4} = "x" 
                  t3 += t7 
                end 
                t7 >>= 1 
                if t7 = 0 
                  if t3 < 10 
                    data = data // chs(t3) 
                  else 
                    data = data // chr(55 + t3) 
                  end 
                  if len(data) = 60 
                    ++sd_cnt 
                    tput [SD,sd_cnt] ~data 
                    data = "" 
                  end 
                end 
              end 
            repeat 
          repeat 
          if len(data) > 0 
            ++sd_cnt 
            tput [SD,sd_cnt] ~data 
          end 
          ++sd_cnt 
          tput [SD,sd_cnt] > ] def 
          ++a1                              /* skip terminating ":" 
          tget [ST,a1] temp 
        repeat 
        ++sd_cnt 
        tput [SD,sd_cnt]   /.b46 notdef [ 0 0 0 0 0 1 0 0 <> ] def 
        ++sd_cnt 
        tput [SD,sd_cnt]   end 

        a6 = (t5 + 1) * 1000 + t6 
        ++sd_cnt 
        tput [SD,sd_cnt]   /UniqueID ~a6  def 
        ++sd_cnt 
        tput [SD,sd_cnt] end 
        ++sd_cnt 
        tput [SD,sd_cnt] /Bitfont~a6  exch definefont pop 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 41. build_long_slur_dict (t1,t2,t3,t4)                         ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose: construct a customized Postscript                    ³ 
&dA &d@³                dictionary for one long slur                      ³ 
&dA &d@³                                                                  ³ 
&dA &d@³   Inputs:  table SST contains data for long slurs                ³ 
&dA &d@³            int   t1      table pointer to first entry            ³ 
&dA &d@³            int   t2      table pointer to last data entry        ³ 
&dA &d@³            int   t3      dictionary number (3 and climbing)      ³ 
&dA &d@³            int   t4      page number                             ³ 
&dA &d@³            int   pt_cnt2 pointer to next available location      ³ 
&dA &d@³                            in auxillary PostScript output table  ³ 
&dA &d@³            int   sd_cnt  pointer to next available location      ³ 
&dA &d@³                            in the slur dictionary                ³ 
&dA &d@³                                                                  ³ 
&dA &d@³   Output:  table SD  custormized Postscript dictionaries         ³ 
&dA &d@³                        of slurs                                  ³ 
&dA &d@³            int   pt_cnt2 pointer to next available location      ³ 
&dA &d@³                            in auxillary PostScript output table  ³ 
&dA &d@³            int   sd_cnt  pointer to next available location      ³ 
&dA &d@³                            in the slur dictionary                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure build_long_slur_dict (t1, t2, t3, t4) 
        str data.100
        str temp.1000

        int font,glyph 
        int t1,t2,t3,t4,t5,t6 
        int a1,a3,a4,a5,a6,a7,a8 
        int hh,kk 

        getvalue t1,t2,t3,t4 
&dA 
&dA &d@    Add to the auxiliary PostScript output table for this page 
&dA 
        a6 = (t3 + 1) * 1000 + t4 
        ++pt_cnt2 
        tput [PT2,pt_cnt2] /Bitfont~a6  findfont 24 scalefont setfont 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt] 9 dict dup begin 
        ++sd_cnt 
        tput [SD,sd_cnt]   /FontType 3 def 
        ++sd_cnt 
        tput [SD,sd_cnt]   /FontMatrix [1 0 0 1 0 0] def 

        a1 = t1
        
        tget [SST,a1] temp 
        if temp con "location" 
          a3 = mpt 
          temp = temp{a3+10..} 
          tput [Y,1] ~temp 
          tget [Y,1] hh kk 
        end 
        ++a1 
        tget [SST,a1] temp 
&dA 
&dA &d@      Determine height and width of this slur 
&dA 
        a4 = 0                                 /* height counter 
        a5 = 0                                 /* max width 
        loop for a3 = a1+1 to t2               /* t2 is end of table 
          tget [SST,a3] temp 
          temp = trm(temp) 
          temp = temp // pad(1) 
          if temp{1} = ":"                     /* terminating ":" 
            if a3 <> t2 
              stop 
            end 
          else 
            ++a4                               /* increment height 
            a6 = len(temp) 
            if a6 > a5 
              a5 = a6 
            end 
          end 
        repeat 
        a5 *= 4                                /* convert to bit length 
&dA 
&dA &d@      With height now determined, you can now locate the slur 
&dA 
        t6 = hh + 50               /* magic number 
        t6 = t6 * 10 * 24 

        t5 = 3150 - kk             /* also a magic number 
        t5 -= a4                   /* position to bottom of image 
        t5 = t5 + 1                /* another magic number 
        t5 = t5 * 10 * 24 
&dA 
&dA &d@      Convert t6 and t5 to decimals (i.e., divide by 1000) 
&dA 
        data = "" 
        a6 = t6 / 1000 
        a7 = rem 
        data = data // chs(a6) // "." 
        if a7 < 100 
          data = data // "0" 
        end 
        if a7 < 10 
          data = data // "0" 
        end 
        data = data // chs(a7) // " " 

        a6 = t5 / 1000 
        a7 = rem 
        data = data // chs(a6) // "." 
        if a7 < 100 
          data = data // "0" 
        end 
        if a7 < 10 
          data = data // "0" 
        end 
        data = data // chs(a7) 

        ++pt_cnt2 
        tput [PT2,pt_cnt2] ~data   moveto (\040) show 
&dA 
&dA &d@    Construct coordinates for font bounding box 
&dA 
        temp = "" 
        a6 = a5 / 100 
        a7 = rem 
        temp = temp // chs(a6) // "." 
        if a7 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a7) // " " 

        a6 = a4 / 100 
        a7 = rem 
        temp = temp // chs(a6) // "." 
        if a7 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a7) // " 0 0" 

        ++sd_cnt 
        tput [SD,sd_cnt]   /FontBBox [~temp ] def 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /Encoding 256 array def 
        ++sd_cnt 
        tput [SD,sd_cnt]   0 1 255 {Encoding exch /.b46 notdef put} for 
        ++sd_cnt 
        tput [SD,sd_cnt]   Encoding 
        ++sd_cnt 
        tput [SD,sd_cnt]   32 /mus_32  put 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /BuildChar 
        ++sd_cnt 
        tput [SD,sd_cnt]     {0 begin 
        ++sd_cnt 
        tput [SD,sd_cnt]       /char exch def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /fontdict exch def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charname fontdict /Encoding get char get def
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charinfo fontdict /CharData get charname get def
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       /wx charinfo 0 get def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charbbox charinfo 1 4 getinterval def 
        ++sd_cnt 
        tput [SD,sd_cnt]       wx 0 charbbox aload pop setcachedevice 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       charinfo 5 get charinfo 6 get true 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       fontdict /imagemaskmatrix get 
        ++sd_cnt 
        tput [SD,sd_cnt]         dup 4 charinfo 7 get put 
        ++sd_cnt 
        tput [SD,sd_cnt]         dup 5 charinfo 8 get put 
        ++sd_cnt 
        tput [SD,sd_cnt]       charinfo 9 1 getinterval cvx 
        ++sd_cnt 
        tput [SD,sd_cnt]       imagemask 
        ++sd_cnt 
        tput [SD,sd_cnt]       end 
        ++sd_cnt 
        tput [SD,sd_cnt]     } def 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /BuildChar load 0 6 dict put 
        ++sd_cnt 
        tput [SD,sd_cnt] 


        ++sd_cnt 
        tput [SD,sd_cnt]   /imagemaskmatrix [100 0 0 -100 0 0] def 
        ++sd_cnt 
        tput [SD,sd_cnt] 

        ++sd_cnt 
        tput [SD,sd_cnt]   /CharData 2 dict def 
        ++sd_cnt 
        tput [SD,sd_cnt]   CharData begin 
&dA 
&dA &d@      Construct first 9 elements of def matrix 
&dA 
        temp = "[ 0 0 0 " 
        a6 = a5 / 100 
        a7 = rem 
        temp = temp // chs(a6) // "." 
        if a7 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a7) // " " 

        a6 = a4 / 100 
        a7 = rem 
        temp = temp // chs(a6) // "." 
        if a7 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a7) // " " 

        temp = temp // chs(a5) // " " // chs(a4) // " -0.5 " // chs(a4) // " "

        ++sd_cnt 
        tput [SD,sd_cnt]   /mus_32 ~temp  < 
&dA 
&dA &d@       Build the definition strings 
&dA 
        data = "" 
        loop for a3 = 1 to a4 
          ++a1                                 /* next record 
          tget [SST,a1] temp 
&dA 
&dA &d@       This is already a hex string 
&dA 
          loop for a8 = 1 to len(temp) 
            data = data // temp{a8} 
            if len(data) = 60 
              ++sd_cnt 
              tput [SD,sd_cnt] ~data 
              data = "" 
            end 
          repeat 
        repeat 
        if len(data) > 0 
          ++sd_cnt 
          tput [SD,sd_cnt] ~data 
        end 

        ++sd_cnt 
        tput [SD,sd_cnt] > ] def 

        ++sd_cnt 
        tput [SD,sd_cnt]   /.b46 notdef [ 0 0 0 0 0 1 0 0 <> ] def 
        ++sd_cnt 
        tput [SD,sd_cnt]   end 

        a6 = (t3 + 1) * 1000 + t4 
        ++sd_cnt 
        tput [SD,sd_cnt]   /UniqueID ~a6  def 
        ++sd_cnt 
        tput [SD,sd_cnt] end 
        ++sd_cnt 
        tput [SD,sd_cnt] /Bitfont~a6  exch definefont pop 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 42. vpage_limits (topp,bottomm)                                    ³ 
&dA &d@³                                                                      ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Purpose: determine top and bottom page limits                     ³ 
&dA &d@³                ignoring the caption at the bottom                    ³ 
&dA &d@³                                                                      ³ 
&dA &d@³   Inputs:  gstr  The struction of this string was determined         ³ 
&dA &d@³                  by the instruction  setup gstr,300,3100,3           ³ 
&dA &d@³                  According to the documentation, the first 20        ³ 
&dA &d@³                  bytes contain display information.  In particular,  ³ 
&dA &d@³                  bytes 13-14 contain the top display boundary;       ³ 
&dA &d@³                  and bytes 17-18 contain the bottom display          ³ 
&dA &d@³                  boundary.  The top boundary, we can use; but        ³ 
&dA &d@³                  the bottom boundary includes the bottom             ³ 
&dA &d@³                  caption, so we must look above this.                ³ 
&dA &d@³                                                                      ³ 
&dA &d@³   Output:  int   topp    =  top_limit                                ³ 
&dA &d@³            int   bottomm =  bottom_limit                             ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure vpage_limits (topp,bottomm) 
        int topp,bottomm 
        int a1,a2,a3,a4,a5 
&dA 
&dA &d@    Get top limit 
&dA 
        topp = 10000 
        a3 = 20 
        loop for a1 = 1 to 3099 
          loop for a2 = 1 to 300 
            ++a3 
            if gstr{a3} <> chr(0) 
              topp = a1 
              goto BBB 
            end 
          repeat 
        repeat 
BBB: 
&dA 
&dA &d@    Get bottom limit 
&dA 
        a5 = 0 
        loop for a1 = 3050 to 1 step -1 
          loop for a2 = 1 to 300 
            a3 = a1 * 300 + a2 + 20 
            if gstr{a3} <> chr(0) 
              a5 = a1 
              goto BBB1 
            end 
          repeat 
        repeat 
BBB1: 
        bottomm = a5 

        passback topp,bottomm 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 43. hpage_limits (leftt,rightt)                                    ³ 
&dA &d@³                                                                      ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Purpose: determine left and right page limits for those           ³ 
&dA &d@³                pages that do not have a system                       ³ 
&dA &d@³                                                                      ³ 
&dA &d@³   Inputs:  gstr  The structure of this string was determined         ³ 
&dA &d@³                  by the instruction  setup gstr,300,3100,3           ³ 
&dA &d@³                  According to the documentation, the first 20        ³ 
&dA &d@³                  bytes contain display information.  In particular,  ³ 
&dA &d@³                  bytes 13-14 contain the top display boundary;       ³ 
&dA &d@³                  and bytes 17-18 contain the bottom display          ³ 
&dA &d@³                  boundary.  The top boundary, we can use; but        ³ 
&dA &d@³                  the bottom boundary includes the bottom             ³ 
&dA &d@³                  caption, so we must look above this.                ³ 
&dA &d@³                                                                      ³ 
&dA &d@³   Output:  int   leftt  = left_limit                                 ³ 
&dA &d@³            int   rightt = right_limit                                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure hpage_limits (leftt,rightt) 
        str line.300 
        bstr bline.2400,bline2.2400 
        int a1,a2,a3 
        int leftt,rightt 
&dA 
&dA &d@    Get limits 
&dA 
        leftt = 10000 
        rightt = 10000 

        loop for a1 = 1 to 3090 
          a2 = (a1 - 1) * 300 + 21 
          line = gstr{a2,300} 
          bline = cbi(line) 
          bline = bline // zpd(2400) 
          bline2 = rev(bline) 
          if bline con "1" 
            a3 = mpt 
            if a3 < leftt 
              leftt = a3 
            end 
          end 
          if bline2 con "1" 
            a3 = mpt 
            if a3 < rightt 
              rightt = a3 
            end 
          end 
        repeat 

        if leftt = 10000 
          leftt = 1200 
          rightt = 1200 
        else 
          rightt = 2401 - rightt 
        end 
        passback leftt,rightt 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 44. not_very_messy                                          ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose: get slurpar and tiepar parameters from the        ³ 
&dA &d@³                slurpars glob                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure not_very_messy 
        str big_slurpars.1500000 
        str temp2.480 
        str rec.400,delim.2 
        int a1,a2,a3,a4 
        int t1,t2,t3
        int start 

        open [8,8] slurpars 
        len(big_slurpars) = sze 
        read [8] big_slurpars 
        close [8] 

        delim = chr(13) // chr(10) 
        start = 1 
        loop for t1 = 1 to 11 
          loop for t2 = 1 to 11 
            loop for t3 = 1 to 6 
              if big_slurpars{start..} con delim 
                slurpar06(t1,t2,t3) = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
            repeat 
          repeat 
        repeat 
        loop for t1 = 1 to 11 
          loop for t2 = 1 to 11 
            loop for t3 = 1 to 6 
              if big_slurpars{start..} con delim 
                slurpar14(t1,t2,t3) = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
            repeat 
          repeat 
        repeat 
        loop for t1 = 1 to 11 
          loop for t2 = 1 to 11 
            loop for t3 = 1 to 6 
              if big_slurpars{start..} con delim 
                slurpar16(t1,t2,t3) = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
            repeat 
          repeat 
        repeat 
        loop for t1 = 1 to 11 
          loop for t2 = 1 to 11 
            loop for t3 = 1 to 6 
              if big_slurpars{start..} con delim 
                slurpar18(t1,t2,t3) = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
            repeat 
          repeat 
        repeat 
        loop for t1 = 1 to 11 
          loop for t2 = 1 to 11 
            loop for t3 = 1 to 6 
              if big_slurpars{start..} con delim 
                slurpar21(t1,t2,t3) = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
            repeat 
          repeat 
        repeat 
&dA 
&dA &d@    Get tie parameters 
&dA 
        loop for a1 = 1 to 12 
          loop for a2 = 1 to 4 
            loop for a4 = 1 to 12 
              if big_slurpars{start..} con delim 
                temp2 = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
              a3 = 0 
              t1 = 1 
              t3 = 0 
              sub = 0 
              loop while a3 < ( TIE_DISTS ) 
                if temp2{t1} = "+" 
                  t2 = int(temp2{t1+1..}) 
                  t1 = sub - 1 
                else 
                  t2 = ors(temp2{t1}) 
                  if t2 < 96 
                    t2 -= 64 
                  else 
                    t2 = 96 - t2 
                  end 
                end 
                t3 += t2 
                ++a3 
                tiearr(a1,a2,a3,a4) = t3 
                ++t1 
              repeat 
            repeat 
          repeat 
        repeat 

      return 
      run
