
&dA                                                                        
&dA &d@                                                                      &dA 
&dA &d@                   Global #define Definitions                         &dA 
&dA &d@                                                                      &dA 
&dA                                                                        

#define    DMUSE          1     
                               /* when program is being tested in the Dmuse environment
#define    XPOS_FIXED     1 
                               /* with Beethoven, try 1 first, then 0; with Haydn, use 1
#define    SFZ            0 
                               /* SFZ            = 1:  print sfortzando as sfz 
#define    NO_EDIT        0 
                               /* NO_EDIT        = 1:  do not process editorial data
#define    ROMAN_EDIT     0 
                               /* ROMAN_EDIT     = 1:  use Times Roman font for 
                               /*                        editorial marks: tr, dynamics
#define    OLD_REPEATERS  1 
                               /* OLD_REPEATERS  = 1:  use half notes instead of quarters
#define    CUSTOM_PAR     1 
                               /* allows use of custom parameters, for whatever reason
                               /* see code at CUSTOM_PAR 
#define    DEFAULT_DTIVFONT    37 
#define    DEFAULT_MDIRFONT    31 
                               /* default font for musical directions 

#define    TRUE           0 
#define    FALSE          1 
#define    YES            0 
#define    NO             1 
#define    OFF            0 
#define    ON             1 

&dA &d@     Actual Characters 

#define    DOT_CHAR      44 

&dA &d@     Font parameters 

#define   BEAM_OFFSET     12 
#define   TIE_OFFSET      25 
#define   LARGE_BRACK     42 
#define   SMALL_BRACK     43 

&dA &d@     Descriptive Definitions (array elements) 
  
#define    TIE_SNUM       1
#define    TIE_NTYPE      2
#define    TIE_VLOC       3
#define    TIE_FHDIS      4
#define    TIE_FSTEM      5
#define    TIE_NDX        6 
#define    TIE_STAFF      7 
#define    TIE_FOUND      8 
#define    TIE_FORCE      9 
#define    TIE_SUGG      10 
#define    TIE_COLOR     11 
#define    TIE_ARR_SZ    11 

#define    FIG_SNUM       1
#define    FIG_HOFF1      2
#define    FIG_HOFF2      3
#define    FIG_READY      4
 
#define    REG            1
#define    GRACE          2
#define    CUE            3
#define    CUEGRACE       4
 
#define    BM_SNUM        1
#define    BM_CNT         2
#define    BM_READY       3
#define    BM_STEM        4
#define    BM_TUPLE       5
#define    BM_SIZE        6 
#define    BM_SUGG        7 
#define    BM_COLOR       8 
#define    BM_SZ          8 
  
#define    SL_SNUM        1
#define    SL_YSHIFT      2
#define    SL_XSHIFT      3 
#define    SL_NEXTSNUM    4
#define    SL_BEAMF       5 
#define    SL_SUGG        6 
#define    SL_SIZE        6 
 
#define    TU_SNUM        1
#define    TU_Y1          2
#define    TU_Y2          3
#define    TU_FSTEM       4
 
#define    TYPE           1
#define    DIV            2
#define    CLAVE          3
#define    AX             4
#define    TEMP4          4
#define    NTYPE          5
#define    DOT            6
#define    TUPLE          7
#define    STAFFLOC       8
#define    SPACING        9
#define    STEM_FLAGS    10
#define    BEAM_FLAG     11
#define    BEAM_CODE     12
#define    LOCAL_XOFF    13 
#define    SUPER_FLAG    14
#define    SLUR_FLAG     15
#define    SUBFLAG_1     16
#define    SUBFLAG_2     17
#define    VIRT_NOTE     18
#define    SORTPAR1      18
#define    SORTPAR2      19
#define    TEMP2         19
#define    GLOBAL_XOFF   19
#define    TEXT_INDEX    20
#define    PASSNUM       21
#define    BACKTIE       22
#define    NOTE_DUR      23
#define    DINC_FLAG     24
#define    VIRT_STEM     25 
#define    ED_SUBFLAG_1  26 
#define    ED_SUBFLAG_2  27 
#define    STAFF_NUM     28 
#define    NUM_STAVES    28 
#define    MULTI_TRACK   29 
#define    TEMP1         30 
#define    SPN_NUM       30 
#define    OBY           31 
#define    SLUR_X        32 
#define    NODE_SHIFT    33 
#define    TRACK_NUM     34 
#define    BASE_40       35 
#define    NOTE_DISP     36 
#define    AX_DISP       37 
#define    AUG_DOTS      38 
#define    TSR_POINT     39 
#define    TS_SIZE       39 
&dA 
&dA &d@     ts(.) Array positions for arpeggio variables  (note doublings with other flags)
&dA 
#define    ARPEG_FLAG    16 
#define    ARPEG_TOP     26 
#define    ARPEG_BOTTOM  27 
#define    ARPEGGIO      33 
 
#define    TSR_LENG     116 
                                         
#define    NUMBER_OF_FIG  3
#define    FIG_SPACE      4
#define    FIG_DATA       5
#define    MIN_FIG_SPAC  20 
#define    FIG_DUR       23
 
#define    SIGN_POS       3
#define    SIGN_TYPE      4
#define    SUPER_TYPE     5
#define    FONT_NUM       6
#define    WEDGE_OFFSET   7
#define    S_TRACK_NUM    8 
#define    WEDGE_SPREAD  10 
#define    POSI_SHIFT1   11 
#define    ISOLATED      12 
#define    POSI_SHIFT2   13 
 
#define    DOLLAR_SPN     5 
#define    DIVSPQ         3
 
#define    CLEF_NUM       3
#define    CLEF_FONT      4
#define    CLEF_STAFF_POS 6
 
#define    BAR_NUMBER     3
#define    BAR_TYPE       4
#define    REPEAT         5
#define    BACK_ENDING    6
#define    FORW_ENDING    7
#define    BAR_FLAGS      8
#define    M_NUMBER      10 
 
#define    REGULAR        1
#define    HEAVY          2
#define    DOTTED         3
#define    DOUBLE_REG     5
#define    REG_HEAVY      6
#define    HEAVY_REG      9
#define    DOUBLE_HEAVY  10
#define    DOUBLE_DOTTED 15
 
#define    WEDGES         1
#define    DASHES         2
#define    OCT_UP         3
#define    OCT_DOWN       4
#define    DBL_OCT_UP     5
#define    DBL_OCT_DOWN   6
#define    NORMAL_TRANS  13 
 
#define    NOTE           1
#define    XNOTE          2
#define    REST           3
#define    CUE_NOTE       4
#define    XCUE_NOTE      5
#define    CUE_REST       6
#define    GR_NOTE        7
#define    XGR_NOTE       8
#define    NOTE_OR_REST   8
#define    FIGURES        9
#define    BAR_LINE      10
#define    SIGN          11
#define    WORDS         12
#define    MARK          13
#define    CLEF_CHG      14
#define    DESIGNATION   15
#define    METER_CHG     16
#define    DIV_CHG       17
#define    AX_CHG        18
#define    P_SUGGESTION  19 
 
#define    MUSICAL_DIR   11
#define    IREST         12
#define    BACKSPACE     13
 
#define    SEGNO          1
#define    PED            2
#define    END_PED        3
#define    LETTER_DYNAM   4
#define    RIGHT_JUST_STR 5 
#define    CENTER_STR     6 
#define    LEFT_JUST_STR  7 
#define    TIE_TERM       8 
#define    REH_MARK       9 

#define    BELOW          1 
#define    ABOVE          2 
 
#define    HEAD           0
#define    TAIL           1
 
#define    FULLSIZE       0
#define    CUESIZE        1
 
#define    THIRTY_SECOND  4
#define    SIXTEENTH      5
#define    EIGHTH         6
#define    QUARTER        7
#define    HALF           8
#define    WHOLE          9
#define    BREVE         10 
#define    SLASH8         0 

#define    UP             0
#define    DOWN           1
#define    SINGLE_NOTE    0
#define    CHORD          1
 
#define    NO_BEAM        0
#define    END_BEAM       1
#define    START_BEAM     2
#define    CONT_BEAM      3 
 
*     Parametric Definitions
 
#define    MAX_STAFF      2 
#define    MAX_TIES      16 
#define    MAX_FIG        4
#define    MAX_PASS      10 
#define    MAX_OBJECTS 1000 
#define    MAX_M        400 
 
*     Other Definitions 
 
#define    DUMMY_VALUE 10000 
#define    INT1000000  1000000 
#define    INT10000    10000 
#define    INT100        100 
#define    INT9000      9000 
#define    BHPAR1         30 
#define    MAX_MEAS     2000 

&dA                                        
&dA &d@                                      &dA 
&dA &d@    Definitions added with mskpage    &dA 
&dA &d@                                      &dA 
&dA                                        

#define   M_NUM_FONT      37 
#define   NAMELEN         17 

#define   SUPERSIZE      128    
#define   MAX_BNOTES      32 
#define   N_SUPER         16 
#define   LIM1         20000 

#define   PRE_DIST         1 
#define   MNODE_TYPE       2 
#define   TIME_NUM         3 
#define   SNODE            4 
#define   ACT_FLAG         5 
#define   M_ADJ            6 
#define   MARR_TEMP        7 
#define   MARR_PARS        7 
                                
#define   CONTINUO         0 
                                /* 1 = set figured harmonies above staff 
#define   MAGIC1         300 

#define SUPERMAX          50 
#define N_SIZES           12            /* changed &dA03/15/04&d@ from 4 to 12 
#define TIE_DISTS        200 

&dA                                                                  
&dA &d@                                                                &dA 
&dA &d@               Global Variables and Global Program              &dA 
&dA &d@                                                                &dA 
&dA                                                                  

      str out.10000,line.480,temp.480,temp3.480,temp4.160 
      str slurstr.160,slurover.80,slurunder.80 
      str ttext.480,jtype.1 
      str tcode.4(MAX_M),tdata.80(MAX_M,2) 
      str sobl.120(30),tsdata.100(MAX_OBJECTS) 
      str tsr.TSR_LENG(MAX_OBJECTS)                           /* &dA05/14/03&d@ expanded length to 116
      str mrest_line.200                                      /* New &dA03/07/06
      int tv1(MAX_M),tv2(MAX_M),tv3(MAX_M),tv4(MAX_M),tv5(MAX_M) 
      int tiecnt 
      int supcnt,supnums(12) 
      int mf(256),beampar(4,MAX_PASS,BM_SZ)                   /* &dA05/14/03&d@ expanded BM_SZ to 7
      int slurar(8,SL_SIZE),tuar(4,MAX_PASS,4) 
      int super_flag,slur_flag 
      int spc(255),nsp(33),claveax(50),measax(4,50)           /* &dA06/04/08&d@ expanding measax to (4,50)
      int zak(2,7),wak(9),hpar(200),vpar(200),bvpar(35),vpar20 
      int clef_vpos 
      int @n,old@n 
      int notesize,mtfont,twfont,curfont,mdirfont,dtivfont 
      int olddivspq,divspq 
      int cline(MAX_STAFF),clef(MAX_STAFF),key 
      int a1,a2,a5,a6 
      int c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17 
      int beamdata(4,MAX_PASS,31),beamcode(31) 
      int emptyspace(MAX_STAFF,45) 
      int ts(MAX_OBJECTS,TS_SIZE) 
      int sct,oldsct,maxsct,measnum 
      int esnum 
      int tsnum(MAX_PASS) 
      int pre_tsnum(MAX_PASS),pre_ctrarrf(MAX_PASS),pre_try(MAX_PASS) 
      int ntype,f8,inctype,jcode,pcode,passtype,passsize,stem 
      int firstoff,sigflag 
      int obx,oby,sobx,soby,sobcnt,snum 
      int c8flag(MAX_STAFF),transflag(MAX_STAFF),tuflag,passnum,spn 
      int ctrflag(MAX_PASS) 
      int mindist 
      int tnum,tden,nstaves 
      int scnt 
      int vflag 
      int granddist,tword_height,outpnt 
      int note_dur 
      int minshort 
      int global_tpflag 
      int tpflag 
      int pcontrol,px,py,pyy,pxx 
      int putobjpar 
      int repeater_case 
      int textconflag 
      int min_space                                              /* added &dA11/19/07
      int slur_adjust                                            /* added &dA05/01/08

      bstr outslurs.8 
      label E(20),TT(6),SS(21),PSUG(20),TPF(5),TPFF(5),ADJS(5)    /* expanding PSUG &dA05/01/08
      table X(400000),Y(400000) 

      int curvedata(8,4,8) 

      int ndata(20,11) 
      int pcnt 
      int printpos(10) 
      int gl(2,45),gr(2,45) 
      int pseudo_gr(2,45) 
      int pseudo_gl(2,45) 

      int p,x,y,z 
      int m_number 
      int xmindist 
      int opt_rest_flag 
      int fix_next_inctype 

      str hitestr.270 
      str fontspac.18000 

      int XFonts(12,19) 
      int sizenum 
      int kernmap(52,26) 
      int all_real_kernmaps(30,26,26) 
      int revsizes(24) 
      int revmap(400) 

      int art_flag 
      int single_line 
      int stem_change_flag 
      int dot_difference_flag 

      int multirest_flag 
      int key_reprint_flag 
      int mixed_color_flag 

      int suppress_key 
      int font_base,font_height,zero_height 
      int in_line_edslur 
      int large_clef_flag 
      int rest_collapse 

      int how_much_mrest(2) 
&dA 
&dA &d@   Variables initialized by get_options and possibly 
&dA &d@     altered by the control line 
&dA 
      int Cfactor
      int Debugg 
      int Vspace_flag
      int Granddist 
      int Min_space 
      int Just_flag 
      int Length_of_page 
      int Marg_left 
      int Max_sys_cnt
      int Minshort   
      int W(32)   
      int Sys_width  
      int Defeat_flag
      int Notesize  
      int Nparts 
      str Syscode.80 
&dA 
&dA &d@   These variables are new additions to global from mskpage 
&dA 
      int f(32,17),f11,f12 
      str cjtype.1 
      str msk_beamcode.6(MAX_BNOTES),syscode.80,superline.180 
      int ldist,larr(300,MARR_PARS),marr(60,MARR_PARS),larc,marc,tarr(32) 
      int tdist(32,2) 
      int small(300),cflag,dxoff(32),dyoff(32) 
      int rec,crec,drec(32),beamfont 
      int hxpar(25),mhpar(32,25),mvpar(32,41),mvpar20(32) 
      int snode,dincf,maxnotesize,oldbarnum,cntype,coby,cz,csnode 
      int lowerlim,toplim,false_rmarg 
      int superdata(32,N_SUPER,SUPERSIZE) 
      int sp,vst(32),psq(32),x1,x2,y1,y2 
      int bcount,bdata(MAX_BNOTES,2),supernum 
      int mkey(32),mclef(32,2),mtcode(32),savtcode(32) 
      int gbar(2),gbarflag,tplace,w(32) 
      int olddist(32),dvar1,cdv 
      int lpt,intersys,sys_bottom,old_sys_bottom 

      str outfile.280 
      str tacetline.180,mvtline.180 
      str lbyte.1,last_jtype.1 
      int justflag,start_look,sys_count,firstsys 
      int adj_space,small2(300),scnt2 
      int mainyp,pn_left,psysnum,mnum 
      int no_action 
      int zcnt 

      table Z(400000) 
&dA 
&dA &d@   These variables are new additions to global from pspage 
&dA 
      str line2.480,xbyte.1(10) 
      str longslur.800(250) 
      str gstr.8000000 
      str slurpar06.600(11,11,6) 
      str slurpar14.600(11,11,6) 
      str slurpar16.600(11,11,6) 
      str slurpar18.600(11,11,6) 
      str slurpar21.300(11,11,6) 
      str mtloc.100 

      bstr slmap.4500(750) 
      bstr bt.2500(250) 
      bstr dotted.2500 

      int beamt,qwid,stemchar,bthick,backloc(10),uxstart(10),uxstop(10) 
      int ibackloc(10),phpar(63),pvpar(45),pvpar20 
      int underflag,pos(256),urpos(256),underspc(12),hyphspc(12) 
      int beamext(435,12),tiearr(N_SIZES,4,TIE_DISTS,12) 
      int tupldata(7),tbflag 
      int z3 
      int ps_beamdata(MAX_BNOTES,3)        /* 2nd dimension increased from 2 to 3 &dA12/21/10
      int expar(8),sitflag 
      int barbreak(10,2),brkcnt,gapsize 
      int music_con(255),Beaminc(255),Wedginc(255),Tieinc(12,255) 
      int Mfontinc(12,255) 
      int postx,posty,slur_edit_flag 
      int figoff(32),nsz(32) 
      int hookbackshift(14) 
      int FA(7500) 
      int scx,scy,scb,scf 
      int glyph_record(140,256) 
      int sd_cnt,st_cnt,ct_cnt,sst_cnt,pd_cnt,pt_cnt,pt_cnt2,ppt_cnt 
      int if_cnt 
      int ycnt,zpnt,zpnt2 

      real slpara(8,55) 

      table NC(100) 
      table SD(200000)               /* slur dictionaries 
      table ST(50000)                /* primary slur table 
      table CT(10000)                /* character table 
      table SST(10000)               /* longslur table 
      table PD(20000)                /* PostScript dictionary output 
      table PT(20000)                /* PostScript character output 
      table PT2(1000)                /* Auxiliary PostScript character output
      table ZZ(2000)                 /* font/glyph usage table 
      table XX(200000)               /* "fontdict" table 
      table PPT(1200000)             /* combined Postscript character output

      glob slurpars: j:/release/internet/linux/compprogs/sparfils/allinone 
      glob postdict: j:/zprogs/apps/postdict 
      glob gfontspac: j:/release/internet/linux/compprogs/fontspac 
      glob gmfontspac: j:/release/internet/linux/compprogs/mfontspac 
      glob gkernspac: j:/release/internet/linux/compprogs/kernspac 

&dA                              
&dA &d@                            &dA 
&dA &d@       Global Program       &dA 
&dA &d@                            &dA 
&dA                              

      putc Autoset -> Mskpage -> &dEPspage&d@ 

&dK &d@     perform get_options 

      perform load_font_stuff 

&dK &d@     perform my_autoset 

&dK &d@     perform my_mskpage 

      perform my_pspage 

      stop 

&dA                                                                       
&dA &d@                                                                     &dA 
&dA &d@             &dAÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@             &dA 
&dA &d@             &dA³          P R O C E D U R E S            ³&d@             &dA 
&dA &d@             &dAÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@             &dA 
&dA &d@                                                                     &dA 
&dA                                                                       

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  1. my_pspage                                                ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Input: from source library (at the moment)                  ³ 
&dA &d@³                                                                ³ 
&dA &d@³    Output: .ps pages to the same source library                ³ 
&dA &d@³                                                                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure my_pspage 
        str file.280
        str temp2.400,temp3.200 
        str tline.480,ttext.480,htype.1,save_jtype.1 
        str quote.1 
        str xystring_out.100 
        str FAdata.610 
        str recon.6400 
        str Beamincstr.255 
        str Wedgincstr.255 
        str Tieincstr.50 
        str cr.1 

        int saverec,textlen 
        int buxstop(10) 
        int t1,t2,t3,t4,t5,t6,t7,t8 
        int q(12) 
        int a1,a2,a3,a4,a5,a6,a7,a8,a9 
        int c1,c2,c3,c4,c5,c6,c7,c8,c9 
        int f4,f(32,10) 
        int ps_superdata(SUPERMAX,SUPERSIZE),supermap(SUPERMAX),superpnt(SUPERMAX)
        int sysy,sysh,syslen,sysflag,sysnum,sysright 
        int ntext,tlevel 
        int govstaff 
        int savensz 
        int savesub 
        int stave_type 
        int active_font 
        int lastx,lasty 
        int top_limit 
        int bottom_limit 
        int left_limit 
        int right_limit 
        int mpgfile_start(300) 
        int sys_left_limit(300) 
        int sys_right_limit(300) 
        int sys_top_limit(300) 
        int sys_bottom_limit(300) 
        int box_left_limit(300) 
        int box_right_limit(300) 
        int box_top_limit(300) 
        int box_bottom_limit(300) 
        int beambig(5220) 
        int page_cnt 
&dA 
&dA &d@    &dA12/31/08&d@ Initializing the hookbackshift array         
&dA 
        hookbackshift(1)  =  7 
        hookbackshift(2)  =  8 
        hookbackshift(3)  =  8   /* for size 6 regular 
        hookbackshift(4)  = 11 
        hookbackshift(5)  = 12 
        hookbackshift(6)  = 14 
        hookbackshift(7)  = 15 
        hookbackshift(8)  = 17   /* for size 14 regular 
        hookbackshift(9)  = 18 
        hookbackshift(10) = 19   /* for size 18 regular 
        hookbackshift(11) = 21 
        hookbackshift(12) = 22   /* for size 21 regular 
        hookbackshift(13) = 24 
        hookbackshift(14) = 25 

&dA   &d@   End of &dA12/31/08&d@ addition 

        perform not_very_messy 

        cr = chr(13) 
        notesize = 14 
        sizenum = 8
        mtfont = 31 
&dA 
&dA &d@  get shift parameters for music font 
&dA 
        line = "3/0/102.2.2.2.0/0/0.0!.0(3/0/101/1/2/2/1/0/0A"

        t5 = len(line) 
        t6 = 0 
        loop for t1 = 1 to t5 step 2 
          t2 = ors(line{t1}) - 48 
          t3 = ors(line{t1+1}) 
          loop for t4 = 1 to t3 
            ++t6 
            urpos(t6) = t2 
          repeat 
        repeat 

        perform ps_init_par 

&dA &d@     Outputs:  pvpar(.)
&dA &d@               phpar(.) 
&dA &d@               pvpar20 
&dA &d@               expar(.) 
&dA &d@               revmap(.) 
&dA &d@               sizenum 

        wak(1) = 140 
        wak(2) = 156      /* works for ‡. but not for ó 
        wak(3) = 131 
        wak(4) = 156 
        wak(5) = 128 
        wak(6) = 140 
        wak(7) = 128 
        wak(8) = 129 
        wak(9) = 130 
 
        quote = chr(34) 
        ttext = "" 

        loop for t3 = 1 to 255 
          music_con(t3) = t3 
        repeat 
        music_con(102) = 110            /* forte 
        music_con(109) = 109            /* mezzo 
        music_con(112) = 108            /* piano 
        music_con(114) = 113            /* r 
        music_con(115) = 111            /* s 
        music_con(122) = 112            /* z 
&dA 
&dA &d@   &dA03/04/05&d@  Need screen fonts for line length code, even when PRINTING 
&dA 
&dA &d@   Get screen fonts 
&dA 
        FAdata = "~CC~C«C®~CÉCÌ~CçCê~CC~C#C&~CšC"
        FAdata = FAdata // "~CC~CˆC‹~CC~C¨C«~C[C^CC Cô"
        FAdata = FAdata // " CÿCÿCÿCÿCÿCC Cô CÿCÿCÿCÿCÿCC Cô C"
        FAdata = FAdata // "ÿCÿCÿCÿCÿCC Cô CÿCÿCÿCÿCÿCC Cô CÿC"
        FAdata = FAdata // "ÿCÿCÿCÿCC9@Cä@CÿhCÿhCÿhCÿhCÿCC9@Cä@CÿhCÿhC"
        FAdata = FAdata // "ÿhCÿhCÿCC9@Cä@CÿhCÿhCÿhCÿhCÿCCA@Cà@CÿxCÿxCÿxC"
        FAdata = FAdata // "ÿxCÿC(CJ@CÜ@Cî»€Cî»€Cî»€Cî»€Cî»C-CW@CÖ@CÿCÿ"
        FAdata = FAdata // "CÿCÿCÿC-CW@CÖ@CÿCÿCÿCÿCÿ"

        a3 = len(FAdata) 
        loop for a1 = 1 to a3 
          a2 = ors(FAdata{a1}) 
          if a2 = 67 
            a2 = 0 
          end 
          if a2 = 68 
            a2 = 10 
          end 
          if a2 = 69 
            a2 = 11 
          end 
          if a2 = 70 
            a2 = 27 
          end 
          FAdata{a1} = chr(a2) 
        repeat 

        gstr = "" 
        loop for a1 = 1 to a3 step 2 
          a2 = ors(FAdata{a1}) 
          loop for a4 = 1 to a2 
            gstr = gstr // FAdata{a1+1} 
          repeat 
        repeat 

        t4 = 1 
        loop for t3 = 1 to len(gstr) step 4 
          FA(t4) = ors(gstr{t3,4}) 
          ++t4 
        repeat 
&dA 
&dA &d@   Construct increments for beam characters 
&dA 
        Beamincstr = "22222222222222222222222222222222PPPPPPPPPPPPPPPPCCCCCCCCCCCCCCCC"
        Beamincstr = Beamincstr // "ABBBBBBBBBBBCCCC344555566666677777777788888888899999999:::;<2222"
        Beamincstr = Beamincstr // "22222222222222222222222222222222PPPPPPPPPPPPPPPPCCCCCCCCCCCCCCCC"
        Beamincstr = Beamincstr // "ABBBBBBBBBBBBBBB344555566666677777777788888888899999999:::;<222"

        loop for t3 = 1 to 255 
          Beaminc(t3) = ors(Beamincstr{t3}) - 50 
        repeat 
&dA 
&dA &d@   Construct increments for tie characters 
&dA 
        loop for t3 = 1 to 12 
          loop for t4 = 1 to 255 
            Tieinc(t3,t4) = 0 
          repeat 
        repeat 

        Tieincstr = "68:<>@BDFH4" 
        loop for t3 = 1 to 5                          /*    68:<>@BDFH4
          loop for t4 = 1 to 24                       /*                          
            Tieinc(t3,t4+90) = ors(Tieincstr{t4})     /*    91                     114
            Tieinc(t3,t4+218) = ors(Tieincstr{t4})    /*    219                    242
          repeat 
        repeat 

        Tieincstr = "|€„ˆŒ”˜œ x" 
        loop for t3 = 6 to 8                          /*    |€„ˆŒ”˜œ x
          loop for t4 = 1 to 24                       /*                          
            Tieinc(t3,t4+90) = ors(Tieincstr{t4})     /*    91                     114
            Tieinc(t3,t4+218) = ors(Tieincstr{t4})    /*    219                    242
          repeat 
        repeat 

        Tieincstr = "`einrw{€…‰’—› ¥©®²·‰" 
        loop for t4 = 1 to 44                      /* `einrw{€…‰’—› ¥©®²·‰
          Tieinc(9,t4+80) = ors(Tieincstr{t4})     /*                                           
          Tieinc(9,t4+208) = ors(Tieincstr{t4})    /* 81                                         124
        repeat                                     /* 209                                        252

        Tieincstr = "mrw|†‹‘–› ¥ª°µº¿ÄÊĞ›" 
        loop for t4 = 1 to 44                      /* mrw|†‹‘–› ¥ª°µº¿ÄÊĞ›
          Tieinc(10,t4+80) = ors(Tieincstr{t4})    /*                                           
          Tieinc(10,t4+208) = ors(Tieincstr{t4})   /* 81                                         124
        repeat                                     /* 209                                        252

        Tieincstr = "~„Š–œ¢¨®´ºÀÆÌÒØŞäêğ´" 
        loop for t3 = 11 to 12                     /* ~„Š–œ¢¨®´ºÀÆÌÒØŞäêğ´
          loop for t4 = 1 to 44                    /*                                           
            Tieinc(t3,t4+80) = ors(Tieincstr{t4})  /* 81                                         124
            Tieinc(t3,t4+208) = ors(Tieincstr{t4}) /* 209                                        252
          repeat 
        repeat 

        loop for t3 = 1 to 12 
          loop for t4 = 1 to 255 
            if Tieinc(t3,t4) = 6 
              Tieinc(t3,t4) = 0 
            end 
          repeat 
        repeat 
&dA 
&dA &d@   Construct increments for wedge characters 
&dA 
        Wedgincstr = "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<xdZTPMKIHGFEDCBA@?>=xdZTPMKIHGFE"
        Wedgincstr = Wedgincstr // "DCBA@?>=xZPKHFEDCBA@?>=<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
        Wedgincstr = Wedgincstr // "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<HEB?HHHHHEEEEEBBBBB?????HHHHHEEE"
        Wedgincstr = Wedgincstr // "EEBBBBB?????<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"

        loop for t3 = 1 to 255 
          Wedginc(t3) = ors(Wedgincstr{t3}) - 60 
        repeat 
&dA 
&dA &d@   &dA12/01/08&d@  Need postscript dictionary generator for POSTSCRIPT
&dA 
        open [8,8] postdict 
        len(gstr) = sze 
        read [8] gstr 
        close [8] 
                
        temp2 = chr(13) // chr(10) 
        a1 = 0 
        a2 = 1 
        loop while gstr{a2..} con temp2 
          ++a1 
          tput [XX,a1] ~gstr{a2..sub-1} 
          a2 = sub + 2 
        repeat 
&dA 
&dA &d@  get spacing parameters for hyphon and underline characters (text font) 
&dA 
        loop for a1 = 1 to 12 
          a2 = mtfont - 29                   /* 1 <= a2 <= 19 
          a3 = XFonts(a1,a2) - 50            /* 1 <= a3 <= 90 (text font) 
          a3 = (a3 - 1) * 200 + 1 

          loop for a4 = 32 to 45 
            hyphspc(a1) = ors(fontspac{a3}) 
            ++a3 
          repeat 
          loop for a4 = 46 to 95 
            underspc(a1) = ors(fontspac{a3}) 
            ++a3 
          repeat 
        repeat 
&dA 
&dA &d@  get beam generation parameters (5220 total) 
&dA 
        out = "1¼2¼3¹4¶5º1¶2¼3»4¼5¸1¾2¾3½1»2»3¼4»1¹2º3º4º5º1¸2¹3¹4¹5¹6¹1¹2¹3¼4¹5º1»2¸3»4¹5º1»2º"
        out = out // "3»4»5¶1º2º3º4º5¹1º2º3¹4º5º1¹2¹3¹4¹5¹6¸1¹2»3º4¹5º1º2¹3º4»5¹1º2º3º4º5¹QµSµVµ\µcµkµ"
        out = out // "tµyÊQµSĞQµÓµÖµÛµáµéµòµøµ{µ|ÈQµSµWµ]µdµlµuËQµSµWµ]µdÍQµSµWµ]ÎQµSµVµ\µcÍQµRµTµXµ^µ"
        out = out // "gµpËQµRµTµYµ_µhµqËQµRµTµYµ_µhÌQµRµTµYµ_µhÌQµRµTµYµ_ÍQµRµUµZµ`ÍQµRµUµZµfµoÌQµRµUµ"
        out = out // "ZµfµoÌ0¼1É0¶1Ï0¾1Ç0»2Ê0¹2Ì0¸2Í0¹2Ì0»1Ê0»2Ê0º2Ë0º2Ë0¹2Ì0¹2Ì0º3Ë0º3Ë0¼QµÓµÖµÛµáµéµ"
        out = out // "òµøÂ0¶QµÓµÖµÛµáµéµòµøÈ0¾QµÓµÖµÛµáµéµòµøµ{µ|¾0»QµÓµÖµÛµáµéµòÄ0¹QµÓµÖµÛµáµéÇ0¸QµÓµ"
        out = out // "ÖµÛµáÉ0¹QµÓµÖµÛµáÈ0»QµSµWµ]Ç0»QµRµTµYµ_µhÅ0ºQµRµTµYµ_µhÆ0ºQµRµUµZµ`µnÆ0¹QµRµTµYµ"
        out = out // "_È0¹QµRµUµZµfµoµwÆ0ºQµRµTµYµ_Ç0ºQµRµUµZµfµoÆ0M1½0Â1Ã0¿1Æ0½1È0¾1Ç0¿2Æ0Á2Ä0À2Å0À2Å"
        out = out // "0¾2Ç0À3Å0¿2Æ0À3Å0ÄQµRµTµXµ^½0¾QµSµVµ[µbµjµsÁ0ÈQµÓµÖµÛµáµéµòµøµ{µ0ÂQµÓµÖµÛµáµéµòµ"
        out = out // "ø¼0¿QµÓµÖµÛµáµéÁ0½QµÓµÖµÛµáÄ0¾QµÓµÖµÛµeµmµvµzÀ0¿QµRµTµXµ^µgµpÀ0ÁQµRµTµXµ^µgµp¾0À"
        out = out // "QµRµTµYµ_µhÀ0ÀQµRµUµZµ`Á0¾QµRµTµYµ_Ã0ÀQµRµUµZµfµoÀ0¿QµRµUµZµfµoÁ0ÀQµRµUµZµfµoÀ0-"
        out = out // "1À021»0Å1À0Â1Ã0Æ2¿0Æ1¿0È2½0Æ2¿0Å2À0Ã2Â0Æ3¿0Å3À0Æ3¿0ÉQµR»0ÅQµÓµÖµÛµáµéµòµø¹02QµÓµ"
        out = out // "ÖµÛµáµéµòµ0ÅQµÓµÖµÛµáµé»0ÂQµÓµÖµÛµá¿0ÆQµÓµÖµÛµá»0ÆQµSµWµ]µd»0ÈQµRµTµYµ_µhµq·0ÆQµ"
        out = out // "RµTµYµ_µhº0ÅQµRµUµZµ`µn»0ÃQµRµTµYµ_¾0ÆQµRµTµYµ_»0ÅQµRµUµZµfµoµwº0ÆQµRµUµZµfµoº0Š"
        out = out // "1º0Ç1¾0Ë1º0Ë2º0Ï2¶0Ì2¹0Ë2º0È2½0Ë2º0Ì3¹0Ì3¹0ËQµSµVµ[µbµjµ0ÍQµSµVµ[µ0PQµÓµÖµÛµáµéµ"
        out = out // "0ÇQµÓµÖµÛµáº0ËQµÓµÖµÛµeµmµ0ËQµRµTµYµ_µhµ0ÏQµRµ0ÌQµRµTµYµ_µ0ËQµRµUµZµfµoµ0ÈQµRµTµ"
        out = out // "Yµ_¹0ËQµRµUµZµ`µnµ0ÌQµRµUµZµfµ0ÌQµRµUµZµfµ0¨1¹0©2¸0ÿQµÓµÖµÛµáµ0©QµRµTµYµ0V"

        t5 = 0 
        loop for t1 = 1 to len(out) step 2 
          t2 = ors(out{t1}) 
          if t2 < 80 
            t2 -= 48 
          end 
          t3 = ors(out{t1+1}) 
          if t3 >= 180 and t3 < 220 
            t3 -= 180 
          else 
            ++t3 
          end 
          loop for t4 = 1 to t3 
            ++t5 
            beambig(t5) = t2 
          repeat 
        repeat 

        t1 = 0 
        loop for t7 = 1 to 12 
          loop for t8 = 1 to 435 
            ++t1 
            beamext(t8,t7) = beambig(t1) 
          repeat 
        repeat 
&dA 
&dA &d@   Set parameters for circular slur generation 
&dA 
        slpara(1,1)  =   20.60 
        slpara(1,2)  =   27.00 
        slpara(1,3)  =   33.70 
        slpara(1,4)  =   40.70 
        slpara(1,5)  =   48.10 
        slpara(1,6)  =   55.80 
        slpara(1,7)  =   63.70 
        slpara(1,8)  =   72.40 
        slpara(1,9)  =   81.70 
        slpara(1,10) =   91.90 
        slpara(1,11) =  105.40 
        slpara(1,12) =  122.70 
        slpara(1,13) =  134.70 
        slpara(1,14) =  153.00 
        slpara(1,15) =  173.50 
        slpara(1,16) =  198.00 
        slpara(1,17) =  230.40 
        slpara(1,18) =  259.10 
        slpara(1,19) =  300.00 
        slpara(1,20) =  800.00 
* 
        slpara(2,1)  =   13.90 
        slpara(2,2)  =   19.80 
        slpara(2,3)  =   25.70 
        slpara(2,4)  =   31.80 
        slpara(2,5)  =   38.10 
        slpara(2,6)  =   44.70 
        slpara(2,7)  =   51.40 
        slpara(2,8)  =   58.40 
        slpara(2,9)  =   65.80 
        slpara(2,10) =   73.60 
        slpara(2,11) =   82.00 
        slpara(2,12) =   93.20 
        slpara(2,13) =  107.70 
        slpara(2,14) =  116.00 
        slpara(2,15) =  129.90 
        slpara(2,16) =  145.50 
        slpara(2,17) =  164.40 
        slpara(2,18) =  188.70 
        slpara(2,19) =  206.00 
        slpara(2,20) =  800.00 
        slpara(2,21) =  800.00 
        slpara(2,22) =  800.00 
* 
        slpara(3,1)  =    7.00 
        slpara(3,2)  =   13.20 
        slpara(3,3)  =   18.80 
        slpara(3,4)  =   24.40 
        slpara(3,5)  =   30.20 
        slpara(3,6)  =   36.20 
        slpara(3,7)  =   42.40 
        slpara(3,8)  =   48.80 
        slpara(3,9)  =   55.40 
        slpara(3,10) =   62.40 
        slpara(3,11) =   69.40 
        slpara(3,12) =   77.40 
        slpara(3,13) =   86.20 
        slpara(3,14) =   95.80 
        slpara(3,15) =  106.00 
        slpara(3,16) =  117.20 
        slpara(3,17) =  129.80 
        slpara(3,18) =  144.40 
        slpara(3,19) =  162.20 
        slpara(3,20) =  187.60 
        slpara(3,21) =  225.40 
        slpara(3,22) =  800.00 
        slpara(3,23) =  800.00 
        slpara(3,24) =  800.00 
        slpara(3,25) =  800.00 
        slpara(3,26) =  800.00 
        slpara(3,27) =  800.00 
        slpara(3,28) =  800.00 
* 
        slpara(4,1)  =    7.00 
        slpara(4,2)  =   10.00 
        slpara(4,3)  =   13.20 
        slpara(4,4)  =   18.80 
        slpara(4,5)  =   24.40 
        slpara(4,6)  =   30.20 
        slpara(4,7)  =   36.20 
        slpara(4,8)  =   42.40 
        slpara(4,9)  =   48.80 
        slpara(4,10) =   55.40 
        slpara(4,11) =   62.40 
        slpara(4,12) =   69.40 
        slpara(4,13) =   77.00 
        slpara(4,14) =   84.80 
        slpara(4,15) =   93.20 
        slpara(4,16) =  102.00 
        slpara(4,17) =  111.40 
        slpara(4,18) =  121.60 
        slpara(4,19) =  132.80 
        slpara(4,20) =  145.40 
        slpara(4,21) =  159.80 
        slpara(4,22) =  177.60 
        slpara(4,23) =  202.00 
        slpara(4,24) =  227.80 
        slpara(4,25) =  275.00 
        slpara(4,26) =  375.00 
        slpara(4,27) =  575.00 
        slpara(4,28) =  800.00 
        slpara(4,29) =  800.00 
        slpara(4,30) =  800.00 
        slpara(4,31) =  800.00 
        slpara(4,32) =  800.00 
* 
        slpara(5,1)  =    7.00 
        slpara(5,2)  =    7.00 
        slpara(5,3)  =   10.00 
        slpara(5,4)  =   13.20 
        slpara(5,5)  =   18.80 
        slpara(5,6)  =   24.40 
        slpara(5,7)  =   30.20 
        slpara(5,8)  =   36.20 
        slpara(5,9)  =   42.40 
        slpara(5,10) =   48.80 
        slpara(5,11) =   55.40 
        slpara(5,12) =   62.40 
        slpara(5,13) =   69.40 
        slpara(5,14) =   76.40 
        slpara(5,15) =   83.60 
        slpara(5,16) =   91.00 
        slpara(5,17) =   98.80 
        slpara(5,18) =  107.00 
        slpara(5,19) =  115.60 
        slpara(5,20) =  125.00 
        slpara(5,21) =  135.00 
        slpara(5,22) =  145.80 
        slpara(5,23) =  158.00 
        slpara(5,24) =  171.80 
        slpara(5,25) =  188.60 
        slpara(5,26) =  207.80 
        slpara(5,27) =  228.20 
        slpara(5,28) =  258.40 
        slpara(5,29) =  320.00 
        slpara(5,30) =  440.00 
        slpara(5,31) =  680.00 
        slpara(5,32) =  800.00 
        slpara(5,33) =  800.00 
        slpara(5,34) =  800.00 
        slpara(5,35) =  800.00 
        slpara(5,36) =  800.00 
* 
        slpara(6,1)  =    7.00 
        slpara(6,2)  =    7.00 
        slpara(6,3)  =    7.00 
        slpara(6,4)  =   11.00 
        slpara(6,5)  =   15.00 
        slpara(6,6)  =   18.80 
        slpara(6,7)  =   24.40 
        slpara(6,8)  =   30.20 
        slpara(6,9)  =   36.20 
        slpara(6,10) =   42.40 
        slpara(6,11) =   48.80 
        slpara(6,12) =   55.40 
        slpara(6,13) =   62.40 
        slpara(6,14) =   68.60 
        slpara(6,15) =   74.60 
        slpara(6,16) =   80.80 
        slpara(6,17) =   87.40 
        slpara(6,18) =   94.20 
        slpara(6,19) =  101.20 
        slpara(6,20) =  108.60 
        slpara(6,21) =  116.20 
        slpara(6,22) =  124.40 
        slpara(6,23) =  132.80 
        slpara(6,24) =  142.00 
        slpara(6,25) =  151.80 
        slpara(6,26) =  162.60 
        slpara(6,27) =  174.40 
        slpara(6,28) =  188.00 
        slpara(6,29) =  203.20 
        slpara(6,30) =  217.80 
        slpara(6,31) =  234.80 
        slpara(6,32) =  256.40 
        slpara(6,33) =  291.00 
        slpara(6,34) =  350.00 
        slpara(6,35) =  500.00 
        slpara(6,36) =  800.00 
        slpara(6,37) =  800.00 
        slpara(6,38) =  800.00 
        slpara(6,39) =  800.00 
        slpara(6,40) =  800.00 
        slpara(6,41) =  800.00 
* 
        slpara(7,1)  =    7.00 
        slpara(7,2)  =    7.00 
        slpara(7,3)  =    7.00 
        slpara(7,4)  =    7.00 
        slpara(7,5)  =   11.00 
        slpara(7,6)  =   18.00 
        slpara(7,7)  =   21.00 
        slpara(7,8)  =   24.40 
        slpara(7,9)  =   30.20 
        slpara(7,10) =   36.20 
        slpara(7,11) =   42.40 
        slpara(7,12) =   48.80 
        slpara(7,13) =   55.40 
        slpara(7,14) =   60.60 
        slpara(7,15) =   65.80 
        slpara(7,16) =   71.20 
        slpara(7,17) =   76.60 
        slpara(7,18) =   82.20 
        slpara(7,19) =   88.00 
        slpara(7,20) =   94.00 
        slpara(7,21) =  100.00 
        slpara(7,22) =  106.40 
        slpara(7,23) =  113.00 
        slpara(7,24) =  119.80 
        slpara(7,25) =  126.80 
        slpara(7,26) =  134.20 
        slpara(7,27) =  142.00 
        slpara(7,28) =  150.40 
        slpara(7,29) =  159.00 
        slpara(7,30) =  168.40 
        slpara(7,31) =  178.40 
        slpara(7,32) =  189.60 
        slpara(7,33) =  201.60 
        slpara(7,34) =  212.80 
        slpara(7,35) =  225.00 
        slpara(7,36) =  238.40 
        slpara(7,37) =  256.40 
        slpara(7,38) =  291.00 
        slpara(7,39) =  350.00 
        slpara(7,40) =  500.00 
        slpara(7,41) =  800.00 
        slpara(7,42) =  800.00 
        slpara(7,43) =  800.00 
        slpara(7,44) =  800.00 
        slpara(7,45) =  800.00 
        slpara(7,46) =  800.00 
* 
        slpara(8,1)  =    7.00 
        slpara(8,2)  =    7.00 
        slpara(8,3)  =    7.00 
        slpara(8,4)  =    7.00 
        slpara(8,5)  =    9.00 
        slpara(8,6)  =   16.00 
        slpara(8,7)  =   21.00 
        slpara(8,8)  =   24.00 
        slpara(8,9)  =   27.00 
        slpara(8,10) =   30.20 
        slpara(8,11) =   36.20 
        slpara(8,12) =   42.40 
        slpara(8,13) =   48.80 
        slpara(8,14) =   53.80 
        slpara(8,15) =   58.10 
        slpara(8,16) =   62.80 
        slpara(8,17) =   67.50 
        slpara(8,18) =   72.00 
        slpara(8,19) =   76.80 
        slpara(8,20) =   81.70 
        slpara(8,21) =   86.60 
        slpara(8,22) =   91.60 
        slpara(8,23) =   96.70 
        slpara(8,24) =  101.90 
        slpara(8,25) =  107.00 
        slpara(8,26) =  112.10 
        slpara(8,27) =  117.20 
        slpara(8,28) =  122.50 
        slpara(8,29) =  127.80 
        slpara(8,30) =  135.20 
        slpara(8,31) =  143.10 
        slpara(8,32) =  151.60 
        slpara(8,33) =  161.20 
        slpara(8,34) =  171.40 
        slpara(8,35) =  180.90 
        slpara(8,36) =  191.30 
        slpara(8,37) =  202.60 
        slpara(8,38) =  212.80 
        slpara(8,39) =  224.00 
        slpara(8,40) =  238.40 
        slpara(8,41) =  255.40 
        slpara(8,42) =  280.00 
        slpara(8,43) =  311.00 
        slpara(8,44) =  350.00 
        slpara(8,45) =  500.00 
        slpara(8,46) =  800.00 
        slpara(8,47) =  800.00 
        slpara(8,48) =  800.00 
        slpara(8,49) =  800.00 
        slpara(8,50) =  800.00 

&dA 
&dA &d@ &dE                                        
&dA &d@ &dE  End of Initialization of parameters   
&dA &d@ &dE                                        
&dA 
        if Source_type = 1 
#if DMUSE 
          putc Source file?  
          getc temp 
          open [3,1] temp 
#endif 
          t3 = 0 
          loop for t1 = 1 to 1000000 
#if DMUSE 
            getf [3] line 
#else 
            getc line 
            t2 = len(line) 
            if line{t2} = cr 
              line = line{1,t2-1} 
            end 
            if line{1} = "P" 
              if t3 = 1 
                t4 = t1 
              end 
              ++t3 
              if t3 = 5 
                t1 = t4 
                goto eof3 
              end 
            else 
              t3 = 0 
            end 
#endif 
            tput [IF,t1] ~line 
          repeat 
eof3: 
#if DMUSE 
          close [3] 
#endif 
          if_cnt = t1 - 1 
        end 

#if DMUSE 
        putc Output file?  
        getc file 
        file = trm(file) 
        outfile = file 
        line = rev(file) 
        if line{1,3} <> "sp." 
          outfile = outfile // ".ps" 
        end 
#endif 
&dA 
&dA &d@   Setup for display 
&dA 
        setup gstr,300,3100,3 

        treset [SD] 
        treset [Y] 
        treset [ST] 
        treset [CT] 
        treset [SST] 
        treset [PD] 
        treset [PT] 
        treset [PT2] 
        treset [ZZ] 

        sd_cnt  = 0 
        ycnt    = 0 
        st_cnt  = 0 
        ct_cnt  = 0 
        sst_cnt = 0 
        pd_cnt  = 0 
        pt_cnt  = 0 
        pt_cnt2 = 0 
        ppt_cnt = 0 

        active_font = 0 
&dA 
&dA &d@  Transfer source file to X table 
&dA 
        loop for t5 = 1 to 300 
          sys_right_limit(t5)  = 0 
          sys_left_limit(t5)  = 10000 
          sys_top_limit(t5)  = 10000 
          sys_bottom_limit(t5)  = 0 
          box_top_limit(t5)  = 10000 
          box_bottom_limit(t5)  = 0 
        repeat 

        page_cnt = 1 
        a5 = 0 
&dK &d@       open [1,1] file 
        treset [X] 
        mpgfile_start(1) = 1 

        loop for t5 = 1 to if_cnt 
          tget [IF,t5] line 
          line = line // "    " 
&dA     
&dA 
&dA &d@    New code &dA01/05/09&d@ to ascertain the left and right limits of a system 
&dA 
          if line{1} = "S" 
            tput [NC,1] ~line 
            tget [NC,1] .t3 a1 a1 a2 a3 a4 
            if a1 < sys_left_limit(page_cnt) 
              sys_left_limit(page_cnt) = a1 
              box_left_limit(page_cnt) = a1 
            end 
            if a2 < sys_top_limit(page_cnt) 
              sys_top_limit(page_cnt) = a2 
            end 
            if (a2 + a4) > sys_bottom_limit(page_cnt) 
              sys_bottom_limit(page_cnt) = a2 + a4 
            end 
            a3 += a1 
            if a3 > sys_right_limit(page_cnt) 
              sys_right_limit(page_cnt) = a3 
              box_right_limit(page_cnt) = a3 
            end 
            a9 = a1 
          end 
          if a5 = 1 
            if line{1,3} = "J D" 
              tput [NC,1] ~line 
              tget [NC,1] .t5 a1 a2 
              if (a9 + a2) < box_left_limit(page_cnt) 
                box_left_limit(page_cnt) = (a9 + a2) 
              end 
              a5 = 0 
            end 
            if box_left_limit(page_cnt) < 0 
              box_left_limit(page_cnt) = 0 
            end 
          end 
          if line{1} = "L" 
            a5 = 1 
          end 
&dA 
&dA     
          tput [X,t5] ~line 
          if line{1} = "P" 
            ++page_cnt 
            mpgfile_start(page_cnt) = t5 + 1 
          end 
        repeat 
        --page_cnt 

        psfile_header(1) = "%%BoundingBox: (atend)" 
        psfile_header(2) = "%%HiResBoundingBox: (atend)" 
&dA 
&dA &d@    Construct the HiResSystemBox 
&dA 
        a5 = 10000 
        a6 = 0 
        a7 = 10000 
        a8 = 0 
        loop for t5 = 1 to page_cnt 
          if sys_top_limit(t5) < a5 
            a5 = sys_top_limit(t5) 
          end 
          if sys_bottom_limit(t5) > a6 
            a6 = sys_bottom_limit(t5) 
          end 
          if sys_left_limit(t5) < a7 
            a7 = sys_left_limit(t5) 
          end 
          if sys_right_limit(t5) > a8 
            a8 = sys_right_limit(t5) 
          end 
        repeat 

        a7 -= 1 
        a5 -= 1 
        a7 += 50 
        a8 += 50 
        a5 = 3150 - a5 
        a6 = 3150 - a6 

        temp = "" 
        a1 = a7 * 24 
        a2 = a1 / 100 
        a3 = rem 
        temp = temp // chs(a2) // "." 
        if a3 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a3) 

        temp = temp // " " 
        a1 = a6 * 24 
        a2 = a1 / 100 
        a3 = rem 
        temp = temp // chs(a2) // "." 
        if a3 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a3) 

        temp = temp // " " 
        a1 = a8 * 24 
        a2 = a1 / 100 
        a3 = rem 
        temp = temp // chs(a2) // "." 
        if a3 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a3) 

        temp = temp // " " 
        a1 = a5 * 24 
        a2 = a1 / 100 
        a3 = rem 
        temp = temp // chs(a2) // "." 
        if a3 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a3)

        psfile_header(3) = "%%HiResSystemBox: " // temp 
&dA      
        psfile_header(5) = "%%Creator: muse2ps 1.0" 
&dA 
&dA &d@    Get the creation data 
&dA 
        getd temp 
        psfile_header(6) = "%%CreationDate: " // temp 
&dA      
        psfile_header(7) = "%%Orientation: Portrait" 
        psfile_header(8) = "%%Pages: " // chs(page_cnt) 
        psfile_header(9) = "%%PageOrder: Ascend" 

        f4 = if_cnt 
        sysnum = 0 
        rec = 1 
        f12 = 0 
        scf = notesize 
        page_cnt = 1 
TOP2: 
        if rec > f4 
          goto TASK_DONE 
        end 

        tget [X,rec] line 
        line = trm(line) 
        ++rec 
        if line{1} = "P" 
&dA 
&dA &d@    Step 0:  We need to compute the coordinates of the high-res 
&dA &d@               system box 
&dA 
          left_limit   = sys_left_limit(page_cnt) 
          right_limit  = sys_right_limit(page_cnt) 
          top_limit    = sys_top_limit(page_cnt) 
          bottom_limit = sys_bottom_limit(page_cnt) 

          left_limit -= 1 
          top_limit  -= 1 

          left_limit += 50 
          right_limit += 50 
          top_limit = 3150 - top_limit 
          bottom_limit = 3150 - bottom_limit 

          temp3 = "" 
          a1 = left_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          temp3 = temp3 // chs(a2) // "." 
          if a3 < 10 
            temp3 = temp3 // "0" 
          end 
          temp3 = temp3 // chs(a3) // " " 

          a1 = bottom_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          temp3 = temp3 // chs(a2) // "." 
          if a3 < 10 
            temp3 = temp3 // "0" 
          end 
          temp3 = temp3 // chs(a3) // " " 

          a1 = right_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          temp3 = temp3 // chs(a2) // "." 
          if a3 < 10 
            temp3 = temp3 // "0" 
          end 
          temp3 = temp3 // chs(a3) // " " 

          a1 = top_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          temp3 = temp3 // chs(a2) // "." 
          if a3 < 10 
            temp3 = temp3 // "0" 
          end 
          temp3 = temp3 // chs(a3)
&dA 
&dA &d@    Step 1: Put out the bounding box for this page 
&dA 
          if sys_left_limit(page_cnt) < 10000 
            left_limit = box_left_limit(page_cnt) 
            right_limit = box_right_limit(page_cnt) + notesize 
          else 
            perform hpage_limits (left_limit,right_limit) 
          end 
          perform vpage_limits (top_limit,bottom_limit) 
          if box_top_limit(page_cnt) > top_limit 
            box_top_limit(page_cnt) = top_limit 
          end 
          if box_bottom_limit(page_cnt) < bottom_limit 
            box_bottom_limit(page_cnt) = bottom_limit 
          end 
&dA 
&dA &d@       Shift and transform coordinate system based on the 
&dA &d@       notion that: 
&dA 
&dA &d@         The position of a dot in my system is actually the 
&dA &d@         position of the lower-right corner of a dot.  
&dA 
&dA &d@       and that: 
&dA 
&dA &d@         (0,0) -> (12,756) which in dots is (50,3150) 
&dA 
&dA &d@       and that:  the top/bottom system is reversed 
&dA 
          left_limit -= 1 
          top_limit  -= 2 

          left_limit += 50 
          right_limit += 50 
          top_limit = 3150 - top_limit 
          bottom_limit = 3150 - bottom_limit 
&dA 
&dA &d@       Convert dots to points, using 300 dpi 
&dA &d@       Format = llx lly ulx uly 
&dA 
          temp = "" 
          temp2 = "" 
          a1 = left_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          if rem < 50 
            temp2 = temp2 // chs(a2) // " " 
          else 
            temp2 = temp2 // chs(a2+1) // " " 
          end 
          temp = temp // chs(a2) // "." 
          if a3 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a3) // " " 

          a1 = bottom_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          if rem < 50 
            temp2 = temp2 // chs(a2) // " " 
          else 
            temp2 = temp2 // chs(a2+1) // " " 
          end 
          temp = temp // chs(a2) // "." 
          if a3 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a3) // " " 

          a1 = right_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          if rem < 50 
            temp2 = temp2 // chs(a2) // " " 
          else 
            temp2 = temp2 // chs(a2+1) // " " 
          end 
          temp = temp // chs(a2) // "." 
          if a3 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a3) // " " 

          a1 = top_limit * 24 
          a2 = a1 / 100 
          a3 = rem 
          if rem < 50 
            temp2 = temp2 // chs(a2)
          else 
            temp2 = temp2 // chs(a2+1)
          end 
          temp = temp // chs(a2) // "." 
          if a3 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a3)

          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%Page ~page_cnt  ~page_cnt 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%BeginPageSetup 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%PageBoundingBox: ~temp2 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%PageHiResBoundingBox: ~temp 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%PageHiResSystemBox: ~temp3 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%EndPageSetup 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
&dA 
&dA &d@    Step 2: Generate the PT table from the CT table 
&dA 
          xystring_out = "" 
          ycnt = 0 
          pt_cnt = 0 

          loop for t3 = 1 to ct_cnt 
            tget [CT,t3] out 
&dA &d@            
&dA &d@      Loop for special case of beginning of staff lines 
&dA 
            a1 = 0 
            a2 = len(out) 
            if out{a2-2,3} = " 81" 
              if active_font < 1013    /* music font 
                a3 = len(xystring_out) 
                if a3 > 0 
                  if xystring_out{a3} <> "Q" 
                    a1 = 1             /* new staff lines 
                  end 
                end 
              end 
            end 

            if out con "charout" 
              temp = out{25..} 
              tput [Y,1] ~temp 
              tget [Y,1] t5 
              t5 += 1000 
              if t5 <> active_font or len(xystring_out) > 60 or a1 = 1 
                if len(xystring_out) > 0 
                  xystring_out = xystring_out // ")" 
                  ++pt_cnt 
                  tput [PT,pt_cnt] ~xystring_out 
                  loop for t4 = 2 to ycnt - 1 
                    tget [Y,t4] temp 
                    ++pt_cnt 
                    tput [PT,pt_cnt] ~temp 
                  repeat 
                  tget [Y,ycnt] temp 
                  temp = temp // " 0 0 ] xyshow" 
                  ++pt_cnt 
                  tput [PT,pt_cnt] ~temp 
                  ycnt = 0 
                  xystring_out = "" 
                end 

                if t5 <> active_font 
                  active_font = t5 
                  ++pt_cnt 
                  tput [PT,pt_cnt] /Bitfont~t5  findfont 24 scalefont setfont
                end 

                if out con "loc =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                end 
                tput [Y,1] ~temp 
                tget [Y,1] t1 t5 
                lastx = t1 
                lasty = t5 

                perform move_to_loc (t1,t5) 
                ++pt_cnt 
                tput [PT,pt_cnt] ~mtloc 

                if t3 = ct_cnt 
                  if out con "char =" 
                    t1 = mpt 
                    temp = out{t1+7..} 
                    t5 = int(temp) 
                    temp = oct(t5) 
                    ++pt_cnt 
                    tput [PT,pt_cnt] (\~temp ) show 
                  end 
                  goto CMP_DONE 
                else 
                  tget [CT,t3+1] temp 
                  if temp con "charout" 
                    temp = temp{25..} 
                    tput [Y,1] ~temp 
                    tget [Y,1] t5 
                    t5 += 1000 
                    if t5 <> active_font 
                      if out con "char =" 
                        t1 = mpt 
                        temp = out{t1+7..} 
                        t5 = int(temp) 
                        temp = oct(t5) 
                        ++pt_cnt 
                        tput [PT,pt_cnt] (\~temp ) show 
                      end 
                      goto NXT_CHAR 
                    end 
                  end 
                end 
&dA 
&dA &d@          At this point, you have called for a new font and/or 
&dA &d@          you are restarting the xystring_out and 
&dA &d@          there is more than one character in this new font.  
&dA &d@          Time to setup the xyshow macro.  
&dA 
                if out con "char =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                  t5 = int(temp) 
                  if t5 > 31 and t5 < 127 and t5 <> 40 and t5 <> 41 and t5 <> 92
                    xystring_out = "(" // chr(t5) 
                  else 
                    temp = oct(t5) 
                    if len(temp) < 3 
                      temp = "0" // oct(t5) 
                    end 
                    xystring_out = "(\" // temp 
                  end 
                  ycnt = 2 
                  temp = "[ " 
                  tput [Y,ycnt] ~temp 
                end 
&dA 
&dA &d@          Otherwise, you are adding to the xyshow macro 
&dA 
              else 
                if out con "loc =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                end 
                tput [Y,1] ~temp 
                tget [Y,1] t1 t5 

                perform compute_delta_move (lastx, lasty, t1, t5) 

                lastx = t1 
                lasty = t5 

                if out con "char =" 
                  t1 = mpt 
                  temp = out{t1+7..} 
                  t5 = int(temp) 
                  if t5 > 31 and t5 < 127 and t5 <> 40 and t5 <> 41 and t5 <> 92
                    xystring_out = xystring_out // chr(t5) 
                  else 
                    temp = oct(t5) 
                    if len(temp) < 3 
                      temp = "0" // oct(t5) 
                    end 
                    xystring_out = xystring_out // "\" // temp 
                  end 
                end 
                tget [Y,ycnt] temp 
                temp = temp // " " // mtloc 
                tput [Y,ycnt] ~temp 
                if len(temp) > 60 
                  ++ycnt 
                  temp = "  " 
                  tput [Y,ycnt] ~temp 
                end 

                if t3 = ct_cnt 
                  if len(xystring_out) > 0 
                    xystring_out = xystring_out // ")" 
                    ++pt_cnt 
                    tput [PT,pt_cnt] ~xystring_out 

                    loop for t4 = 2 to ycnt - 1 
                      tget [Y,t4] temp 
                      ++pt_cnt 
                      tput [PT,pt_cnt] ~temp 
                    repeat 
                    tget [Y,ycnt] temp 
                    temp = temp // " 0 0 ] xyshow" 
                    ++pt_cnt 
                    tput [PT,pt_cnt] ~temp 
                    ycnt = 0 
                    xystring_out = "" 
                  end 
                end 
              end 
            end 
NXT_CHAR: 
          repeat 

CMP_DONE: 
&dA 
&dA &d@    Step 3: Add the regular slur dictionaries to the SD table 
&dA &d@              and generate the PT2 table 
&dA 
          pt_cnt2 = 0 
          t6 = 0 
          a1 = 0 
          a4 = 0                /* stores maximum height 
          a5 = 0                /* stores maximum width 
          loop for t3 = 1 to st_cnt 
            tget [ST,t3] out 
            out = trm(out) 
            if out con "Calling" 
              a6 = 0            /* height counter 
              ++t6 
              if t6 = 193 
                a1 = t3 - 1      /* last ":" in regular dictionary 
                t3 = st_cnt      /* exit loop 
              end 
            else 
              if out{1} <> ":" 
                ++a6            /* increment height 
                a7 = len(out) 
                if a7 > a5 
                  a5 = a7       /* new maximum width 
                end 
              else 
                if a6 = 0       /* this is the first ":" 
                else 
                  if a6 > a4 
                    a4 = a6     /* new maximum height 
                  end 
                  a6 = 0        /* redundant, but safe 
                end 
              end 
            end 
          repeat 

          if a1 = 0 
            a1 = st_cnt 
          else 
            t6 = 192 
          end 
&dA 
&dA &d@      The meaning of a1 is as follows: 
&dA &d@         Normally (almost always) the number of regular slurs on a 
&dA &d@         page will not exceed 192.  In this case, a1 = st_cnt, and 
&dA &d@         all regular slurs will fit into one dictionary.  
&dA &d@         When a1 < st_cnt, this means that there are regular slurs 
&dA &d@         which did not fit into the primary slur dictionary and 
&dA &d@         will need to be included in subsequent dictionaries.  
&dA &d@      The meaning of t6: 
&dA &d@         t6 is the number of slurs in the primary slur dictionary 
&dA 
          a2 = 1 
          a3 = 1 

          if a1 > 0 
            perform build_regular_slur_dict (t6, a2, a1, a4, a5, a3, page_cnt)
          end 
&dA 
&dA &d@      For the moment, this code assumes a maximum of two regular 
&dA &d@        slur dictionaries, and will fail otherwise.  
&dA 
          if a1 < st_cnt 
            t6 = 0 
            a2 = a1 + 1              /* next entry 
            a1 = 0 
            a4 = 0                /* stores maximum height 
            a5 = 0                /* stores maximum width 
            loop for t3 = a2 to st_cnt 
              tget [ST,t3] out 
              if out con "Calling" 
                a6 = 0            /* height counter 
                ++t6 
                if t6 = 193 
                  if (Debugg & 0x12) > 0 
                    pute For the moment, this code assumes a maximum of 
                    pute two regular slur dictionaries.  No provision is 
                    pute made for overflow; extra slurs will be discarded.  
                  end 
                  a1 = t3 - 1      /* last ":" in regular dictionary 
                  t6 = 192 
                  t3 = st_cnt      /* exit loop 
                end 
              else 
                if out{1} <> ":" 
                  ++a6            /* increment height 
                  a7 = len(out) 
                  if a7 > a5 
                    a5 = a7       /* new maximum width 
                  end 
                else 
                  if a6 = 0       /* this is the first ":" 
                  else 
                    if a6 > a4 
                      a4 = a6     /* new maximum height 
                    end 
                    a6 = 0        /* redundant, but safe 
                  end 
                end 
              end 
            repeat 
            if a1 = 0 
              a1 = st_cnt 
            end 
            a3 = 2 
            perform build_regular_slur_dict (t6, a2, a1, a4, a5, a3, page_cnt)
          end 
&dA 
&dA &d@      Build long slur dictionaries 
&dA 
          if sst_cnt > 0 
            a1 = 0 
            a2 = 0 
            a3 = 3 
            loop for t3 = 1 to sst_cnt 
              tget [SST,t3] out 
              out = out // pad(4) 
              if out{1,4} = "Call" 
                a1 = t3 
                ++t3                /* skip ":" 
              else 
                if out{1} = ":" 
                  a2 = t3 
                  perform build_long_slur_dict (a1, a2, a3, page_cnt) 
                  ++a3 
                end 
              end 
            repeat 
          end 
&dA 
&dA &d@    Step 4: Write the PT and PT2 tables for this page to the PPT table 
&dA 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % This is the PT table for page ~page_cnt 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % ==================== 
          loop for t3 = 1 to pt_cnt 
            tget [PT,t3] temp 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] ~temp 
          repeat 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % =========================== 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % This is the PT2 table for page ~page_cnt 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % ===================== 
          loop for t3 = 1 to pt_cnt2 
            tget [PT2,t3] temp 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] ~temp 
          repeat 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % =========================== 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] showpage 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] %%PageTrailer 
          if (Addfiles & 0x02) = 0x02 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] %=BeginMPGData: ~page_cnt 
            loop for t3 = mpgfile_start(page_cnt) to 1000000 
              tget [X,t3] line 
              ++ppt_cnt 
              tput [PPT,ppt_cnt] %=~line 
              if line{1} = "P"
                t3 = 1000000 
              end 
            repeat 
            ++ppt_cnt 
            tput [PPT,ppt_cnt] %=EndMPGData: ~page_cnt 
          end 
          ++ppt_cnt 
          tput [PPT,ppt_cnt] % 
&dA 
&dA &d@    Step 5: Initialize for the next page
&dA 
          setup gstr,300,3100,3 
          ++page_cnt 

          active_font = 0 

          treset [PT] 
          treset [PT2] 
          treset [SST] 
          treset [ST] 
          treset [CT] 

          st_cnt  = 0 
          ct_cnt  = 0 
          sst_cnt = 0 
          pt_cnt  = 0 
          pt_cnt2 = 0 

          sysnum = 0 
          f12 = 0 
          scf = notesize 

          goto TOP2 
        end 

        if line{1} = "E" 
          line = line // pad(12) 
          loop for t5 = 1 to SUPERMAX 
            if supermap(t5) <> 0 
              if (Debugg & 0x12) > 0 
                pute Outstanding superobject at end of line 
              end 
              return 
            end 
          repeat 
          loop for c8 = 1 to ntext 
            if line{c8+2} <> " " 
              if line{c8+2} <> "*" 
                if line{c8+2} <> xbyte(c8) 
                  if (Debugg & 0x12) > 0 
                    pute Current xbyte different from xbyte at end of line 
                  end 
                  return 
                end 
                y = psq(f12) + f(f12,c8) 
                if xbyte(c8) = "-" 
                  x = sp + syslen 
                  perform sethyph (c8,sysright) 
                end 
                if "_,.;:!?" con xbyte(c8) 
                  uxstop(c8) = sp + syslen - phpar(56) 
                  underflag = 2 
                  perform setunder (c8) 
                end 
                xbyte(c8) = "*" 
              else 
                if "_,.;:!?" con xbyte(c8) 
                  y = psq(f12) + f(f12,c8) 
                  underflag = 1 
                  if uxstop(c8) > sp + syslen - phpar(57) 
                    uxstop(c8) = sp + syslen - phpar(57) 
                  end 
                  perform setunder (c8) 
                end 
              end 
            end 
          repeat 
          goto TOP2 
        end 
        if line{1} = "S" 
&dA 
&dA &d@         S Y S T E M  (recoded &dA05/26/03&d@) &dIOK&d@ 
&dA &d@         ÄÄÄÄÄÄÄÄÄÄÄ  
&dA 
          f12 = 0 
          sysnum  = sysnum + 1 
          sub = 5 
          sp = int(line{sub..}) 

          sysy = int(line{sub..}) 
          syslen = int(line{sub..}) 
          sysright = sysy + syslen              /* added &dA12/31/08&d@ 
          sysh = int(line{sub..}) 
          f11 = int(line{sub..}) 
          line = line // "  " 
          tline = line{sub..} 
          tline = mrt(tline) 
          syscode = tline{2..} 
          if syscode con quote 
            syscode = syscode{1,mpt-1} 
          end 
&dA 
&dA &d@    Code to check number of parts in syscode (modified &dA11/13/03&d@) &dIOK&d@ 
&dA 
          a2 = 0 
          loop for c8 = 1 to len(syscode) 
            if ".:,;" con syscode{c8} 
              ++a2 
            end 
          repeat 
          if a2 <> f11 and syscode <> "" 
            if (Debugg & 0x12) > 0 
#if DMUSE 
              putc &dASyscode Warning&d@: Incorrect number of parts in syscode.  rec = ~(rec - 1)
#else 
              pute Syscode Warning: Incorrect number of parts in syscode.  rec = ~(rec - 1)
#endif 
            end 
          end 
&dA   
          sysflag = 0 
          goto TOP2 
        end 
        if line{1} = "L" or line{1} = "l"        /* New &dA11/11/05&d@ 
&dA 
&dA &d@         L I N E  
&dA &d@         ÄÄÄÄÄÄÄ  
&dA 
          stave_type = 0 
          if line{1} = "l" 
            line{1} = "L" 
            stave_type = 1 
          end 
          loop for c8 = 1 to 10 
            dyoff(c8) = 0 
            uxstart(c8) = 0 
            backloc(c8) = 0 
            ibackloc(c8) = 0 
          repeat 

          line = line // "            " 
          f12 = f12 + 1 
&dA 
&dA &d@    Field 2: y off-set in system  
&dA 
          psq(f12) = int(line{3..}) 
          psq(f12) += sysy 
&dA 
&dA &d@    Field 3: text off-set(s) from line   (separated by |) 
&dA 
          ntext = 0 
NSR1: 
          ++ntext 
          f(f12,ntext) = int(line{sub..}) 
          if line{sub} = "|" 
            ++sub 
            goto NSR1 
          end 
&dA 
&dA &d@    Field 4: dyoff(s)   separated by | 
&dA 
          c8 = 0 
NSR2: 
          ++c8 
          dyoff(c8) = int(line{sub..}) 
          if line{sub} = "|" 
            ++sub 
            goto NSR2 
          end 
&dA 
&dA &d@    Field 5: uxstart(s) separated by | 
&dA 
          c8 = 0 
NSR3: 
          ++c8 
          uxstart(c8) = int(line{sub..}) 
          if line{sub} = "|" 
            ++sub 
            goto NSR3 
          end 
&dA 
&dA &d@    Field 6: backloc(s) separated by | 
&dA 
          c8 = 0 
NSR4: 
          ++c8 
          backloc(c8) = int(line{sub..}) 
          ibackloc(c8) = backloc(c8)            /* New &dA08/26/03&d@ &dIOK&d@ 
          if line{sub} = "|" 
            ++sub 
            goto NSR4 
          end 

          tline = line{sub+1..} 
          tline = mrt(tline) 
&dA 
&dA &d@    Field 7: xbyte(s)   (length of field = number of bytes) 
&dA 
          if tline con " " 
            c8 = mpt - 1 
            if ntext < c8 
              loop for ntext = ntext + 1 to c8 
                f(f12,ntext) = f(f12,ntext-1) + pvpar(41) 
              repeat 
            end 
            loop for c8 = 1 to ntext 
              xbyte(c8) = tline{c8} 
            repeat 
          end 
&dA 
&dA &d@                New &dA08/28/03&d@ &dIOK&d@ 
&dA 
          loop for c8 = 1 to ntext 
            if dyoff(c8) = 0 
              dyoff(c8) = dyoff(1) 
            end 
            if uxstart(c8) = 0 
              uxstart(c8) = uxstart(1) 
            end 
            if backloc(c8) = 0 
              backloc(c8) = backloc(1) 
            end 
            if ibackloc(c8) = 0 
              ibackloc(c8) = ibackloc(1) 
            end 
          repeat 
&dA 
&dA &d@    Field 8: y off-set to virtual staff line (0 = none) 
&dA 
          vst(f12) = 0 
          if tline con " " 
            tline = tline{mpt..} 
            vst(f12) = int(tline) 
            tline = tline // " " 
            tline = tline{sub..} 
          end 
&dA 
&dA &d@    Field 9: notesize (0 = not specified; i.e., no change) 
&dA 
          if tline con " " 
            tline = tline{mpt..} 
            c8 = int(tline) 

            tline = tline // " "            /* New code &dA09/14/03&d@ &dIOK&d@ 
            tline = tline{sub..}            /*  "    "      " 

            if chr(c8) in [6,14,16,18,21]   /* New: notesize 16 added &dA12/31/08&d@ &dNnot OK
              if c8 <> notesize 
                notesize = c8 
                perform ps_init_par 
              end 
            end 
          end 
          nsz(f12) = notesize               /* New code &dA11/13/03&d@ &dIOK&d@ 
&dA 
&dA &d@    Field 10: additional off-set for figured harmony   New &dA09/14/03&d@ &dIOK&d@ 
&dA 
          figoff(f12) = 0 
          if tline con " " 
            tline = tline{mpt..} 
            figoff(f12) = int(tline) 

            tline = tline // " "            /* New code &dA09/14/03&d@ &dIOK&d@ 
            tline = tline{sub..}            /*  "    "      " 
          end 

          y = psq(f12) 
          perform staff (syslen,stave_type) 
          if vst(f12) > 0 
            y = psq(f12) + vst(f12) 
            perform staff (syslen,stave_type) 
          end 
          loop for c8 = 1 to ntext 
            buxstop(c8) = 1000000 
          repeat 
          goto TOP2 
        end 
        if line{1} = "@" 
&dA 
&dA &d@          @ - L I N E 
&dA &d@          ÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          goto TOP2 
        end 
        if line{1} = "Y" 
&dA 
&dA &d@          Y - L I N E 
&dA &d@          ÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          sub = 3 
          z = int(line{sub..}) 
          if z = 0                             /* New &dA03/26/05&d@ 
            goto TOP2 
          end 
          x = int(line{sub..}) 
          ttext = " " 
          if line{sub} = "C" or line{sub} = "R" 
            ttext = line{sub} // " " 
            ++sub 
          end 

          y = int(line{sub..}) 
          tline = line{sub..} 
          tline = mrt(tline) 
          line = "X " // chs(z) // " " // chs(x) // ttext // chs(y) // " " 
          if tline <> "" 
            loop for t3 = 1 to len(tline) 
              if tline{t3} = "\" 
                if t3 < len(tline) 
                  if ">]" con tline{t3+1} 
                    ++t3                      /* skip \> and \] 
                  else 
                    if "<[" con tline{t3+1} 
                      loop while t3 < len(tline) and tline{t3} <> "|" 
                        ++t3                  /* skip up to "|" character 
                      repeat 
                    else 
                      line = line // tline{t3} 
                    end 
                  end 
                else 
                  line = line // tline{t3} 
                end 
              else 
                line = line // tline{t3} 
              end 
            repeat 
          end 
        end 

        if line{1} = "X" 
&dA 
&dA &d@          X - L I N E 
&dA &d@          ÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          lpt = 3 
          tline = txt(line,[' '],lpt) 
          z = int(tline) 
          if lpt > len(line) 
            if z = 6 or z = 14 or z = 21 or z = 18 or z = 16 
              notesize = z 
              perform ps_init_par 
              scf = notesize 
            end 
            goto TOP2 
          end 

          tline = txt(line,[' '],lpt) 
          tline = tline // "  " 
          x = int(tline) 
          ttext = tline{sub} 

          tline = txt(line,[' '],lpt) 
          y = int(tline) 
          if lpt > len(line) 
            line = "" 
          else 
            line = line{lpt+1..} 
            line = trm(line) 
          end 
&dA 
&dA &d@    Code added &dA03/04/05&d@ to deal with "C" and "R" options 
&dA 
          if ttext = "C" or ttext = "R" 
            perform line_length (a1) 
            if ttext = "C" 
              a1 >>= 1 
            end 
            x -= a1 
          end 
          a1 = 0 
          perform setwords (a1) 

          goto TOP2 
        end 
        if line{1} = "J" 
&dA 
&dA &d@         O B J E C T S  
&dA &d@         ÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          tget [X,rec-1] line .t3 jtype ntype obx oby z t3 t3 supcnt 
          if jtype = "F" 
            oby += figoff(f12) 
          end 

          save_jtype = jtype 
          if jtype = "N" 
            loop for c8 = 1 to ntext 
              uxstop(c8) = sp + obx + phpar(7) 
              buxstop(c8) = 1000000 
            repeat 
          end 
*  
          if jtype = "D" 
            if ntype = 0 
              goto CZ4 
            end 
            if bit(1,ntype) = 1 
              goto CZ4 
            end 
            if bit(2,ntype) = 1 and f12 = 1 
              goto CZ4 
            end 
            if bit(3,ntype) = 1 and f12 = f11 
              goto CZ4 
            end 

        /* skip over directives 
SKD3: 
            tget [X,rec] line2 
            if line2{1} = "W" 
              ++rec 
              goto SKD3 
            end 

            goto TOP2 
          end 
&dA 
&dA &d@   Collect super-object information 
&dA 
CZ4: 
          if supcnt > 0 
        /*  This was the old strip8 code 
            loop for t3 = 1 to 7 
              if line con " " 
                line{mpt} = "." 
              end 
            repeat 
            if line con " " 
              line = line{mpt+1..} 
            else 
              line = "" 
            end 

            if int(line) <> supcnt       /* TEMP 
              if (Debugg & 0x12) > 0 
                pute Error reading an object record 
              end 
              return 
            end 
            lpt = 0 
            tline = txt(line,[' '],lpt) 
            loop for t3 = 1 to supcnt 
              tline = txt(line,[' '],lpt) 
              t4 = int(tline) 
*     look for previous reference to this superobject  
              loop for t5 = 1 to SUPERMAX 
                if supermap(t5) = t4 
                  goto WD 
                end 
              repeat 
              t1 = 0 
              loop for t5 = 1 to SUPERMAX 
                if supermap(t5) = 0 
                  t1 = t5 
                  t5 = SUPERMAX 
                end 
              repeat 
              if t1 = 0 
                if (Debugg & 0x12) > 0 
                  pute No more superobject capacity 
                end 
                return 
              end 
&dA 
&dA &d@     if not found, then set up reference to this superobject. 
&dA 
              t5 = t1 
              supermap(t5) = t4 
              superpnt(t5) = 1 
*       t5 (value 1 to SUPERMAX) = pointer into ps_superdata for this superobject
WD: 
              t1 = superpnt(t5) 
*       store object information in ps_superdata and increment superpnt 
              superpnt(t5) = t1 + 3       /* New increment in ps_superdata pointer &dA12/21/10
              ps_superdata(t5,t1) = obx 
              ps_superdata(t5,t1+1) = oby 
&dA 
&dA &d@   New code &dA12/21/10&d@.  We need to determine whether there is "color" in this
&dA &d@            object.  If there is, we need to store the "color flag" in 
&dA &d@            ps_superdata(t5,t1+2), a new element of ps_superdata.  The value
&dA &d@            matters only for dskpage and pspage.  
&dA 
              a2 = 0 
              a1 = rec 
              loop 
                tget [X,a1] line2 
                ++a1 
                if line2{1} = "C" 
                  a2 = 1 
                end 
              repeat while line2{1} = "K" or line2{1} = "C" 
              ps_superdata(t5,t1+2) = a2 
            repeat 
          end 
&dA 
&dA &d@     if no sub-objects, then typeset object 
&dA 
          if vst(f12) > 0 and oby > 700 
            oby -= 1000 
            oby += vst(f12) 
          end 

          if z > 32 
            x = sp + obx 
            if jtype <> "B" 
              y = psq(f12) + oby 
              perform setmus 
            end 
          end 
&dA 
&dA &d@   typeset underline (if unset) 
&dA 
          saverec = rec 
          if jtype = "R" 
            loop for c8 = 1 to ntext 
              if "_,.;:!?" con xbyte(c8) 
&dA 
&dA &d@   check next note for new syllable 
&dA 
YR4: 
                tget [X,rec] line 
                ++rec 
                line = line // pad(12) 
                if line{1} = "E" 
                  if line{c8+2} = "*" 
                    goto YR2 
                  end 
                  goto YR3 
                end 
                if line{1,3} = "J N" 
YR1: 
                  tget [X,rec] line 
                  ++rec 
                  if "kKA" con line{1} 
                    goto YR1 
                  end 
                  if line{1} = "T" 
                    c9 = int(line{3..}) 
                    c9 = int(line{sub..})     /* text line number 
                    if c8 = c9 
                      goto YR2 
                    end 
                    goto YR1 
                  end 
                  goto YR3 
                end 
                goto YR4 
* 
YR2: 
                y = psq(f12) + f(f12,c8) 
                underflag = 1 
                if mpt > 1 
                  uxstop(c8) -= phpar(20) 
                end 
                if buxstop(c8) < uxstop(c8) 
                  uxstop(c8) = buxstop(c8) 
                end 
                perform setunder (c8) 
                xbyte(c8) = "*" 
                buxstop(c8) = 1000000 
              end 
YR3: 
              rec = saverec 
            repeat 
          end 

          if jtype = "B" 
            oby = 0 
            loop for c8 = 1 to ntext 
              buxstop(c8) = sp + obx - phpar(57) 
            repeat 
          end 
          goto TOP2 
        end 
        if line{1} = "k" 
&dA 
&dA &d@      "Silent" S U B - O B J E C T S 
&dA &d@      ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          goto TOP2 
        end 
        if line{1} = "K" or line{1} = "C"     /* "C" added &dA12/17/10&d@ 
&dA 
&dA &d@       S U B - O B J E C T S 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          if line{1} = "C"                    /* New &dA12/17/10&d@ 
            color_flag = 1 
          else 
            color_flag = 0 
          end 

          tget [X,rec-1] .t3 sobx soby z 
          x = sp + obx + sobx 
          y = psq(f12) + oby + soby 
          perform setmus 
          if save_jtype = "B" and z = DOT_CHAR 
            y += vst(f12) 
            perform setmus 
          end 
          color_flag = 0 

          goto TOP2 
        end 
        if line{1} = "A"                   /* Added &dA11-11-93&d@ 
&dA 
&dA &d@       A T T R I B U T E S  
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ  
&dA 
          goto TOP2 
        end 
        if line{1} = "W" or line{1} = "w"    /* New &dA11/29/09&d@ 
&dA 
&dA &d@       W O R D S 
&dA &d@       ÄÄÄÄÄÄÄÄÄ 
&dA 
          lpt = 3 
          tline = txt(line,[' '],lpt) 
*  line structure = sobx soby font# text 
          sobx = int(tline) 
          tline = txt(line,[' '],lpt) 
          soby = int(tline) 
          tline = txt(line,[' '],lpt) 
          z = int(tline) 
          if len(line) > lpt and z <> 0         /* &dA10/01/03&d@ adding condition z <> 0  &dIOK
            line = line{lpt+1..} 
            x = sp + obx + sobx 
            y = psq(f12) + oby + soby 
            a1 = 0 
            perform setwords (a1) 
          end 
          goto TOP2 
        end 
        if line{1} = "T" 
&dA 
&dA &d@       T E X T 
&dA &d@       ÄÄÄÄÄÄÄ 
&dA 
          line = line // "  " 
*  line structure = sobx tlevel[|soby] ttext xbyte textlen 
          sobx = int(line{3..}) 
          tlevel = int(line{sub..}) 
          if tlevel < 1 or tlevel > 10 
            if (Debugg & 0x12) > 0 
              pute Error: Invalid tlevel in Text record ~(rec - 1) 
            end 
            return    
          end 
          soby = 0 
          if line{sub} = "|" 
            ++sub 
            soby = int(line{sub..}) 
          end 
          line = line{sub..} 
          line = mrt(line)           /* ttext is next in line 
          if line con " " 
            ttext = line{1,mpt-1} 
            line = line{mpt..} 
            line = mrt(line) 
          end 
&dA 
&dA &d@  typeset back hyphons or underlines (if they exist) 
&dA 
          if xbyte(tlevel) = "-" 
            y = psq(f12) + f(f12,tlevel) 
            x = sp + obx + sobx 
            perform sethyph (tlevel,sysright) 
          end 

          if "_,.;:!?" con xbyte(tlevel) 
            x = sp + obx + sobx - phpar(20) 
            if mpt > 1 
              x -= phpar(20) 
            end 
            if uxstop(tlevel) > x 
              uxstop(tlevel) = x 
            end 
            y = psq(f12) + f(f12,tlevel) 
            if ttext = "~" 
              underflag = 2 
            else 
              underflag = 1 
            end 
            perform setunder (tlevel) 
          end 
&dA 
&dA &d@  typeset underline if terminator (~) is found  (Code added &dA02-24-95&d@) 
&dA 
          if ttext = "~" 
            x = sp + obx + sobx + phpar(20) + phpar(20) 
            uxstop(tlevel) = x 
            y = psq(f12) + f(f12,tlevel) 
            underflag = 1 
            perform setunder (tlevel) 
            xbyte(tlevel) = " " 
            goto TOP2 
          end 

          sub = 1 
          loop while ttext con "_" 
            ttext{mpt} = " " 
          repeat 

          textlen = 0 
          xbyte(tlevel) = "*" 
          if line <> "" 
            line = line // " " 
            xbyte(tlevel) = line{1} 
            textlen = int(line{2..}) 
          end 

          x = sp + obx + sobx 
          y = psq(f12) + f(f12,tlevel) + soby 
          backloc(tlevel) = x + textlen 
          uxstart(tlevel) = x + textlen + phpar(19) 
          z = mtfont 
          line = ttext 
          a1 = 1 
          perform setwords (a1) 
          goto TOP2 
        end 
        if line{1} = "H" or line{1} = "P"           /* "P" added &dA12/17/10&d@ 
&dA 
&dA &d@       S U P E R - O B J E C T S 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          lpt = 3 
          tline = txt(line,[' '],lpt) 
*  line structure = supernum htype . . .  
          supernum = int(tline) 
*  get ps_superdata for this superobject 
          loop for t5 = 1 to SUPERMAX 
            if supermap(t5) = supernum 
              goto WE 
            end 
          repeat 
          if (Debugg & 0x12) > 0 
            pute Error: No refererce to superobject ~supernum  in previous objects
          end    
          return 
&dA 
&dA &d@  t5 = index into ps_superdata.  WE is the continuation point 
&dA 
WE: 
          htype = txt(line,[' '],lpt) 
          color_flag = 0                          /* New &dA12/17/10&d@ 
          if line{1} = "P" 
            if htype = "B" or htype = "T" 
              color_flag = 1 
            end 
          end 
&dA 
&dA &d@  compensate for out-of-order objects 
&dA 
&dA &d@  Code changes &dA12/21/10&d@: New index for second obx element 
&dA &d@                         Switching 3 superdata elements instead of 2 
&dA 
          if ps_superdata(t5,1) > ps_superdata(t5,4) 
            x1 = ps_superdata(t5,4) 
            y1 = ps_superdata(t5,5) 
            a1 = ps_superdata(t5,6) 
            ps_superdata(t5,4) = ps_superdata(t5,1) 
            ps_superdata(t5,5) = ps_superdata(t5,2) 
            ps_superdata(t5,6) = ps_superdata(t5,3 
            ps_superdata(t5,1) = x1 
            ps_superdata(t5,2) = y1 
            ps_superdata(t5,3) = a1 
          end 
&dA      
          if htype = "T" 
&dA 
&dA &d@  structure of &dDtie superobject&d@:  4. vertical position of tied note 
&dA &d@                                 5. horiz. displacement from 1st note 
&dA &d@                                 6. horiz. displacement from 2nd note 
&dA &d@                                 7. post adjustment of calculated left x position  &dA04/20/03&d@ &dIOK
&dA &d@                                 8. post adjustment of calculated y position          "
&dA &d@                                 9. post adjustment of calculated right x position    "
&dA &d@                                10. sitflag 
&dA &d@                                11. recalc flag 
&dA 
            tline = txt(line,[' '],lpt) 
            y1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) 
            tline = txt(line,[' '],lpt) 
            a2 = int(tline)                          /* tpost_x 
            tline = txt(line,[' '],lpt) 
            a3 = int(tline)                          /* tpost_y 
            tline = txt(line,[' '],lpt) 
            a4 = int(tline)                          /* tpost_leng 
            tline = txt(line,[' '],lpt) 
            sitflag = int(tline) 
            a1 = ps_superdata(t5,4) + x2 - x1        /* New index for second element &dA12/21/10
            perform settie (a1,a2,a3,a4) 
            color_flag = 0                           /* New &dA12/17/10&d@ 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "B" 
&dA 
&dA &d@  structure of &dDbeam superobject&d@: slope vertoff font# #obs bc(1) ...  
&dA 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline)                         /* @k 
            tline = txt(line,[' '],lpt) 
            a2 = int(tline)                         /* @m 
            tline = txt(line,[' '],lpt) 
            beamfont = int(tline) 
            t3 = ors("ffffgghiijjkkllmmnoopprr"{notesize})    /* old "Mbeamfont()"
            if beamfont = t3 
              stemchar = 59 
              beamt = pvpar(32) 
              qwid = phpar(3) 
            else 
              stemchar = 187 
              beamt = pvpar(32) * 4 + 3 / 5 
              qwid = phpar(5) 
            end 
            tline = txt(line,[' '],lpt) 
            bcount = int(tline) 
            t4 = 1 
            loop for t3 = 1 to bcount 
              ps_beamdata(t3,1) = ps_superdata(t5,t4) + sp 
              ps_beamdata(t3,2) = ps_superdata(t5,t4+1) + psq(f12) 
              ps_beamdata(t3,3) = ps_superdata(t5,t4+2) + psq(f12)   /* New data &dA12/21/10
              temp = txt(line,[' '],lpt) 
              temp = rev(temp) 
              t1 = 6 - len(temp) 
              msk_beamcode(t3) = temp // "00000"{1,t1} 
              t4 += 3                                    /* New increment in superdata &dA12/21/10
            repeat 
*   print beam 
            tbflag = 0 
            if tupldata(1) > 0 and tupldata(5) = supernum 
              tbflag = bit(4,tupldata(1)) 
              ++tbflag 
            end 
            perform ps_setbeam (a1,a2) 
            tupldata(1) = 0 
            supermap(t5) = 0 
            color_flag = 0                                 /* New &dA12/17/10&d@ 
            goto TOP2 
          end 
          if htype = "S" 
&dA 
&dA &d@  structure of &dDslur superobject&d@:  4. sitflag 
&dA &d@                                  5. extra horiz. displ. from obj-1 
&dA &d@                                  6. extra vert. displ. from obj-1 
&dA &d@                                  7. extra horiz. displ. from obj-2 
&dA &d@                                  8. extra vert. displ. from obj-2 
&dA &d@                                  9. extra curvature     (new 6-30-93) 
&dA &d@                                 10. beam flag        
&dA &d@                                 11. post adjustment to x co-ordinate 
&dA &d@                                 12. post adjustment to y co-ordinate 
&dA 
            slur_edit_flag = 0 
            tline = txt(line,[' '],lpt) 
            sitflag = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            y1 = int(tline) 
            if y1 <> 0 
              slur_edit_flag = 1 
            end 
            y1 += ps_superdata(t5,2) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)       /* New index for second obx &dA12/21/10
            tline = txt(line,[' '],lpt) 
            y2 = int(tline) 
            if y2 <> 0 
              slur_edit_flag = 1 
            end 
            y2 += ps_superdata(t5,5)                   /* New index for second oby &dA12/21/10
            if y1 > 700 
              y1 -= 1000 
              y1 += vst(f12) 
            end 
            if y2 > 700 
              y2 -= 1000 
              y2 += vst(f12) 
            end 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline)               /* addcurve 
            tline = txt(line,[' '],lpt) 
            t4 = int(tline) 
            postx = 0 
            posty = 0 
            if lpt < len(line) 
              tline = txt(line,[' '],lpt) 
              postx = int(tline) 
            end 
            if lpt < len(line) 
              tline = txt(line,[' '],lpt) 
              posty = int(tline) 
            end 
            if bit(5,sitflag) = 0           /* This condition added &dA04/26/05
              perform putslur (a1) 
            end 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "F" 
&dA 
&dA &d@  structure of &dDfigcon super-object&d@:  4. figure level 
&dA &d@                                     5. horiz. disp. from obj1 
&dA &d@                                     6. horiz. disp. from obj2 
&dA &d@                                     7. (optional) additional vert. disp.  &dANew 11/06/03
&dA &d@                                          from default height 
&dA 
            tline = txt(line,[' '],lpt) 
            a3 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)      /* New index for second obx &dA12/21/10
            y1 = 0 
            if lpt < len(line) 
              tline = txt(line,[' '],lpt) 
              y1 = int(tline) 
            end 
            perform putfigcon (a3) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "X" 
&dA 
&dA &d@  structure of &dDtuplet super-object&d@:  4. situation flag 
&dA &d@                                     5. tuplet number 
&dA &d@                                     6. horiz. disp. from obj1 
&dA &d@                                     7. vert. disp. from obj1 
&dA &d@                                     8. horiz. disp. from obj2 
&dA &d@                                     9. vert. disp. from obj2 
&dA &d@                                    10. associated beam super-number 
&dA 
            tline = txt(line,[' '],lpt) 
            sitflag = int(tline) 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            y1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) 
            tline = txt(line,[' '],lpt) 
            y2 = int(tline) 
            tline = txt(line,[' '],lpt) 
            a2 = int(tline) 
            if bit(3,sitflag) = 1 
              tupldata(1) = sitflag 
              tupldata(2) = a1 
              tupldata(3) = x1 
              tupldata(4) = x2 
              tupldata(5) = a2 
              tupldata(6) = y1 
              tupldata(7) = y2 
            else 
              x1 += ps_superdata(t5,1) 
              y1 += ps_superdata(t5,2) 
              x2 += ps_superdata(t5,4)         /* New index for second obx &dA12/21/10
              y2 += ps_superdata(t5,5)         /* New index for second oby &dA12/21/10
              if y1 > 700 
                y1 -= 1000 
                y1 += vst(f12) 
              end 
              if y2 > 700 
                y2 -= 1000 
                y2 += vst(f12) 
              end 
              perform puttuplet (a1) 
            end 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "V" 
&dA 
&dA &d@  structure of &dDtransp super-object&d@:  4. situation: 0=8av up, 1=8av down 
&dA &d@                                     5. horiz. disp. from obj1  
&dA &d@                                     6. horiz. disp. from obj2  
&dA &d@                                     7. vert. disp. from obj1 
&dA &d@                                     8. length of right vertical hook 
&dA 
            tline = txt(line,[' '],lpt) 
            a3 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)    /* New index for second obx &dA12/21/10
            tline = txt(line,[' '],lpt) 
            y1 = int(tline)                    /*   + ps_superdata(t5,2) 
            if y1 > 700 
              y1 -= 1000 
              y1 += vst(f12) 
            end 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline) 
            perform puttrans (a1,a3) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "E" 
&dA 
&dA &d@  structure of &dDending super-object&d@:  4. ending number (0 = none)  
&dA &d@                                     5. horiz. disp. from obj1  
&dA &d@                                     6. horiz. disp. from obj2  
&dA &d@                                     7. vert. disp. from staff lines  
&dA &d@                                     8. length of left vertical hook  
&dA &d@                                     9. length of right vertical hook 
&dA 
            tline = txt(line,[' '],lpt) 
            a3 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)    /* New index for second obx &dA12/21/10
            tline = txt(line,[' '],lpt) 
            y1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            a2 = int(tline) 
            perform putending (a1,a2,a3) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "D" 
&dA 
&dA &d@  structure of &dDdashes super-object&d@:  4. horiz. disp. from obj1  
&dA &d@                                     5. horiz. disp. from obj2  
&dA &d@                                     6. vert. disp. from staff lines  
&dA &d@                                     7. spacing parameter 
&dA &d@                                     8. font designator 
&dA 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)    /* New index for second obx &dA12/21/10
            tline = txt(line,[' '],lpt) 
            y1 = ps_superdata(t5,2) 
            if y1 > 700 
              y1 = vst(f12) 
            else 
              y1 = 0 
            end 
            y1 += int(tline) 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            a2 = int(tline) 
            perform putdashes (a1,a2) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "R" 
&dA 
&dA &d@  structure of &dDtrill super-object&d@:  4. situation: 1 = no trill, only ~~~~ 
&dA &d@                                                  2 = trill with ~~~~ 
&dA &d@                                                  3 = tr ~~~~ with sharp above
&dA &d@                                                  4 = tr ~~~~ with natural above
&dA &d@                                                  5 = tr ~~~~ with flat above
&dA &d@                                    5. horiz. disp. from object 1 
&dA &d@                                    6. horiz. disp. from object 2 
&dA &d@                                    7. vert. disp. from object 1 
&dA 
            tline = txt(line,[' '],lpt) 
            a1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)    /* New index for second obx &dA12/21/10
            tline = txt(line,[' '],lpt) 
            y1 = int(tline) + ps_superdata(t5,2) 
            if y1 > 700 
              y1 -= 1000 
              y1 += vst(f12) 
            end 
            perform puttrill (a1) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "W" 
&dA 
&dA &d@  structure of &dDwedge super-object&d@:  4. left spread  
&dA &d@                                    5. right spread 
&dA &d@                                    6. horiz. disp. from obj1 
&dA &d@                                    7. beg. vert. disp. from staff  
&dA &d@                                    8. horiz. disp. from obj2 
&dA &d@                                    9. end. vert. disp. from staff  
&dA 
            tline = txt(line,[' '],lpt) 
            c1 = int(tline) 
            tline = txt(line,[' '],lpt) 
            c2 = int(tline) 
            tline = txt(line,[' '],lpt) 
            x1 = int(tline) + ps_superdata(t5,1) 
            tline = txt(line,[' '],lpt) 
            c3 = ps_superdata(t5,2) 
            if c3 > 700 
              c3 = vst(f12) 
            else 
              c3 = 0 
            end 
            y1 = int(tline) + c3 
            tline = txt(line,[' '],lpt) 
            x2 = int(tline) + ps_superdata(t5,4)    /* New index for second obx &dA12/21/10
            a1 = x2 - x1 
            if a1 < phpar(39) 
              x2 = x1 + phpar(39) 
            end 
            tline = txt(line,[' '],lpt) 
            y2 = int(tline) + c3 
            perform putwedge (c1,c2) 
            supermap(t5) = 0 
            goto TOP2 
          end 
          if htype = "N" 
            supermap(t5) = 0 
            goto TOP2 
          end 
        end 
        if line{1} = "B" 
&dA 
&dA &d@       B A R    L I N E  (section recoded &dA05/26/03&d@)  &dIOK&d@ 
&dA &d@       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
          sub = 3 
          a7 = int(line{sub..}) 
          if a7 = 99 
            if sysflag = 0 
              sysflag = 1 
            end 
            goto TOP2 
          end 
&dA 
&dA &d@    First make sure that the system line is printed.  
&dA &d@    (this code moved here and revised &dA11/13/03&d@) &dIOK&d@ 
&dA 
          savesub = sub 
          savensz = notesize 
          if sysflag = 0 
&dA 
&dA &d@    Code added here &dA11/13/03&d@ to set govstaff for printing sysline, etc. &dIOK&d@ 
&dA 
            govstaff = 0 
            a2 = 0 
            loop for c8 = 1 to len(syscode) 
              if ".:,;" con syscode{c8} 
                ++a2 
                if mpt > 2 
                  if govstaff = 0 
                    govstaff = a2 
                  else 
                    if nsz(a2) > nsz(govstaff) 
                      govstaff = a2 
                    end 
                  end 
                end 
              end 
            repeat 
            if govstaff = 0 
              govstaff = f11                   /* default for govstaff 
            end 

            a2 = nsz(govstaff) 
            if a2 <> notesize 
              notesize = a2 
              perform ps_init_par 
            end 

            perform sysline 
            sysflag = 1 
          end 
          sub = savesub 
&dA    
          a8 = a7 & 0x0f 
          x = int(line{sub..}) 
          brkcnt = int(line{sub..}) 
          loop for t3 = 1 to brkcnt 
            a6 = int(line{sub..}) 
            barbreak(t3,1) = a6 + sysy 
            a6 = int(line{sub..}) 
            barbreak(t3,2) = a6 + sysy 
          repeat 
*    sort breaks in ascending order of offset  
          if brkcnt > 1 
            c5 = brkcnt - 1 
            loop for c1 = 1 to c5 
              c6 = c1 + 1 
              loop for c2 = c6 to brkcnt 
                if barbreak(c2,1) < barbreak(c1,1) 
                  c3 = barbreak(c1,1) 
                  c4 = barbreak(c1,2) 
                  barbreak(c1,1) = barbreak(c2,1) 
                  barbreak(c1,2) = barbreak(c2,2) 
                  barbreak(c2,1) = c3 
                  barbreak(c2,2) = c4 
                end 
              repeat 
            repeat 
          end 
* 
          x = x + sp 
          if a8 < 2 
            z = 82 
            perform barline 
          end 
          if a8 = 2 
            x = x - phpar(33)     /* phpar(33) = heavy - light + 1 
            z = 84 
            perform barline 
          end 
          if a8 = 3 
            z = 86 
            perform barline 
          end 
          if a8 = 5 
            z = 82 
            perform barline 
            x = x - phpar(48)     /* phpar(48) = light + delta-light (auto hpar(44))
            perform barline 
          end 
          if a8 = 6 
            z = 84 
            x = x - phpar(33) 
            perform barline 
            z = 82 
            x = x - phpar(34)     /* phpar(34) = light + delta-heavy (auto hpar(45))
            perform barline 
          end 
          if a8 = 9 
            z = 84 
            perform barline 
            z = 82 
            x = x + phpar(33) + phpar(34) - 1 
            perform barline 
            if a7 > 15 
              x = x + phpar(36) 
              loop for f12 = 1 to f11 
                y = psq(f12) + pvpar(3) 
                z = 44 
                perform setmus 
                y = y + pvpar(2) 
                perform setmus 
&dA 
&dA &d@        Adding code &dA05/26/03&d@ for print second set of dots in case of grandstaff   &dIOK
&dA &d@ 
                if vst(f12) > 0 
                  y = y - pvpar(2) + vst(f12) 
                  z = 44 
                  perform setmus 
                  y = y + pvpar(2) 
                  perform setmus 
                end 

              repeat 
            end 
          end 
          if a8 = 10 
            z = 84 
            perform barline 
            x = x - phpar(33) - phpar(34) + 1 
            perform barline 
          end 
&dA 
&dA &d@    Code added &dA11/13/03&d@ to reset notesize to local value &dIOK&d@ 
&dA 
          if notesize <> savensz 
            notesize = savensz 
            perform ps_init_par 
          end 
&dA   
          goto TOP2 
        end 
        goto TOP2 

TASK_DONE: 

        --page_cnt 
        zpnt = 0 
        loop for t3 = 1 to 140 
          t5 = 0 
          loop for t4 = 1 to 256 
            if glyph_record(t3,t4) > 0 
              if t5 = 0 
                ++zpnt 
                tput [ZZ,zpnt] font .w4 ~t3 
                ++zpnt 
                tput [ZZ,zpnt] ============== 
                t5 = 1 
              end 
              ++zpnt 
              tput [ZZ,zpnt] .t4 char .w4 ~t4 
            end 
          repeat 
        repeat 
        ++zpnt 
        tput [ZZ,zpnt] $ 

        perform build_page_pdict 

        a5 = 10000 
        a6 = 0 
        a7 = 10000 
        a8 = 0 
        loop for t5 = 1 to page_cnt 
          if box_top_limit(t5) < a5 
            a5 = box_top_limit(t5) 
          end 
          if box_bottom_limit(t5) > a6 
            a6 = box_bottom_limit(t5) 
          end 
          if box_left_limit(t5) < a7 
            a7 = box_left_limit(t5) 
          end 
          if box_right_limit(t5) > a8 
            a8 = box_right_limit(t5) 
          end 
        repeat 
&dA 
&dA &d@    Now construct the global box limits 
&dA 
&dA 
        left_limit = a7 
        right_limit = a8 
        top_limit = a5 
        bottom_limit = a6 

        left_limit -= 1 
        top_limit  -= 1 

        left_limit += 50 
        right_limit += 50 
        top_limit = 3150 - top_limit 
        bottom_limit = 3150 - bottom_limit 
&dA 
&dA &d@       Convert dots to points, using 300 dpi 
&dA &d@       Format = llx lly ulx uly 
&dA 
        temp3 = "" 
        temp2 = "" 
        a1 = left_limit * 24 
        a2 = a1 / 100 
        a3 = rem 
        if rem < 50 
          temp2 = temp2 // chs(a2) // " " 
        else 
          temp2 = temp2 // chs(a2+1) // " " 
        end 
        temp3 = temp3 // chs(a2) // "." 
        if a3 < 10 
          temp3 = temp3 // "0" 
        end 
        temp3 = temp3 // chs(a3) // " " 

        a1 = bottom_limit * 24 
        a2 = a1 / 100 
        a3 = rem 
        if rem < 50 
          temp2 = temp2 // chs(a2) // " " 
        else 
          temp2 = temp2 // chs(a2+1) // " " 
        end 
        temp3 = temp3 // chs(a2) // "." 
        if a3 < 10 
          temp3 = temp3 // "0" 
        end 
        temp3 = temp3 // chs(a3) // " " 

        a1 = right_limit * 24 
        a2 = a1 / 100 
        a3 = rem 
        if rem < 50 
          temp2 = temp2 // chs(a2) // " " 
        else 
          temp2 = temp2 // chs(a2+1) // " " 
        end 
        temp3 = temp3 // chs(a2) // "." 
        if a3 < 10 
          temp3 = temp3 // "0" 
        end 
        temp3 = temp3 // chs(a3) // " " 

        a1 = top_limit * 24 
        a2 = a1 / 100 
        a3 = rem 
        if rem < 50 
          temp2 = temp2 // chs(a2) 
        else 
          temp2 = temp2 // chs(a2+1) 
        end 
        temp3 = temp3 // chs(a2) // "." 
        if a3 < 10 
          temp3 = temp3 // "0" 
        end 
        temp3 = temp3 // chs(a3)
&dA 
&dA            

&dK &d@       putc %!PS 
&dK &d@       putc 
&dK &d@       putc % This is the PD dictionary 
&dK &d@       putc % ========================= 
&dK &d@       loop for t3 = 1 to pd_cnt 
&dK &d@         tget [PD,t3] temp 
&dK &d@         putc ~temp 
&dK &d@       repeat 
&dK &d@       putc % =========================== 
&dK &d@       putc 
&dK &d@       putc % This is the SD dictionary 
&dK &d@       putc % ========================= 
&dK &d@       loop for t3 = 1 to sd_cnt 
&dK &d@         tget [SD,t3] temp 
&dK &d@         putc ~temp 
&dK &d@       repeat 
&dK &d@       putc % =========================== 
&dK &d@       putc 
&dK &d@       putc % This is the PT table 
&dK &d@       putc % ==================== 
&dK &d@       loop for t3 = 1 to pt_cnt 
&dK &d@         tget [PT,t3] temp 
&dK &d@         putc ~temp 
&dK &d@       repeat 
&dK &d@       putc % =========================== 
&dK &d@       putc 
&dK &d@       putc % This is the PT2 table 
&dK &d@       putc % ===================== 
&dK &d@       loop for t3 = 1 to pt_cnt2 
&dK &d@         tget [PT2,t3] temp 
&dK &d@         putc ~temp 
&dK &d@       repeat 
&dK &d@       putc % =========================== 
&dK &d@       putc 
&dK &d@       putc showpage 

#if DMUSE 
        open [2,2] outfile 

        putf [2] %!PS-Adobe-3.0 
        loop for t1 = 1 to 9 
          putf [2] ~psfile_header(t1) 
        repeat 
        loop for t1 = 1 to finums
          putf [2] %=~time_stamps(t1) 
        repeat 
        putf [2] %%EndComments 
        putf [2] 
        putf [2] %%BeginProlog 
        putf [2] %%EndProlog 
        putf [2] 
        putf [2] %%BeginSetup 
        putf [2] 
        putf [2] % This is the PD dictionary 
        putf [2] % ========================= 
        loop for t3 = 1 to pd_cnt 
          tget [PD,t3] temp 
          putf [2] ~temp 
        repeat 
        putf [2] % =========================== 
        putf [2] 
        putf [2] % This is the SD dictionary 
        putf [2] % ========================= 
        loop for t3 = 1 to sd_cnt 
          tget [SD,t3] temp 
          putf [2] ~temp 
        repeat 
        putf [2] % =========================== 
        putf [2] 
        putf [2] %%EndSetup 
        putf [2] 
        loop for t3 = 1 to ppt_cnt 
          tget [PPT,t3] temp 
          putf [2] ~temp 
        repeat 
        putf [2] 
        putf [2] %%Trailer 
        putf [2] %%BoundingBox: ~temp2 
        putf [2] %%HiResBoundingBox: ~temp3 
        putf [2] 
        if (Addfiles & 0x01) = 0x01 
          loop for t1 = 1 to finums 
            loop for t2 = 1 to finums 
              if part_order(t2) = t1 
                t3 = t2 
                t2 = finums 
              end 
            repeat 
            t4 = fioffs(t3) - 4 
            putf [2] %=BeginMuseData: ~t1 
            loop for t5 = 1 to 100000 
              tget [FI,t4] line 
              ++t4 
              line = line // pad(4) 
              if line = "/END" 
                t5 = 100000 
              end 
              line = trm(line) 
              putf [2] %=~line 
            repeat 
            putf [2] %=EndMuseData: ~t1 
          repeat 
        end 
        putf [2] 
        putf [2] %%EOF
        putf [2] 

        close [2] 
#else 
        putc %!PS-Adobe-3.0 
        loop for t1 = 1 to 9 
          putc ~psfile_header(t1) 
        repeat 
        loop for t1 = 1 to finums   
          putc %=~time_stamps(t1) 
        repeat 
        putc %%EndComments 
        putc 
        putc %%BeginProlog 
        putc %%EndProlog 
        putc 
        putc %%BeginSetup 
        putc 
        putc % This is the PD dictionary 
        putc % ========================= 
        loop for t3 = 1 to pd_cnt 
          tget [PD,t3] temp 
          putc ~temp 
        repeat 
        putc % =========================== 
        putc 
        putc % This is the SD dictionary 
        putc % ========================= 
        loop for t3 = 1 to sd_cnt 
          tget [SD,t3] temp 
          putc ~temp 
        repeat 
        putc % =========================== 
        putc 
        putc %%EndSetup 
        putc 
        loop for t3 = 1 to ppt_cnt 
          tget [PPT,t3] temp 
          putc ~temp 
        repeat 
        putc 
        putc %%Trailer 
        putc %%BoundingBox: ~temp2 
        putc %%HiResBoundingBox: ~temp3 
        putc 
        if (Addfiles & 0x01) = 0x01 
          loop for t1 = 1 to finums 
            loop for t2 = 1 to finums 
              if part_order(t2) = t1 
                t3 = t2 
                t2 = finums 
              end 
            repeat 
            t4 = fioffs(t3) - 4 
            putc %=BeginMuseData: ~t1 
            loop for t5 = 1 to 100000 
              tget [FI,t4] line 
              ++t4 
              line = line // pad(4) 
              if line = "/END" 
                t5 = 100000 
              end 
              line = trm(line) 
              putc %=~line 
            repeat 
            putc %=EndMuseData: ~t1 
          repeat 
        end 
        putc 
        putc %%EOF 
        putc 
#endif 
      return 
&dA 
&dA &d@   End of processing music data 
&dA 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³D*  2. ps_setbeam (@k,@m)                                                        ³
&dA &d@³                                                                                 ³
&dA &d@³    Purpose:  Typeset beams and accompanying notes and                           ³
&dA &d@³              stems.  Also typeset accompanying tuplet, if present               ³
&dA &d@³                                                                                 ³
&dA &d@³    Inputs:   bcount        = number of notes under beam                         ³
&dA &d@³              ps_beamdata(.,1) = x-position of note                              ³
&dA &d@³              ps_beamdata(.,2) = y-position of note                              ³
&dA &d@³              ps_beamdata(.,3) = color_flag                                      ³
&dA &d@³              msk_beamcode(.)   = beam code                                      ³
&dA &d@³                                                                                 ³
&dA &d@³                  beam code = 6 digit number (string)                            ³
&dA &d@³                                                                                 ³
&dA &d@³                          0 = no beam                                            ³
&dA &d@³                          1 = continue beam                                      ³
&dA &d@³                          2 = begin beam                                         ³
&dA &d@³                          3 = end beam                                           ³
&dA &d@³                          4 = forward hook                                       ³
&dA &d@³                          5 = backward hook                                      ³
&dA &d@³                          6 = single stem repeater                               ³
&dA &d@³                          7 = begin repeated beam                                ³
&dA &d@³                          8 = end repeated beam                                  ³
&dA &d@³                                                                                 ³
&dA &d@³                      100000's digit = eighth level beams                        ³
&dA &d@³                       10000's digit = 16th level beams                          ³
&dA &d@³                        1000's digit = 32nd level beams                          ³
&dA &d@³                         100's digit = 64th level beams                          ³
&dA &d@³                          10's digit = 128th level beams                         ³
&dA &d@³                           1's digit = 256th level beams                         ³
&dA &d@³                                                                                 ³
&dA &d@³                                                                                 ³
&dA &d@³                       @k   = distance from first object (oby of                 ³
&dA &d@³                              note group) to top of top beam (for                ³
&dA &d@³                              stems up) or bottom of bottom beam                 ³
&dA &d@³                              (for stems down).  @k > 0 means                    ³
&dA &d@³                              stem up.                                           ³
&dA &d@³                       @m   = number of dots the beam falls                      ³
&dA &d@³                              (rises = negative) in a distance                   ³
&dA &d@³                              of 30 horizontal dots.  (i.e.                      ³
&dA &d@³                              slope * 30)                                        ³
&dA &d@³                 beamfont   = font for printing beam                             ³
&dA &d@³                 stemchar   = character number for stem                          ³
&dA &d@³                    beamt   = vertical space between beams (normally pvpar(32))  ³
&dA &d@³                     qwid   = width of quarter note (normally phpar(3))          ³
&dA &d@³              tupldata(1)   = tuplet situation flag                              ³
&dA &d@³              tupldata(2)   = tuplet number                                      ³
&dA &d@³              tupldata(3)   = x1 offset                                          ³
&dA &d@³              tupldata(4)   = x2 offset                                          ³
&dA &d@³              tupldata(6)   = y1 offset   / For case where tuple goes over       ³
&dA &d@³              tupldata(7)   = y2 offset   \ note heads &dAand&d@ there are chords.     ³
&dA &d@³                   tbflag   = print tuplet flag                                  ³
&dA &d@³                                                                                 ³
&dA &d@³    Outputs:  prints out beams, stems and notes by means of                      ³
&dA &d@³              procedures, printbeam, hook and revset.                            ³
&dA &d@³                                                                                 ³
&dA &d@³    Internal variables:                                                          ³
&dA &d@³                         @b = y-intercept of beam                                ³
&dA &d@³                         @f = temporary variable                                 ³
&dA &d@³                         @g = temporary variable (related to @@g)                ³
&dA &d@³                         @h = temporary variable                                 ³
&dA &d@³                         @i = temporary variable                                 ³
&dA &d@³                         @j = temporary counter                                  ³
&dA &d@³                         @k = |@m|                                               ³
&dA &d@³                         @n = temporary variable                                 ³
&dA &d@³                         @q = temporary counter                                  ³
&dA &d@³                         @s = temporary variable                                 ³
&dA &d@³                         @t = temporary variable                                 ³
&dA &d@³                        @@b = vertical range of note set                         ³
&dA &d@³                        @@g = top of staff line                                  ³
&dA &d@³                        @@n = temporary variable                                 ³
&dA &d@³                        @@q = temporary variable                                 ³
&dA &d@³                     bthick = thickness of beam - 1                              ³
&dA &d@³                    (x1,y1) = temporary coordinates                              ³
&dA &d@³                    (x2,y2) = temporary coordinates                              ³
&dA &d@³                      z1,z2 = temporary character numbers                        ³
&dA &d@³                stemdir(80) = stem directions for mixed direction case           ³
&dA &d@³               stemends(80) = stem endpoints for mixed direction case            ³
&dA &d@³                 beampos(8) = position of beam (mixed stem dir)                  ³
&dA &d@³                  beamlevel = index into beampos(for each note belonging to beam)³
&dA &d@³                                                                                 ³
&dA &d@³    Global variables used to communicate                                         ³
&dA &d@³                                                                                 ³
&dA &d@³                         z3 = character number for revset                        ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure ps_setbeam (@k,@m) 
        int @b,@f,@g,@h,@i,@j,@k,@m,@n,@q,@s,@t 
        int @@b,@@g,@@n,@@q 
        int z1,z2,mixflag 
        int stemends(80),stemdir(80),beampos(8),beamlevel(MAX_BNOTES) 
        int savex1 
        int staff_height 
        int t1,t2,t3                   /* NEW 
        int a4 
        int bshflg 
        int cc,color_flag2             /* New &dA12/21/10&d@ 
        int dv3 
        int a1 
        getvalue @k,@m 
&dA 
&dA &d@  check for errors in beam repeaters 
&dA 
&dA &d@  And &dA12/21/10&d@, determine the finel color for the beam 
&dA 
        color_flag2 = color_flag           /* New &dA12/21/10&d@ 
        cc = color_flag                    /* New &dA12/21/10&d@ 
        t1 = 0                             /* New &dA12/21/10&d@ 
        loop for @j = 1 to bcount 
          if beamdata(@j,3) = 0            /* New &dA12/21/10&d@ 
            ++t1 
            if t1 > (bcount / 2) 
              cc = 0 
            end 
          end 
          if msk_beamcode(@j) con "7" or msk_beamcode(@j) con "8" 
            if bcount <> 2 
              if (Debugg & 0x12) > 0 
                pute Improper use of beam repeaters 
              end 
              goto BERR 
            end 
            loop for @j = 1 to 6 
              if "270" con msk_beamcode(1){@j} 
                if msk_beamcode(1){@j} = "2" 
                  if msk_beamcode(2){@j} <> "3" 
                    if (Debugg & 0x12) > 0 
                      pute Mismatching beamcodes 
                    end 
                    goto BERR 
                  end 
                end 
                if msk_beamcode(1){@j} = "7" 
                  if msk_beamcode(2){@j} <> "8" 
                    if (Debugg & 0x12) > 0 
                      pute Mismatching beamcodes 
                    end 
                    goto BERR 
                  end 
                end 
                if msk_beamcode(1){@j} = "0" 
                  if msk_beamcode(2){@j} <> "0" 
                    if (Debugg & 0x12) > 0 
                      pute Mismatching beamcodes 
                    end 
                    goto BERR 
                  end 
                end 
              else 
                if (Debugg & 0x12) > 0 
                  pute Improper use of beam repeaters 
                end 
                goto BERR 
              end 
            repeat 
            @j = 10000 
          end 
        repeat 

        if @k > 0 
          stem = UP 
        else 
          stem = DOWN 
        end 
&dA 
&dA &d@    Check for situation where notes span two staves (grand staff) 
&dA 
        staff_height = 0 

        if vst(f12) > 0 
          @g = ps_beamdata(1,2) 
          loop for @j = 2 to bcount 
            if abs(ps_beamdata(@j,2) - @g) > 500 
              staff_height = 10000 
              @j = 10000 
            end 
          repeat 
        end 
&dA 
&dA &d@    Adjust all y coordinates be relative to the top staff 
&dA 
        loop for @j = 1 to bcount 
          if ps_beamdata(@j,2) - psq(f12) > 700 
            ps_beamdata(@j,2) -= 1000 
            ps_beamdata(@j,2) += vst(f12) 
            if staff_height <> 10000 
              staff_height = vst(f12) 
            end 
          end 
        repeat 
&dA 
&dA &d@    Check for mixed stem directions 
&dA 
        mixflag = 0 
        loop for @j = 2 to bcount 
          @h = ps_beamdata(@j,1) - ps_beamdata(1,1) * @m / 30 
          @h = @h + ps_beamdata(1,2) - @k - ps_beamdata(@j,2) 
          if @h < 0 
            if stem = DOWN 
              mixflag = 1 
              @j = 10000 
            end 
          else 
            if stem = UP 
              mixflag = 1 
              @j = 10000 
            end 
          end 
        repeat 
&dA 
&dA &d@    Deal with tuplets attached to &dAnote heads&d@ 
&dA 
        if tbflag = 1  
          @f = ps_beamdata(bcount,1) - ps_beamdata(1,1) 
          @g = ps_beamdata(bcount,2) - ps_beamdata(1,2) * 30 
          @t = @g / @f 
          @s = 0 
          @n = bcount - 1  
          loop for @i = 2 to @n  
            @h = ps_beamdata(@i,1) - ps_beamdata(1,1) * @t / 30 + ps_beamdata(1,2)
            @q = ps_beamdata(@i,2) - @h 
            if stem = DOWN
              @q = 0 - @q  
            end  
            if @q > @s 
              @s = @q  
            end  
          repeat 

          if stem = DOWN 
            @j = pvpar(39) + @s + psq(f12)     
            y1 = ps_beamdata(1,2) - @j 
            y2 = ps_beamdata(bcount,2) - @j 
          else 
            @j = pvpar(39) + pvpar(38) + @s - psq(f12)    
            y1 = ps_beamdata(1,2) + @j 
            y2 = ps_beamdata(bcount,2) + @j 
          end  
&dA 
&dA &d@    Adding code &dA05/09/03&d@ to make space for numbers inside brackets  &dIOK&d@ 
&dA 
          sitflag = tupldata(1)  
          @s = pvpar(1) 
          if bit(0,sitflag) = 1               /* number present 
            if bit(1,sitflag) = 1               /* bracket present 
              if bit(4,sitflag) = 0               /* number near note head 
                if bit(5,sitflag) = 1               /* continuous bracket     
                  if bit(6,sitflag) = 1               /* number inside        
                    if bit(2,sitflag) = 0               /* tips down       
                      y1 -= pvpar(2)                       /* raise bracket 
                      y2 -= pvpar(2) 
                      @s = pvpar(3) 
                    else                                /* tips up 
                      y1 += pvpar(2)                       /* lower bracket 
                      y2 += pvpar(2) 
                      @s = pvpar(2) 
                    end 
                  end 
                end 
              end 
            end 
          end 

          if stem = DOWN 
            if staff_height <> 10000 
              @h = 0 - notesize * 2 / 3 + staff_height      
              if (y1 + tupldata(6)) > @h 
                y1 = @h - tupldata(6) 
              end 
              if (y2 + tupldata(6)) > @h 
                y2 = @h - tupldata(6) 
              end 
            end 
          else 
            if staff_height <> 10000 
              @h = 11 * notesize / 2 + staff_height 
              if (y1 + tupldata(6)) < @h 
                y1 = @h - tupldata(6) 
              end 
              if (y2 + tupldata(6)) < @h 
                y2 = @h - tupldata(6) 
              end 
            end 
          end  
          a1 = tupldata(2) 
          x1 = tupldata(3) + ps_beamdata(1,1) - sp 
          x2 = tupldata(4) + ps_beamdata(bcount,1) - sp 
          y1 += tupldata(6) 
          y2 += tupldata(7) 
          perform puttuplet (a1) 
        end  

        bthick = beamfont - 101  
&dA 
&dA &d@    Reverse all y co-ordinates if first stem is down 
&dA 
        @g = psq(f12)   
        if stem = DOWN 
          @g = pvpar(2) * 500  - pvpar(8) - @g 
          loop for @j = 1 to bcount  
            ps_beamdata(@j,2) = pvpar(2) * 500  - ps_beamdata(@j,2) 
          repeat 
        end  
        @@g = @g 

        if stem = 1 
          @m = 0 - @m 
          @k = 0 - @k 
        end 
        dv3 = @m * ps_beamdata(1,1) 
        dv3 = ps_beamdata(1,2) - @k * phpar(1) - dv3 
        @k = abs(@m) 
        @@q = 0 
        loop for @j = 1 to bcount 
          @n = 5 
          if msk_beamcode(@j) con "0" 
            @n = mpt - 2       /* number of additional beams on this note 
          end 
          if @n > @@q 
            @@q = @n           /* max number of additional beams 
          end 
        repeat 
        ++@@q 
        if @@q > 3 
          beamt = pvpar(33) 
        end 

&dA                                                            
&dA &d@                                                          &dA 
&dA &d@    This is the printout portion of the procedure         &dA 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ         &dA 
&dA &d@       @m = phpar(1) * slope of beam                      &dA 
&dA &d@       @k = |@m|                                          &dA 
&dA &d@       dv3 = y-intercept of top of beam (times phpar(1))  &dA 
&dA &d@                                                          &dA 
&dA                                                            

&dA 
&dA &d@  identify beam characters  
&dA 
        z1 = @k + 33 
        if @m > 0  
          z1 += 128 
        end  
        z2 = @k + 49   
        if @m > 0  
          z2 += 128 
        end  
&dA 
&dA &d@  check for tuplet over beam 
&dA 
        if tbflag = 2  
          sitflag = tupldata(1)  
          if bit(7,sitflag) = 1             /* curved bracket &dA03/15/97&d@  &dIOK&d@ 
            a4 = 0 - 2 * qwid / 3 
            if stem = UP 
              a4 = qwid / 3 
            end 
          else 
            a4 = 0 - qwid / 3 
            if stem = UP 
              a4 = 2 * qwid / 3 
            end 
          end 

          a1 = tupldata(2) 
          x1 = ps_beamdata(1,1) + a4 - sp                 + tupldata(3) 
          x2 = ps_beamdata(bcount,1) + a4 - sp            + tupldata(4) 
          y1 = @m * ps_beamdata(1,1) + dv3 / phpar(1) 
          y2 = @m * ps_beamdata(bcount,1) + dv3 / phpar(1) 
          if stem = DOWN 
            y1 = pvpar(2) * 500  - y1 - bthick - psq(f12) + pvpar(39) + pvpar(38)
            y2 = pvpar(2) * 500  - y2 - bthick - psq(f12) + pvpar(39) + pvpar(38)
          else 
            y1 = y1 - pvpar(39) - psq(f12)     
            y2 = y2 - pvpar(39) - psq(f12)     
          end  
          y1 += tupldata(6) 
          y2 += tupldata(7) 
          perform puttuplet (a1) 
        end  
&dA 
&dA &d@   Here the situation diverges 
&dA 
&dA &d@     Case I:  all stems go in the same direction 
&dA &d@     Case II: stem directions are mixed 
&dA 
        if mixflag = 0     /*  Case I: all stems go in the same direction 
&dA 
&dA &d@  put in first beam 
&dA 
          x1 = ps_beamdata(1,1) 
          x2 = ps_beamdata(bcount,1) 
          if msk_beamcode(1){1} = "7" 
            x1 += phpar(59) 
            x2 -= phpar(59) 
          end 
          color_flag = cc                      /* New &dA12/21/10&d@ 
          perform printbeam (z1,dv3,@m) 
          color_flag = color_flag2             /* New &dA12/21/10&d@ 
&dA 
&dA &d@  put in vertical stems 
&dA 
          loop for @j = 1 to bcount 
            if beamdata(@j,3) = 0              /* New &dA12/21/10&d@ 
              color_flag = 0     
            end 
            x1 = ps_beamdata(@j,1) 
            y1 = @m * x1 + dv3 / phpar(1) + pvpar(42) 
            y1 += pvpar(4) 
            y2 = ps_beamdata(@j,2) 
            z3 = stemchar 
            if y1 >= y2 
              z3 += 2 
              y1 -= pvpar(2) 
              loop while y1 < y2 
                perform revset 
                y1 += pvpar(2) 
              repeat 
            else 
              loop while y1 < y2 
                perform revset 
                y1 += pvpar(4) 
              repeat 
            end 
            y1 = y2 
            perform revset 
            color_flag = color_flag2           /* New &dA12/21/10&d@ 
          repeat 
&dA &d@    
&dA &d@  put in other beams  
&dA 
          loop for @q = 2 to @@q 
            if msk_beamcode(1){@q} = "7" 
              dv3 = (pvpar(2) + beamt) * phpar(1) / 2 + dv3 
            else 
              if msk_beamcode(1){@q} = "6" 
                dv3 = pvpar(2) * phpar(1) + dv3 
              else 
                dv3 = beamt * phpar(1) + dv3 
              end 
            end 
            bshflg = 0 
            loop for @j = 1 to bcount 
              if "123456780" con msk_beamcode(@j){@q} 
                if mpt = 2 
                  @i = @j 
BB1:              ++@j 
                  if @j > bcount 
                    if (Debugg & 0x12) > 0 
                      pute @j (~@j ) exceeds bcount (~bcount ) 
                    end 
                    goto BERR 
                  end 
                  if "1234560" con msk_beamcode(@j){@q} 
                    if mpt = 1 
                      goto BB1 
                    else 
                      if mpt = 3 
                        if @i > 1 and bshflg = 0 
                          dv3 += (3 * phpar(1) / 8) 
                          bshflg = 1 
                        end 
                        x1 = ps_beamdata(@i,1) 
                        x2 = ps_beamdata(@j,1) 
                        color_flag = cc                      /* New &dA12/21/10
                        perform printbeam (z1,dv3,@m) 
                        color_flag = color_flag2             /* New &dA12/21/10
                        goto BBR 
                      else 
                        if (Debugg & 0x12) > 0 
                          pute expecting a "1" or a "3" here (got a ~msk_beamcode(@j){@q} )
                          pute msk_beamcode(~@j ) = ~msk_beamcode(@j) 
                        end 
                        goto BERR 
                      end 
                    end 
                  end 
                end 
                if mpt = 7 
                  x1 = ps_beamdata(1,1) + phpar(59) 
                  x2 = ps_beamdata(2,1) - phpar(59) 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform printbeam (z1,dv3,@m) 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                  goto BBR 
                end 
                if mpt = 1 
                  if (Debugg & 0x12) > 0 
                    pute "1" not allowed in this position 
                  end 
                  goto BERR 
                end 
                if mpt = 3 
                  if (Debugg & 0x12) > 0 
                    pute "3" not allowed in this position 
                  end 
                  goto BERR 
                end 
                t1 = phpar(1) >> 1 
                if mpt = 4                               /* print forward hook
                  x1 = ps_beamdata(@j,1) + phpar(29) 
                  y  = @m * x1 + dv3 + t1 / phpar(1) 
                  z  = z2 + 16 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
                if mpt = 5                               /* print backward hook
                  x1 = ps_beamdata(@j,1) 
                  y  = @m * x1 + dv3 + t1 / phpar(1) 
                  x1 -= hookbackshift(beamfont-100)      /* New &dA12/31/08&d@ 
                  z = z2 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
                if mpt = 6                               /* make cross piece
                  x1 = ps_beamdata(@j,1) 
                  t3 = int("0001122344567"{beamfont-100})  /* magic number 
                  t3 += 3 
                  x1 -= t3 
                  y1 = @m * x1 + dv3 + t1 / phpar(1) 
                  y  = y1 
                  z  = z2 + 16 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
              end 
BBR:        repeat 
          repeat 

        else          /*  Case II: stem directions are mixed 
&dA 
&dA &d@    1. Determine definitive stem directions and end points 
&dA &d@         on main staff.  
&dA 
          loop for @j = 1 to bcount 
            x1 = ps_beamdata(@j,1) 
            y1 = @m * x1 + dv3 / phpar(1) + 4   /* middle of main beam 
            y2 = ps_beamdata(@j,2)                /* oby of note 
            if y1 < y2 
              stemdir(@j) = UP 
            else 
              stemdir(@j) = DOWN               /* different x intersection 
              if stem = UP                     /* direction of &dAfirst&d@ stem 
                x1 -= qwid - phpar(29) 
              else 
                x1 += qwid - phpar(29) 
              end 
              y1 = @m * x1 + dv3 / phpar(1) + 4 
            end 
            stemends(@j) = y1 
          repeat 
&dA 
&dA &d@    2. Put in first beam 
&dA 
          x1 = ps_beamdata(1,1)         /* stemdir(1) is always UP 
          x2 = ps_beamdata(bcount,1) 
          if stemdir(bcount) = DOWN 
            if stem = UP 
              x2 -= qwid - phpar(29) 
            else 
              x2 += qwid - phpar(29) 
            end 
          end 
          color_flag = cc                      /* New &dA12/21/10&d@ 
          perform printbeam (z1,dv3,@m) 
          color_flag = color_flag2             /* New &dA12/21/10&d@ 
          beampos(1) = dv3 
&dA 
&dA &d@    2a. Set beamlevel = 1 for all notes.  beamlevel for notes will change 
&dA &d@        as we move through the beam.  Basically, if notes A and B start 
&dA &d@        and end a beam respectively, then beamlevel will be given the 
&dA &d@        same value for all of these notes and any that might be in between.  
&dA &d@        If another beam extends between notes C and B, then beamlevel 
&dA &d@        for these notes will be increased.  In the end, beamlevel for each 
&dA &d@        note will be the number of beams connecting or going through the 
&dA &d@        stem for that note.  
&dA 
          loop for @j = 1 to bcount 
            beamlevel(@j) = 1 
          repeat 
&dA 
&dA &d@     NEW &dA05/19/03&d@  I am going to attempt a rewrite of this section.  The problem
&dA &d@     with the old code was that it sometimes didn't give asthetically pleasing 
&dA &d@     solutions.  In particular, the problem arises when a secondary beam is
&dA &d@     to be drawn between endpoints whose stems are in different directions.
&dA &d@     The old code made the arbitrary decision to draw the secondary beam according
&dA &d@     to the direction of the stem of the initial note.  This had the additional
&dA &d@     advantage that stems could be drawn as notes were processed, i.e., we would
&dA &d@     not have to go back and "lengthen" a stem because a secondary beam was 
&dA &d@     drawn on the other side of the primary.  
&dA 
&dA &d@     With this rewrite, I must change this, i.e., stems cannot be drawn until 
&dA &d@     all beams are set.  Secondly, I need to come up with a set of rules as to
&dA &d@     how to deal with the situation where the endpoints of a secondary connect
&dA &d@     to stems of different directions.  I propose to generate these rules from
&dA &d@     experience, and by trial and error.  As we encounter situations where the
&dA &d@     result seems to violate common sense, then we can consider adding a new 
&dA &d@     rule.  It should be pointed out that at the moment &dEthere is no provision
&dA &d@     &dEmade for editing the decision made by this program&d@ as regards the placing
&dA &d@     of secondary beams.  To add this feature, we would need to expand the 
&dA &d@     contents of the beam super-object record.  
&dA 
&dA &d@     As of this date &dA05/19/03&d@, I have only one rule to propose for cases where  
&dA &d@     the endpoints have stems that go in different directions.  
&dA &d@                              
&dA &d@        1. If there is a stem that follows the terminating stem, then use 
&dA &d@           use this stem direction to "arbitrate" between the directions of  
&dA &d@           the endpoint stems.  If no stem follows, then the stem direction
&dA &d@           of the initial note wins.  
&dA 

&dA 
&dA &d@    3. Loop through notes, one at a time 
&dA 
          loop for @j = 1 to bcount 
            x1 = ps_beamdata(@j,1) 
            if stemdir(@j) = DOWN 
              if stem = UP 
                x1 -= qwid - phpar(29) 
              else 
                x1 += qwid - phpar(29) 
              end 
            end 
            savex1 = x1 
&dA 
&dA &d@      a. add &dAall&d@ extra beams starting at this note (and increase beamlevel accordingly)
&dA 
            loop for @h = beamlevel(@j) + 1 to 6 
              if msk_beamcode(@j){@h} = "2"          /* begin beam 
                ++beamlevel(@j)                  /* increment beamlevel for starting point
                loop for @g = @j + 1 to bcount 
                  if msk_beamcode(@g){@h} = "3"      /* end beam 
                    x1 = savex1                  /* x1 needs to be reset for each beam
                    x2 = ps_beamdata(@g,1) 
                    if stemdir(@g) = DOWN        
                      if stem = UP 
                        x2 -= qwid - phpar(29) 
                      else 
                        x2 += qwid - phpar(29) 
                      end 
                    end 
                    dv3 = beampos(1) 
&dA 
&dA &d@       Here is where the rules take effect.  
&dA 
&dA &d@         Case I: Use stem direction of first note to determine secondary beam position
&dA 
&dA &d@                cases:  1) Normal:  stemdir(@g) = stemdir(@j) 
&dA 
&dA &d@                        2) stemdir(@g) <> stemdir(@j) but 
&dA &d@                            either  @g = bcount 
&dA &d@                            or  stemdir(@g+1) = stemdir(@j) 
&dA 
                    t2 = 0 
                    if stemdir(@g) <> stemdir(@j) 
                      if @g < bcount 
                        if stemdir(@g+1) <> stemdir(@j) 
                          t2 = 1 
                        end 
                      end 
                    end 

                    if t2 = 0
                      loop for @f = 1 to beamlevel(@g) 
                        if stemdir(@j) = UP 
                          if beampos(@f) > dv3 
                            dv3 = beampos(@f) 
                          end 
                        else 
                          if beampos(@f) < dv3 
                            dv3 = beampos(@f) 
                          end 
                        end 
                      repeat 
                      ++beamlevel(@g)           /* increment beamlevel for endpoint
                      if stemdir(@j) = UP              
                        dv3 += (beamt * phpar(1)) 
                      else 
                        dv3 -= (beamt * phpar(1)) 
                      end 
                      beampos(beamlevel(@g)) = dv3 
                       
                      color_flag = cc                      /* New &dA12/21/10&d@ 
                      perform printbeam (z1,dv3,@m) 
                      color_flag = color_flag2             /* New &dA12/21/10&d@ 
&dA 
&dA &d@      b. adjust stem ends for notes under (over) this beam 
&dA 
                      loop for @f = @j + 1 to @g 
                        if stemdir(@j) = UP 
                          if stemdir(@f) = DOWN 
                            stemends(@f) += beamt 
                          end 
                        else 
                          if stemdir(@f) = UP 
                            stemends(@f) -= beamt 
                          end 
                        end 
                      repeat 
                    else  
&dA 
&dA &d@         Case II: Use stem direction of last note to determine secondary beam position
&dA 
&dA &d@                cases:  1) stemdir(@g) <> stemdir(@j), and 
&dA &d@                            @g < bcount, and 
&dA &d@                            stemdir(@g+1) = stemdir(@g) 
&dA 
                      loop for @f = 1 to beamlevel(@g) 
                        if stemdir(@g) = UP                 /* changing @j to @g
                          if beampos(@f) > dv3 
                            dv3 = beampos(@f) 
                          end 
                        else 
                          if beampos(@f) < dv3 
                            dv3 = beampos(@f) 
                          end 
                        end 
                      repeat 
                      ++beamlevel(@g)           /* increment beamlevel for endpoint
                      if stemdir(@g) = UP                   /* changing @j to @g
                        dv3 += (beamt * phpar(1)) 
                      else 
                        dv3 -= (beamt * phpar(1)) 
                      end 
                      beampos(beamlevel(@g)) = dv3 

                      color_flag = cc                      /* New &dA12/21/10&d@ 
                      perform printbeam (z1,dv3,@m) 
                      color_flag = color_flag2             /* New &dA12/21/10&d@ 
&dA 
&dA &d@      b. adjust stem ends for notes under (over) this beam 
&dA 
                      loop for @f = @j to @g 
                        if stemdir(@g) = UP                 /* changing @j to @g
                          if stemdir(@f) = DOWN 
                            stemends(@f) += beamt 
                          end 
                        else 
                          if stemdir(@f) = UP 
                            stemends(@f) -= beamt 
                          end 
                        end 
                      repeat 
                    end 

                    @g = 10000 
                  else 
&dA 
&dA &d@                   Increment beamlevel for all notes between endpoints of this beam
&dA 
                    ++beamlevel(@g)                                           
                  end 
                repeat 
                if @g <> 10000 
                  if (Debugg & 0x12) > 0 
                    pute No termination found for beam 
                  end 
                  goto BERR 
                end 
              else 
                @h = 6 
              end 
            repeat 
&dA 
&dA &d@      c. put in any hooks that might go with this note 
&dA 
            loop for @h = beamlevel(@j) + 1 to 6 
              if "456" con msk_beamcode(@j){@h}         /* begin beam 
                @g = mpt 
                loop for @f = 1 to beamlevel(@j) 
                  if stemdir(@j) = UP 
                    if beampos(@f) > dv3 
                      dv3 = beampos(@f) 
                    end 
                  else 
                    if beampos(@f) < dv3 
                      dv3 = beampos(@f) 
                    end 
                  end 
                repeat 
                if @g = 3 
                  t1 = pvpar(2) * phpar(1) 
                else 
                  t1 = beamt * phpar(1) 
                end 
                if stemdir(@j) = UP 
                  dv3 += t1
                else 
                  dv3 -= t1
                end 
                t1 = phpar(1) >> 1 
                if @g = 1                                /* print forward hook
                  x1 = savex1 + phpar(29) 
                  y  = @m * x1 + dv3 + t1 / phpar(1) 
                  z  = z2 + 16 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
                if @g = 2                                /* print backward hook
                  x1 = savex1          
                  y  = @m * x1 + dv3 + t1 / phpar(1) 
                  x1 -= hookbackshift(beamfont-100)      /* New &dA12/31/08&d@ 
                  z = z2 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
                if @g = 3                                /* make cross piece
                  x1 = savex1 
                  y1 = @m * x1 + dv3 + t1 / phpar(1) 
                  x1 -= 5 
                  y  = y1 
                  if @m > 0 
                    y -= int("111111222222233"{@m}) 
                  end 
                  if @m < 0 
                    y += int("111111222222233"{0-@m}) 
                  end 
                  z  = z2 + 16 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                  x1 -= phpar(30) - phpar(29) - 10  /* = 7 
                  y  = y1 
                  if @m > 0 
                    y += int("000111111222222"{@m}) 
                  end 
                  if @m < 0 
                    y -= int("000111111222222"{0-@m}) 
                  end 
                  z = z2 
                  color_flag = cc                      /* New &dA12/21/10&d@ 
                  perform hook 
                  color_flag = color_flag2             /* New &dA12/21/10&d@ 
                end 
              else 
                @h = 6 
              end 
            repeat 
          repeat 
&dA 
&dA &d@    4. Loop again through notes, one at a time, and now draw the stems (&dA05/19/03&d@)
&dA 
          loop for @j = 1 to bcount 
&dA 
&dA &d@      a. put in stem 
&dA 
            if beamdata(@j,3) = 0              /* New &dA12/21/10&d@ 
              color_flag = 0     
            end 
            x1 = ps_beamdata(@j,1) 
            if stemdir(@j) = DOWN 
              if stem = UP 
                x1 -= qwid - phpar(29) 
              else 
                x1 += qwid - phpar(29) 
              end 
            end 
            savex1 = x1 
            if stemdir(@j) = UP 
              y1 = stemends(@j) 
              y2 = ps_beamdata(@j,2) 
            else 
              y2 = stemends(@j) 
              y1 = ps_beamdata(@j,2) + 2          /* I think this is needed 
            end 
            y1 += pvpar(4) 
            z3 = stemchar 
            if y1 >= y2 
              z3 += 2 
              y1 -= pvpar(2) 
              loop while y1 < y2 
                perform revset 
                y1 += pvpar(2) 
              repeat 
            else 
              loop while y1 < y2 
                perform revset 
                y1 += pvpar(4) 
              repeat 
            end 
            y1 = y2 
            perform revset 
            color_flag = color_flag2           /* New &dA12/21/10&d@ 
          repeat 
&dA 
&dA &d@    End of &dA05/19/03&d@ rewrite &dIOK&d@ 
&dA 
        end 

        return 
BERR: 
        if (Debugg & 0x12) > 0 
          pute Beam format error, printbeam aborted 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  3. hook                                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset hook beam                                ³ 
&dA &d@³                                                               ³ 
&dA &d@³             x1       = horizontal position of note            ³ 
&dA &d@³             y        = vertical position of hook attachment   ³ 
&dA &d@³             stem     = stem direction                         ³ 
&dA &d@³             z        = hook character                         ³ 
&dA &d@³             beamfont = type of font for beam                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure hook 
        x = x1 
        if stem = 1  
          y = pvpar(2) * 500  - y - bthick  
          z += 128 
          z &= 0xff 
        else 
          x += qwid - phpar(29) 
        end  
        scf = beamfont 
        scx = x 
        scy = y 
        scb = z 
        perform charout 
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  4. printbeam (z1,dv3,@@m)                                  ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset beam                                     ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  @@m = slope * phpar(1)                            ³ 
&dA &d@³             x1  = starting point of beam                      ³ 
&dA &d@³             x2  = end point of beam                           ³ 
&dA &d@³             dv3 = y intercept of beam (times phpar(1))        ³ 
&dA &d@³             stem = stem direction                             ³ 
&dA &d@³             z1 = beam character number for this slope         ³ 
&dA &d@³                                                               ³ 
&dA &d@³             @@k = |@@m|                                       ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure printbeam (z1,dv3,@@m) 
        int x3,z1,dv3,@@k,@@m 
        getvalue z1,dv3,@@m 

        @@k = abs(@@m) 
        x = x1 
        if stem = UP 
          x += qwid - phpar(29) 
        end  
        scx = x 
        scf = beamfont 

        x2 = x2 + phpar(29) - phpar(1) 
        y1 = @@m * x1 + dv3 / phpar(1) 
        if x2 < x1 and @@k = 0 
          x2 = phpar(1) - 4 + x2              /* no beam shorter than 4 dots  
          y = y1                            /* put out <n> "overlapping" 4 dot lengths
          if stem = DOWN 
            y = pvpar(2) * 500  - y - bthick 
          else 
            x2 += qwid - phpar(29) 
          end 
PBEAM01: 
          scy = y 
          scb = 88 
          perform charout 

          x += 4          
          if x < x2 
            goto PBEAM01 
          end 
          scx = x2 
          scb = 88 
          perform charout 
          scf = notesize 
          return 
        end  
        z = z1   
        if stem = DOWN 
          z += 128
          z &= 0xff 
        end  
        loop while x1 <= x2  
          y = y1 
          if stem = DOWN 
            y = pvpar(2) * 500  - y - bthick  
          end  
          scy = y 
          scb = z
          perform charout 
          x1 += phpar(1) 
          y1 += @@m 
        repeat 
        y2 = x2 + phpar(1) - x1   
&dA 
&dA &d@  print fraction of beam 
&dA &d@   y2 = extra length needed to complete beam 
&dA 
        if y2 = 0  
          scf = notesize 
          return 
        end  
        y = y1 
        if stem = DOWN 
          y = pvpar(2) * 500  - y - bthick  
        end  
&dA &d@   y = starting point   
        if @@k = 0  
          x = x1 - 30 + y2   
          if stem = UP 
            x += qwid - phpar(29) 
          end  
          scx = x 
          scy = y 
          scb = 33 
          perform charout 
          scf = notesize 
          return 
        end  
        scy = y 

        x3 = @@k - 1 * 29 + y2  
        if x3 < 1 or x3 > 435             /* added &dA11/29/09&d@ 
          return 
        end 

        x2 = beamext(x3,1)
        y1 = 2 
        loop for y2 = 1 to x2  
          z = beamext(x3,y1)
          if @@m > 0  
            z += 128 
            z &= 0xff 
          end  
          if stem = 1  
            z += 128 
            z &= 0xff 
          end  
          scb = z 
          perform charout 
          if y2 < x2 
            ++y1
            x1 = beamext(x3,y1)
            if stem = 1  
              x1 = 0 - x1  
            end  
            if @@m > 0  
              x1 = 0 - x1  
            end  
            y -= x1 
            scy = y 
            ++y1
          end  
        repeat 
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  5. revset                                                  ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Check for reversal of page and correct x y and z ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  x1 = horizontal position of note                  ³ 
&dA &d@³             y1 = vertical position of note                    ³ 
&dA &d@³             z3 = character to typeset                         ³ 
&dA &d@³             stem = stem direction                             ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Note: Called only by ps_setbeam                            ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure revset
        int cc                       /* New &dA12/17/10&d@ 

        cc = color_flag              /* New &dA12/17/10&d@ 
        x = x1 
        y = y1 
        z = z3 
        if stem = DOWN 
          if z = 59 or z = 61 or z = 187 or z = 189 
            ++z       
          end  
          y = pvpar(2) * 500  - y   
        end      
        perform setmus 
        color_flag = cc              /* New &dA12/17/10&d@ 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  6. setmus                                                  ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset character                                ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  x = horizontal position of note                   ³ 
&dA &d@³             y = vertical position of note                     ³ 
&dA &d@³             z = character to typeset                          ³ 
&dA &d@³       sizenum = current scale size (1 to 12)                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setmus     
        int sy,pz 

        if z = 0 
          return  
        end 
&dA 
&dA &d@    Implementing back ties as a character   &dA04/22/08&d@ 
&dA 
        if z > 1999 
          if z < 2032                
            return 
          end 
          if z > 2090 and z < 2160 
            return 
          end 
          if z > 2218 
            return 
          end 
          z -= 2000                 /* z is now a legal single tie character

          scf = 300 
          scx = x 
          scy = y 
          scb = z          
          perform charout 
          scf = notesize 

          return 
        end 
&dA 
&dA &d@    Implementing extended music font  &dA02/19/06&d@ 
&dA 
        if z > 999 

          pz = ors("000011112222"{sizenum})     /* old "dummy()" 
          sy = y 

          z += ors(" P Ğ P Ğ P Ğ"{sizenum})     /* old "extendoff()" 
          z -= 1001 

          scx = x 
          scy = sy 
          scb = z 
          scf = pz + 50      /* scf is index into revmap producing fonts 48,49,50
          perform charout 
          scf = notesize 

          return 
        end 
&dA 
&dA      &d@   End of &dA02/19/06&d@ addition 

        sy = y - pos(z-32) 
        scx = x 
        scy = sy 
        scb = z 
        perform charout 
      return   

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  7. setwords (t1)                                           ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset words                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  t1   = flag: 0 = regular setwords call            ³ 
&dA &d@³                          1 = setwords called from TEXT sub-obj³ 
&dA &d@³             x    = horizontal position of words               ³ 
&dA &d@³             y    = vertical position of words                 ³ 
&dA &d@³             z    = font number for words                      ³ 
&dA &d@³             line = words to set                               ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setwords (t1) 
        str textline.300 
        int t1,t2 
        int d1 

        getvalue t1 
        if t1 = 1 and line = "&" 
          return 
        end 

        if x < 0 
          if (Debugg & 0x12) > 0 
#if DMUSE 
            putc &dAWARNING&d@:  Attempting to typeset a word with a (net) negative x position
#else 
            pute WARNING:  Attempting to typeset a word with a (net) negative x position
#endif 
          end 
          x = 0
        end 

        scx = x 
        scy = y 

        if z = 1 
          scf = notesize 
        else 
          scf = z 
        end 
        textline = line // "  " 

A11:    if textline con "\" 
          if mpt > 1   
            t2 = mpt 
            line2  = textline{1,mpt-1}   
            perform lineout 
            textline = textline{t2..} 
            goto A11 
          end  
          if textline{2} = "\" 
            line2 = "\" 
            perform lineout 
            textline = textline{3..} 
            goto A11 
          end 
&dA 
&dA &d@     This coded added &dA03/05/04&d@ to implement "in-line" space commands 
&dA 
          if "!@#$%^&*(-=" con textline{2}              
            textline = chr(130+mpt) // textline{3..} 
            goto A11 
          end 
&dA 
&dA &d@     This coded added &dA02/02/09&d@ to implement in-line "space" character 
&dA 
          if textline{2} = "+" 
            textline = " " // textline{3..} 
            goto A11 
          end 
&dA   
          if textline{2} = "0" 
            t2 = ors(textline{3}) + 128 
            if chr(t2) in [160,206,212,224] 
            else 
              line2 = chr(t2) 
              perform lineout 
            end 
            textline = textline{4..} 
            goto A11 
          end 
               
          if textline{2} in ['a'..'z','A'..'Z'] 
            d1 = ors(textline{2}) 
            if textline{3} = "1" 
              if "ANOano" con textline{2} 
                t2 = d1 + 140                                 /* 140 = wak(1)
              else 
                if textline{2} in ['A'..'Z'] 
                  t2 = 205 
                else 
                  t2 = 237 
                end 
              end 
              line2 = chr(t2) // textline{2} 
            else 
              if textline{3} = "5" 
                if textline{2} in ['A'..'Z'] 
                  t2 = 211                                    /* 211 = wak(5)(=128) + 83(S)
                else 
                  t2 = 243 
                end 
                line2 = chr(t2) // textline{2} 
              else 
                if textline{3} = "2" 
                  if "CcOos" con textline{2} 
                    if mpt < 3 
                      line2 = chr(d1+156) // textline{2}      /* 156 = wak(2)
                    else 
                      if mpt < 5 
                        line2 = chr(d1+143) // textline{2}    /* 79(O) + 143 = 222  etc.
                      else 
                        line2 = chr(244)                      /* German ss 
                      end 
                    end 
                  else 
                    line2 = textline{2} 
                  end 
                else 
                  if textline{3} = "4" 
                    if "Aa" con textline{2} 
                      line2 = chr(d1+156) // textline{2}      /* 156 = wak(4)
                    else 
                      line2 = textline{2} 
                    end 
                  else 
                    if "7893" con textline{3} 
                      t2 = mpt + 127                          /* wak(3,7,8,9)
                      if ("73" con textline{3} and "Yy" con textline{2}) or "AEIOUaeiou" con textline{2}
                        if textline{2} = "i" 
                          line2 = chr(d1+t2) // chr(238)      /* 238 = dotless i
                        else 
                          line2 = chr(d1+t2) // textline{2} 
                        end 
                      else 
                        line2 = textline{2} 
                      end 
                    else 
                      line2 = "\"              
                      perform lineout 
                      textline = textline{2..} 
                      goto A11 
                    end 
                  end 
                end 
              end 
            end 
            perform lineout 
            textline = textline{4..} 
            goto A11 
          else 
            line2 = "\" 
            perform lineout 
            textline = textline{2..} 
            goto A11 
          end 
        else 
          t2 = len(textline) - 2 
          if t2 > 0 
            line2 = textline{1,t2} 
            perform lineout 
          end 
        end    

        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  8. lineout                                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Send a line of text to output device             ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  line2                                             ³ 
&dA &d@³             z = font number for words                         ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Side effects: value of z   may be changed                  ³ 
&dA &d@³                  value of scf may be changed                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure lineout    
        int t1,t2,t3 
        str textline.300 

AAA111: if line2 con "!" 
          t1 = mpt 
          if t1 > 1 
            if z <> notesize and z <> 1           /* z <> 1 added &dA01/13/04&d@ 
              textline = line2{1,t1-1} 
            else 
              textline = "" 
              loop for t2 = 1 to t1 - 1 
                t3 = ors(line2{t2}) 
                t3 = music_con(t3) 
                textline = textline // chr(t3) 
              repeat 
            end 
            perform stringout (textline) 

            line2 = line2{t1..} 
          end 
          if len(line2) > 1     
            if "0123456789" con line2{2} 
              z = int(line2{2..}) 
              if z = 1                       /* added &dA03/15/04&d@ 
                scf = notesize 
              else 
                scf = z 
              end 

              if sub <= len(line2) 
                line2 = line2{sub..} 
&dA 
&dA &d@       Code added &dA01/17/04&d@ to remove terminator to font designation field 
&dA 
                if line2{1} = "|" 
                  if len(line2) = 1 
                    return 
                  end 
                  line2 = line2{2..} 
                end 
&dA   
                goto AAA111 
              else 
                return 
              end 
            else 
              if z <> notesize and z <> 1         /* z <> 1 added &dA01/13/04&d@ 
                textline = "!"
              else 
                t3 = ors("!") 
                t3 = music_con(t3) 
                textline = chr(t3) 
              end 
              perform stringout (textline) 

              line2 = line2{2..} 
              goto AAA111 
            end 
          end 
        end  
        if z <> notesize and z <> 1               /* z <> 1 added &dA01/13/04&d@ &dIOK
          textline = line2 
        else 
          textline = "" 
          loop for t2 = 1 to len(line2)
            t3 = ors(line2{t2}) 
            t3 = music_con(t3) 
            textline = textline // chr(t3) 
          repeat 
        end 
        perform stringout (textline) 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D*  9. line_length (xtot)                                      ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Determine the length (in dots) of a line of      ³ 
&dA &d@³              text before it is typeset.                       ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   line = line whose length is to be determined     ³ 
&dA &d@³              z    = font active at time of call               ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure line_length (xtot) 
        str textline.400 
        str ngline2.400 
        int xtot,xinc 
        int tscf 
        int t1,t2,t3 

        xtot = 0 

        if z = 1
          tscf = notesize 
        else 
          tscf = z 
        end 
        textline = line // "   " 
LLL1: 
        if textline con "!" 
          t1 = mpt 
          if t1 > 1 
            ngline2 = textline{1,t1-1} 
            perform lineout_length (ngline2, tscf, xinc) 
            xtot += xinc 
            textline = textline{t1..} 
            goto LLL1 
          end 
          if "0123456789" con textline{2} 
            t1 = int(textline{2..}) 
            t2 = sub 
            if textline{t2} = "|" 
              ++t2 
            end 

            if t1 = 1 
              tscf = notesize 
            else 
              tscf = t1 
            end 

            textline = textline{t2..} 
            goto LLL1 
          end 
          t3 = 33                     /* ! character 
          perform get_xinc (tscf, t3, xinc) 
          xtot += xinc 
          textline = textline{2..} 
          goto LLL1 
        end 
        ngline2 = trm(textline) 
        if ngline2 <> "" 
          perform lineout_length (ngline2, tscf, xinc) 
          xtot += xinc 
        end 
        passback xtot 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 10. lineout_length (thline2, tscf, xtot)                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Determine the length (in dots) of a line of      ³ 
&dA &d@³              text which has no font changes in it             ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   thline2 = line whose length is to be determined  ³ 
&dA &d@³              tscf    = font active at time of call            ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Output:   xtot                                             ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure lineout_length (thline2, tscf, xtot) 
        str thline2.400,out.400 
        int tscf, xtot 
        int xinc 
        int t1,t2,t3 

        getvalue thline2, tscf 

        xtot = 0 
        thline2 = thline2 // "   " 
LLL2: 
        if thline2 con "\" 
          if mpt > 1 
            t1 = mpt 
            out = thline2{1,t1-1} 
            perform string_length (out, tscf, xinc) 
            xtot += xinc 
            thline2 = thline2{t1..} 
            goto LLL2 
          end 
          if thline2{2} = "\" 
            t3 = 92                     /* \ character 
            perform get_xinc (tscf, t3, xinc) 
            xtot += xinc 
            thline2 = thline2{3..} 
            goto LLL2 
          end 
          if "!@#$%^&*(-=" con thline2{2} 
            t1 = mpt 
            if t1 < 10 
              xtot += t1 
            else 
              xtot -= (t1 - 9) 
            end 
            thline2 = thline2{3..} 
            goto LLL2 
          end 
          if thline2{2} = "0" 
            t3 = ors(thline2{3}) + 128 
            if chr(t3) in [160,206,212,224] 
            else 
              perform get_xinc (tscf, t3, xinc) 
              xtot += xinc 
            end 
            thline2 = thline2{4..} 
            goto LLL2 
          end 
          if thline2{2} in ['a'..'z','A'..'Z'] 
            t3 = ors(thline2{2}) 
            if thline2{2,2} = "s2" 
              t3 = 244                                        /* German ss 
              perform get_xinc (tscf, t3, xinc) 
              xtot += xinc 
              thline2 = thline2{4..} 
              goto LLL2 
            else 
              if "12345789" con thline2{3} 
                if ("73" con thline2{3} and "Yy" con thline2{2}) or "AEIOUaeiou" con thline2{2}
                  perform get_xinc (tscf, t3, xinc) 
                  xtot += xinc 
                  thline2 = thline2{4..} 
                  goto LLL2 
                end 
              end 
            end 
          end 
          t3 = 92                     /* \ character 
          perform get_xinc (tscf, t3, xinc) 
          xtot += xinc 
          thline2 = thline2{2..} 
          goto LLL2 
        end 
        out = trm(thline2) 
        if out <> "" 
          perform string_length (out, tscf, xinc) 
          xtot += xinc 
        end 
        passback xtot 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 11. string_length (out, tscf, xtot)                             ³ 
&dA &d@³                                                                   ³ 
&dA &d@³    Purpose:  Determine the length (in dots) of a line of          ³ 
&dA &d@³              text which has no font changes and no "\" character  ³ 
&dA &d@³                                                                   ³ 
&dA &d@³    Inputs:   out   = line whose length is to be determined        ³ 
&dA &d@³              tscf  = font active at time of call                  ³ 
&dA &d@³                                                                   ³ 
&dA &d@³    Output:   xtot                                                 ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure string_length (out, tscf, xtot) 
        str out.500 
        int t1,t2 
        int xinc,xtot,tscf 
        getvalue out, tscf 

        xtot = 0 
        loop for t1 = 1 to len(out) 
          t2 = ors(out{t1}) 
          if tscf = notesize 
            t2 = music_con(t2) 
          end 
          perform get_xinc (tscf, t2, xinc) 
          xtot += xinc 
        repeat 
        passback xtot 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 12. get_xinc (z,kk,xinc)                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Determine the x increment to printing a glyph    ³ 
&dA &d@³              from a particular font.                          ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   z    = font active (not the "real" font)         ³ 
&dA &d@³              kk   = glyph number                              ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Output:   xinc = increment                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Note:  This is not the code contained in pspage.z          ³ 
&dA &d@³           That code is precise; this code is a cluge.         ³ 
&dA &d@³           The difference is that for music glyphs,            ³ 
&dA &d@³           xinc is only an estimate.                           ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure get_xinc (z,kk,xinc) 
        int z,kk,xinc 
        int font 
        int t1

        getvalue z,kk 

        z = revmap(z)              /*   get "real" font number 
        if z < 51                  /*   1,3,4,4,5 -> 51..80 (1..30) + 50 
          z = notesize / 4 * 5     /*   5,15,20,20,25 
          if z > 25 
            z = 25 
          end 
          z += 50 
          kk = 65                  /*   The letter "A" takes space of music note
        end 
        font = z 
        t1 = font - 50                     /* 1 <= t1 <= 90 (text font) 
        t1 = (t1 - 1) * 200 + 1 

        if kk > 128 
          t1 += 100 
          kk -= 128 
        end 
        kk -= 32 
        xinc = ors(fontspac{t1+kk}) 

        passback xinc 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 13. staff (syslength,stv_type)                              ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset staff                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:  y          = absolute vertical location           ³ 
&dA &d@³             sp         = starting point of staff lines        ³ 
&dA &d@³             syslength  = length of staff lines                ³ 
&dA &d@³             stv_type   = type of staff   0 = 5-line           ³ 
&dA &d@³                                          1 = single line      ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure staff (syslength,stv_type) 
        int slen,syslength,stv_type 
        int d2 
        getvalue syslength,stv_type 

        if notesize >= 10 
          slen = 64 
        else 
          slen = 32 
        end 
&dA 
&dA &d@     New &dA11/11/05&d@:  Single line stave 
&dA 
        if stv_type = 1 
          y += pvpar(4) 
          d2 = sp + syslength - phpar(1) 
          z = 90 
          loop for x = sp to d2 step phpar(1) 
            perform setmus 
          repeat 
          x = d2 
          perform setmus 
          y -= pvpar(4) 
          return 
        end 
&dA 
&dA       &d@   End of &dA11/11/05&d@ addition 

        if notesize >= 18           /* Added &dA11/18/03&d@ to fill holes in lines &dIOK
          d2 = sp + syslength - slen 
          z = 81 
          loop for x = sp to d2 step slen - 1 
            perform setmus 
            ++x 
          repeat 
          x = d2 
          perform setmus 
        else 
          d2 = sp + syslength - slen 
          z = 81 
          loop for x = sp to d2 step slen 
            perform setmus 
          repeat 
          x = d2 
          perform setmus 
        end 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 14. settie (tspan,tpost_x,tpost_y,tpost_leng)               ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset typeset tie                              ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs: x1         = x-object coordinate of first note     ³ 
&dA &d@³            y1         = y-object coordinate of first note     ³ 
&dA &d@³                             (+1000 if on virtual staff)       ³ 
&dA &d@³            tspan      = distance spanned by tie               ³ 
&dA &d@³            sitflag    = situation flag                        ³ 
&dA &d@³            f12        = staff number                          ³ 
&dA &d@³            tpost_x    = post adjustment to left x position    ³ 
&dA &d@³            tpost_y    = post adjustment to y position         ³ 
&dA &d@³            tpost_leng = post adjustment to right x position   ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Internal varibles:  d1 = temporary variable                ³ 
&dA &d@³                        d2 = temporary variable                ³ 
&dA &d@³                        tiechar = first tie character          ³ 
&dA &d@³                        textend = tie extention character      ³ 
&dA &d@³                        hd = horizontal displacement           ³ 
&dA &d@³                        vd = vertical displacement             ³ 
&dA &d@³                        out = output string                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure settie (tspan,tpost_x,tpost_y,tpost_leng) 
        int tpost_x,tpost_y,tpost_leng 
        int d1,d2,d3,d4,d5 
        int virtoff 
        int hd,vd,tiechar,textend,tspan,tcnt 
        label STL(4) 

        getvalue tspan,tpost_x,tpost_y,tpost_leng 
&dA 
&dA &d@ 1) decode y-object coordinate of first note 
&dA 
        virtoff = 0 
        if y1 > 700 
          y1 -= 1000 
          virtoff = vst(f12) 
        end 
&dA 
&dA &d@ 2) complete sitflag  
&dA 

        d5 = phpar(60) 

        d1 = sitflag - 1 & 0x0c >> 2 + 1 
        goto STL(d1) 
STL(1):                     /* tips down, space 
        if y1 < pvpar(2) 
          ++sitflag 
        else 
          if y1 = pvpar(3) and tspan > d5     /* e.g., C5 
            ++sitflag 
          end 
        end 
        goto STLE 
STL(2):                     /* tips down, line 
        if y1 < pvpar(1) 
          ++sitflag 
        else 
          if y1 = pvpar(2) and tspan > d5 
            ++sitflag 
          end 
        end 
        goto STLE 
STL(3):                     /* tips up, space 
        if y1 > pvpar(6) 
          ++sitflag 
        else 
          if y1 = pvpar(7) and tspan > d5 
            ++sitflag 
          end 
        end 
        goto STLE 
STL(4):                     /* tips up, line 
        if y1 > pvpar(5) 
          ++sitflag 
        else 
          if y1 = pvpar(6) and tspan > d5 
            ++sitflag 
          end 
        end 
STLE: 
&dA 
&dA &d@ 3) from sitflag and tspan, get tiechar, hd and vd  
&dA 
        tspan -= tpost_x         
        tspan += tpost_leng      

        if tspan < phpar(61)    /* minimum length depends on notesize 
          if (Debugg & 0x12) > 0 
            pute Error: Tie too short to print 
            pute SETTIE, x1 = ~x1  y1 = ~y1  tspan = ~tspan  sitf = ~sitflag
          end 
          return 
        end  

        d1 = sitflag + 3 / 4
        d3 = rem * 3 + 1
        d2 = ( TIE_DISTS ) 
        if tspan < ( (TIE_DISTS - 1) * phpar(62) + phpar(61) ) 
          d2 = tspan - phpar(61)  
          if phpar(62) = 3 
            ++d2 
          end 
          d2 = d2 / phpar(62) + 1         /* row number for tie parameters 
        end 

        tiechar = tiearr(sizenum,d1,d2,d3)
        hd = tiearr(sizenum,d1,d2,d3+1) 
        vd = tiearr(sizenum,d1,d2,d3+2) 
        if sitflag > 8 
          vd = 0 - vd  
        end  
&dA 
&dA &d@ 4) typeset tie 
&dA &d@    
        x = x1 + hd + sp + tpost_x                         /* modified &dA04/20/03&d@  etc.  &dIOK
        y = y1 - vd + psq(f12) + virtoff 
        if tpost_y < 1000 
          y += tpost_y 
        else 
          tpost_y -= 10000 
          y = y1 + tpost_y + psq(f12) + virtoff 
        end 

        scf = 300
        scx = x 
        scy = y 
        scb = tiechar 
        perform charout 

        d1 = tiechar & 0x7f 
        if d1 = tiearr(sizenum,1,TIE_DISTS,4)  /* staff free general long glyph
          textend = tiechar + 5 
          ++tiechar 
          goto EXT 
        end 
        if d1 = tiearr(sizenum,1,TIE_DISTS,1)  /* staff constrained general long glphy
          textend = tiechar + 1 
          tiechar += 2 
          goto EXT 
        end 

        if d1 > phpar(63)     /* above glyph phpar(63), tie is compound 
          ++tiechar 
          scb = tiechar 
          perform charout 
        end 
        goto EXTa  
*  
EXT:    vd = sitflag - 1 / 8 
        sitflag = rem + 1  
        hd = tspan   
        vd = hd - expar(sitflag) + 32 / 8        /* was + 8 / 8 

        scb = textend 
        loop for tcnt = 1 to vd  
          perform charout 
        repeat 
        vd = hd - expar(sitflag) + 32 / 8        /* was + 16 / 8 
        vd = 40 - rem                            /* was 16 - rem 
        scx -= vd 
        scb = tiechar 
        perform charout 
*  
EXTa:   
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 15. sethyph (level,syshit)                                          ³ 
&dA &d@³                                                                       ³ 
&dA &d@³    Purpose:  Typeset hyphons                                          ³ 
&dA &d@³                                                                       ³ 
&dA &d@³    Inputs: level        = level of text line (usually 1)              ³ 
&dA &d@³            x            = absolute coordinate of terminating syllable ³ 
&dA &d@³            y            = absolute coordinate text line               ³ 
&dA &d@³            backloc(.)   = location first space beyond last syllable   ³ 
&dA &d@³                            or location of first hyphon on next line   ³ 
&dA &d@³            syshit       = value of sysright                           ³ 
&dA &d@³                                                                       ³ 
&dA &d@³    Internal varibles:  a,b,c,d                                        ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure sethyph (level,syshit) 
        int level,syshit 
        int t1,t2,t3,t4                        
        getvalue level,syshit 

        scy = y 
        scf = mtfont 

        t1 = x - backloc(level)              /*  t1 = distance over which to set hyphons
        t2 = 3 * phpar(6)  
        if t1 < t2 
          if t1 >= phpar(17) 
            if backloc(level) = ibackloc(level)      
              scx = backloc(level) 
              scb = ors("-") 
              perform charout 
              if t1 < phpar(6) 
                goto CM  
              end  
            end  
            t2 /= 2 
            if t1 > t2 
              t2 = t1 - phpar(17) + 3 * 2 / 5 
              t1 = t2 + backloc(level) 
              scx = t1 
              scb = ors("-") 
              perform charout 
              t1 += t2 
            else 
              t1 = t1 - phpar(17) + 3 / 2 + backloc(level) 
            end  
            scx = t1 
            scb = ors("-") 
            perform charout 
          else 
            if x = syshit       /* sysright (from i-file) replaces phpar(9) &dA12/31/08
              scx = backloc(level) 
              scb = ors("-") 
              perform charout 
              goto CM  
            end  
          end  
        else 
          if backloc(level) = ibackloc(level)     
            t2 = 2 * t1 / phpar(6) + 1  
            t3 = t1 / t2 
            backloc(level) -= t3 
            t1 += t3 
          end  
          t2 = t1 / phpar(6)  
          t3 = t1 / t2 
          --t2 
          backloc(level) += t3 / 2 
          scx = backloc(level) 
          scb = ors("-") 
          perform charout 
          loop for t4 = 1 to t2 
            backloc(level) += t3 
            scx = backloc(level) 
            scb = ors("-") 
            perform charout 
          repeat 
        end  
CM: 
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 16. setunder (level)                                                 ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Purpose:  Typeset underline                                         ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Inputs: level       = level of text line (usually 1)                ³ 
&dA &d@³            uxstop(.)   = x-coordinate of end of line                   ³ 
&dA &d@³            uxstart(.)  = x-coord. of first space beyond last syllable  ³ 
&dA &d@³                            or location of first hyphon on next line    ³ 
&dA &d@³            y           = y-coordinate for text line                    ³ 
&dA &d@³            underflag   = execution flag, currently set for ties and    ³ 
&dA &d@³                            melismas                                    ³ 
&dA &d@³            xbyte(.)    = ending punctuation                            ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Internal varibles:  a,b,c,d                                         ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure setunder (level) 
        int t1,t2,t3,t4                   
        int level 

        getvalue level 

        if underflag = 0 
          return 
        end  
        x = uxstart(level) - phpar(19) 
        scx = x 
        scy = y 
        scf = mtfont 

        t1 = uxstop(level) - uxstart(level)    /*  t1 = distance over which to set hyphons
        if t1 >= phpar(18) 
          y -= pvpar(13) 
          scx = uxstart(level) 
          scy = y 
          scb = ors("_") 
          t2 = uxstop(level) - underspc(sizenum) 
          t4 = underspc(sizenum) 
          loop for t3 = uxstart(level) to t2 step t4 
            perform charout 
          repeat 
          scx = t2     
          perform charout 
          scx += 5 
          scy += pvpar(13) 
        end  
        if underflag = 1 and xbyte(level) <> "_" 
          scb = ors(xbyte(level)) 
          perform charout 
        end  

        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³D* 17. putslur (addcurve)                                                           ³
&dA &d@³                                                                                    ³
&dA &d@³                                                                                    ³
&dA &d@³    Purpose:  Typeset slur                                                          ³
&dA &d@³                                                                                    ³
&dA &d@³    Inputs:   (x1,y1)        = starting note head                                   ³
&dA &d@³              (x2,y2)        = terminating note head                                ³
&dA &d@³              slur_edit_flag = flag indicating that y1 and/or y2 have been altered  ³
&dA &d@³              postx          = horiz. movement of slur after it has been chosen     ³
&dA &d@³              posty          = vert.  movement of slur after it has been chosen     ³
&dA &d@³              addcurve       = flag indicating the curvature should be added        ³
&dA &d@³              sitflag        = situation flag                                       ³
&dA &d@³                                                                                    ³
&dA &d@³                     bit clear            bit set                                   ³
&dA &d@³                   --------------       -------------                               ³
&dA &d@³          bit 0:   full slur            dotted slur                                 ³
&dA &d@³          bit 1:   stock slur           custom slur                                 ³
&dA &d@³          bit 2:   first tip down       first tip up                                ³
&dA &d@³     (*)  bit 3:   second tip down      second tip up                               ³
&dA &d@³     (+)  bit 4:   compute stock slur   hold stock slur                             ³
&dA &d@³                                                                                    ³
&dA &d@³          (*) used on custom slurs only                                             ³
&dA &d@³          (+) used on stock slurs only                                              ³
&dA &d@³                                                                                    ³
&dA &d@³          bit 5:   continuous slur      broken slur                                 ³
&dA &d@³                                                                                    ³
&dA &d@³          bits 8-15:  size of break (0 to 255 dots, centered)                       ³
&dA &d@³                                                                                    ³
&dA &d@³                                                                                    ³
&dA &d@³    Internal variables:  a1,a3,a5,a6,a7,a8,a9,a10,a11,a12                           ³
&dA &d@³                         c1,c2,c3,c4,c5,c6,c7                                       ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure putslur (addcurve) 
        str sbt1.2500 
        str sbt2.2500 
        str temp.600(3) 
        str ptline2.480 

        bstr tbt.2500                  /* added &dA01/26/05&d@ 
        bstr tbt2.2500                 /* added &dA01/26/05&d@ 

        int t1,t2,t3,t4,t5,t6,t7,t8,t9 
        int c1,c2,c3,c4,c5,c6,c7 
        int a1,a3,a5,a6,a7,a8,a9,a10,a11,a12 
        int aa(3),cc(3),dd(3) 
        int save_y1,save_y2 
        int save_x1,save_x2 
        int addcurve 

        getvalue addcurve 

        save_y1 = y1                  /* added &dA01/03/05&d@, etc.  
        save_y2 = y2 
        save_x1 = x1 
        save_x2 = x2 
&dA 
&dA &d@  determine case  
&dA 
        a9 = bit(2,sitflag) 
        a1 = a9 * 2 + 1          /* 1,1,3,3 
        if y1 < y2 
          ++a1                   /* 1,2,3,4 = tips down rising, tips down falling, etc.
        end  
&dA 
&dA &d@  determine method of dealing with slurs   stock vs. custom 
&dA 
        if notesize = 14 
          a5 = 800               /* changed from 801 on &dA9-12-97&d@ 
        end 
        if notesize = 6                    
          a5 = 400               /* changed from 801 on &dA9-12-97&d@ 
        end 
        if notesize = 21 
          a5 = 600               /* changed from 601 on &dA9-12-97&d@ 
        end 

        if notesize = 18 
          a5 = 800 
        end 

        if notesize = 16 
          a5 = 800               
        end 
        if x2 - x1 < a5   /* stock slurs 
SR5:       
          a5 = pvpar(10) + pvpar20 - y1 * 2 + 1 / pvpar(2) - 20 
          a6 = pvpar(10) + pvpar20 - y2 * 2 + 1 / pvpar(2) - 20 
          a7 = abs(a5-a6) 
&dA 
&dA &d@  determine whether to use the parametric method of slur placement 
&dA 
          if a7 < 11 or (x2 - x1 < 100 and slur_edit_flag = 0)    /* protopar file specific

            if a7 > 10 
              a7 -= 10 
              a7 = a7 + 20 * pvpar(2) / 2 - pvpar20 
              if a1 = 1 
                y1 -= a7 
              else 
                if a1 = 2 
                  y2 -= a7 
                else 
                  if a1 = 3 
                    y2 += a7 
                  else              /* a1 = 4 
                    y1 += a7 
                  end 
                end 
              end 
              goto SR5 
            end 
            if a5 < 1 or a6 < 1 
              goto SR1 
            end 
            if a5 > 11 or a6 > 11 
              goto SR2 
            end 
            goto SR3 
*                            adjust parameters upward 
SR1:        a10 = a5 
            a11 = a6 
            if a6 < a5 
              a10 = a6 
              a11 = a5 
            end 
            a10 = 1 - a10        /* minimum amount to raise pars 
            if a7 < 10 
              a12 = a10 / 2 
              if a9 = 0          /* convex slur 
                a10 += rem 
              else 
                if a11 + a10 > 3 
                  a10 += rem 
                end 
              end 
            end 
            a5 += a10 
            a6 += a10 
            goto SR3 
*                              adjust parameters downward
SR2:        a10 = a5 
            a11 = a6 
            if a6 > a5 
              a10 = a6 
              a11 = a5 
            end 
            a10 -= 11            /* minimum amount to lower pars 
            if a7 < 10 
              a12 = a10 / 2 
              if a9 = 1          /* concave slur 
                a10 += rem 
              else 
                if a11 - a10 < 9 
                  a10 += rem 
                end 
              end 
            end 
            a5 -= a10 
            a6 -= a10 
SR3: 
&dA 
&dA &d@  get stock slur number and location  
&dA 
SR4:        a7 = x2 - x1 
            if notesize = 14 or notesize = 18 or notesize = 16   /* Modified (size-16) &dA12/31/08&d@ &dNnot OK
              if a7 < 10 
                --x1 
                ++x2 
                goto SR4 
              end 
            end 
            if notesize = 21      
              if a7 < 15 
                --x1 
                ++x2 
                goto SR4 
              end 
            end 
            if notesize = 6 
              if a7 < 5 
                --x1 
                ++x2 
                goto SR4 
              end 
            end 

            if notesize = 14 or notesize = 18 or notesize = 16   /* Modified (size-16) &dA12/31/08&d@ &dNnot OK
              a7 = x2 - x1 / 2 - 2         /* a7 should be less than 399 
            end 
            if notesize = 21 
              a7 = x2 - x1 + 1 / 3 - 2     /* a7 should be less than 199 
            end 
            if notesize = 6 
              a7 = x2 - x1 - 2             /* a7 should be less than 399 
            end 

            if notesize = 6 
              if a1 < 3 
                temp(1) = slurpar06(a5,a6,1) 
                temp(2) = slurpar06(a5,a6,2) 
                temp(3) = slurpar06(a5,a6,3) 
              else 
                temp(1) = slurpar06(a5,a6,4) 
                temp(2) = slurpar06(a5,a6,5) 
                temp(3) = slurpar06(a5,a6,6) 
              end 
            end 
            if notesize = 14 
              if a1 < 3 
                temp(1) = slurpar14(a5,a6,1) 
                temp(2) = slurpar14(a5,a6,2) 
                temp(3) = slurpar14(a5,a6,3) 
              else 
                temp(1) = slurpar14(a5,a6,4) 
                temp(2) = slurpar14(a5,a6,5) 
                temp(3) = slurpar14(a5,a6,6) 
              end 
            end 
            if notesize = 16 
              if a1 < 3 
                temp(1) = slurpar16(a5,a6,1) 
                temp(2) = slurpar16(a5,a6,2) 
                temp(3) = slurpar16(a5,a6,3) 
              else 
                temp(1) = slurpar16(a5,a6,4) 
                temp(2) = slurpar16(a5,a6,5) 
                temp(3) = slurpar16(a5,a6,6) 
              end 
            end 
            if notesize = 18 
              if a1 < 3 
                temp(1) = slurpar18(a5,a6,1) 
                temp(2) = slurpar18(a5,a6,2) 
                temp(3) = slurpar18(a5,a6,3) 
              else 
                temp(1) = slurpar18(a5,a6,4) 
                temp(2) = slurpar18(a5,a6,5) 
                temp(3) = slurpar18(a5,a6,6) 
              end 
            end 
            if notesize = 21 
              if a1 < 3 
                temp(1) = slurpar21(a5,a6,1) 
                temp(2) = slurpar21(a5,a6,2) 
                temp(3) = slurpar21(a5,a6,3) 
              else 
                temp(1) = slurpar21(a5,a6,4) 
                temp(2) = slurpar21(a5,a6,5) 
                temp(3) = slurpar21(a5,a6,6) 
              end 
            end 
            loop for t5 = 1 to 3 
              cc(t5) = 0 
              dd(t5) = 1 
            repeat 
            loop for t4 = 1 to (a7-2) 
              loop for t5 = 1 to 3 
                t6 = dd(t5) 
                if "zyxwvutsrqponmlkjihgfedcba@ABCDEFGHIJKLMNOPQRSTUVWXYZ" con temp(t5){t6}
                  aa(t5) = mpt - 27 
                  ++t6 
                else 
                  if temp(t5){t6} <> "+" and temp(t5){t6} <> "-" 
                    if (Debugg & 0x12) > 0 
                      pute Slur Coding Error 
                    end 
                  end 
                  if temp(t5){t6} = "+" 
                    t7 = 1 
                  else 
                    t7 = -1 
                  end 
                  ++t6 
                  t8 = 0 
SR6: 
                  if "0123456789" con temp(t5){t6} 
                    --mpt 
                    t8 *= 10 
                    t8 += mpt 
                    ++t6 
                    goto SR6 
                  end 
                  aa(t5) = t8 * t7 
                end 
                cc(t5) += aa(t5) 
                dd(t5) = t6 
              repeat 
            repeat 

            if a1 < 3 
              x1 += cc(1) 
              y1 -= cc(2) 
              a3 =  cc(3) 
            else 
              x1 += cc(1) 
              y1 += cc(2) 
              a3 =  cc(3) 
            end 
            x = x1 + sp 
            y = y1 + psq(f12) 
          else                    /* we don't use parametric method 
            if a1 < 3          /* tips down 
              c1 = y1 / pvpar(2) 
              if y1 > pvpar(1) and rem = 0 
                y1 = (c1 - 1) * pvpar(2) + pvpar(1) 
              end 
              c1 = y2 / pvpar(2) 
              if y2 > pvpar(1) and rem = 0 
                y2 = (c1 - 1) * pvpar(2) + pvpar(1) 
              end 
              a3 = abs(y1 - y2)        /* rise 
              y1 -= pvpar(2) 
            else 
              c1 = y1 / pvpar(2) 
              if y1 < pvpar(8) and rem = 0 
                y1 += pvpar(1)              /* OK 04-24-95 
              end 
              c1 = y2 / pvpar(2) 
              if y2 < pvpar(8) and rem = 0 
                y2 += pvpar(1)              /* OK 04-24-95 
              end 
              a3 = abs(y1 - y2)        /* rise 
              y1 += pvpar(2) 
            end 
            x = x1 + sp + pvpar(2) 
            y = y1 + psq(f12) 
            a7 = x2 - x1 - pvpar(1)        /* length 

            if notesize = 14 or notesize = 18 or notesize = 16   /* Modified (size-16) &dA12/31/08&d@ &dNnot OK
&dA 
&dA &d@      For 14-dot slurs, the distribution of length for stock slurs is a follows
&dA 
&dA &d@            Lengths        Length        Rise       Number 
&dA &d@            in dots      increments   increments   of types (possible)
&dA &d@          ÄÄÄÄÄÄÄÄÄÄ     ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄ 
&dA &d@            8 to 18           2            2           6 
&dA &d@           20 to 196          4            2          12 
&dA &d@          200 to 392          8            2          24 
&dA &d@          400 to 784         16            2          48 
&dA 
              if a7 < 8 
                a7 = 8 
              end 
              if a7 < 20 
                c1 = a7 / 2 
                if rem > 0          /* Fixing error: was &dEif rem > 1&d@  &dA12/18/04&d@ &dIOK
                  ++a7 
                end 
              else 
                if a7 < 200 
                  c1 = a7 / 4 
                  if rem > 1 
                    ++x 
                  end 
                  a7 -= rem 
                else 
                  if a7 < 400 
                    c1 = a7 / 8 
                    x += (rem >> 1) 
                    a7 -= rem 
                  else 
                    c1 = a7 / 16 
                    x += (rem >> 1) 
                    a7 -= rem 
                    if rem > 11 
                      x -= 8 
                      a7 += 16 
                    end 
                    if a7 >= 784 
                      a7 = 784 
                    end 
                  end 
                end 
              end 
&dA 
&dA &d@      For 14-dot slurs, 16-dot slurs and 18-dot slurs,  (Comment modified (size-16) &dA12/31/08&d@) &dNnot OK
&dA 
&dA &d@          Slur number = (rise * 1200) + (length * 3) + type number 
&dA &d@              number ranges from 8 to 143999 
&dA 
              c1 = a3 / 4 
              a3 -= rem 
              if a1 > 2 
                y += rem 
              end 
              a3 = a3 * 1200 + (a7 * 3) + 1 
            end 

            if notesize = 21 
&dA 
&dA &d@      For 21-dot slurs, the distribution of length for stock slurs is a follows
&dA 
&dA &d@            Lengths        Length        Rise       Number 
&dA &d@            in dots      increments   increments   of types (possible)
&dA &d@          ÄÄÄÄÄÄÄÄÄÄ     ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄ 
&dA &d@           12 to 27           3            2           6 
&dA &d@           30 to 294          6            2          12 
&dA &d@          300 to 600         12            2          24 
&dA 
              if a7 < 12 
                a7 = 12 
              end 
              if a7 < 30 
                a7 = a7 + 1 / 3 * 3 
              else 
                if a7 < 300 
                  a7 = a7 + 1 / 6 * 6 
                  rem >>= 1 
                  x += rem 
                else 
                  if a7 < 600 
                    a7 = a7 + 3 / 12 * 12 
                    rem >>= 1 
                    x += rem 
                  else 
                    a7 = 600 
                  end 
                end 
              end 
&dA 
&dA &d@      For 21-dot slurs,
&dA 
&dA &d@          Slur number = (rise * 600) + (length * 2) + type number 
&dA &d@              number ranges from 8 to 143999 
&dA 
              c1 = a3 / 4 
              a3 -= rem 
              if a1 > 2 
                y += rem 
              end 
              a3 = a3 * 600 + (a7 * 2) + 1 
            end 

            if notesize = 6 
&dA 
&dA &d@      For 6-dot slurs, the distribution of length for stock slurs is a follows
&dA 
&dA &d@            Lengths        Length        Rise       Number 
&dA &d@            in dots      increments   increments   of types (possible)
&dA &d@          ÄÄÄÄÄÄÄÄÄÄ     ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄ 
&dA &d@            4 to 9            1            1           6 
&dA &d@           10 to 98           2            1          12 
&dA &d@          100 to 396          4            1          24 
&dA 
              if a7 < 4 
                a7 = 4 
              end 
              if a7 > 9 
                if a7 < 100 
                  c1 = a7 / 2 
                  a7 -= rem 
                else 
                  if a7 < 396 
                    c1 = a7 / 4 
                    x += (rem >> 1) 
                    a7 -= rem 
                  else 
                    a7 = 396 
                  end 
                end 
              end 
&dA 
&dA &d@      For 6-dot slurs, 
&dA 
&dA &d@          Slur number = (rise * 2400) + (length * 6) + type number 
&dA &d@              number ranges from 8 to 143999 
&dA 
              c1 = a3 / 2 
              a3 -= rem 
              y += rem 
              a3 = a3 * 2400 + (a7 * 6) + 1 
            end 
          end 
          x += postx 
          y += posty 
          a3 += addcurve    /* new 6-30-93 

          if notesize = 14 
            if a3 > 120000                       /* max rise = 96 
              goto NOSTOCK 
            end 
          end 
          if notesize = 16 
            if a3 > 120000                       /* max rise = 96 &dA12/31/08&d@ &dNnot OK
              goto NOSTOCK 
            end 
          end 
          if notesize = 18                       /* New (size-18) &dA12/18/04&d@ &dIOK
            if a3 > 115200                       /* max rise = 92 
              goto NOSTOCK 
            end 
          end 
          if notesize = 21 
            if a3 > 70000 
              goto NOSTOCK 
            end 
          end 
&dA 
&dA &d@   a1 = case number   
&dA &d@   a3 = stock slur number   
&dA &d@   x = horizontal position    
&dA &d@   y = vertical position    
&dA 
&dA &d@   Enter new code for acquiring and printing slur 
&dA 
          a5 = 1 
          perform printslur_screen (a1, a3, x, y, a5, sitflag) 
          if a3 = 1000000 
            goto NOSTOCK 
          end 
          return 
        end 

NOSTOCK:                /* long slurs 

        y1 = save_y1                       /* added &dA01/03/05&d@, etc.  
        y2 = save_y2 
        x1 = save_x1 
        x2 = save_x2 

        if a1 < 3          /* tips down 
          c1 = y1 / pvpar(2) 
          if y1 > pvpar(1) and rem = 0 
            y1 = (c1 - 1) * pvpar(2) + pvpar(1) 
          end 
          c1 = y2 / pvpar(2) 
          if y2 > pvpar(1) and rem = 0 
            y2 = (c1 - 1) * pvpar(2) + pvpar(1) 
          end 
          a3 = abs(y1 - y2)        /* rise 
          y1 -= pvpar(2) 
        else 
          c1 = y1 / pvpar(2) 
          if y1 < pvpar(8) and rem = 0 
            y1 += pvpar(1)                /* OK 04-24-95 
          end 
          c1 = y2 / pvpar(2) 
          if y2 < pvpar(8) and rem = 0 
            y2 += pvpar(1)                /* OK 04-24-95 
          end 
          a3 = abs(y1 - y2)        /* rise 
          y1 += pvpar(2) 
        end 
        x = x1 + sp + pvpar(2) + postx 
        y = y1 + psq(f12) + posty 
        a7 = x2 - x1 - pvpar(1)        /* length 

        perform make_longslur (a7,a3,a1)     /* length,rise,smode 
                                             /* return: a7 = offset, a3 = height
        y = y - a7 
&dA 
&dA &d@    Code added &dA01/26/05&d@ to implement dotted slurs in NOSTOCK situation 
&dA &d@      1) Determine a5 = maximum length of slur 
&dA &d@      2) Construct tbt = dotted mask for this slur 
&dA 
        if sitflag = 1 
          a5 = 0 
          loop for t3 = 1 to a3 
            tbt = cbi(longslur(t3)) 
            a6 = bln(tbt) 
            if a6 > a5 
              a5 = a6 
            end 
          repeat 
          if a5 = 0 
            a5 = 100 
          end 
          a6 = a5 / gapsize 
          if bit(0,a6) = 0 
            --a6 
          end 
&dA 
&dA &d@           xxxxxxxxxxx....xxxx....xxxx....xxxx....xxxx....xxxxxxxxxxx 
&dA &d@                  |               odd number                 | 
&dA &d@          a6 = largest odd number of intervals that will fit inside a5   
&dA 
          a6 *= gapsize 
          a7 = a5 - a6 
          a7 >>= 1             /* initial correction 
          tbt = dup("1",a7) // dotted{1,a6} // dup("1",a7+10)   /* mask 
        end 
&dA                  &d@ End of this &dA01/26/05&d@ addition 

        scx = x 
        scy = y 

        c2 = 0 
        loop for t3 = 1 to a3 
&dA 
&dA &d@    Code added &dA01/26/05&d@ to implement dotted slurs in NOSTOCK situation 
&dA 
          if sitflag = 1 
            tbt2 = cbi(longslur(t3))      /* bit equivalent of longslur(t3) 
            tbt2 = bnd(tbt2,tbt)          /* &dEand&d@ this with mask 
            tbt2 = trm(tbt2)              /* and trm to length 
            longslur(t3) = cby(tbt2)      /* put this back in longslur(t3) 
          end 
&dA                  &d@ End of this &dA01/26/05&d@ addition 

          bt(t3) = cbi(longslur(t3)) 
          c1 = bln(bt(t3)) 
          if c1 > c2 
            c2 = c1 
          end 
        repeat 
*  
        ++sst_cnt 
        tput [SST,sst_cnt] Calling longslur at location <~scx ,~scy > 
        ++sst_cnt 
        tput [SST,sst_cnt] : 

        t1 = c2 + 7 / 8 * 8 

        loop for t3 = 1 to a3 
          sbt1 = upk(bt(t3)) 
          sbt1 = sbt1 // pad(t1) 
                         
          sbt2 = "" 
          t4 = 0 
          loop for t5 = 1 to t1 
            if t4 = 0 
              t4 = 0x04 
              if sbt1{t5} = "x" 
                t2 = 0x08 
              else 
                t2 = 0 
              end 
            else 
              if sbt1{t5} = "x" 
                t2 += t4 
              end 
              t4 >>= 1 
              if t4 = 0 
                if t2 < 10 
                  sbt2 = sbt2 // chs(t2) 
                else 
                  sbt2 = sbt2 // chr(55 + t2) 
                end 
              end 
            end 
          repeat 
          ++sst_cnt 
          tput [SST,sst_cnt] ~sbt2 
        repeat 
        ++sst_cnt 
        tput [SST,sst_cnt] : 
&dA 
&dA &d@     display slur contained in bt(a3) 
&dA 
        setb gstr,bt,scx,scy,a3,c2,1,3 
      return 
 
&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 18. puttuplet (a1)                                          ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset tuplet and/or bracket                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of tuplet/bracket ³ 
&dA &d@³              x2 = horizontal stopping point of tuplet/bracket ³ 
&dA &d@³              y1 = vertical starting point                     ³ 
&dA &d@³              y2 = vertical stopping point                     ³ 
&dA &d@³              a1 = tuplet number                               ³ 
&dA &d@³         sitflag = situation flag                              ³ 
&dA &d@³                                                               ³ 
&dA &d@³                         bit clear        bit set              ³ 
&dA &d@³                        ÄÄÄÄÄÄÄÄÄÄÄ      ÄÄÄÄÄÄÄÄÄ             ³ 
&dA &d@³               bit 0    no tuplet        tuplet                ³ 
&dA &d@³               bit 1    no bracket       bracket               ³ 
&dA &d@³               bit 2    tips down        tips up               ³ 
&dA &d@³                                                               ³ 
&dA &d@³               bit 5    broken bracket   continuous bracket    ³ 
&dA &d@³               bit 6    number outside   number inside         ³ 
&dA &d@³               bit 7    square bracket   curved bracket        ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Calling variables to internal procedures:  a1,a4,a5        ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure puttuplet (a1) 
        int xav,yav 
        int t1,t2,t3,t4,t5,savex2 
        int a1,a2,a3,a4,a5,a6 

        getvalue a1 
        savex2 = x2 
        x2 += notesize 
        if bit(1,sitflag) = 1 
          x2 = pvpar(2) / 3 + x2 
        end  
        a4 = x2 - x1 
        a4 = y2 - y1 * 60 / a4 
        xav = x1 + x2 / 2 
        yav = xav - x1 * a4 / 60 + y1  
&dA &d@   xav = x at center of tuplet/bracket 
&dA &d@   a4  = slope * 60 
&dA &d@   yav = y at center of tuplet/bracket 
&dA 
&dA &d@   Part I: tuplet present 
&dA 
        if bit(0,sitflag) = 1 
          x = xav 
          y = yav + psq(f12)   
          a3 = x - phpar(45) + (notesize / 3) 
          a6 = x + phpar(45) - (notesize / 7) 
          x = 0 - phpar(45) / 2 + x + sp  
&dA 
&dA &d@   New code (12/01/94) to deal with complex tuples 
&dA 
          t4 = a1 
          t1 = t4 / 1000 
          t2 = rem 

          if t1 > 0 
            t3 = 2 
            if t2 > 9 
              ++t3 
            end 
            if t1 > 9 
              ++t3 
            end 
            t4 = phpar(45) * t3 + 1 >> 1 
            x -= t4                /* create space for colon + double digits 
            a3 -= t4 
            a6 += t4 
          else 
            t3 = 0 
            if t2 > 9 
              ++t3 
            end 
            t4 = phpar(45) * t3 + 1 >> 1 
            x -= t4                /* create space for double digits 
            a3 -= t4 
            a6 += t4 
          end 

          if bit(1,sitflag) = 1             /* bracket present 
            if bit(7,sitflag) = 1             /* curved bracket 
              if bit(2,sitflag) = 0             /* tips down 
                y -= (pvpar(1) + 1 / 2) 
              else                              /* tips up 
                y += (pvpar(1) + 1 / 2) 
              end 
              if bit(5,sitflag) = 0             /* broken bracket 
                y -= (pvpar(3) >> 2) 
              end 
            end 
&dA 
&dA &d@                 &dA03/15/97&d@ numbers below or above  &dIOK&d@ 
&dA 
            if bit(5,sitflag) = 1             /* continuous bracket 
              if bit(7,sitflag) = 1             /* curved bracket 
                if bit(6,sitflag) = 0             /* number outside 
                  if bit(2,sitflag) = 1             /* tips up 
                    y += pvpar(2) 
                  else                              /* tips down 
                    y -= (pvpar(5) + 1 / 2) 
                  end 
                else                              /* number inside 
                  if bit(2,sitflag) = 1             /* tips up 
                    y -= pvpar(3) 
                  else                              /* tips down 
                    y += (pvpar(5) + 1 / 2) 
                  end 
                end 
              else                              /* square bracket 
                if bit(6,sitflag) = 0             /* number outside 
                  if bit(2,sitflag) = 1             /* tips up 
                    y += pvpar(3) 
                  else                              /* tips down 
                    y -= pvpar(2) 
                  end 
                else                              /* number inside 
                  if bit(2,sitflag) = 1             /* tips up 
                    y -= pvpar(2) 
                  else                              /* tips down 
                    y += pvpar(3) 
                  end 
                end 
              end 
              a3 = xav + 2                  /* eliminate space in bracket line
              a6 = xav - 2 
            end 
          end 
          scx = x 
          scy = y 
&dA 
&dA &d@     Put out numerator of tuple 
&dA 
          t3 = t2 / 10 
          t2 = rem 
          if t3 > 0 
            scb = t3 + 221 
            perform charout 
          end 
          scb = t2 + 221 
          perform charout 
&dA 
&dA &d@     Put out denominator of tuple (if present) 
&dA 
          if t1 > 0 
            scb = 249           /* colon 
            perform charout 
            t3 = t1 / 10 
            t1 = rem 
            if t3 > 0 
              scb = t3 + 221 
              perform charout 
            end 
            scb = t1 + 221 
            perform charout 
          end 

        end  
&dA 
&dA &d@   Part II: bracket present 
&dA 
        if bit(1,sitflag) = 1               /* bracket present 
&dA 
&dA &d@     Square brackets 
&dA 
          if bit(7,sitflag) = 0               /* square bracket 
&dA 
&dA &d@   1) compute slope 
&dA 
            a5 = abs(a4) 
            a5 = a5 + 3 / 5 
            if a5 > 6 
              a5 = 6 
            end 
            if a5 = 5 
              a5 = 4 
            end 
            if a5 = 6 
              a5 = 5 
            end 
            if a4 > 0 
              a4 = a5 
            else 
              a4 = 0 - a5 
            end 
            yav -= pvpar(40) 
&dA 
&dA &d@   2) case 1: broken bracket 
&dA 
            if bit(5,sitflag) = 0        
              a1 = a3 - x1 + 2 / 3 * 3 
              x1 = a3 - a1 
              a2 = 6 
              if a4 < 0 
                a2 = -6 
              end 
              y1 = x1 - xav * a4 + 6 / 12 + yav 
              x = x1 + sp 
              y = y1 + psq(f12) 
              perform brackethook 
              perform bracketline (a1,a4,a5) 
              a1 = x2 - a6 + 2 / 3 * 3 
              y1 = a6 - x1 * a4 + a2 / 12 + y1 
              x1 = a6 
              perform bracketline (a1,a4,a5) 
              perform brackethook 
            else 
&dA 
&dA &d@   3) case 2: continuous bracket 
&dA 
              a1 = x2 - x1 + 2 / 3 * 3 
              x1 = 0 - a1 - 1 / 2 + xav 
              y1 = x1 - xav * a4 + 6 / 12 + yav 
              x = x1 + sp 
              y = y1 + psq(f12) 
              perform brackethook 
              perform bracketline (a1,a4,a5) 
              perform brackethook 
            end 
          else 
&dA 
&dA &d@      Curved brackets (slurs)      /* &dA03/15/97&d@  &dIOK&d@ 
&dA 
&dA &d@     Inputs:   (x1,y1)        = starting note head 
&dA &d@               (x2,y2)        = terminating note head 
&dA &d@               slur_edit_flag = flag indicating that y1 and/or y2 have been altered
&dA &d@               postx          = horiz. movement of slur after it has been chosen
&dA &d@               posty          = vert.  movement of slur after it has been chosen
&dA &d@               addcurve (t5)  = flag indicating the curvature should be added 
&dA &d@               sitflag        = situation flag 
&dA &d@  
&dA &d@                      bit clear            bit set 
&dA &d@                    --------------       ------------- 
&dA &d@           bit 0:   full slur            dotted slur 
&dA &d@           bit 1:   stock slur           custom slur 
&dA &d@           bit 2:   first tip down       first tip up  
&dA &d@      (*)  bit 3:   second tip down      second tip up     
&dA &d@      (+)  bit 4:   compute stock slur   hold stock slur 
&dA &d@          
&dA &d@           (*) used on custom slurs only  
&dA &d@           (+) used on stock slurs only 
&dA 
&dA &d@           bit 5:   continuous slur      broken slur             /* &dA03/15/97&d@  &dIOK
&dA &d@    
&dA &d@           bits 8-15:  size of break (0 to 255 dots, centered) 
&dA &d@    
            t1 = sitflag 
            x2 = savex2               /* restore x2 to original 
            if bit(2,t1) = 1          /* tips up 
              sitflag = 12 
              posty = 0 - pvpar(5)     /* reason: y1 and y2 were supplied as endpoints
            else                      /* for square brackets, not the notes themselves
              sitflag = 0             /* this code is a cludge to correct for this
              posty = pvpar(5) / 2     /* approximately.  Rigorous solution would be
            end                       /* to set through the original oby's 
            slur_edit_flag = 1 
            postx = 0 
            t5 = 0 

            if bit(5,t1) = 0          /* broken slur 
              t2 = a6 - a3 << 8 + 0x20 
              sitflag += t2 
            end 
            perform putslur (t5) 
          end 
        end  
      return 
*  
&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 18a. brackethook                                            ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset vertical hook for bracket                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure brackethook  
        if bit(2,sitflag) = 1 
          y = y - notesize + 2 
        end  
        scx = x 
        scy = y 
        scb = 89 
        perform charout 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 19. bracketline (t1,t2,t3)                                  ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  typeset bracket line                             ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   t1 = length                                      ³ 
&dA &d@³              t2 = slope                                       ³ 
&dA &d@³              t3 = slope type  0,1,2,3,4,5                     ³ 
&dA &d@³              x1 = x starting point                            ³ 
&dA &d@³              y1 = y starting point                            ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Outputs:  x = x coordinate of end of line                  ³ 
&dA &d@³              y = y coordinate of end of line                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure bracketline (t1,t2,t3) 
        int a1,a2,a3 
        int t1,t2,t3 

        getvalue t1,t2,t3 
        if t1 = 0  
          return 
        end  
        x = x1 + sp  
        y = y1 + psq(f12)   
        scx = x 
        scy = y 
        scf = 400 

        if t2 > 0  
          z = 184 + t3   
        end  
        if t2 < 0  
          z = 164 + t3   
        end  
        if t2 = 0  
          z = 161  
        end  
        a1 = t1 / 12 
        a3 = rem 
        if t2 = 0 
          loop for a2 = 1 to a1 
            x += 12 
            scb = z 
            perform charout 
          repeat 
        else 
          loop for a2 = 1 to a1 
            scb = z 
            perform charout 
            if t2 > 0 
              scy += t2 
            else 
              a1 = 0 - t2 
              scy -= a1 
            end 
            x += 12 
            y += t2 
          repeat 
        end 
        if a3 > 0 
          if a3 = 9 
            if t2 < 0  
              a1 = t2 - 1 * 2 / 3 
              z += 5 
            end  
            if t2 > 0  
              a1 = t2 + 1 * 2 / 3 
              z += 5 
            end  
            if t2 = 0  
              a1 = 0 
              ++z
            end  
          end  
          if a3 = 6 
            if t2 < 0  
              a1 = t2 - 1 / 2 
              z += 10 
            end  
            if t2 > 0  
              a1 = t2 + 1 / 2 
              z += 10 
            end  
            if t2 = 0  
              a1 = 0 
              z += 2 
            end  
          end  
          if a3 = 3 
            if t2 < 0  
              a1 = t2 - 1 / 3 
              z += 15 
            end  
            if t2 > 0  
              a1 = t2 + 1 / 3 
              z += 15 
            end  
            if t2 = 0  
              a1 = 0 
              z += 3 
            end  
          end  
          scb = z 
          perform charout 
          x += a3 
          y += a1 
        end  
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 20. putwedge (t1,t2)                                        ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset wedge                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of wedge          ³ 
&dA &d@³              x2 = horizontal stopping point of wedge          ³ 
&dA &d@³              y1 = vertical starting point                     ³ 
&dA &d@³              y2 = vertical stopping point                     ³ 
&dA &d@³              t1 = starting spread of wedge                    ³ 
&dA &d@³              t2 = stopping spread of wedge                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putwedge (t1,t2) 
        int t1,t2,t3 
        int leng,slope,z1,clen,fullcnt 
        int nex

        getvalue t1,t2 
        y1 -= pvpar(1) 
        y2 -= pvpar(1) 
        leng = x2 - x1   
        x = x1 + sp  

        scx = x 
        scf = 400 
*   compute slope  
        slope = t2 - t1 * 240 / leng 
        slope = abs(slope) 
        if slope < 8 
          slope = 8 
        end  
        if t2 > t1 
          slope = slope + 2 / 4 
        else 
          slope = slope + 3 / 4 
        end  
        if slope > 20 
          slope = 20 
        end  
        z1 = slope 
        if t2 < t1 
          slope = 0 - slope 
        end  
*   compute character  
        if z1 > 12 
          z1 = z1 - 13 / 2 + 13  
        end  
*   compute length of character  
        if z1 < 11 
          clen = 120 / z1 
        else 
          clen = 128 / z1 
        end  
*   compute number of full characters  
        fullcnt = leng / clen 
*   compute extension set  
        nex = 0 
        t3 = rem - 30 
        if t3 > 0 
          ++nex 
          tarr(nex) = 74 
          rem = t3 
        end  
        t3 = rem - 20 
        if t3 > 0 
          ++nex 
          tarr(nex) = 75 
          rem = t3 
        end  
        t3 = rem - 10 
        if t3 > 0 
          ++nex 
          tarr(nex) = 78 
          rem = t3 
        end  
        if rem > 0 
          ++nex 
          tarr(nex) = 88 - rem 
        end  
*   write out wedge . . .  
        if slope > 0                    /* cresc.  
          t3 = t1 / 2 
          y2 += t3 
          y1 -= t3 
          z = z1 + 31  
*   -- top 
          y = y1 + psq(f12)   
          loop for t3 = 1 to fullcnt 
            scy = y 
            scb = z 
            perform charout 
            --y
          repeat 
          loop for t3 = 1 to nex 
            z = tarr(t3) 
            scy = y 
            scb = z 
            perform charout 
          repeat 
*   -- bottom  
          scx = x 
          z = z1 + 51  
          y = y2 + psq(f12)   
          loop for t3 = 1 to fullcnt 
            scy = y 
            scb = z 
            perform charout 
            ++y
          repeat 
          loop for t3 = 1 to nex 
            z = tarr(t3) 
            scy = y 
            scb = z 
            perform charout 
          repeat 
        else                            /* decresc.  
          t3 = t2 / 2 
          y1 = y1 - t3 - fullcnt 
          y2 = y2 + t3 + fullcnt 
*   -- top 
          y = y1 + psq(f12)   
          loop for t3 = 1 to nex 
            z = tarr(t3) 
            scy = y 
            scb = z 
            perform charout 
          repeat 
          z = z1 + 51  
          loop for t3 = 1 to fullcnt 
            scy = y 
            scb = z 
            perform charout 
            ++y
          repeat 
          scx = x 
*   -- bottom  
          y = y2 + psq(f12)   
          loop for t3 = 1 to nex 
            z = tarr(t3) 
            scy = y 
            scb = z 
            perform charout 
          repeat 
          z = z1 + 31  
          loop for t3 = 1 to fullcnt 
            scy = y 
            scb = z 
            perform charout 
            --y 
          repeat 
        end  
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 21. putfigcon (t3)                                                   ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Purpose:  Typeset figure continuation line                          ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of line                    ³ 
&dA &d@³              x2 = horizontal stopping point of line                    ³ 
&dA &d@³              t3 = vertical level of line                               ³ 
&dA &d@³              y1 = additional vertical displacement from default height ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putfigcon (t3) 
        int t1,t3 

        getvalue t3 
        x = x1 + sp  
        --t3 
&dA 
&dA &d@    New code &dA11/06/03&d@ adding figoff(.) and y1 
&dA 
        y = pvpar(37) * t3 + pvpar(36) + psq(f12) + figoff(f12) + y1 
        scx = x 
        scy = y 
        t1 = x2 - phpar(44) 
        scb = 220 
        loop while x1 <= t1 
          perform charout 
          x1 += phpar(44) 
        repeat 
        x = t1 + sp 
        scx = x 
        perform charout 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 22. puttrans (t1,t2)                                        ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset octave transposition                     ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of transposition  ³ 
&dA &d@³              x2 = horizontal stopping point of transposition  ³ 
&dA &d@³              y1 = vertical level of transposition             ³ 
&dA &d@³              t1 = length of ending hook                       ³ 
&dA &d@³              t2 = situation, 0 = 8av up, 1 = 8av down         ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure puttrans (t1,t2) 
        int a1,a2,a3 
        int t1,t2 

        getvalue t1,t2 
        x = x1 + sp  
        y = y1 + psq(f12)   
        scx = x 
        scy = y 
        scb = 233 
        perform charout 
        x += phpar(42) 
        scx = x 
        x1 += phpar(42) 
        a2 = x2 - (phpar(43) >> 1) 
        a3 = 0 
        scb = 91 
        loop while x1 <= a2 
          a3 = 1 
          perform charout 
          x1 += phpar(43) 
        repeat 
        a1 = phpar(43) >> 1 
        x1 -= a1 
        if a3 = 1 
          if x1 <= a2 
            scx -= a1 
            perform charout 
          end  
          if t1 > 0  
            a2 = phpar(43) >> 2      
            scx -= a2 
            if t1 < notesize 
              t1 = notesize 
            end 
            if t2 = 1 
              a3 = t1 - 2 
              scy -= a3 
            end  
            loop while t1 > notesize 
              scb = 89 
              perform charout 
              scy += notesize 
              t1 -= notesize 
            repeat 
            a3 = notesize - t1 
            scy -= a3 
            scb = 89 
            perform charout 
          end  
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 23. putending (t1,t2,t3)                                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset ending                                   ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of ending         ³ 
&dA &d@³              x2 = horizontal stopping point of ending         ³ 
&dA &d@³              y1 = vertical level of ending                    ³ 
&dA &d@³              t1 = length of start hook                        ³ 
&dA &d@³              t2 = length of ending hook                       ³ 
&dA &d@³              t3 = ending number, 0 = none                     ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putending (t1,t2,t3) 
        int a1,a2 
        int t1,t2,t3 

        getvalue t1,t2,t3 
        if f12 > 1 
          if t3 > 9                       /* New condition &dA04/25/09&d@ 
            t3 -= 10 
          else 
            return 
          end 
        end  
        x = x1 + sp  
        y = y1 + psq(f12)   
        scx = x 
        scy = y 
        if t1 > 0  
          if t1 < notesize 
            t1 = notesize 
          end 
          loop while t1 > notesize 
            scb = 89 
            perform charout 
            scy += notesize 
            t1 -= notesize 
          repeat 
          a2 = notesize - t1 
          scy -= a2 
          scb = 89 
          perform charout 
        end  
        if t3 > 0  
          scx = x + pvpar(1) 
          scy = y + pvpar(4) 
          scf = mtfont 
          out = chs(t3) 
          perform stringout (out) 
          scb = 46 
          perform charout 
          scf = notesize 
        end  
        scx = x 
        scy = y 
        a1 = x2 - phpar(1) 
        scb = 90 
        loop while x1 <= a1 
          perform charout 
          x1 += phpar(1) 
        repeat 
        x = a1 + sp 
        scx = x 
        perform charout 
        if t2 > 0  
          if t2 < notesize 
            t2 = notesize 
          end 
          loop while t2 > notesize 
            scb = 89 
            perform charout 
            scy += notesize 
            t2 -= notesize 
          repeat 
          a2 = notesize - t2 
          scy -= a2 
          scb = 89 
          perform charout 
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 24. putdashes (t1,t2)                                       ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset dashes                                   ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of dashes         ³ 
&dA &d@³              x2 = horizontal stopping point of dashes         ³ 
&dA &d@³              y1 = vertical level of dashes                    ³ 
&dA &d@³              t1 = spacing parameter                           ³ 
&dA &d@³              t2 = font designator                             ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putdashes (t1,t2) 
        int t1,t2 
        int a1,a2,a3,a4,a5 

        getvalue t1,t2 
        a2 = x2 - x1 
        if a2 < 0 
          return 
        end 
        x = x1 + sp + hyphspc(sizenum) 
        y = y1 + psq(f12)   

        scf = t2 
        scx = x 
        scy = y 
        scb = 173 
        perform charout 
        if t1 = 0  
          a1 = hyphspc(sizenum) * 5 
          a3 = a2 / a1 
          if a3 = 0 
            t1 = x2 - x1 
            a3 = 2 
          else 
            if rem > hyphspc(sizenum) * 2 
              ++a3 
            end 
            t1 = a2 / a3              
          end 
          a4 = 1 
        else 
          a1 = t1              
          a3 = a2 / a1 
          a4 = 0 
        end  

        loop for a5 = 1 to a3 - 1 
          x += t1 
          scx = x 
          perform charout 
          if a4 = 1 
            a2 -= t1 
            --a3 
            if a3 > 0 
              t1 = a2 / a3 
            end 
          end 
        repeat 
        scf = notesize 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 25. puttrill (t1)                                           ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset long trill                               ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   x1 = horizontal starting point of trill          ³ 
&dA &d@³              x2 = horizontal stopping point of trill          ³ 
&dA &d@³              y1 = vertical level of trill                     ³ 
&dA &d@³              t1 = situation  1 = no trill                     ³ 
&dA &d@³                              2 = trill with no accidental     ³ 
&dA &d@³                              3 = trill with sharp             ³ 
&dA &d@³                              4 = trill with natural           ³ 
&dA &d@³                              5 = trill with flat              ³ 
&dA &d@³                              6 = trill with sharp following   ³ 
&dA &d@³                              7 = trill with natural following ³ 
&dA &d@³                              8 = trill with flat following    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure puttrill (t1) 
        int hh,k1                                      /* k1 is new &dA11/05/05
        int t1 

        getvalue t1 
        x = x1 + sp  
        y = y1 + psq(f12)   
        k1 = x1                 /* localize x1            /* New &dA11/05/05&d@ 
        hh  = k1                                          /* New &dA11/05/05&d@ 
        scx = x 
        scy = y 
        if t1 > 1 
          if t1 > 2 and t1 < 6 
            scb = int("..389"{t1}) + 210     /* music font 
            scy = y - pvpar(45) 
            perform charout 
            scy = y 
          end 
          x += phpar(41) 
          scb = 236 
          perform charout 
          scx = x 
&dA 
&dA &d@      New code added to implement accidentals following a trill sign  &dA11/05/05
&dA 
          if t1 > 5 and t1 < 9 
            x -= pvpar(1) 

            k1 += pvpar(2) 
            scx = x         
            scy = y - pvpar(2) 
            scb = t1 + 185                   /* music font (cue size) 
            perform charout 
            x += pvpar(3)                      
            scx = x 
            scy = y 
          end 
&dA 
&dA        &d@    End of &dA11/05/05&d@ New Code 

          hh = k1 + phpar(41)                              /* k1 replaces x1  &dA11/05/05
        end  
        scb = 237 
        loop while hh < x2 
          perform charout 
          hh += phpar(40) 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 26. sysline                                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset left-hand system line                    ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   f11 = number of parts                            ³ 
&dA &d@³              psq(1) = y coordinate of first part              ³ 
&dA &d@³              psq(f11) = y coordinate of last part             ³ 
&dA &d@³              sp = x-coordinate of beginning of line           ³ 
&dA &d@³              syscode = format for brace/bracket               ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure sysline  
        int a1,a2,a3,a4,a5,a6,a7 
        int a8,a9,a10,a11,a12             /* added &dA03/11/06&d@ 

        if syscode = ""  
          return 
        end  
&dA 
&dA &d@  1. typeset left-hand bar  
&dA 
        x = sp 
        z = 82 
        y1 = psq(1) 
&dA 
&dA &d@     Adding code &dA11/13/03&d@ to deal with mixed staff sizes &dIOK&d@ 
&dA 
        a4 = notesize 
        a3 = nsz(f11)                /* notesize of staff for this termination
        a5 = a4 - a3 * 4             /* length correction 
        if notesize <> a3 
          notesize = a3              /* set font size for computing pvpar(44)
          perform ps_init_par 
        end 
        y2 = psq(f11) + pvpar(44)      /* line thickness added &dA04-25-95&d@ 
        y2 -= a5 

        if notesize <> a4 
          notesize = a4              /* return to original font size 
          perform ps_init_par 
        end 
&dA   
        brkcnt = 0 
        if f11 > 1 or vst(1) > 0 
          perform putbar (f11)
        end 
&dA 
&dA &d@  2. typeset braces 
&dA 
        a2 = 0 
        loop for a1 = 1 to len(syscode)  
          if syscode{a1} = "[" 
            x = sp - phpar(46)  
            y1 = psq(a2+1)  
          end  
          if syscode{a1} = "]" 
            y2 = psq(a2) 
&dA 
&dA &d@     Adding code &dA11/13/03&d@ to deal with mixed staff sizes  &dIOK&d@ 
&dA 
            a4 = notesize 
            a3 = nsz(a2)             /* notesize of staff for this termination
            a5 = a4 - a3 * 4         /* length correction 
            y2 -= a5 
&dA   
            z = 84 
            brkcnt = 0 
            perform putbar (a2)
            y = y1 
            z = 87 
            perform setmus 
            y = y2 + pvpar(8) + vst(a2) 
            z = 88 
            perform setmus 
          end  
          if ".:,;" con syscode{a1}            /* changed &dA11/13/03&d@  &dIOK&d@ 
            ++a2
          end  
        repeat 
&dA 
&dA &d@  3. typeset brackets 
&dA 
        x1 = x - phpar(47)
        a2 = 0 
        loop for a1 = 1 to len(syscode)  
          if syscode{a1} = "{" 
            y1 = psq(a2+1)  
          end  
          if syscode{a1} = "}" 
            x = x1 
            y2 = psq(a2) + pvpar(8) + vst(a2) 
&dA 
&dA &d@     Adding code &dA11/13/03&d@ to deal with mixed staff sizes  &dIOK&d@ 
&dA 
            a4 = notesize 
            a3 = nsz(a2)             /* notesize of staff for this termination
            a5 = a4 - a3 * 4         /* length correction 
            y2 -= a5 
&dA   
            if notesize < 10 
              a7  = 66 
              a8  = 100 
              a9  = 3 
              a10 = 6 
              a11 = 96 
            else 
              a7  = 132 
              a8  = 201 
              a9  = 6 
              a10 = 12 
              a11 = 192 
            end 
            a3 = y2 - y1   
&dA 
&dA &d@      There are three cases:         a3 <= 201 (one glyph)    granularity = 6 
&dA &d@                              202 <= a3 <= 402 (two glyphs)   granularity = 12
&dA &d@                              403 <= a3 <= 570 (three glyphs) granularity = 12
&dA 
            if a3 <= a8                     /*                 New &dA03/11/06&d@ 
              a4 = a3 + 2 / a9 * a9         /* actual length   New &dA03/11/06&d@ 
              a5 = a4 - a3 / 2              /* delta / 2 
              y  = y1 - a5                  /* corrected value of y 
              a5 = a4 / a9 + 20             /* font number     New &dA03/11/06&d@ 
              scx = x 
              scy = y 
              scb = a5 
              if scb < 33 
                if (Debugg & 0x12) > 0 
#if DMUSE 
                  putc &dAWARNING&d@: You are trying to typeset a bracket which is too short.
                  putc          This is sometimes the result of a faulty system code.
                  putc          If other problems occur as well, check system code first.
#else 
                  pute WARNING: You are trying to typeset a bracket which is too short.
                  pute          This is sometimes the result of a faulty system code.
                  pute          If other problems occur as well, check system code first.
#endif 
                end 
                scb = 33 
              end 

              scf = 320 
              perform charout 
              scf = notesize 
            else 
              if a3 <= (a8 * 2)             /*                 New &dA03/11/06&d@ 
                a4 = a3 + 5 / a10 * a10     /* actual length   New &dA03/11/06&d@ 
                a5 = a4 - a3 / 2            /* delta / 2 
                y  = y1 - a5                /* corrected value of y 
                a5 = a4 / a10 + 10 * 2      /* font number     New &dA03/11/06&d@ 
                a6 = a4 / 2                 /* y increment to second glyph 
                scx = x 
                scy = y 
                scb = a5 
                scf = 320 
                perform charout 
                scy += a6 
                ++scb 
                perform charout 
                scf = notesize       
              else 
                a4 = a3 + 5 / a10 * a10     /* actual length   New &dA03/11/06&d@ 
                a5 = a4 - a3 / 2            /* delta / 2 
                y  = y1 - a5                /* corrected value of y 
                a5 = a4 / a10 - 5 * 3 + 1   /* font number     New &dA03/11/06&d@ 
                a6 = a4 - (a11 * 2)         /* y increment to third glyph    New &dA03/11/06
                scx = x 
                scy = y 
&dA 
&dA &d@           New code &dA01/31/10&d@ to enable display of extra-tall brackets.  
&dA &d@             Code uses new glyph 124 in the bracket font.  
&dA 
                if a5 > 121 
                  a5 = 115 
                   
                  scb = 115 
                  scf = 320 
                  perform charout                          /*  New &dA03/11/06&d@ 
                  scy += a11 
                  a12 = scy + (a6 - a7 / 2 )
                  scb = 124 
                  loop 
                    perform charout 
                    scy += 6 
                  repeat while scy < a12 
                  scy = a12 
                  scb = 116 
                  perform charout 
                  a12 = scy + a6 - (a6 - a7 / 2 ) 
                  scb = 124 
                  scy += a7 
                  loop 
                    perform charout 
                    scy += 6 
                  repeat while scy < a12 
                  scy = a12 
                  scb = 117 
                  perform charout 
                  scf = notesize 
               else 
                  scb = a5 
                  scf = 320 
                  perform charout 
                  scy += a11                               /*  New &dA03/11/06&d@ 
                  ++scb 
                  perform charout 
                  scy += a6 
                  ++scb 
                  perform charout 
                  scf = notesize 
                end 
              end 
            end 
          end  
          if ".:,;" con syscode{a1}            
            ++a2
          end  
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 27. putbar (t1)                                             ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset bar line                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   t1 = staff number of last line                   ³ 
&dA &d@³              y1 = coordinate of top of line                   ³ 
&dA &d@³              y2 = coordinate of last bar character            ³ 
&dA &d@³              brkcnt = number of breaks in bar                 ³ 
&dA &d@³              barbreak(.,1) = y coordinate of top of break     ³ 
&dA &d@³              barbreak(.,2) = y coordinage of bottom of break  ³ 
&dA &d@³              x = x-coordinat of line                          ³ 
&dA &d@³              z = font character                               ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure putbar (t1)
        int t1,t2 
        int c1,c3,c4 
        getvalue t1

        if brkcnt = 0  
          t2 = y2 + vst(t1) 
          loop for y = y1 to t2 step pvpar(8) 
            perform setmus 
          repeat 
          y = t2 
          perform setmus 
          return 
        end  
        c3 = y1  
        loop for c1 = 1 to brkcnt  
          c4 = barbreak(c1,1) - pvpar(8)  
          if c4 > c3 
            if c4 < y2   
              loop for y = c3 to c4 step pvpar(8) 
                perform setmus 
              repeat 
              y = c4 
              perform setmus 
              c3 = barbreak(c1,2)  
            end  
          end  
        repeat 
        c4 = y2 + vst(t1) 
        if c4 >= c3  
          loop for y = c3 to c4 step pvpar(8) 
            perform setmus 
          repeat 
          y = c4 
          perform setmus 
        end  
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 28. printslur_screen (ori,snum,x,y,mode,sitflag)            ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose: read slur data from bigslur, compile and          ³ 
&dA &d@³                send slur to screen                            ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Input:  ori    case: 1,2,3 or 4                             ³ 
&dA &d@³           snum   slur number                                  ³ 
&dA &d@³           x      x location                                   ³ 
&dA &d@³           y      y location                                   ³ 
&dA &d@³           mode   1 = display, 0 = clear (cancel)              ³ 
&dA &d@³        sitflag   situation flag                               ³ 
&dA &d@³                                                               ³ 
&dA &d@³          bit 5:   continuous slur      broken slur            ³ 
&dA &d@³                                                               ³ 
&dA &d@³          bits 8-15:  size of break (0 to 255 dots, centered)  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure printslur_screen (ori,snum,x,y,mode,sitflag) 
        str pfile.100,pointer.6,data.500
&dA &d@       bstr bt.2500(250)                  &dAThis is now global&d@ 
        int snum,ori 
        int offset,datalen,nrows 
        int slen,srise 
        int bulge 
        int t1,t2 
        int x,y,maxn 
        int dpnt,sdpnt 
        int code,cnt,ndata(2),kdata(2) 
        int mode,sitflag 
        int broksize                                /* &dA03/15/97&d@  &dIOK&d@ 
        real rx 
        int scx2                                    /* added &dA11/29/09&d@ 

        str sbt.800
* 
        getvalue ori,snum,x,y,mode,sitflag 
        if bit(5,sitflag) = 1                       /* &dA03/15/97&d@  &dIOK&d@ 
          broksize = sitflag >> 8 
        else 
          broksize = 0 
        end 
        sitflag &= 0x01 

        if snum < 24 or snum >= 144000 
          snum = 1000000 
          passback snum 
          return 
        end 

        perform construct_bigslur_element (ori,notesize,snum,srise,nrows,slen,bulge)
        maxn = slen 

        if bulge > 127                 /* added &dA01/03/05&d@ 
          bulge = 0 
        end 

        slen += bulge                  /* added &dA11-19-92&d@ 
        if bulge > 0 
          x -= bulge 
        end 

        t1 = 0                         /* look for vert shift 
        if ori = 1
          t1 = nrows - 1
        else 
          if ori = 2
            t1 = nrows - 1 - srise
          else
            if ori = 3
              t1 = srise
            end
          end
        end
        y = y - t1   

    /* move screen cursor to point <x,y> 

        scx = x 
        scy = y 

        if sitflag = 1 
          t2 = maxn / gapsize 
          if bit(0,t2) = 0 
            --t2 
          end 
&dA 
&dA &d@           xxxxxxxxxxx....xxxx....xxxx....xxxx....xxxx....xxxxxxxxxxx 
&dA &d@                  |               odd number                 | 
&dA &d@          t2 = largest odd number of intervals that will fit inside maxn 
&dA 
          t2 *= gapsize 
          t1 = maxn - t2 
          t1 >>= 1             /* initial correction 
          bt(250) = dup("1",t1) // dotted{1,t2} // dup("1",t1+10)   /* mask 

          loop for t1 = 1 to nrows 
            bt(t1) = bnd(bt(t1),bt(250)) 
          repeat 
        end 

        if broksize > 0                               /* &dA03/15/97&d@  &dIOK&d@ 
          t2 = maxn - broksize >> 1 
          if t2 < 0 
            t2 = 0 
          end 
          t1 = maxn - t2 - t2 
          bt(250) = dup("1",t2) // dup("0",t1) // dup("1",t2) 
          loop for t1 = 1 to nrows 
            bt(t1) = bnd(bt(t1),bt(250)) 
          repeat 
        end 

        ++st_cnt 
        tput [ST,st_cnt] Calling for a slur at <~scx ,~scy > 
        ++st_cnt 
        tput [ST,st_cnt] : 

        loop for t1 = 1 to nrows 
          sbt = upk(bt(t1)) 
          ++st_cnt 
          tput [ST,st_cnt] ~sbt 
        repeat 
        ++st_cnt 
        tput [ST,st_cnt] : 
&dA 
&dA &d@   &dA01/05/09&d@ Code below added back to POSTSCRIPT case, because we need the 
&dA &d@            "dots" to determine the bounding box.  mode is always = 1 
&dA 
        setb gstr,bt,scx,scy,nrows,maxn,1,3 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 29. barline                                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose:  Typeset bar line                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Inputs:   f11 = number of parts                            ³ 
&dA &d@³              psq(1) = y coordinate of first part              ³ 
&dA &d@³              psq(f11) = y coordinate of last part             ³ 
&dA &d@³              x = x-coordinate of line                         ³ 
&dA &d@³              z = bar character                                ³ 
&dA &d@³              syscode = format for bar                         ³ 
&dA &d@³              nsz(.)  = notesizes for each staff in the system ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure barline  
        int a1,a2,a3,a4,a5   

        if z = 86                          /* Case: dotted bar line cannot connect staff lines
          loop for a1 = 1 to f11 
            y = psq(a1) 
            a4 = nsz(a1) 
            if notesize <> a4 
              notesize = a4                /* set font size for segment 
              perform ps_init_par 
            end 
            perform setmus 
          repeat 
        else 
          a2 = 0 
          loop for a1 = 1 to len(syscode) 
            if "[(" con syscode{a1} 
              a4 = 0                       /* this will become the font size for this segment
              y1 = psq(a2+1) 
            end 
            if "])" con syscode{a1} 
&dA 
&dA &d@    If a4 is not determined at this point, set it to the default 
&dA 
              if a4 = 0 
                a4 = nsz(a2)               /* font size of bottom staff in this segment
              end 
              a3 = nsz(a2)                 /* notesize of staff for this termination
              a5 = a4 - a3 * 4             /* length correction 
              if notesize <> a3 
                notesize = a3              /* set font size for computing pvpar(44)
                perform ps_init_par 
              end 
              y2 = psq(a2) + pvpar(44)       /* line thickness added &dA04-25-95
              y2 -= a5 

              if notesize <> a4 
                notesize = a4              /* set font size for segment 
                perform ps_init_par 
              end 

              perform putbar (a2)
            end 
            if ".:,;" con syscode{a1}        
              ++a2
              if mpt > 2 
                if a4 = 0 
                  a4 = nsz(a2) 
                else 
                  if nsz(a2) > a4 
                    a4 = nsz(a2) 
                  end 
                end 
              end 
            end  
          repeat 
        end  
      return 
 
&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³D* 30. construct_bigslur_element (case,nsize,snum,rise,height,maxlen,bulge)  ³
&dA &d@³                                                                             ³
&dA &d@³    Operation:  This procedure is a replacement for the set of               ³
&dA &d@³                bigslur files used by the dskpage family of programs.        ³
&dA &d@³                Given a case (1 to 4), a notesize (6,14,16,18,21) and        ³
&dA &d@³                a slur number (from the slurpar data), this procedure        ³
&dA &d@³                constructs the requested slur on the fly.  Code for          ³
&dA &d@³                this procedure (and its two satalites) was lifted            ³
&dA &d@³                directly from the create programs                            ³
&dA &d@³                                                                             ³
&dA &d@³    Inputs:     int case:   1 = rising,convex                                ³
&dA &d@³                            2 = falling,convex                               ³
&dA &d@³                            3 = rising,concave                               ³
&dA &d@³                            4 = falling,concave                              ³
&dA &d@³                int nsize   [6,14,16,18,21]                                  ³
&dA &d@³                int snum    1200 < ... < 144000  from slurpars               ³
&dA &d@³                                                                             ³
&dA &d@³    Output:     bstr bt.2500(250)                                            ³
&dA &d@³                                                                             ³
&dA &d@³    There are also the following outputs:                                    ³
&dA &d@³                                                                             ³
&dA &d@³                int rise                                                     ³
&dA &d@³                int height  number of rows of data                           ³
&dA &d@³                int maxlen  actual length of slur generated                  ³
&dA &d@³                int bulge   the amount of left bulge in a vertical           ³
&dA &d@³                              convex rising, or concave falling slur         ³
&dA &d@³                                                                             ³
&dA &d@³    Calling procedure:  &dCprintslur_screen&d@  We need to do this because         ³
&dA &d@³                        there may be a dotted mask, and because that         ³
&dA &d@³                        procudure writes to the postscript dictionary        ³
&dA &d@³                                                                             ³
&dA &d@³    Procedures called:  &dCcircular&d@  and  &dCasymetric&d@                             ³
&dA &d@³                                                               (possible)    ³
&dA &d@³           Lengths                      Length        Rise       Number      ³
&dA &d@³           in dots                    increments   increments   of types     ³
&dA &d@³         ÄÄÄÄÄÄÄÄÄÄ                   ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄÄÄ   ÄÄÄÄÄÄÄÄ     ³
&dA &d@³&dE  4 to 9  &d@  &dI  8 to 18 &d@  &dA 12 to 27 &d@    &dE1&d@  &dI 2&d@  &dA 3&d@    &dE1&d@   &dI2&d@   &dA2&d@    &dE 6&d@  &dI 6&d@  &dA 6&d@   ³
&dA &d@³&dE 10 to 98 &d@  &dI 20 to 196&d@  &dA 30 to 294&d@    &dE2&d@  &dI 4&d@  &dA 6&d@    &dE1&d@   &dI2&d@   &dA2&d@    &dE12&d@  &dI12&d@  &dA12&d@   ³
&dA &d@³&dE100 to 396&d@  &dI200 to 392&d@  &dA300 to 588&d@    &dE4&d@  &dI 8&d@  &dA12&d@    &dE1&d@   &dI2&d@   &dA2&d@    &dE24&d@  &dI24&d@  &dA24&d@   ³
&dA &d@³            &dI400 to 784&d@                   &dI16&d@            &dI2&d@            &dI48&d@       ³
&dA &d@³                                                                             ³
&dA &d@³                &dE(rise * 2400) + (length * 6)&d@                 &dEmax rise = 58 &d@  ³
&dA &d@³  Slur number = &dI(rise * 1200) + (length * 3)&d@  + type number  &dImax rise = 116&d@  ³
&dA &d@³                &dA(rise * 600) + (length * 2)&d@                  &dAmax rise = 236&d@  ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure construct_bigslur_element (case,nsize,snum,rise,height,maxlen,bulge)
        str out.1000 
        str newout.1000 

        bstr zeros.4500, temp.4500 
        int t1,t2,t3,t4,t5,t6,t7 
        int ii,jj
        int rise,type,length 
        int acc(1200) 
        int version 

        real X,Y,YY 
        real tenX,tenY 

        int xpnt,maxlen 
        int trycnt 
        int toplead(200),toptrail(200) 
        int topdiff(200) 
        str tstr.1000 
        int nsize,snum,case 
        int height,bulge 
        int h2l_ratio 

        table TTT(10000) 

&dA*   I. Set parameters                       

        zeros = zpd(4500) 

        getvalue case,nsize,snum 

        if nsize = 21 
          rise = snum / 1200        /* rem = 0 ... 1199 
          rise *= 2                 /* max is 238 
          if rise = 238 
            rise = 236 
          end 
        else 
          rise = snum / 2400        /* rem = 0 ... 2399  max rise = 59 
          if nsize = 6 
            if rise = 59 
              rise = 58 
            end 
          else 
            rise *= 2               /* max is 118 
            if rise = 118 
              rise = 116 
            end 
          end 
        end 
        snum = rem 
        if nsize = 6 
          length = snum / 6         /* rem = 0 ... 5 
          type = rem 
          if length > 9 
            length = snum / 12      /* rem = 0 ... 11 
            type = rem 
            length *= 2 
            if length > 98 
              length = snum / 24    /* rem = 0 ... 23 
              type = rem 
              length *= 4 
            end 
          end 
        else 
          if nsize < 21 
            length = snum / 6         /* rem = 0 ... 5 
            type = rem 
            length *= 2               /* max = 798 
            if length > 18 
              length = snum / 12      /* rem = 0 ... 11 
              type = rem 
              length *= 4             /* max = 796 
              if length > 196 
                length = snum / 24    /* rem = 0 ... 23 
                type = rem 
                length *= 8           /* max = 792 
                if length > 392 
                  length = snum / 48  /* rem = 0 ... 47 
                  type = rem 
                  length *= 16        /* max = 784 
                end 
              end 
            end 
          else 
            length = snum / 6         /* rem = 0 ... 5 
            type = rem 
            length *= 3               /* max = 597 
            if length > 27 
              length = snum / 12      /* rem = 0 ... 11 
              type = rem 
              length *= 6             /* max = 594 
              if length > 294 
                length = snum / 24    /* rem = 0 ... 23 
                type = rem 
                length *= 12          /* max = 588 
              end 
            end 
          end 
        end 

        if nsize = 6 
          if rise > 31 
            t3 = rise / 2 
            if rem > 0 
              rise += 1 
            end 
          end 
        else 
          if rise > 62 
            t3 = rise / 4 
            if rem > 0 
              rise += 2 
            end 
          end 
        end 
* 

&dA*   III. Beginning of Construction            

        h2l_ratio = rise / length 
        YY = flt(rise) 
        t3 = length - 1 
        X = flt(t3) 

        Y = YY 

  /* Set version and type numbers 

        if nsize = 6 
          if length < 10 
            version = 0              /* circular only 
            if type > 2 
              type -= 2 
            end 
            type += 2                /* type = 2, 3, or 4 
            ++type                   /* &dATemporary "fix"&d@ to accommodate the older slurpar files
          else 
            if length < 60 
              version = 0            /* circular only 
              if type > 5 
                type -= 6 
              end 
              ++type                 /* type = 1, 2, 3, 4, 5, or 6 
              if type < 6 
                ++type               /* &dATemporary "fix"&d@ to accommodate the older slurpar files
              end 
            else 
              if length < 100 
                if type < 6 
                  version = 0          /* circular 
                  ++type               /* type = 1, 2, 3, 4, 5, or 6 
                else 
                  if type < 9 
                    version = 1        /* high right 
                  else 
                    version = 2        /* symmetric 
                  end 
                  t3 = type / 3 
                  if version = 1 
                    rem <<= 1            /* rem = 0, 2, or 4 
                    type = rem + 1       /* type = 2, 4 or 6 
                  else 
                    type = rem + 2       /* type = 2, 3 or 4 
                  end 
                end 
                if type < 6 and version = 0 
                  ++type             /* &dATemporary "fix"&d@ to accommodate the older slurpar files
                end 
              else 
                if length < 200 
                  version = type  / 8  /* version = 0, 1, or 2 
                  type = rem + 1       /* type = 1 -> 8 
                else 
                  if type > 9 
                    type = 9 
                  end 
                  if type < 5 
                    version = 1        /* high right 
                  else 
                    version = 2        /* symmetric 
                  end 
                  t3 = type / 5 
                  type = rem + 2       /* type = 2,3,4,5,6 
                  if type < 6 
                    --type             /* type = 1,2,3,4,6 
                  end 
                end 
                if type < 8 and version = 0 
                  ++type             /* &dATemporary "fix"&d@ to accommodate the older slurpar files
                end 
              end 
            end 
          end 
        else 
          if nsize = 21 
            if length < 30 
              if type > 5              /* only six types 
                type -= 6 
              end 
              version = 0              /* circular only 
              t3 = type / 3 
              type = rem + 2           /* type = 2, 3, 4  (5,6,7) 
              if type > 4 
                type -= 3 
                ++rise 
                Y += 1.0 
              end 
            else 
              if length < 180 
                if type > 5 
                  type -= 6 
                end 
                version = 0            /* circular only 
                t3 = type / 6 
                type = rem + 1         /* type = 1, 2, 3, 4, 5, or 6 
              else 
                if length < 300 
                  if type > 11 
                    type -= 12 
                  end 
                  if type < 6 
                    version = 0          /* circular 
                    t3 = type / 6 
                    type = rem + 1       /* type = 1, 2, 3, 4, 5, or 6 
                  else 
                    if type < 9 
                      version = 1        /* high right 
                    else 
                      version = 2        /* symmetric 
                    end 
                    t3 = type / 3 
                    if version = 1 
                      rem <<= 1            /* rem = 0, 2, or 4 
                      type = rem + 1       /* type = 2, 4 or 6 
                    else 
                      type = rem + 2       /* type = 2, 3 or 4 
                    end 
                  end 
                else 
                  version = type / 8   /* version = 0, 1, or 2 
                  type = rem + 1       /* type = 1 -> 8 
                end 
              end 
            end 
          else 
            if length < 20 
              if type > 5              /* only six types 
                type -= 6 
              end 
              version = 0              /* circular only 
              t3 = type / 3 
              type = rem + 2           /* type = 2, 3, or 4  (5,6,7) 
              if type > 4 
                type -= 3 
                ++rise 
                Y += 1.0 
              end 
              if type < 6 and nsize = 14 
                ++type                 /* &dATemporary "fix"&d@ to accommodate the older slurpar files
              end 
            else 
              if length < 120 
                if type > 5 
                  type -= 6 
                end 
                version = 0            /* circular only 
                t3 = type / 6 
                type = rem + 1         /* type = 1, 2, 3, 4, 5, or 6 
                if type < 6 and nsize = 14 
                  ++type               /* &dATemporary "fix"&d@ to accommodate the older slurpar files
                end 
              else 
                if length < 200 
                  if type > 11 
                    type -= 12 
                  end 
                  if type < 6 
                    version = 0          /* circular 
                    t3 = type / 6 
                    type = rem + 1       /* type = 1, 2, 3, 4, 5, or 6 
                    if type < 6 and nsize = 14 
                      ++type             /* &dATemporary "fix"&d@ to accommodate the older slurpar files
                    end 
                  else 
                    if type < 9 
                      version = 1        /* high right 
                    else 
                      version = 2        /* symmetric 
                    end 
                    t3 = type / 3 
                    if version = 1 
                      rem <<= 1            /* rem = 0, 2, or 4 
                      type = rem + 1       /* type = 2, 4 or 6 
                    else 
                      type = rem + 2       /* type = 2, 3 or 4 
                    end 
                  end 
                else 
                  if length < 400 
                    version = type / 8   /* version = 0, 1, or 2 
                    type = rem + 1       /* type = 1 -> 8 
                  else 
                    if type > 9 
                      type = 9 
                    end 
                    if type < 6 
                      version = 1        /* high right 
                    else 
                      version = 2        /* symmetric 
                    end 
                    t3 = type / 5 
                    type = rem + 2       /* type = 2,3,4,5,6 
                  end 
                  if type < 6 and nsize = 14 and version = 0 
                    ++type               /* &dATemporary "fix"&d@ to accommodate the older slurpar files
                  end 
                end 
              end 
            end 
          end 
        end 
&dA 
&dA &d@   clear slur array 
&dA 
        tenX = X 
        tenY = Y 
        trycnt = 0 
CBE_RETRY: 

        loop for t3 = 1 to 750 
          slmap(t3) = zpd(4500) 
        repeat 

        if version = 0 
          perform circular (tenX,tenY,type,nsize) 
        else 
          perform asymetric (tenX,tenY,type,length,version,nsize)  /* magic 
        end 
&dA 
&dA &d@   determine size of slmap display 
&dA 
        loop for t3 = 1 to 750 
          if slmap(t3) <> zeros 
            goto CBE_CE 
          end 
        repeat 
        pute all Zeros 
        stop 
CBE_CE: 
        y1 = t3 - 1 
        loop for t4 = t3 to 750 
          if slmap(t4) = zeros and slmap(t4+1) = zeros 
            goto CBE_CF 
          end 
        repeat 
CBE_CF: 
        y2 = t4 - 1 
        loop for t4 = 1 to 4500 
          loop for t3 = y1 to y2 
            if slmap(t3){t4} = "1" 
              goto CBE_CH 
            end 
          repeat 
        repeat 
CBE_CH: 
        if nsize = 16 or nsize = 18 
          x1 = t4                      /* try this &dA10-31-04&d@ 
        else 
          x1 = t4 - 1 
        end 
        x2 = 0 
        loop for t3 = y1 to y2 
          temp = trm(slmap(t3)) 
          if x2 < bln(temp) 
            x2 = bln(temp) 
          end 
        repeat 
&dA 
&dA &d@   write slur to screen    (New &dA10-31-04&d@:  writing of slur delayed) 
&dA 
        x2 = x2 - x1 + 3 / 3 * 3        /* x range 
        loop for t3 = y1 to y2 
          slmap(t3) = slmap(t3){x1,x2} 
        repeat 
        t2 = y2 - y1 + 3 / 3 * 3        /* y range 

        t2 = t2 / 3                     /* t2 = number of vert rows 
        t1 = x2 / 3                     /* t1 = number of horiz cols 

        treset [TTT]                    /* New &dA10-31-04&d@ 

        xpnt = 0                        /* New &dA10-31-04&d@ 
        maxlen = 0                      /* New &dA10-31-04&d@ 

        loop for t3 = 1 to t2 
          loop for t5 = 1 to t1 
            acc(t5) = 0                 /* clear accumulators 
          repeat 
          loop for t4 = 1 to 3 
            t7 = 1                      /* t7 = column counter 
            loop for t5 = 1 to t1 
              loop for t6 = 1 to 3 
                if slmap(y1){t7} = "1" 
                  ++acc(t5) 
                end 
                ++t7                    /* advance column 
              repeat 
            repeat 
            ++y1                        /* advance row 
          repeat 
          out = pad(t1) 
          loop for t5 = 1 to t1 
            if acc(t5) > 3 
              out{t5} = "x" 
            end 
          repeat 
          out = trm(out) 

          ii = len(out) 
          if ii > maxlen 
            maxlen = ii 
          end 
&dA 
&dA &d@     New &dA10-31-04&d@:  Slur compaction and writing is delayed 
&dA &d@                    Send output temporarily - TTT table.  
&dA 
          if out = "" and (t3 = 1 or t3 = t2) 
          else 
            newout = out 
            ++xpnt 
            tput [TTT,xpnt] ~newout 
          end 
        repeat 
&dA 
&dA &d@    New Code &dA10-31-04&d@:  If the actual length is different than the requested
&dA &d@                        (planned) length, then adjust tenX and try again.  
&dA 
        if h2l_ratio > 1 
          goto CBE_NO_CHANGE 
        end 

        if trycnt = 0 
          if maxlen > length 
            tenX -= .9 
            --trycnt 
            goto CBE_RETRY 
          end 
          if maxlen < length 
            tenX += .9 
            ++trycnt 
            goto CBE_RETRY 
          end 
        end 
        if trycnt > 0 
          if maxlen < length 
            tenX += .9 
            ++trycnt 
            goto CBE_RETRY 
          end 
        end 
        if trycnt < 0 
          if maxlen > length 
            tenX -= .9 
            if tenX < 0.0 
              tenX = 0.0 
              trycnt = 1000 
            end 
            --trycnt 
            goto CBE_RETRY 
          end 
        end 
&dA 
&dA &d@     New Code &dA10-31-04&d@:  Make adjustments to slur shape (important code) 
&dA 
        if rise > 3 * length / 2 
          goto CBE_NO_CHANGE 
        end 

        loop for t3 = 1 to 200 
          toplead(t3)     = 0 
          toptrail(t3)    = 1000 
        repeat 

        loop for t3 = 1 to xpnt 
          tget [TTT,t3] out 
          tstr = mrt(out) 
          toplead(xpnt - t3 + 1) = len(out) - len(tstr) + 1 
          tstr = trm(out) 
          if t3 = 1 
            t4 = len(tstr) 
          end 
          t5 = len(tstr) 
          if t5 >= t4 
            toptrail(xpnt - t3 + 1) = t5 
          end 
        repeat 
&dA 
&dA &d@   1. Fix top of slur 
&dA 
        if toptrail(xpnt-1) < 1000 
          t4 = toptrail(xpnt) - toplead(xpnt) + 1 
          t5 = toptrail(xpnt-1) - toplead(xpnt-1) + 1 

          loop while t4 <= (2 * t5 / 5) 
            ++toptrail(xpnt) 
            --toplead(xpnt) 
            t4 += 2 
          repeat 
          tget [TTT,1] out 
          out = out // pad(999) 

          t5 = toplead(xpnt) 
          loop while out{t5} = " " 
            out{t5} = "x" 
            ++t5 
          repeat 
          loop while t5 <= toptrail(xpnt) 
            if out{t5} = " " 
              out{t5} = "x" 
            end 
            ++t5 
          repeat 
          out = out{1,length} 
          out = trm(out) 

          tput [TTT,1] ~out 
        end 
&dA 
&dA &d@   2. Fix outside rising part of slur (left side) 
&dA 
        loop for t3 = 1 to xpnt - 1 
          t4 = toplead(t3) 
          t5 = toplead(t3+1) 
          topdiff(t3) = t5 - t4 
        repeat 

        loop for t3 = 1 to xpnt - 4 
          if topdiff(t3) <> topdiff(t3+1) 
            t5 = topdiff(t3) + topdiff(t3+1) 
            t5 = t5 / 2 
            t4 = rem 
            topdiff(t3) = t5 
            topdiff(t3+1) = t5 
            if t4 = 1 
              ++topdiff(t3+1) 
            end 
            if t3 < xpnt - 5 
              ++t3 
            end 
          end 
        repeat 

        loop for t3 = 1 to xpnt - 4 
          if topdiff(t3) > topdiff(t3+1) + 1 
            --topdiff(t3) 
            ++topdiff(t3+1) 
          end 
        repeat 

        loop for t3 = 1 to xpnt - 1 
          toplead(t3+1) = toplead(t3) + topdiff(t3) 
        repeat 
        loop for t3 = 1 to xpnt 
          t4 = xpnt + 1 - t3 
          tget [TTT,t4] out 
          t5 = toplead(t3) 
          if t5 > 1 and t5 <= len(out) 
            out{1,t5-1} = pad(t5-1) 
            loop while out{t5} = " " 
              out{t5} = "x" 
              ++t5 
            repeat 
          end 
          tput [TTT,t4] ~out 
        repeat 
&dA 
&dA &d@   3. Fix outside decending side (right side) 
&dA 
        loop for t3 = 1 to xpnt - 1 
          t4 = toptrail(t3) 
          t5 = toptrail(t3+1) 
          if t5 < 1000 and t4 < 1000 
            topdiff(t3) = t4 - t5 
          else 
            topdiff(t3) = 1000 
          end 
        repeat 

        loop for t3 = 1 to xpnt - 4 
          if topdiff(t3) < 1000 
            if topdiff(t3) <> topdiff(t3+1) 
              t5 = topdiff(t3) + topdiff(t3+1) 
              t5 = t5 / 2 
              t4 = rem 
              topdiff(t3) = t5 
              topdiff(t3+1) = t5 
              if t4 = 1 
                ++topdiff(t3+1) 
              end 
              if t3 < xpnt - 5 
                ++t3 
              end 
            end 
          end 
        repeat 

        loop for t3 = 1 to xpnt - 4 
          if topdiff(t3) < 1000 
            if topdiff(t3) > topdiff(t3+1) + 1 
              --topdiff(t3) 
              ++topdiff(t3+1) 
            end 
          end 
        repeat 

        loop for t3 = xpnt - 1 to 1 step -1 
          if topdiff(t3) < 1000 
            toptrail(t3) = toptrail(t3+1) + topdiff(t3) 
          end 
        repeat 

        loop for t4 = 1 to xpnt 
          tget [TTT,t4] out 
          t5 = toptrail(xpnt + 1 - t4) 
          if t5 < 1000 
            out = out // pad(999) 
            if out{t5} = " " 
              out{t5} = "x" 
              if out{t5-1} = " " 
                out{t5-1} = "x" 
                if out{t5-2} = " " 
                  out{t5-2} = "x" 
                  if out{t5-3} = " " 
                    out{t5-3} = "x" 
                  end 
                end 
              end 
            end 
            if out{t5+1} = "x" 
              out{t5+1} = " " 
            end 
            if out{t5+2} = "x" 
              out{t5+2} = " " 
            end 
            if out{t5+3} = "x" 
              out{t5+3} = " " 
            end 
            out = trm(out) 
          end 

          tput [TTT,t4] ~out 
        repeat 

CBE_NO_CHANGE: 

&dA 
&dA &d@  Here is where the slur is processed 
&dA 
&dA &d@   4. Store slur in bstr bt.2500(250) 
&dA 
        if case < 3 
          jj = 1 
        else 
          jj = xpnt 
        end 
        loop for t4 = 1 to xpnt 
          tget [TTT,t4] out 
          out = out // pad(length) 
          out = out{1,length} 
          if case = 2 or case = 3 
            out = rev(out) 
          end 
          bt(jj) = pak(out) 
          if case < 3 
            ++jj 
          else 
            --jj 
          end 
        repeat 
&dA 
&dA &d@   5. Now display the slur on the screen 
&dA 
        height = xpnt 
        passback rise,height,maxlen,bulge 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 31. circular (X,Y,type,nsize)                                        ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Operation:  Construct a circular type slur of length X and rise Y   ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Inputs:     real X          length                                  ³ 
&dA &d@³                real Y          rise                                    ³ 
&dA &d@³                int  type       curvature                               ³ 
&dA &d@³                int  nsize      [6,14,16,18,21]                         ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Output:     bstr slmap.4500(750)                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure circular (X,Y,type,nsize) 
        real X,Y 
        real treal1,treal2
        int cir_leng 
        int t1,t2,t3,t4,t5 
        int type,nsize 
        int pc,pd,pe,pf,pg
        int scnt 
        real delta,alpha,beta
        real x,y,L,H,Cx,Cy,R,D
        real z,aa,bb,cc 
        real xx 
        real inpx,outpx,inpy,outpy,ind,outd 
        real sx(6000),sy(6000) 
        real flpd,flpc 

        getvalue X,Y,type,nsize 
&dA 
&dA &d@   compute R,L,H,Cx,Cy,beta 
&dA 
&dA &d@   1. L = (X*X + Y*Y)^1/2 
&dA 
        x = X * X 
        y = Y * Y 
        xx = x + y 
        L = sqt(xx) 
        cir_leng = fix(L) 
&dA 
&dA &d@   2. H:  Find smallest t1 such that L < slpara(type,t1+1).   H = flt(t1) 
&dA 
        if nsize = 6 
          treal1 = 2.33   /*  14 / 6 
          treal2 = 1.0 
        else                            /*  14: 2.0          14 / 7 
          treal1 = 14.0 / flt(nsize)    /*  16: 2.2857       16 / 7 
          treal2 = flt(nsize) / 7.0     /*  18: 2.5714       18 / 7 
        end                             /*  21; 3.0          21 / 7 

        loop for t1 = 1 to 55 
          if slpara(type,t1) > L * treal1    /* Factors added for different sizes
            if t1 = 1 
              H = 1.0 
            else 
              if t1 = 2 
                x = 1.0 
                y = 1.8 
              else 
                x = flt(t1-1) 
                x -= .2 
                y = x + 1.0 
              end 
              aa = L * treal1 - slpara(type,t1-1) 
              bb = slpara(type,t1) - (L * treal1)      /* Factor added
              cc = slpara(type,t1) - slpara(type,t1-1) 
              aa /= cc 
              bb /= cc 
              H = (x * bb) + (y * aa) 

              H /= treal1        /* Factor added.  Now correct H 
              if H < 1.0 
                H = 1.0 
              end 

            end 
            goto CBE_CAA 
          end 
        repeat 
&dA 
&dA &d@   3. R = L*L/H/8 + H/2 
&dA 
CBE_CAA: 
        x = xx / H / 8.0 
        y = H / 2.0 
        R = x + y 
&dA 
&dA &d@   4. Cx = X/2 + Y*(R - H)/L 
&dA 
        z = R - H / L 
        y = Y * z 
        Cx = X / 2.0 + y 
&dA 
&dA &d@   5. Cy = Y/2 - X*(R - H)/L 
&dA 
        x = X * z 
        Cy = Y / 2.0 - x 
&dA 
&dA &d@   6. beta = 2 * sin-1(L/2/R) 
&dA 
        x = L / 2.0 / R 
        beta = 2.0 * ars(x) 
&dA 
&dA &d@   normalize D-function 
&dA 
        xx = L / treal2       /* &dA04-25-95&d@   changed from L / 2.0 
        D = sqt(xx) / 4.8 
        if D > 1.50 
          D -= .16         /* radical 
          if H / L > .200     /* &dA10-28-94&d@   This is a ratio; no change.  
            D -= .10 
          end 
        end 
        if D > 1.70 
          D = D - 1.70 * .2 + 1.70 
        end 
        if D > 1.95 
          D = D - 1.95 * .3 + 1.95 
        end 
        D /= treal1           /* &dA04-25-95&d@    Correction to D 

        if nsize > 14 
          if D > 2.0 
            D = D - 2.00 * .5 + 2.00  /* &dA05-16-95&d@    added to thin out the circular slurs
          end 
          if D < .9 
            D = .9 
          end 
        else 
          if nsize < 14 
            if D < .4 
              D = .4 
            end 
          end 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P            ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

        delta = beta / 4.0 / L         /* four samples per dot 
        alpha = 0.0 
        scnt = 0 

        loop while alpha < beta 
          ++scnt 
&dA 
&dA &d@   1. compute bb = sin(alpha), aa = 1 - cos(alpha) 
&dA 
          bb = sin(alpha) 
          aa = 1.0 - cos(alpha) 
&dA 
&dA &d@   2. compute (x,y) 
&dA 
          cc = Cy * bb 
          sx(scnt) = Cx * aa - cc 
          cc = Cx * bb 
          sy(scnt) = Cy * aa + cc 
&dA 
&dA &d@   3. increment alpha 
&dA 
          alpha += delta 
        repeat
        ++scnt 
        sx(scnt) = X 
        sy(scnt) = Y 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³  E N D   O F   S W E E P.    C O N S T R U C T   S L U R     ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

        if cir_leng < 200 
          if nsize < 16 
            pc = 14 * scnt / 100         /* left hand side of slur 
            pd = 42 * scnt / 1000        /* extreme left end 
            pe = 86 * scnt / 100         /* right hand side of slur 
            pf = 958 * scnt / 1000       /* extreme right end 
          else 
            if nsize < 21 
              pc = 11 * scnt / 100       /* left hand side of slur 
              pd = 33 * scnt / 1000      /* extreme left end 
              pe = 89 * scnt / 100       /* right hand side of slur 
              pf = 967 * scnt / 1000     /* extreme right end 
            else 
              pc = 12 * scnt / 100       /* left hand side of slur 
              pd = 100 * scnt / 1000     /* extreme left end 
              pe = 88 * scnt / 100       /* right hand side of slur 
              pf = 900 * scnt / 1000     /* extreme right end 
            end 
          end 
        else 
          if nsize < 16 
            t1 = 1000 - cir_leng         /* 800 times too big 
            pc = 14 * t1 
            pd = 42 * t1 
            pe = 80000 - pc 
            pf = 800000 - pd 
            pc = pc * scnt / 80000       /* left hand side of slur 
            pd = pd * scnt / 800000      /* extreme left end 
            pe = pe * scnt / 80000       /* right hand side of slur 
            pf = pf * scnt / 800000      /* extreme right end 
          else 
            pc = cir_leng * 100 / (cir_leng + 600) /* left hand side of slur
            pd = pc * 3 / 10                       /* extreme left end 
            pe = scnt - pc                         /* right hand side of slur
            pf = scnt - pd                         /* extreme right end 
          end 
        end 
        flpd = flt(pd) 
        flpc = flt(pc) 

        loop for t1 = 1 to scnt 
          x = sx(t1) 
          y = sy(t1) 
&dA 
&dA &d@   1. compute ind, outd 
&dA 
          if nsize < 16 
            if t1 < pc                   /* left hand side of slur 
              ind = 0.0 
              if t1 < pd                 /* extreme left end 
                if flpc = 0.0 
                  outd = .4                        /* &dEwas .1&d@ 
                else 
                  outd = flt(t1) / flpc + .4       /* &dEwas .1&d@ 
                end 
              else 
                outd = .4 
              end 
              goto CBE_CCD 
            end 
            if t1 > pe                   /* right hand side of slur 
              ind = 0.0 
              if t1 >= pf                /* extreme right end 
                t2 = scnt - t1 
                if flpc = 0.0 
                  outd = .4                        /* &dEwas .1&d@ 
                else 
                  outd = flt(t2) / flpc + .4       /* &dEwas .1&d@ 
                end 
              else 
                outd = 0.4 
              end 
              goto CBE_CCD 
            end 
          else 
            if nsize = 16 
              if t1 < pc                   /* left hand side of slur 
                ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                if t1 < pd                 /* extreme left end 
                  outd = .2 * flt(t1) / flpd + .0 
                else 
                  outd = .2 
                end 
                goto CBE_CCD 
              end 
              if t1 > pe                   /* right hand side of slur 
                ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                if t1 >= pf                /* extreme right end 
                  t2 = scnt - t1 
                  if flpd > 0.0 
                    outd = 0.2 * flt(t2) / flpd + .0 
                  else 
                    outd = 0.2 
                  end 
                else 
                  outd = 0.2 
                end 
                goto CBE_CCD 
              end 
            else 
              if nsize = 18 
                if t1 < pc                   /* left hand side of slur 
                  ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                  if t1 < pd                 /* extreme left end 
                    outd = .4 * flt(t1) / flpd + .3 
                  else 
                    outd = .7 
                  end 
                  goto CBE_CCD 
                end 
                if t1 > pe                   /* right hand side of slur 
                  ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                  if t1 >= pf                /* extreme right end 
                    t2 = scnt - t1 
                    if flpd > 0.0 
                      outd = 0.4 * flt(t2) / flpd + .3 
                    else 
                      outd = 0.7 
                    end 
                  else 
                    outd = 0.7 
                  end 
                  goto CBE_CCD 
                end 
              else 
                if t1 < pc                   /* left hand side of slur 
                  ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                  if t1 < pd                 /* extreme left end 
                    outd = .3 * flt(t1) / flpd + .0 
                  else 
                    outd = .3 
                  end 
                  outd -= .1 
                  goto CBE_CCD 
                end 
                if t1 > pe                   /* right hand side of slur 
                  ind = 0.7                  /* &dA05-13-95&d@  changed from 1.3 
                  if t1 >= pf                /* extreme right end 
                    t2 = scnt - t1 
                    outd = 0.3 * flt(t2) / flpd + .0 
                  else 
                    outd = 0.3 
                  end 
                  outd -= .1 
                  goto CBE_CCD 
                end 
              end 
            end 
          end 

    /* middle of slur 
          if t1 > scnt / 2             /* right side 
            t2 = pe - t1 
          else                         /* left side 
            t2 = t1 - pc 
          end 
          t5 = scnt / 2 - pc 
          bb = flt(t2) * ars(1.0) / flt(t5)  /* max(bb) = sin-1(1) 
          aa = sin(bb) 
          if nsize < 16 
            outd = D - 0.4 * aa + 0.4     
            ind = aa * D 
          else 
            if nsize = 16 
              outd = D - 0.1 * aa + 0.2 
            else 
              if nsize = 18 
                outd = D - 0.7 * aa + 0.7 
              else 
                outd = D - 0.2 * aa + 0.2 
              end 
            end 
            ind = D - 0.7 * aa + 0.7 
          end 
&dA 
&dA &d@   2. compute outside point, inside point 
&dA 
CBE_CCD: 
          if nsize > 10 
            if nsize < 15 
              outd += .49000            /* &dEwas .29000&d@ 
              ind  += .49000            /* &dEwas .29000&d@ 
            else 
              if nsize = 16 
                outd += 0.50000 
                ind  += 0.30000 
              else 
                if nsize = 18 
                  outd += 0.90000 
                  ind  += 0.90000 
                else 
                  outd += 0.99000 
                  ind  += 0.99000 
                end 
              end 
            end 
          else 
            outd += .19000 
            ind  += .19000 
          end 

          aa = x - Cx * outd / R 
          bb = y - Cy * outd / R 
          outpx = x + aa 
          outpy = y + bb 
          aa = x - Cx * ind / R 
          bb = y - Cy * ind / R 
          inpx = x - aa 
          inpy = y - bb 
&dA 
&dA &d@   3. compute box coordinates 
&dA 
          if outpx < inpx 
            aa = outpx 
            outpx = inpx 
            inpx = aa 
          end 
          if outpy < inpy 
            aa = outpy 
            outpy = inpy 
            inpy = aa 
          end 
          outpx = outpx + 30.0 * 3. - .5 
          inpx  = inpx  + 30.0 * 3. - .5 
          outpy = outpy + 20.0 * 3. - .5 
          inpy  = inpy  + 20.0 * 3. - .5 
          if nsize < 16 
            inpx -= .5 
            outpx -= .5 
          end 
          x1 = fix(inpx) 
          x2 = fix(outpx) 
          y1 = fix(inpy) 
          y2 = fix(outpy) 
          if x2 - x1 < 2 
            ++y2                  /* radical 
          end 
&dA 
&dA &d@   4. set points inside box to 1 (with inverted vertical axis) 
&dA 
          if x1 < 1                    /* New code &dA10-31-04&d@ 
            x1 = 1                     /* New code &dA10-31-04&d@ 
          end                          /* New code &dA10-31-04&d@ 
          loop for t2 = y1 to y2 
            t4 = 750 - t2 
            loop for t3 = x1 to x2 
              slmap(t4){t3} = "1" 
            repeat 
          repeat 
        repeat 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 32. asymetric (X,Y,type,length,version,nsize)                        ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Operation:  Construct a three curve slur of length X and rise Y     ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Inputs:     real X          length                                  ³ 
&dA &d@³                real Y          rise                                    ³ 
&dA &d@³                int  type       curvature                               ³ 
&dA &d@³                int  length     integer length (for setting height)     ³ 
&dA &d@³                int  version    1 = symmetric, 2 = asymmetric           ³ 
&dA &d@³                int  nsize      [6,14,16,18,21]                         ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Output:     bstr slmap.4500(750)                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure asymetric (X,Y,type,length,version,nsize) 
        real X,Y 
        real PP, QQ 
        real rtype 
        real treal1
        real delta,alpha,beta,delta2,beta2 
        real x,y,L,H,Cx,Cy,R,D
        real W,Q,P,A,B,Ca,Cb 
        real aa,bb,cc 
        real xx,yy,u,v 
        real inpx,outpx,inpy,outpy,ind,outd 
        real sx(6000),sy(6000) 
        real flpd,flpf 

        int truelen 
        int t1,t2,t3,t4,t5 
        int type,length,version,nsize 
        int pc,pd,pe,pf,pg,ph 
        int scnt 

        getvalue X,Y,type,length,version,nsize 
        if nsize = 6 
          treal1 = 2.0    /*  14 / 7 
        else                            /*  14: 2.0          14 / 7 
          treal1 = 14.0 / flt(nsize)    /*  16: 2.2857       16 / 7 
        end                             /*  21; 3.0          21 / 7 

        X *= treal1               /* &dA04-25-95&d@  all computations done 
        Y *= treal1               /* at original size.  
        truelen = length * 14 / nsize 

        rtype = flt(type) 
        L = flt(truelen)           
        if truelen < 600          
          H = L * .03  + (1.9 * rtype)  + 7.1     /* &dA05-16-95&d@   was + 7.1 (types shifted by 1)
        else 
          H = 25.1  + (1.9 * rtype)               /* &dA05-16-95&d@   was 27.0  (types shifted by 1)
        end 
        rtype -= 1.0 

        L = X * X + (Y * Y) 
        L = sqt(L) 

        aa = rtype / 75.  
        W = L * (.66 - aa)  /* experimental value 
&dA 
&dA &d@   compute R, P, A, B, Cx, Cy, Ca, Cb and check limitations 
&dA 
&dA &d@   1. Q:  
&dA 
        if length > 300 
          Q = 15.0 
        else 
          Q = 13.0 
        end 
CBE_PAA: 

&dA 
&dA &d@   2. R = L*L/Q/8 + Q/2 
&dA &d@                        
        x = L * L / Q / 8.0 
        y = Q / 2.0 
        R = x + y 
&dA 
&dA &d@   3. P = R - (R*R - (W*W/4))^1/2  component of height from 
&dA &d@                                      middle section 
        x = (R * R) - (W * W / 4.0) 
        P = R - sqt(x) 
        y = (L - W) / 2.0 + P 
        if H > y 
          H = y 
        end 
        if H < Q 
          H = dec(Q) + .5 
        end 
&dA 
&dA &d@   4. A = (L - W) / 2  B = H - P   <A,B> = transition point 
&dA 
        A = (L - W) / 2.0 
        B = H - P 
&dA 
&dA &d@   5. Cx = X/2  Cy = R - H       <Cx,Cy> = center of main arc 
&dA 
        Cx = L / 2.0 
        Cy = H - R                  /* a negative number 
&dA 
&dA &d@   6. Compute  <Ca,Cb> = center of starting arc 
&dA 
&dA &d@           [ B*(Cx-A)/(Cy-B) + (A*A + B*B)/2/A - A ] 
&dA &d@      Cb = ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@                   [ B/A + (Cx-A)/(Cy-B) ] 
&dA 
&dA &d@      Ca = (A*A + B*B)/2/A - B*(Cb)/ A 
&dA 
        aa = (Cx - A) / (Cy - B) 
        bb = (A * A) + (B * B) 
        bb = bb / 2.0 / A 

        Cb = (B * aa + bb - A) / (B / A + aa) 

        Ca = bb - (B * Cb / A) 
&dA 
&dA &d@   normalize D-function 
&dA 
        xx = L / 2.0
        D = sqt(xx) / 4.8 
        if D > 1.50 
          D -= .16         /* radical 
          if H / L > .200 
            D -= .10 
          end 
        end 
        if D > 1.70 
          D = D - 1.70 * .2 + 1.70 
        end 
        if D > 1.95 
          D = D - 1.95 * .3 + 1.95 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   1        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@                              º   sqt(A*A + B*B)    º 
&dA &d@   1. compute beta = 2 * sin-1ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº  sweep angle 
&dA &d@                              º 2*sqt(Ca*Ca + Cb*Cb)º 
&dA 
        aa = A * A + (B * B) 
        bb = Ca * Ca + (Cb * Cb) 

        cc = sqt(bb) 
        beta = rtype / 7.5 

        if L >= 400.  
          delta = L * .001                  
        else                                
          delta = L * .006 - 2.00           
        end                                 

        if R / cc > 3.00 - beta + delta 
          Q += .1 
          if Q < H - .5 
            goto CBE_PAA 
          end 
        end 

        cc = sqt(aa/bb) 

        beta = 2.0 * ars(cc/2.0) 
&dA 
&dA &d@   2. compute delta so that sweep hits every one-third dot 
&dA 
        aa = sqt(aa) * 3.0      /* thrice length of arc (approx) 
        delta = beta / aa 
        scnt = 0 
        alpha = 0.0 
&dA 
&dA &d@   3. begin sweep 
&dA 
CBE_SW1A: 
        aa = 1.0 - cos(alpha) 
        bb = sin(alpha) 

        x = Ca * aa - (Cb * bb) 
        y = Ca * bb + (Cb * aa) 
        if x < A 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha += delta 
          goto CBE_SW1A 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   2        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. compute beta2 = sin-1{ [(L/2)-A] / R } 
&dA 
        aa = L / 2.0 - A / R 
        beta2 = ars(aa) 
&dA 
&dA &d@   2. compute delta so that sweep hits every one-third dot 
&dA 
        delta2 = beta2 * 2.0 / 3.0 / W 
        alpha = 0.0 - beta2 
&dA 
&dA &d@   3. begin sweep 
&dA 
CBE_SW2A: 
        x = R * sin(alpha) + Cx 
        y = R * cos(alpha) + Cy 
        if x < L - A 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha += delta2 
          goto CBE_SW2A 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   3        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. beta and delta already computed 
&dA 
        alpha = beta 
&dA 
&dA &d@   2. begin sweep 
&dA 
CBE_SW3A: 
        aa = 1.0 - cos(alpha) 
        bb = sin(alpha) 

        x = L - (Ca * aa) + (Cb * bb) 
        y = Ca * bb + (Cb * aa) 
        if x < L 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha -= delta 
          goto CBE_SW3A 
        end 
        ++scnt 
        sx(scnt) = L 
        sy(scnt) = 0.0 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³  E N D   O F   S W E E P S.    C O N S T R U C T   S L U R   ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. rotate data to produce rise 
&dA 
        aa = X / L 
        bb = Y / L 
        loop for t1 = 1 to scnt 
          x = sx(t1) * aa - (sy(t1) * bb) 
          y = sx(t1) * bb + (sy(t1) * aa) 
          sx(t1) = x 
          sy(t1) = y 
        repeat 
&dA 
&dA &d@   2. setup thickness parameters 
&dA 
        if length < 200 
          if nsize < 21 
            pc = 12 * scnt / 100         /* left hand side of slur 
            pd = 36 * scnt / 1000        /* extreme left end 
            pe = 88 * scnt / 100         /* right hand side of slur 
            pf = 964 * scnt / 1000       /* extreme right end 
            if version = 1 
              pe = 93 * scnt / 100 
              pf = 979 * scnt / 1000 
            end 
          else 
            pc = 12 * scnt / 100         /* left hand side of slur 
            pd = 80 * scnt / 1000        /* extreme left end 
            pe = 88 * scnt / 100         /* right hand side of slur 
            pf = 930 * scnt / 1000       /* extreme right end 
            if version = 1 
              pe = 93 * scnt / 100 
              pf = 950 * scnt / 1000 
            end 
          end 
        else 
          if nsize < 16 
            t1 = 1000 - length           /* 800 times too big 
            pc = 10 * t1 
            pd = 30 * t1 
            pe = 80000 - pc 
            pf = 800000 - pd 
            pc = pc * scnt / 80000       /* left hand side of slur 
            pd = pd * scnt / 800000      /* extreme left end 
            pe = pe * scnt / 80000       /* right hand side of slur 
            pf = pf * scnt / 800000      /* extreme right end 
            if version = 1 
              pe = 80000 - (6 * t1) 
              pf = 800000 - (18 * t1) 
              pe = pe * scnt / 80000       /* right hand side of slur 
              pf = pf * scnt / 800000      /* extreme right end 
            end 
          else 
            if nsize < 21 
              pc = length * 90 / (length + 600)    /* left hand side of slur
              pd = pc * 3 / 10                     /* extreme left end 
              pe = scnt - pc                       /* right hand side of slur
              pf = scnt - pd                       /* extreme right end 
              if version = 1 
                pe = scnt - (pc * 6 / 10) 
                pf = scnt - (pd * 6 / 10) 
              end 
            else 
              pc = length * 90 / (length + 600)    /* left hand side of slur
              pd = pc * 8 / 10                     /* extreme left end 
              pe = scnt - pc                       /* right hand side of slur
              pf = scnt - pd                       /* extreme right end 
              if version = 1 
                pe = scnt - (pc * 8 / 10) 
                pf = scnt - (pd * 8 / 10) 
              end 
            end 
          end 
        end 
        flpd = flt(pd) 
        flpf = flt(scnt - pf) 

        if version = 1 
          pg = 53 * scnt / 100 
        end 
        if version = 2 
          pg = 50 * scnt / 100         /* make asym left slurs fat in middle 
        end 

        if length < 400 
          ph = 0 
        else 
          ph = (length - 400) * scnt * 4 / 40000 
        end 
&dA 
&dA &d@   3. compute ind, outd 
&dA 
        loop for t1 = 1 to scnt 
          if nsize < 16 
            if t1 < pc                   /* left hand side of slur 
              ind = 0.0 
              if t1 < pd                 /* extreme left end 
                outd = flt(t1) / flt(pc) + .1 
              else 
                outd = .4 
              end 
              goto CBE_PCD 
            end 
            if t1 > pe                   /* right hand side of slur 
              ind = 0.0 
              if t1 >= pf                /* extreme right end 
                t2 = scnt - t1 
                outd = flt(t2) / flt(pc) + .1 
              else 
                outd = 0.4 
              end 
              goto CBE_PCD 
            end 
          else 
            if nsize = 16 
              if t1 < pc                    
                ind = 0.6                  
                if t1 < pd                  
                  outd = .4 * flt(t1) / flpd + .0 
                else 
                  outd = .4 
                end 
                goto CBE_PCD 
              end 
              if t1 > pe                    
                ind = 0.6                  
                if t1 >= pf                 
                  t2 = scnt - t1 
                  outd = 0.4 * flt(t2) / flpf + .0 
                else 
                  outd = 0.4 
                end 
                goto CBE_PCD 
              end 
            else 
              if nsize = 18 
                if t1 < pc                    
                  ind = 0.6                  
                  if t1 < pd                  
                    outd = .4 * flt(t1) / flpd + .3 
                  else 
                    outd = .7 
                  end 
                  goto CBE_PCD 
                end 
                if t1 > pe                    
                  ind = 0.6                  
                  if t1 >= pf                 
                    t2 = scnt - t1 
                    outd = 0.4 * flt(t2) / flpf + .3 
                  else 
                    outd = 0.7 
                  end 
                  goto CBE_PCD 
                end 
              else 
                if t1 < pc                    
                  ind = 0.6                  
                  if t1 < pd                  
                    outd = .3 * flt(t1) / flpd + .0 
                  else 
                    outd = .3 
                  end 
                  outd -= .1 
                  goto CBE_PCD 
                end 
                if t1 > pe                    
                  ind = 0.6                  
                  if t1 >= pf                 
                    t2 = scnt - t1 
                    outd = 0.3 * flt(t2) / flpf + .0 
                  else 
                    outd = 0.3 
                  end 
                  outd -= .1 
                  goto CBE_PCD 
                end 
              end 
            end 
          end 

    /* middle of slur 
          if t1 > pg + ph              /* right side 
            t2 = pe - t1 
            t5 = pe - pg - ph 
          else                         /* left side 
            if t1 < pg - ph 
              t2 = t1 - pc 
              t5 = pg - pc - ph 
            else 
              t5 = 10000 
              t2 = 9999 
            end 
          end 
          bb = flt(t2) * ars(1.0) / flt(t5)  /* max(bb) = sin-1(1) 
          aa = sin(bb) 
          if nsize < 16 
            outd = D - 0.4 * aa + 0.4 
            ind = aa * D 
          else 
            if nsize = 16 
              outd = D - 0.1 * aa + 0.4 
              ind = D - 0.6 * aa + 0.6 
            else 
              if nsize = 18 
                outd = D - 0.7 * aa + 0.7 
                ind = D - 0.6 * aa + 0.6 
              else 
                outd = D - 0.2 * aa + 0.2 
                ind = D - 0.6 * aa + 0.6 
              end 
            end 
          end 
&dA 
&dA &d@   4. compute outside point, inside point 
&dA 
CBE_PCD: 
          if nsize > 10 
            if nsize < 18 
              outd += 0.29000 
              ind  += 0.29000 
            else 
              if nsize = 18 
                outd += 0.69000 
                ind  += 0.79000 
              else 
                outd += 0.45000 
                ind  += 0.59000 
              end 
            end 
          else 
            outd += 0.10000 
            ind  += 0.10000 
          end 
  
          x = sx(t1) 
&dA 
&dA &d@   asymetric weighting for y 
&dA 
          if type < 3 
            cc = flt(scnt-1) 
            if version = 1 
              aa =  .9  * flt(scnt-t1) / cc 
              bb = 1.05 * flt(t1-1) / cc 
              y = sy(t1) * (aa + bb) 
              y = y - (.05 * Y * flt(t1-1) / cc) 
            else 
              y = sy(t1) 
            end 
          else 
            if type < 5          /* types 3 and 4 have reduced asymmetry 
              cc = flt(scnt-1) 
              if version = 1 
                aa =  .92 * flt(scnt-t1) / cc 
                bb = 1.04 * flt(t1-1) / cc 
                y = sy(t1) * (aa + bb) 
                y = y - (.04 * Y * flt(t1-1) / cc) 
              else 
                y = sy(t1) 
              end 
            else 
              if type < 7    /* types 5 and 6 have further reduced asymmetry 
                cc = flt(scnt-1) 
                if version = 1 
                  aa =  .96 * flt(scnt-t1) / cc 
                  bb = 1.02 * flt(t1-1) / cc 
                  y = sy(t1) * (aa + bb) 
                  y = y - (.02 * Y * flt(t1-1) / cc) 
                else 
                  y = sy(t1) 
                end 
              else 
                y = sy(t1)      /* types 7 and 8 are not asymmetric 
              end 
            end 
          end 
&dA 
&dA &d@   give finite width to slur 
&dA 
          if t1 < scnt 
            u = sx(t1+1) 
            v = sy(t1+1) 
          else 
            u = x 
            v = y 
          end 
          if t1 > 1 
            xx = sx(t1-1) 
            yy = sy(t1-1) 
          else 
            xx = x 
            yy = y 
          end 
          u -= xx          /* delta x 
          v -= yy          /* delta y 
          cc = u * u + (v * v) 
          cc = sqt(cc)       /* delta hypotinus 
          aa = outd / cc 
          bb = ind / cc 
          outpx = x - (aa * v) 
          outpy = y + (aa * u) 
          inpx  = x + (bb * v) 
          inpy  = y - (bb * u) 
&dA 
&dA &d@   5. compute box coordinates 
&dA 
          if outpx < inpx 
            aa = outpx 
            outpx = inpx 
            inpx = aa 
          end 
          if outpy < inpy 
            aa = outpy 
            outpy = inpy 
            inpy = aa 
          end 
          outpx = outpx + 30.0 * 3. - .5 
          inpx  = inpx  + 30.0 * 3. - .5 
          outpy = outpy + 20.0 * 3. - .5 
          inpy  = inpy  + 20.0 * 3. - .5 
          x1 = fix(inpx) 
          x2 = fix(outpx) 
          y1 = fix(inpy) 
          y2 = fix(outpy) 
          if nsize = 6 
            x1 -= 1 
            y2 += 2 
          end 
          if nsize < 16 
            if x2 - x1 < 2 
              ++y2                /* radical 
            end 
          end 
&dA 
&dA &d@   6. set points inside box to 1 (with inverted vertical axis) 
&dA 
&dA &d@     Here is where you scale the size of the slur
&dA 
          if nsize = 6 
            x1 >>= 1 
            x2 >>= 1 
            y1 >>= 1 
            y2 >>= 1 
          end 
          if nsize > 14 
            x1 = x1 * nsize / 14 
            x2 = x2 * nsize / 14 
            y1 = y1 * nsize / 14 
            y2 = y2 * nsize / 14 
          end 
          loop for t2 = y1 to y2 
            t4 = 750 - t2 
            loop for t3 = x1 to x2 
              slmap(t4){t3} = "1" 
            repeat 
          repeat 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 33. make_longslur (length,rise,smode)                                ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Operation:  Construct a three curve longslur                        ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Inputs:     real X          length                                  ³ 
&dA &d@³                real Y          rise                                    ³ 
&dA &d@³                int  type       curvature                               ³ 
&dA &d@³                int  length     integer length (for setting height)     ³ 
&dA &d@³                int  version    1 = symmetric, 2 = asymmetric           ³ 
&dA &d@³                int  nsize      [6,14,16,18,21]                         ³ 
&dA &d@³                                                                        ³ 
&dA &d@³    Output:     bstr slmap.4500(750)                                    ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 

#define MAPZ        2500 

      procedure make_longslur (length,rise,smode) 
        str out.MAPZ 
        str map.MAPZ(250),zeros.MAPZ 
        bstr temp.MAPZ 

        int t1,t2,t3,t4,t5
        int x1,x2,y1,y2 
        int length,rise,smode 
        int pc,pd,pe,pf,pg,ph 
        int scnt 

        real delta,alpha,beta,delta2,beta2 
        real X,x,Y,y,z,Cx,Cy,R,L,H,D,W,Q,P,A,B,Ca,Cb 
        real aa,bb,cc 
        real xx,yy,u,v 
        real inpx,outpx,inpy,outpy,ind,outd 
        real sx(8000),sy(8000) 
        real PP,QQ 
        real SCALE 
        real rtype 

        zeros = zpd(MAPZ) 

&dA*   I.  Determine scaling factor              

        if notesize = 14 
          SCALE = 1.0 
        else 
          SCALE = flt(notesize) / 14.0 
        end 

&dA*   II. Get rise and length limits            

        getvalue length,rise,smode 
        t1 = length - 1 
        X = flt(t1) 
        Y = flt(rise) 

        X = X / SCALE                  /* &dA05-12-95&d@  all computations done 
        Y = Y / SCALE                  /* at original size.  

        length = length * 14 / notesize 

  /* clear slur array 

        loop for t1 = 1 to 250 
          map(t1) = pad(MAPZ) 
        repeat 
&dA 
&dA &d@    &dEBeginning of slur generation&d@ 
&dA 
&dAÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dA³       P A R A M E T R I C    M A G I C         ³&d@ 
&dAÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

        rtype = 2.0        

        if X < 600.0 
          H = X * .03 + 9.0 + (1.9 * rtype) 
        else 
          H = 27.0  + (1.9 * rtype) 
        end 

        if X > 1200.0 
          H = H + (X - 1200.0 / 200.0) 
        end 

        rtype -= 1.0 

        L = X * X + (Y * Y) 
        L = sqt(L) 
        aa = rtype / 75.  
        W = L * (.66 - aa)  /* experimental value 
&dA 
&dA &d@   compute R, P, A, B, Cx, Cy, Ca, Cb and check limitations 
&dA 
&dA &d@   1. Q:  
&dA 
        if X > 300.0 
          Q = 15.0 
        else 
          Q = 13.0 
        end 

LS_PAA: 

&dA 
&dA &d@   2. R = L*L/Q/8 + Q/2 
&dA &d@                        
        x = L * L / Q / 8.0 
        y = Q / 2.0 
        R = x + y 
&dA 
&dA &d@   3. P = R - (R*R - (W*W/4))^1/2  component of height from 
&dA &d@                                      middle section 
        x = (R * R) - (W * W / 4.0) 
        P = R - sqt(x) 
        y = (L - W) / 2.0 + P 
        if H > y 
          H = y 
        end 
        if H < Q 
          H = dec(Q) + .5 
        end 
&dA 
&dA &d@   4. A = (L - W) / 2  B = H - P   <A,B> = transition point 
&dA 
        A = (L - W) / 2.0 
        B = H - P 
&dA 
&dA &d@   5. Cx = X/2  Cy = R - H       <Cx,Cy> = center of main arc 
&dA 
        Cx = L / 2.0 
        Cy = H - R                  /* a negative number 
&dA 
&dA &d@   6. Compute  <Ca,Cb> = center of starting arc 
&dA 
&dA &d@           [ B*(Cx-A)/(Cy-B) + (A*A + B*B)/2/A - A ] 
&dA &d@      Cb = ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA &d@                   [ B/A + (Cx-A)/(Cy-B) ] 
&dA 
&dA &d@      Ca = (A*A + B*B)/2/A - B*(Cb)/ A 
&dA 
        aa = (Cx - A) / (Cy - B) 
        bb = (A * A) + (B * B) 
        bb = bb / 2.0 / A 

        Cb = (B * aa + bb - A) / (B / A + aa) 

        Ca = bb - (B * Cb / A) 
&dA 
&dA &d@   normalize D-function 
&dA 
        xx = L / 2.0 
        D = sqt(xx) / 4.8 
        if D > 1.50 
          D -= .16         /* radical 
          if H / L > .200 
            D -= .10 
          end 
        end 
        if D > 1.70 
          D = D - 1.70 * .2 + 1.70 
        end 
        if D > 1.95 
          D = D - 1.95 * .3 + 1.95 
        end 
        if D > 2.25 
          D = D - 2.25 * .4 + 2.25 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   1        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@                              º   sqt(A*A + B*B)    º 
&dA &d@   1. compute beta = 2 * sin-1ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº  sweep angle 
&dA &d@                              º 2*sqt(Ca*Ca + Cb*Cb)º 
&dA 
        aa = A * A + (B * B) 
        bb = Ca * Ca + (Cb * Cb) 

        cc = sqt(bb) 
        beta = rtype / 7.5 

        if L >= 400.  
          delta = L * .001                  
        else                                
          delta = L * .006 - 2.00           
        end                                 

        if R / cc > 3.00 - beta + delta 
          Q += .1 
          if Q < H - .5 
            goto LS_PAA 
          end 
        end 

        cc = sqt(aa/bb) 

        beta = 2.0 * ars(cc/2.0) 
&dA 
&dA &d@   2. compute delta so that sweep hits every dot 
&dA 
        aa = sqt(aa)          /* length of arc (approx)  
        delta = beta / aa / 2.0  
        scnt = 0 
        alpha = 0.0 
&dA 
&dA &d@   3. begin sweep 
&dA 
LS_SW1A: 
        aa = 1.0 - cos(alpha) 
        bb = sin(alpha) 

        x = Ca * aa - (Cb * bb) 
        y = Ca * bb + (Cb * aa) 
        if x < A 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha += delta 
          goto LS_SW1A 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   2        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. compute beta2 = sin-1{ [(L/2)-A] / R } 
&dA 
        aa = L / 2.0 - A / R 
        beta2 = ars(aa) 
&dA 
&dA &d@   2. compute delta so that sweep hits every dot 
&dA 
        delta2 = beta2 * 2.0 / W / 2.0    
        alpha = 0.0 - beta2 
&dA 
&dA &d@   3. begin sweep 
&dA 
LS_SW2A: 
        x = R * sin(alpha) + Cx 
        y = R * cos(alpha) + Cy 
        if x < L - A and scnt < 7999         /* added &dA11/29/09&d@ 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha += delta2 
          goto LS_SW2A 
        end 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³        S W E E P    L O O P   3        ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. beta and delta already computed 
&dA 
        alpha = beta 
&dA 
&dA &d@   2. begin sweep 
&dA 
LS_SW3A: 
        aa = 1.0 - cos(alpha) 
        bb = sin(alpha) 

        x = L - (Ca * aa) + (Cb * bb) 
        y = Ca * bb + (Cb * aa) 
        if x < L and scnt < 7999             /* added &dA11/29/09&d@ 
          ++scnt 
          sx(scnt) = x 
          sy(scnt) = y 
          alpha -= delta 
          goto LS_SW3A 
        end 
        ++scnt 
        sx(scnt) = L 
        sy(scnt) = 0.0 

&dEÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿&d@ 
&dE³  E N D   O F   S W E E P S.    C O N S T R U C T   S L U R   ³&d@ 
&dEÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ&d@ 

&dA 
&dA &d@   1. rotate data to produce rise 
&dA 
        aa = X / L 
        bb = Y / L 
        loop for t1 = 1 to scnt 
          x = sx(t1) * aa - (sy(t1) * bb) 
          y = sx(t1) * bb + (sy(t1) * aa) 
          sx(t1) = x 
          sy(t1) = y 
        repeat 
&dA 
&dA &d@   2. setup thickness parameters 
&dA 
        pc = length * 60 / (length + 400)   /* carefully worked out formula &dA05/13/95
        pd = pc * 3 / 10 

        pe = scnt - pc 
        pf = scnt - pd 

        if notesize = 21                    /* disable this feature for notesize = 21 &dA12/03/08
          pc = 1 
          pe = scnt 
        end 

        pg = 50 * scnt / 100         

        if length < 400 
          ph = 0 
        else 
          ph = (length - 400) * scnt * 4 / 40000 
        end 
&dA 
&dA &d@   3. compute ind, outd 
&dA 
        loop for t1 = 1 to scnt 
          if t1 < pc                   /* left hand side of slur 
            ind = 0.6 
            if notesize = 21 
              ind = 1.3 
            end 
            if t1 < pd                 /* extreme left end 
              if notesize = 16         /* New size-16  &dA12/31/08&d@ 
                outd = .4 * flt(t1) / flt(pc) 
              else 
                outd = flt(t1) / flt(pc) + .1 
              end 
            else 
              outd = 0.4 
            end 
            if notesize = 14 
              outd += .4 
            end 
            if notesize = 16           /* New size-16  &dA12/31/08&d@ 
              outd += .3 
            end 
            if notesize = 18           /* New size-18  &dA12/18/04&d@ 
              outd += .3 
            end 
            if notesize = 21 
              outd += .3 
            end 
            goto LS_PCD 
          end 
          if t1 > pe                   /* right hand side of slur 
            ind = 0.6 
            if t1 >= pf                /* extreme right end 
              t2 = scnt - t1 
              if notesize = 16         /* New size-16  &dA12/31/08&d@ 
                outd = 0.4 * flt(t2) / flt(pc) 
              else 
                outd = flt(t2) / flt(pc) + .1 
              end 
            else 
              outd = 0.4 
            end 
            if notesize = 14 
              outd += .4 
            end 
            if notesize = 16           /* New size-16  &dA12/31/08&d@ 
              outd += .3 
            end 
            if notesize = 18           /* New size-18  &dA12/18/04&d@ 
              outd += .3 
            end 
            goto LS_PCD 
          end 
    /* middle of slur 
          if t1 > pg + ph              /* right side 
            t2 = pe - t1 
            t5 = pe - pg - ph 
          else                         /* left side 
            if t1 < pg - ph 
              t2 = t1 - pc 
              t5 = pg - pc - ph 
            else 
              t5 = 10000 
              t2 = 9999 
            end 
          end 
          bb = flt(t2) * ars(1.0) / flt(t5)  /* max(bb) = sin-1(1) 
          aa = sin(bb) 
          if notesize = 14 
            outd = D - .8 * aa + .8 
            ind = D - .6 * aa + .6 
          end 
&dA 
&dA &d@    New &dA12/31/08&d@ parameters for notesize 16 (based on create16.z) 
&dA 
          if notesize = 16 
            outd = D - 0.1 * aa + 0.4 
            ind = D - 0.6 * aa + 0.6    
            outd += .29000 
            ind  += .29000 
          end 
&dA 
&dA &d@    New &dA12/18/04&d@ parameters for notesize 18 (based on create18.z) 
&dA 
          if notesize = 18 
            outd = D - 0.7 * aa + 0.7 
            ind = D - 0.6 * aa + 0.6    
            outd += .69000 
            ind  += .79000 
          end 
&dA 
&dA &d@    &dA01/26/06&d@ parameters added for notesize 6
&dA 
          if notesize = 6 
            outd = D - 0.8 * aa + 0.8 
            ind = D - 0.6 * aa + 0.6    
            outd += .39000 
            ind  += .49000 
          end 
&dA 
&dA &d@    &dA12/03/08&d@ parameters changed for notesize 21 
&dA 
          if notesize = 21 
            outd = D - 0.6 * aa + 0.6 
            ind = D - 1.0 * aa + 1.0    
            outd += .29000 
            ind  += .89000 
          end 
&dA 
&dA &d@   4. compute outside point, inside point 
&dA 
LS_PCD: 
          x = sx(t1) 
          y = sy(t1) 
&dA 
&dA &d@   give finite width to slur 
&dA 
          if t1 < scnt 
            u = sx(t1+1) 
            v = sy(t1+1) 
          else 
            u = x 
            v = y 
          end 
          if t1 > 1 
            xx = sx(t1-1) 
            yy = sy(t1-1) 
          else 
            xx = x 
            yy = y 
          end 
          u -= xx          /* delta x 
          v -= yy          /* delta y 
          cc = u * u + (v * v) 
          cc = sqt(cc)       /* delta hypotinus 
          aa = outd / cc 
          bb = ind / cc 
          outpx = x - (aa * v) 
          outpy = y + (aa * u) 
          inpx  = x + (bb * v) 
          inpy  = y - (bb * u) 
&dA 
&dA &d@   5. compute box coordinates 
&dA 
          if outpx < inpx 
            aa = outpx 
            outpx = inpx 
            inpx = aa 
          end 
          if outpy < inpy 
            aa = outpy 
            outpy = inpy 
            inpy = aa 
          end 
          outpx = outpx + 30.0           /*  - .5 
          inpx  = inpx  + 30.0           /*  - .5 
          outpy = outpy + 20.0 - 1.0 
          inpy  = inpy  + 20.0 + .5 
&dA 
&dA &d@    For notesize = 21, it appears that scaling here is better 
&dA 
          if notesize = 21 
            inpx = inpx * SCALE 
            outpx = outpx * SCALE 
            inpy = inpy * SCALE 
            outpy = outpy * SCALE 
          end 

          x1 = fix(inpx) 
          x2 = fix(outpx) 
          y1 = fix(inpy) 
          y2 = fix(outpy) 
          if x2 - x1 < 2 
            ++y2                  /* radical 
          end 
&dA 
&dA &d@   6. set points inside box to 1 (with inverted vertical axis) 
&dA 
&dA &d@     Here is where you scale the slur back to its original size    
&dA 
          if notesize <> 21 
            x1 = x1 * notesize / 14 
            x2 = x2 * notesize + 7 / 14 
            y1 = y1 * notesize / 14 
            y2 = y2 * notesize + 7 / 14 
          end 

          if y2 > 249 
            y2 = 249 
          end 

          if x2 > 2500                        /* added &dA11/29/09&d@ 
            x2 = 2500      
          end 

          loop for t2 = y1 to y2 
            t4 = 250 - t2 
            loop for t3 = x1 to x2 
              map(t4){t3} = "x" 
            repeat 
          repeat 

        repeat 
&dA 
&dA &d@    &dEEnd of slur generation&d@ 
&dA 

/* determine size of map display 

        loop for t1 = 1 to 250 
          map(t1) = trm(map(t1)) 
          if map(t1) <> "" 
            goto LS_CE 
          end 
        repeat 
LS_CE: 
        y1 = t1 
        loop for t2 = t1 to 249 
          map(t2+1) = trm(map(t2+1)) 
          if map(t2) = "" and map(t2+1) = "" 
            goto LS_CF 
          end 
        repeat 
LS_CF: 
        y2 = t2 - 1 
        loop for t2 = 1 to MAPZ 
          loop for t1 = y1 to y2 
            if map(t1){t2} = "x" 
              goto LS_CH 
            end 
          repeat 
        repeat 
LS_CH: 
        x1 = t2 
        x2 = 0 
        loop for t1 = y1 to y2 
          if x2 < len(map(t1)) 
            x2 = len(map(t1)) 
          end 
        repeat 

    /* write slur to longslur(.) 

        x2 = x2 - x1                /* x range 
        t2 = 0 
        if smode < 3 
          loop for t1 = y1 to y2 
            map(t1) = map(t1) // pad(MAPZ) 
            out = map(t1){x1,x2} 
            if smode = 2 
              out = rev(out) 
            end 
            out = trm(out) 

            if out = "" and (t1 = y1 or t1 = y2) 
            else 
              ++t2 
              temp = pak(out) 
              longslur(t2) = cby(temp) 
            end 
          repeat 
        else 
          loop for t1 = y2 to y1 step -1 
            map(t1) = map(t1) // pad(MAPZ) 
            out = map(t1){x1,x2} 
            if smode = 3 
              out = rev(out) 
            end 
            out = trm(out) 

            if out = "" and (t1 = y1 or t1 = y2) 
            else 
              ++t2 
              temp = pak(out) 
              longslur(t2) = cby(temp) 
            end 
          repeat 
        end 
        if smode = 1 
          length = t2 - 1 
        else 
          if smode = 2 
            length = t2 - 1 - rise 
          else 
            if smode = 3 
              length = rise 
            else 
              length = 0 
            end 
          end 
        end 

        rise = t2 
        passback length,rise          /* length = initial offset; rise = number of rows
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 34. stringout (out)                                         ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Operation:  Put out a string of characters                 ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure stringout (out) 
        str out.500 
        int font,kk 
        int t1 
        getvalue out 
        int scx2                    /* added &dA11/29/09&d@ 

        loop for t1 = 1 to len(out) 
          kk = ors(out{t1}) 
          if kk > 130 and kk < 142 
            if kk < 140 
              scx += (kk - 130) 
            else 
              scx -= (kk - 139) 
            end 
          else 
            scb = kk 
            perform charout 
          end 
        repeat 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 35. charout                                                 ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Operation:  Put out a character (to the ps output table)   ³ 
&dA &d@³                Advance the scx pointer, which would normally  ³ 
&dA &d@³                be done by the setb instruction.  setb here    ³ 
&dA &d@³                simply puts out a dummy character for the      ³ 
&dA &d@³                sake of constructing the bounding box (later). ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure charout 
        int font,kk 
        font = revmap(scf) 
        int scx2 
        scx2 = scx 
&dA 
&dA &d@    Here, color_flag is important.  We probably need to have a second CT table
&dA &d@    for the color RED 
&dA 

        ++ct_cnt 
        tput [CT,ct_cnt] Calling charout: font = ~font   loc = <~scx ,~scy >  char = ~scb
        ++glyph_record(font,scb) 

        if font < 13 
          scx += Mfontinc(font,scb) 
        end 
        if font > 12 and font < 26    /* Beams 
          scx += Beaminc(scb) 
        end 
        if font > 25 and font < 38    /* Ties 
          kk = Tieinc(font-25,scb) 
          scx += kk 
        end 
        if font > 37 and font < 42    /* Wedges 
          scx += Wedginc(scb) 
        end 
        if font > 50 
          perform get_xinc (scf,scb,kk) 
          scx += kk 
        end 

        font = revmap(notesize) 
        font = font - 1 * 33 
        kk = 33 + font 
         
        setb gstr,FA,scx2,scy,kk,1 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 36. ps_init_par                                                    ³ 
&dA &d@³                                                                      ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Purpose:  Initialize Vertical and Horizontal Parameters           ³ 
&dA &d@³                also expar(.) parameters                              ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Inputs:   notesize                                                ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Outputs:  pvpar(.)                                                ³ 
&dA &d@³              phpar(.)                                                ³ 
&dA &d@³              pvpar20                                                 ³ 
&dA &d@³              expar(.)                                                ³ 
&dA &d@³              revmap(.)                                               ³ 
&dA &d@³              sizenum                                                 ³ 
&dA &d@³                                                                      ³ 
&dA &d@³     Other operations: In all cases, if scf = old notesize, then      ³ 
&dA &d@³                         scf reset to new notesize                    ³ 
&dA &d@³                       In the case of PRINT, changes the active font  ³ 
&dA &d@³                         to match the new size.                       ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure ps_init_par 
        int pz                            /* added &dA03/15/04&d@ 
        int t1 
        bstr cycle.200 

        sizenum = revsizes(notesize)       /* New &dA02/19/06&d@ 
&dA 
&dA &d@    Vertical parameters 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        if notesize = 14 
          pvpar(13) = 8 
          pvpar(42) = 4 
          pvpar(43) = 240 
          pvpar(44) = 1 
        end 
        if notesize = 6 
          pvpar(13) = 3                  /* Changed from 4 to 3 &dA01/30/05&d@ 
          pvpar(42) = 2 
          pvpar(43) = 80 
          pvpar(44) = 1 
        end 
        if notesize = 21 
          pvpar(13) = 12 
          pvpar(42) = 6 
          pvpar(43) = 240 
          pvpar(44) = 3 
        end 
        if notesize = 18                /* New size-18  &dA12/18/04&d@ 
          pvpar(13) = 10 
          pvpar(42) = 5 
          pvpar(43) = 240 
          pvpar(44) = 2 
        end 
        if notesize = 16                /* New size-16  &dA12/31/08&d@ 
          pvpar(13) = 9 
          pvpar(42) = 4 
          pvpar(43) = 240 
          pvpar(44) = 1 
        end 

        loop for t1 = 1 to 10 
          pvpar(t1) = notesize * t1 / 2 
        repeat 

        pvpar(11) = 200 * notesize / 16 
        pvpar(12) = 4 * notesize / 16 

        pvpar(14) = 160 * notesize / 16 
        pvpar(15) = 64 * notesize / 16 
        pvpar(16) = 3 * notesize 
        pvpar(17) = notesize / 2 
        pvpar(18) = 30 * notesize / 16 
        pvpar(19) = 15 
        pvpar(20) = notesize + 3 / 4 
        pvpar(21) = notesize - pvpar(20) 
        pvpar(22) = 6 * notesize / 16 
        pvpar(23) = 9 * notesize / 16 
        pvpar(24) = 7 * notesize / 16 
        pvpar(25) = 22 * notesize / 16 
        pvpar(26) = 27 * notesize / 16 
        pvpar(27) = 72 * notesize / 16 
        pvpar(28) = 15 * notesize / 16 
        pvpar(29) = 38 * notesize / 16 
        pvpar(30) = 3 * notesize - 8 / 16 
        pvpar(31) = notesize / 2 + 1 
        pvpar(32) = notesize * 8 + 4 / 10 
        pvpar(33) = notesize * 12 + 10 / 14 
        pvpar(34) = notesize - 3 / 9 
        pvpar(35) = notesize / 3 
        pvpar(36) = 7 * notesize 
        pvpar(37) = 5 * notesize / 4 
        pvpar(38) = 4 * notesize / 3 
        pvpar(39) = notesize 
        pvpar(40) = 3 * notesize / 5 
        pvpar(41) = pvpar(5) 
        pvpar(45) = 2 * notesize     
        pvpar20   = notesize * 10 
&dA 
&dA &d@    Horizontal parameters 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        if notesize = 14 
          phpar(2) =   15 
          phpar(3) =   19 
          phpar(5) =   13 
          phpar(6) =   80 
          phpar(7) =   56             /* &dA01/20/05&d@ made explicit 
          phpar(12) =  80 
          phpar(17) =  14 
          phpar(19) =   4 
          phpar(20) =  20 
          phpar(29) =   2 
          phpar(30) =  17 
          phpar(33) =   6 
          phpar(34) =   7 
          phpar(43) =  40 
          phpar(48) =   8 
          phpar(58) =  30 
          phpar(60) = 254 
          phpar(61) =  20 
          phpar(62) =   2 
          phpar(63) =  90 
        end 
        if notesize = 6 
          phpar(2) =    7 
          phpar(3) =    8 
          phpar(5) =    6 
          phpar(6) =   34 
          phpar(7) =   18             /* &dA01/20/05&d@ changed from 24 to 18 and made explicit
          phpar(12) =  35 
          phpar(17) =   7 
          phpar(19) =   2 
          phpar(20) =   9 
          phpar(29) =   1 
          phpar(30) =   8 
          phpar(33) =   3 
          phpar(34) =   4 
          phpar(43) =  30 
          phpar(48) =   4 
          phpar(58) =  10 
          phpar(60) = 110 
          phpar(61) =  10 
          phpar(62) =   1 
          phpar(63) =  90 
        end 
        if notesize = 21 
          phpar(2) =   19 
          phpar(3) =   28 
          phpar(5) =   18             /* &dA12/18/04&d@ changed from 19 to 18 
          phpar(6) =  110 
          phpar(7) =   88             /* &dA01/20/05&d@ made explicit 
          phpar(12) = 100 
          phpar(17) =  21 
          phpar(19) =   6 
          phpar(20) =  30 
          phpar(29) =   3 
          phpar(30) =  22 
          phpar(33) =   8             /* &dA12/18/04&d@ changed from 9 to 8 
          phpar(34) =  11 
          phpar(43) =  30 
          phpar(48) =  13 
          phpar(58) =  30 
          phpar(60) = 381 
          phpar(61) =  30 
          phpar(62) =   3 
          phpar(63) =  80 
        end 
&dA 
&dA &d@    New &dA12/31/08&d@   notesize 16 parameters added 
&dA 
        if notesize = 16 
          phpar(2) =   16 
          phpar(3) =   22 
          phpar(5) =   15 
          phpar(6) =   90 
          phpar(7) =   64 
          phpar(12) =  80 
          phpar(17) =  16 
          phpar(19) =   4 
          phpar(20) =  23 
          phpar(29) =   2 
          phpar(30) =  18 
          phpar(33) =   6 
          phpar(34) =   9 
          phpar(43) =  30 
          phpar(48) =   9 
          phpar(58) =  30 
          phpar(60) = 280 
          phpar(61) =  22 
          phpar(62) =   2 
          phpar(63) =  80 
          ++phpar(3) 

        end 
&dA 
&dA &d@    New &dA12/18/04&d@   notesize 18 parameters added 
&dA 
        if notesize = 18 
          phpar(2) =   17 
          phpar(3) =   26 
          phpar(5) =   17 
          phpar(6) =  100 
          phpar(7) =   72             /* &dA01/20/05&d@ made explicit 
          phpar(12) =  90 
          phpar(17) =  18 
          phpar(19) =   5 
          phpar(20) =  26 
          phpar(29) =   3 
          phpar(30) =  20 
          phpar(33) =   7 
          phpar(34) =   9 
          phpar(43) =  30 
          phpar(48) =  10 
          phpar(58) =  30 
          phpar(60) = 326 
          phpar(61) =  26 
          phpar(62) =   2 
          phpar(63) =  80 
        end 

        phpar(1) = 30 
&dA &d@       phpar(2) = 18 * notesize / 16 
&dA &d@       phpar(3) = 19 * notesize + 8 / 16 
&dA &d@       phpar(4) = 3 
&dA &d@       phpar(5) = 13 * notesize + 2 / 16 
&dA &d@       phpar(6) = 80 
&dA &d@       phpar(7) = 4 * notesize             /* &dA01/20/05&d@ made explicit 
&dA &d@       phpar(8) = 200 
&dA &d@       phpar(9) = 2250 
        phpar(10) = 26 * notesize / 16 
        phpar(11) = 200 * notesize / 16 
&dA &d@       phpar(12) = 80 
        phpar(14) = 40 * notesize / 16 
        phpar(16) = 24 * notesize / 16 
&dA &d@       phpar(17) = 14 
        phpar(18) = 2 * notesize 
&dA &d@       phpar(19) = 4 
&dA &d@       phpar(20) = 20 
&dA &d@       phpar(21) = 300 
&dA &d@       phpar(22) = 6 * notesize / 16       (not used) 
&dA &d@       phpar(23) = 60 * notesize / 16      (not used) 
&dA &d@       phpar(24) = 7 * notesize + 2 / 7    (not used) 
&dA &d@       phpar(25) = notesize + 1            (not used) 
&dA &d@       phpar(26) = 15 * notesize / 16      (not used) 
&dA &d@       phpar(27) = 0                       (not used) 
&dA &d@       phpar(28) = 0 - 32 * notesize / 16  (not used) 
&dA &d@       phpar(29) = 2 * notesize + 8 / 16 
&dA &d@       phpar(30) += phpar(29) 
        phpar(31) = 24 * notesize / 16 
        phpar(32) = 44 * notesize / 16 
&dA &d@       phpar(33) = 6 * notesize / 16 
&dA &d@       phpar(34) = 8 * notesize / 16 
        phpar(35) = 14 * notesize / 16 
        phpar(36) = 8 * notesize / 16 
        phpar(37) = 20 * notesize / 16 
        phpar(38) = 20 * notesize / 16 
        phpar(39) = 50 * notesize / 16 
        phpar(40) = 15 * notesize + 4 / 16 
        phpar(41) = pvpar(5) 
        phpar(42) = notesize * 4 
&dA &d@       phpar(43) = 40 
        phpar(44) = notesize 
        phpar(45) = notesize 
        phpar(46) = 13 * notesize / 16 
        phpar(47) = 2 * notesize / 5 
&dA &d@       phpar(48) = 10 * notesize / 16 
&dA &d@       phpar(49) = 24 * notesize / 16 
&dA &d@       phpar(50) = 12 * notesize / 16 
        phpar(51) = 31 * notesize / 16 
        phpar(52) = 19 * notesize / 16 
        phpar(53) = 4 * notesize / 16 
        phpar(54) = 18 * notesize / 16 
        phpar(55) = 6 * notesize / 16 
        phpar(56) = 12 * notesize / 16 
        phpar(57) = 2 * notesize 
        phpar(59) = 3 * notesize / 5 
&dA 
&dA &d@    New &dA12/31/08&d@ parameters added for notesize 16 
&dA 
        if notesize = 16 
          phpar(42) =  56 
        end 

&dA 
&dA &d@    New &dA12/18/04&d@ parameters added for notesize 18 
&dA 
        if notesize = 18 
          phpar(11) = 225 
          phpar(39) =  50 
          phpar(42) =  67 
        end 

        if notesize = 21 
          phpar(11) = 250 
          phpar(39) =  50 
          phpar(42) =  76 
        end 
&dA 
&dA &d@    Other parameters and variables 
&dA &d@    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 
&dA 
        if notesize = 14 
          expar(1) = 240 
          expar(2) = 324 
          expar(3) = 254 
          expar(4) = 324 
          expar(5) = 256 
          expar(6) = 324 
          expar(7) = 260 
          expar(8) = 324 
        end 
        if notesize = 6 
          expar(1) = 102 
          expar(2) = 139 
          expar(3) = 106 
          expar(4) = 146 
          expar(5) = 107 
          expar(6) = 144 
          expar(7) = 109 
          expar(8) = 148 
        end 
        if notesize = 21 
          expar(1) = 360 
          expar(2) = 486 
          expar(3) = 381 
          expar(4) = 498 
          expar(5) = 386 
          expar(6) = 486 
          expar(7) = 390 
          expar(8) = 498 
        end 
&dA 
&dA &d@   notesize 16 added &dA12/31/08 
&dA 
        if notesize = 16 
          expar(1) = 278 
          expar(2) = 362 
          expar(3) = 290 
          expar(4) = 372 
          expar(5) = 296 
          expar(6) = 368 
          expar(7) = 298 
          expar(8) = 376 
        end 
&dA 
&dA &d@   notesize 18 added &dA12/18/04 
&dA 
        if notesize = 18 
          expar(1) = 308 
          expar(2) = 424 
          expar(3) = 326 
          expar(4) = 428 
          expar(5) = 330 
          expar(6) = 422 
          expar(7) = 334 
          expar(8) = 432 
        end 

        loop for t1 = 1 to 223 
          pos(t1) = urpos(t1) * notesize 
        repeat 
&dA 
&dA &d@   Dotted mask   (modified &dA10/23/03&d@)  &dIOK&d@ 
&dA 
        if notesize = 14 
          gapsize = 5 
          cycle = dup("1",7) // dup("0",3) 
        end 
        if notesize = 6 
          gapsize = 3 
          cycle = dup("1",4) // dup("0",2) 
        end 
        if notesize = 21 
          gapsize = 12 
          cycle = dup("1",15) // dup("0",9) 
        end 
        if notesize = 16                       /* New size-16 mask &dA12/31/08&d@ &dNnot OK
          gapsize = 9 
          cycle = dup("1",11) // dup("0",7) 
        end 
        if notesize = 18                       /* New size-18 mask &dA12/18/04&d@ &dIOK
          gapsize = 10 
          cycle = dup("1",12) // dup("0",8) 
        end 

        dotted = "" 
        t1 = 2500 - (2 * gapsize) 
        loop 
          dotted = dotted // cycle 
        repeat while len(dotted) < t1 
&dA 
&dA &d@   scf can be 
&dA &d@     (1) old notesize (4 to 24)   (requires change in scf) 
&dA &d@     (2) beamfont  (101 to 114)   (independent of notesize) 
&dA &d@     (3) text font (31 to 48)     (actual font depends on notesize) 
&dA &d@     (4) 300 (ties)                             " 
&dA &d@     (5) 320 (brackets)                         " 
&dA &d@     (6) 400 (wedges)                           " 
&dA &d@     (7) 30 (variable pitch screen fonts, display only) 
&dA &d@     (8) 200 (fixed pitch screen font, display only) 
&dA 

        if scf > 0 and scf < 25 
          scf = notesize 
        end 

        pz = revsizes(notesize) 
        loop for t1 = 30 to 48 
          revmap(t1) = XFonts(pz,t1-29) 
        repeat 
                    
        revmap(200) = ors(",,,,----....////////////"{notesize})   /* former scfont()
        revmap(300) = pz + TIE_OFFSET 
        if notesize < 10 
          revmap(320) = SMALL_BRACK 
        else 
          revmap(320) = LARGE_BRACK 
        end 
        revmap(400) = ors("&&&&&&&&''''''((((()))))"{notesize})   /* former wedgefont()

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 37. move_to_loc (hh,kk)                                     ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose: construct a Postscript moveto entry from          ³ 
&dA &d@³                PCL coordinates                                ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Input:  hh     x location                                   ³ 
&dA &d@³           kk     y location                                   ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Output  string mtloc                                        ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure move_to_loc (hh,kk)                          
        int t1,t2,t3,t4 
        int hh,kk 

        getvalue hh,kk 

        hh += 50                  /* magic number 
        t1 = hh * 10 * 24         /* in thousands of Postscript units 

        t3 = 3150 - kk            /* also a magic number 
        t2 = t3 * 10 * 24 

        mtloc = "" 
        if t1 < 0 
          mtloc = mtloc // "-" 
          t1 = 0 - t1 
        end 
        t4 = t1 / 1000 
        t3 = rem 
        mtloc = mtloc // chs(t4) // "." 
        if t3 < 100 
          mtloc = mtloc // "0" 
        end 
        if t3 < 10 
          mtloc = mtloc // "0" 
        end 
        mtloc = mtloc // chs(t3) 

        mtloc = mtloc // " " 

        if t2 < 0 
          mtloc = mtloc // "-" 
          t2 = 0 - t2 
        end 
        t4 = t2 / 1000 
        t3 = rem 
        mtloc = mtloc // chs(t4) // "." 
        if t3 < 100 
          mtloc = mtloc // "0" 
        end 
        if t3 < 10 
          mtloc = mtloc // "0" 
        end 
        mtloc = mtloc // chs(t3) 

        mtloc = mtloc // " moveto" 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 38. compute_delta_move (lastx,lasty,hh,kk)                  ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose: construct a Postscript delta move entry from      ³ 
&dA &d@³                PCL coordinates                                ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Input:  lastx  former  x location                           ³ 
&dA &d@³           lasty  former  y location                           ³ 
&dA &d@³           hh     current x location                           ³ 
&dA &d@³           kk     current y location                           ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Output  string mtloc                                        ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure compute_delta_move (lastx,lasty,hh,kk) 
        int hh,kk,lastx,lasty 
        int t1,t2,t3,t4 

        getvalue lastx,lasty,hh,kk 

        hh = hh - lastx 
        kk = lasty - kk 

        mtloc = "" 

        if hh < 0 
          hh = 0 - hh 
          mtloc = mtloc // "-" 
        end 
        t1 = hh * 10 * 24          /* in thousands of Postscript units 

        if t1 = 0 
          mtloc = mtloc // "0" 
        else 
          t4 = t1 / 1000 
          t3 = rem 
          if t4 > 0 
            mtloc = mtloc // chs(t4) // "." 
            if t3 < 100 
              mtloc = mtloc // "0" 
            end 
            if t3 < 10 
              mtloc = mtloc // "0" 
            end 
            mtloc = mtloc // chs(t3) 
          else 
            mtloc = mtloc // "0." 
            if t1 < 100 
              mtloc = mtloc // "0" 
            end 
            if t1 < 10 
              mtloc = mtloc // "0" 
            end 
            mtloc = mtloc // chs(t1) 
          end 
        end 

        mtloc = mtloc // " " 

        if kk < 0 
          kk = 0 - kk 
          mtloc = mtloc // "-" 
        end 
        t2 = kk * 10 * 24          /* in thousands of Postscript units 

        if t2 = 0 
          mtloc = mtloc // "0" 
        else 
          t4 = t2 / 1000 
          t3 = rem 
          if t4 > 0 
            mtloc = mtloc // chs(t4) // "." 
            if t3 < 100 
              mtloc = mtloc // "0" 
            end 
            if t3 < 10 
              mtloc = mtloc // "0" 
            end 
            mtloc = mtloc // chs(t3) 
          else 
            mtloc = mtloc // "0." 
            if t2 < 100 
              mtloc = mtloc // "0" 
            end 
            if t2 < 10 
              mtloc = mtloc // "0" 
            end 
            mtloc = mtloc // chs(t2) 
          end 
        end 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 39. build_page_pdict                                        ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose: construct a customized Postscript                 ³ 
&dA &d@³                dictionary for a page                          ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Input:  list of fonts and glyphs in table ZZ                ³ 
&dA &d@³                                                               ³ 
&dA &d@³   Output  custormized Postscript dictionary                   ³ 
&dA &d@³             in table PD                                       ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure build_page_pdict 

        str data.100 
        str temp.10000 

        int font,glyph 
        int t1,t2,t3,t4,t5 
        int a(16) 
        int glyph_loc(256) 
        int gcount 
        int glyphs(256) 
        int font_loc 

        pd_cnt = 0 
        zpnt = 1 
BPD_A: 
        tget [ZZ,zpnt] data .t6 font .t9 glyph 
        if data{1} = "$" 
          goto BPD_END 
        end 
        if data{1} = "f" 
          ++pd_cnt 
          tput [PD,pd_cnt] 
          tget [XX,font] t1 
          ++pd_cnt 
          tput [PD,pd_cnt] 
          font_loc = t1 
          t5 = 0 
          loop for t3 = 1 to 16 
            tget [XX,t1] a(1) a(2) a(3) a(4) a(5) a(6) a(7) a(8) a(9) a(10) a(11) a(12) a(13) a(14) a(15) a(16)
            ++t1 
            loop for t4 = 1 to 16 
              ++t5 
              glyph_loc(t5) = a(t4) 
            repeat 
          repeat 
          loop for t3 = 1 to 7 
            tget [XX,t1] data 
            ++t1 
            ++pd_cnt 
            tput [PD,pd_cnt] ~data 
          repeat 

          zpnt2 = zpnt + 2 
          gcount = 1 
BPD_B: 
          tget [ZZ,zpnt2] data .t9 glyph 
          tget [ZZ,zpnt2+1] temp 
          temp = temp // pad(4) 
          glyphs(gcount) = glyph 
          ++gcount 
          if data{4} = "c" and temp{4} = "c" 
            ++pd_cnt 
            tput [PD,pd_cnt]     dup ~glyph  /mus_~glyph  put 
            ++zpnt2 
            goto BPD_B 
          else 
            ++pd_cnt 
            tput [PD,pd_cnt]     ~glyph  /mus_~glyph  put 
            zpnt = zpnt2 + 1 
          end 

          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]   /BuildChar 
          ++pd_cnt 
          tput [PD,pd_cnt]     {0 begin 
          ++pd_cnt 
          tput [PD,pd_cnt]       /char exch def 
          ++pd_cnt 
          tput [PD,pd_cnt]       /fontdict exch def 
          ++pd_cnt 
          tput [PD,pd_cnt]       /charname fontdict /Encoding get char get def
          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]       /charinfo fontdict /CharData get charname get def
          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]       /wx charinfo 0 get def 
          ++pd_cnt 
          tput [PD,pd_cnt]       /charbbox charinfo 1 4 getinterval def 
          ++pd_cnt 
          tput [PD,pd_cnt]       wx 0 charbbox aload pop setcachedevice 
          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]       charinfo 5 get charinfo 6 get true 
          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]       fontdict /imagemaskmatrix get 
          ++pd_cnt 
          tput [PD,pd_cnt]         dup 4 charinfo 7 get put 
          ++pd_cnt 
          tput [PD,pd_cnt]         dup 5 charinfo 8 get put 
          ++pd_cnt 
          tput [PD,pd_cnt]       charinfo 9 1 getinterval cvx 
          ++pd_cnt 
          tput [PD,pd_cnt]       imagemask 
          ++pd_cnt 
          tput [PD,pd_cnt]       end 
          ++pd_cnt 
          tput [PD,pd_cnt]     } def 
          ++pd_cnt 
          tput [PD,pd_cnt] 
          ++pd_cnt 
          tput [PD,pd_cnt]   /BuildChar load 0 6 dict put 
          ++pd_cnt 
          tput [PD,pd_cnt] 

          tget [XX,t1] data 
          ++t1                      /* imagemask 
          ++pd_cnt 
          tput [PD,pd_cnt] ~data 

          tget [XX,t1] data 
          ++t1                      /* /CharData xxx dict def 
          ++pd_cnt 
          tput [PD,pd_cnt]   /CharData ~gcount  dict def 
          ++pd_cnt 
          tput [PD,pd_cnt]   CharData begin 

          loop for t3 = 1 to gcount - 1 
            t4 = glyphs(t3) 
            t5 = glyph_loc(t4) + font_loc 
            tget [XX,t5] data .t8 t2 
            if t2 <> t4 
              if (Debugg & 0x12) > 0 
                pute Logic Error ~data   in building a page 
                pute ~t2  ~t4 
              end 
              stop 
            end 
            ++pd_cnt 
            tput [PD,pd_cnt] ~data 
            loop 
              ++t5 
              tget [XX,t5] data 
              ++pd_cnt 
              tput [PD,pd_cnt] ~data 
            repeat while data{1} <> ">" 
          repeat 

          t5 = glyph_loc(256) + font_loc 
          loop for t3 = 1 to 5 
            tget [XX,t5] data 
            ++t5 
            ++pd_cnt 
            tput [PD,pd_cnt] ~data 
          repeat 

          goto BPD_A 

        end 
       
BPD_END: 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 40. build_regular_slur_dict (ns,t1,t2,t3,t4,t5,t6)               ³ 
&dA &d@³                                                                    ³ 
&dA &d@³                                                                    ³ 
&dA &d@³    Purpose: construct a customized Postscript                      ³ 
&dA &d@³                dictionary for regular slurs on                     ³ 
&dA &d@³                a page                                              ³ 
&dA &d@³                                                                    ³ 
&dA &d@³   Inputs:  table ST  contains data for regular slurs               ³ 
&dA &d@³            int   ns      number of slurs in dictionary             ³ 
&dA &d@³            int   t1      table pointer to first entry              ³ 
&dA &d@³            int   t2      table pointer to last data entry          ³ 
&dA &d@³            int   t3      maximum height for all slurs              ³ 
&dA &d@³            int   t4      maximum width for all slurs               ³ 
&dA &d@³            int   t5      dictionary number (1 or 2, at the moment) ³ 
&dA &d@³            int   t6      page number                               ³ 
&dA &d@³            int   pt_cnt2 pointer to next available location        ³ 
&dA &d@³                            in auxillary PostScript output table    ³ 
&dA &d@³            int   sd_cnt  pointer to next available location        ³ 
&dA &d@³                            in the slur dictionary                  ³ 
&dA &d@³                                                                    ³ 
&dA &d@³   Output:  table SD  custormized Postscript dictionaries           ³ 
&dA &d@³                        of slurs                                    ³ 
&dA &d@³            int   pt_cnt2 pointer to next available location        ³ 
&dA &d@³                            in auxillary PostScript output table    ³ 
&dA &d@³            int   sd_cnt  pointer to next available location        ³ 
&dA &d@³                            in the slur dictionary                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure build_regular_slur_dict (ns, t1, t2, t3, t4, t5, t6) 
        str data.100
        str temp.1000

        int ns 
        int font,glyph 
        int t1,t2,t3,t4,t5,t6,t7 
        int a1,a2,a3,a4,a5,a6,a7,a8 
        int hh,kk 

        getvalue ns,t1,t2,t3,t4,t5,t6 

        t4 = t4 + 7 / 8 * 8                 /* allign maximum width 
                                            /* on byte boundary 
&dA 
&dA &d@    Start up the auxiliary PostScript output table for this page number 
&dA 
        a6 = (t5 + 1) * 1000 + t6 
        ++pt_cnt2 
        tput [PT2,pt_cnt2] /Bitfont~a6  findfont 24 scalefont setfont 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt] 9 dict dup begin 
        ++sd_cnt 
        tput [SD,sd_cnt]   /FontType 3 def 
        ++sd_cnt 
        tput [SD,sd_cnt]   /FontMatrix [1 0 0 1 0 0] def 
&dA 
&dA &d@    Construct coordinates for font bounding box 
&dA 
        temp = "" 
        a1 = t4 / 100 
        a2 = rem 
        temp = temp // chs(a1) // "." 
        if a2 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a2) // " " 

        a1 = t3 / 100 
        a2 = rem 
        temp = temp // chs(a1) // "." 
        if a2 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a2) // " 0 0" 

        ++sd_cnt 
        tput [SD,sd_cnt]   /FontBBox [~temp ] def 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /Encoding 256 array def 
        ++sd_cnt 
        tput [SD,sd_cnt]   0 1 255 {Encoding exch /.b46 notdef put} for 
        ++sd_cnt 
        tput [SD,sd_cnt]   Encoding 

        a2 = 32 
        loop for a1 = 1 to ns 
          if a1 = ns 
            ++sd_cnt 
            tput [SD,sd_cnt]   ~a2  /mus_~a2  put 
          else 
            ++sd_cnt 
            tput [SD,sd_cnt]   dup ~a2  /mus_~a2  put 
          end 
          ++a2 
          if a2 = 128 
            a2 = 160 
          end 
        repeat 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /BuildChar 
        ++sd_cnt 
        tput [SD,sd_cnt]     {0 begin 
        ++sd_cnt 
        tput [SD,sd_cnt]       /char exch def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /fontdict exch def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charname fontdict /Encoding get char get def
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charinfo fontdict /CharData get charname get def
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       /wx charinfo 0 get def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charbbox charinfo 1 4 getinterval def 
        ++sd_cnt 
        tput [SD,sd_cnt]       wx 0 charbbox aload pop setcachedevice 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       charinfo 5 get charinfo 6 get true 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       fontdict /imagemaskmatrix get 
        ++sd_cnt 
        tput [SD,sd_cnt]         dup 4 charinfo 7 get put 
        ++sd_cnt 
        tput [SD,sd_cnt]         dup 5 charinfo 8 get put 
        ++sd_cnt 
        tput [SD,sd_cnt]       charinfo 9 1 getinterval cvx 
        ++sd_cnt 
        tput [SD,sd_cnt]       imagemask 
        ++sd_cnt 
        tput [SD,sd_cnt]       end 
        ++sd_cnt 
        tput [SD,sd_cnt]     } def 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /BuildChar load 0 6 dict put 
        ++sd_cnt 
        tput [SD,sd_cnt] 

        ++sd_cnt 
        tput [SD,sd_cnt]   /imagemaskmatrix [100 0 0 -100 0 0] def 
        ++sd_cnt 
        tput [SD,sd_cnt] 

        ++sd_cnt 
        tput [SD,sd_cnt]   /CharData ~(ns+1)  dict def 
        ++sd_cnt 
        tput [SD,sd_cnt]   CharData begin 

        a1 = t1 - 1 
        a8 = 32 
        loop for a2 = 1 to ns 
          ++a1 
          tget [ST,a1] temp 
          if temp con "slur at" 
            a3 = mpt 
            temp = temp{a3+9..} 
            tput [Y,1] ~temp 
            tget [Y,1] hh kk 
          end 
          ++a1 
          tget [ST,a1] temp 
&dA 
&dA &d@      Determine height and width of this slur 
&dA 
          a4 = 0                                 /* height counter 
          a5 = 0                                 /* max width 
          loop for a3 = a1+1 to t2               /* t2 is end of table 
            tget [ST,a3] temp 
            temp = trm(temp) 
            temp = temp // pad(1) 
            if temp{1} = ":"                     /* terminating ":" 
              a3 = t2                            /* exit loop 
            else 
              ++a4                               /* increment height 
              a6 = len(temp) 
              if a6 > a5 
                a5 = a6 
              end 
            end 
          repeat 
          a5 = a5 + 7 / 8 * 8                    /* allign width on byte boundary
&dA 
&dA &d@      With height now determined, you can now locate the slur 
&dA 
          t3 = hh + 50               /* magic number 
          t3 = t3 * 10 * 24 
             
          t4 = 3150 - kk             /* also a magic number 
          t4 -= a4                   /* position to bottom of image 
          t4 = t4 + 1                /* another magic number 
          t4 = t4 * 10 * 24 

          temp = oct(a8) 
          if len(temp) < 3 
            temp = "0" // temp 
          end 
&dA 
&dA &d@      Convert t3 and t4 to decimals (i.e., divide by 1000) 
&dA 
          data = "" 
          a6 = t3 / 1000 
          a7 = rem 
          data = data // chs(a6) // "." 
          if a7 < 100 
            data = data // "0" 
          end 
          if a7 < 10 
            data = data // "0" 
          end 
          data = data // chs(a7) // " " 

          a6 = t4 / 1000 
          a7 = rem 
          data = data // chs(a6) // "." 
          if a7 < 100 
            data = data // "0" 
          end 
          if a7 < 10 
            data = data // "0" 
          end 
          data = data // chs(a7) 

          ++pt_cnt2 
          tput [PT2,pt_cnt2] ~data   moveto (\~temp ) show 

&dA 
&dA &d@      Construct first 9 elements of def matrix 
&dA 
          temp = "[ 0 0 0 " 
          a6 = a5 / 100 
          a7 = rem 
          temp = temp // chs(a6) // "." 
          if a7 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a7) // " " 

          a6 = a4 / 100 
          a7 = rem 
          temp = temp // chs(a6) // "." 
          if a7 < 10 
            temp = temp // "0" 
          end 
          temp = temp // chs(a7) // " " 

          temp = temp // chs(a5) // " " // chs(a4) // " -0.5 " // chs(a4) // " "

          ++sd_cnt 
          tput [SD,sd_cnt]   /mus_~a8  ~temp  < 
          ++a8 
          if a8 = 128 
            a8 = 160 
          end 
              
&dA 
&dA &d@       Build the definition string 
&dA 
          data = "" 
          loop for a3 = 1 to a4 
            ++a1                                 /* next record
            tget [ST,a1] temp 
            temp = temp // pad(a5) 
&dA 
&dA &d@       Convert this to a hex string 
&dA 
            t7 = 0 
            loop for t4 = 1 to a5 
              if t7 = 0 
                t7 = 0x04 
                if temp{t4} = "x" 
                  t3 = 0x08 
                else 
                  t3 = 0 
                end 
              else 
                if temp{t4} = "x" 
                  t3 += t7 
                end 
                t7 >>= 1 
                if t7 = 0 
                  if t3 < 10 
                    data = data // chs(t3) 
                  else 
                    data = data // chr(55 + t3) 
                  end 
                  if len(data) = 60 
                    ++sd_cnt 
                    tput [SD,sd_cnt] ~data 
                    data = "" 
                  end 
                end 
              end 
            repeat 
          repeat 
          if len(data) > 0 
            ++sd_cnt 
            tput [SD,sd_cnt] ~data 
          end 
          ++sd_cnt 
          tput [SD,sd_cnt] > ] def 
          ++a1                              /* skip terminating ":" 
          tget [ST,a1] temp 
        repeat 
        ++sd_cnt 
        tput [SD,sd_cnt]   /.b46 notdef [ 0 0 0 0 0 1 0 0 <> ] def 
        ++sd_cnt 
        tput [SD,sd_cnt]   end 

        a6 = (t5 + 1) * 1000 + t6 
        ++sd_cnt 
        tput [SD,sd_cnt]   /UniqueID ~a6  def 
        ++sd_cnt 
        tput [SD,sd_cnt] end 
        ++sd_cnt 
        tput [SD,sd_cnt] /Bitfont~a6  exch definefont pop 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 41. build_long_slur_dict (t1,t2,t3,t4)                         ³ 
&dA &d@³                                                                  ³ 
&dA &d@³    Purpose: construct a customized Postscript                    ³ 
&dA &d@³                dictionary for one long slur                      ³ 
&dA &d@³                                                                  ³ 
&dA &d@³   Inputs:  table SST contains data for long slurs                ³ 
&dA &d@³            int   t1      table pointer to first entry            ³ 
&dA &d@³            int   t2      table pointer to last data entry        ³ 
&dA &d@³            int   t3      dictionary number (3 and climbing)      ³ 
&dA &d@³            int   t4      page number                             ³ 
&dA &d@³            int   pt_cnt2 pointer to next available location      ³ 
&dA &d@³                            in auxillary PostScript output table  ³ 
&dA &d@³            int   sd_cnt  pointer to next available location      ³ 
&dA &d@³                            in the slur dictionary                ³ 
&dA &d@³                                                                  ³ 
&dA &d@³   Output:  table SD  custormized Postscript dictionaries         ³ 
&dA &d@³                        of slurs                                  ³ 
&dA &d@³            int   pt_cnt2 pointer to next available location      ³ 
&dA &d@³                            in auxillary PostScript output table  ³ 
&dA &d@³            int   sd_cnt  pointer to next available location      ³ 
&dA &d@³                            in the slur dictionary                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure build_long_slur_dict (t1, t2, t3, t4) 
        str data.100
        str temp.1000

        int font,glyph 
        int t1,t2,t3,t4,t5,t6 
        int a1,a3,a4,a5,a6,a7,a8 
        int hh,kk 

        getvalue t1,t2,t3,t4 
&dA 
&dA &d@    Add to the auxiliary PostScript output table for this page 
&dA 
        a6 = (t3 + 1) * 1000 + t4 
        ++pt_cnt2 
        tput [PT2,pt_cnt2] /Bitfont~a6  findfont 24 scalefont setfont 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt] 9 dict dup begin 
        ++sd_cnt 
        tput [SD,sd_cnt]   /FontType 3 def 
        ++sd_cnt 
        tput [SD,sd_cnt]   /FontMatrix [1 0 0 1 0 0] def 

        a1 = t1
        
        tget [SST,a1] temp 
        if temp con "location" 
          a3 = mpt 
          temp = temp{a3+10..} 
          tput [Y,1] ~temp 
          tget [Y,1] hh kk 
        end 
        ++a1 
        tget [SST,a1] temp 
&dA 
&dA &d@      Determine height and width of this slur 
&dA 
        a4 = 0                                 /* height counter 
        a5 = 0                                 /* max width 
        loop for a3 = a1+1 to t2               /* t2 is end of table 
          tget [SST,a3] temp 
          temp = trm(temp) 
          temp = temp // pad(1) 
          if temp{1} = ":"                     /* terminating ":" 
            if a3 <> t2 
              stop 
            end 
          else 
            ++a4                               /* increment height 
            a6 = len(temp) 
            if a6 > a5 
              a5 = a6 
            end 
          end 
        repeat 
        a5 *= 4                                /* convert to bit length 
&dA 
&dA &d@      With height now determined, you can now locate the slur 
&dA 
        t6 = hh + 50               /* magic number 
        t6 = t6 * 10 * 24 

        t5 = 3150 - kk             /* also a magic number 
        t5 -= a4                   /* position to bottom of image 
        t5 = t5 + 1                /* another magic number 
        t5 = t5 * 10 * 24 
&dA 
&dA &d@      Convert t6 and t5 to decimals (i.e., divide by 1000) 
&dA 
        data = "" 
        a6 = t6 / 1000 
        a7 = rem 
        data = data // chs(a6) // "." 
        if a7 < 100 
          data = data // "0" 
        end 
        if a7 < 10 
          data = data // "0" 
        end 
        data = data // chs(a7) // " " 

        a6 = t5 / 1000 
        a7 = rem 
        data = data // chs(a6) // "." 
        if a7 < 100 
          data = data // "0" 
        end 
        if a7 < 10 
          data = data // "0" 
        end 
        data = data // chs(a7) 

        ++pt_cnt2 
        tput [PT2,pt_cnt2] ~data   moveto (\040) show 
&dA 
&dA &d@    Construct coordinates for font bounding box 
&dA 
        temp = "" 
        a6 = a5 / 100 
        a7 = rem 
        temp = temp // chs(a6) // "." 
        if a7 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a7) // " " 

        a6 = a4 / 100 
        a7 = rem 
        temp = temp // chs(a6) // "." 
        if a7 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a7) // " 0 0" 

        ++sd_cnt 
        tput [SD,sd_cnt]   /FontBBox [~temp ] def 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /Encoding 256 array def 
        ++sd_cnt 
        tput [SD,sd_cnt]   0 1 255 {Encoding exch /.b46 notdef put} for 
        ++sd_cnt 
        tput [SD,sd_cnt]   Encoding 
        ++sd_cnt 
        tput [SD,sd_cnt]   32 /mus_32  put 

        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /BuildChar 
        ++sd_cnt 
        tput [SD,sd_cnt]     {0 begin 
        ++sd_cnt 
        tput [SD,sd_cnt]       /char exch def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /fontdict exch def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charname fontdict /Encoding get char get def
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charinfo fontdict /CharData get charname get def
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       /wx charinfo 0 get def 
        ++sd_cnt 
        tput [SD,sd_cnt]       /charbbox charinfo 1 4 getinterval def 
        ++sd_cnt 
        tput [SD,sd_cnt]       wx 0 charbbox aload pop setcachedevice 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       charinfo 5 get charinfo 6 get true 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]       fontdict /imagemaskmatrix get 
        ++sd_cnt 
        tput [SD,sd_cnt]         dup 4 charinfo 7 get put 
        ++sd_cnt 
        tput [SD,sd_cnt]         dup 5 charinfo 8 get put 
        ++sd_cnt 
        tput [SD,sd_cnt]       charinfo 9 1 getinterval cvx 
        ++sd_cnt 
        tput [SD,sd_cnt]       imagemask 
        ++sd_cnt 
        tput [SD,sd_cnt]       end 
        ++sd_cnt 
        tput [SD,sd_cnt]     } def 
        ++sd_cnt 
        tput [SD,sd_cnt] 
        ++sd_cnt 
        tput [SD,sd_cnt]   /BuildChar load 0 6 dict put 
        ++sd_cnt 
        tput [SD,sd_cnt] 


        ++sd_cnt 
        tput [SD,sd_cnt]   /imagemaskmatrix [100 0 0 -100 0 0] def 
        ++sd_cnt 
        tput [SD,sd_cnt] 

        ++sd_cnt 
        tput [SD,sd_cnt]   /CharData 2 dict def 
        ++sd_cnt 
        tput [SD,sd_cnt]   CharData begin 
&dA 
&dA &d@      Construct first 9 elements of def matrix 
&dA 
        temp = "[ 0 0 0 " 
        a6 = a5 / 100 
        a7 = rem 
        temp = temp // chs(a6) // "." 
        if a7 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a7) // " " 

        a6 = a4 / 100 
        a7 = rem 
        temp = temp // chs(a6) // "." 
        if a7 < 10 
          temp = temp // "0" 
        end 
        temp = temp // chs(a7) // " " 

        temp = temp // chs(a5) // " " // chs(a4) // " -0.5 " // chs(a4) // " "

        ++sd_cnt 
        tput [SD,sd_cnt]   /mus_32 ~temp  < 
&dA 
&dA &d@       Build the definition strings 
&dA 
        data = "" 
        loop for a3 = 1 to a4 
          ++a1                                 /* next record 
          tget [SST,a1] temp 
&dA 
&dA &d@       This is already a hex string 
&dA 
          loop for a8 = 1 to len(temp) 
            data = data // temp{a8} 
            if len(data) = 60 
              ++sd_cnt 
              tput [SD,sd_cnt] ~data 
              data = "" 
            end 
          repeat 
        repeat 
        if len(data) > 0 
          ++sd_cnt 
          tput [SD,sd_cnt] ~data 
        end 

        ++sd_cnt 
        tput [SD,sd_cnt] > ] def 

        ++sd_cnt 
        tput [SD,sd_cnt]   /.b46 notdef [ 0 0 0 0 0 1 0 0 <> ] def 
        ++sd_cnt 
        tput [SD,sd_cnt]   end 

        a6 = (t3 + 1) * 1000 + t4 
        ++sd_cnt 
        tput [SD,sd_cnt]   /UniqueID ~a6  def 
        ++sd_cnt 
        tput [SD,sd_cnt] end 
        ++sd_cnt 
        tput [SD,sd_cnt] /Bitfont~a6  exch definefont pop 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 42. vpage_limits (topp,bottomm)                                    ³ 
&dA &d@³                                                                      ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Purpose: determine top and bottom page limits                     ³ 
&dA &d@³                ignoring the caption at the bottom                    ³ 
&dA &d@³                                                                      ³ 
&dA &d@³   Inputs:  gstr  The struction of this string was determined         ³ 
&dA &d@³                  by the instruction  setup gstr,300,3100,3           ³ 
&dA &d@³                  According to the documentation, the first 20        ³ 
&dA &d@³                  bytes contain display information.  In particular,  ³ 
&dA &d@³                  bytes 13-14 contain the top display boundary;       ³ 
&dA &d@³                  and bytes 17-18 contain the bottom display          ³ 
&dA &d@³                  boundary.  The top boundary, we can use; but        ³ 
&dA &d@³                  the bottom boundary includes the bottom             ³ 
&dA &d@³                  caption, so we must look above this.                ³ 
&dA &d@³                                                                      ³ 
&dA &d@³   Output:  int   topp    =  top_limit                                ³ 
&dA &d@³            int   bottomm =  bottom_limit                             ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure vpage_limits (topp,bottomm) 
        int topp,bottomm 
        int a1,a2,a3,a4,a5 
&dA 
&dA &d@    Get top limit 
&dA 
        topp = 10000 
        a3 = 20 
        loop for a1 = 1 to 3099 
          loop for a2 = 1 to 300 
            ++a3 
            if gstr{a3} <> chr(0) 
              topp = a1 
              goto BBB 
            end 
          repeat 
        repeat 
BBB: 
&dA 
&dA &d@    Get bottom limit 
&dA 
        a5 = 0 
        loop for a1 = 3050 to 1 step -1 
          loop for a2 = 1 to 300 
            a3 = a1 * 300 + a2 + 20 
            if gstr{a3} <> chr(0) 
              a5 = a1 
              goto BBB1 
            end 
          repeat 
        repeat 
BBB1: 
        bottomm = a5 

        passback topp,bottomm 
      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 43. hpage_limits (leftt,rightt)                                    ³ 
&dA &d@³                                                                      ³ 
&dA &d@³                                                                      ³ 
&dA &d@³    Purpose: determine left and right page limits for those           ³ 
&dA &d@³                pages that do not have a system                       ³ 
&dA &d@³                                                                      ³ 
&dA &d@³   Inputs:  gstr  The structure of this string was determined         ³ 
&dA &d@³                  by the instruction  setup gstr,300,3100,3           ³ 
&dA &d@³                  According to the documentation, the first 20        ³ 
&dA &d@³                  bytes contain display information.  In particular,  ³ 
&dA &d@³                  bytes 13-14 contain the top display boundary;       ³ 
&dA &d@³                  and bytes 17-18 contain the bottom display          ³ 
&dA &d@³                  boundary.  The top boundary, we can use; but        ³ 
&dA &d@³                  the bottom boundary includes the bottom             ³ 
&dA &d@³                  caption, so we must look above this.                ³ 
&dA &d@³                                                                      ³ 
&dA &d@³   Output:  int   leftt  = left_limit                                 ³ 
&dA &d@³            int   rightt = right_limit                                ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure hpage_limits (leftt,rightt) 
        str line.300 
        bstr bline.2400,bline2.2400 
        int a1,a2,a3 
        int leftt,rightt 
&dA 
&dA &d@    Get limits 
&dA 
        leftt = 10000 
        rightt = 10000 

        loop for a1 = 1 to 3090 
          a2 = (a1 - 1) * 300 + 21 
          line = gstr{a2,300} 
          bline = cbi(line) 
          bline = bline // zpd(2400) 
          bline2 = rev(bline) 
          if bline con "1" 
            a3 = mpt 
            if a3 < leftt 
              leftt = a3 
            end 
          end 
          if bline2 con "1" 
            a3 = mpt 
            if a3 < rightt 
              rightt = a3 
            end 
          end 
        repeat 

        if leftt = 10000 
          leftt = 1200 
          rightt = 1200 
        else 
          rightt = 2401 - rightt 
        end 
        passback leftt,rightt 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
&dA &d@³D* 44. not_very_messy                                          ³ 
&dA &d@³                                                               ³ 
&dA &d@³    Purpose: get slurpar and tiepar parameters from the        ³ 
&dA &d@³                slurpars glob                                  ³ 
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
      procedure not_very_messy 
        str big_slurpars.1500000 
        str temp2.480 
        str rec.400,delim.2 
        int a1,a2,a3,a4 
        int t1,t2,t3
        int start 

        open [8,8] slurpars 
        len(big_slurpars) = sze 
        read [8] big_slurpars 
        close [8] 

        delim = chr(13) // chr(10) 
        start = 1 
        loop for t1 = 1 to 11 
          loop for t2 = 1 to 11 
            loop for t3 = 1 to 6 
              if big_slurpars{start..} con delim 
                slurpar06(t1,t2,t3) = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
            repeat 
          repeat 
        repeat 
        loop for t1 = 1 to 11 
          loop for t2 = 1 to 11 
            loop for t3 = 1 to 6 
              if big_slurpars{start..} con delim 
                slurpar14(t1,t2,t3) = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
            repeat 
          repeat 
        repeat 
        loop for t1 = 1 to 11 
          loop for t2 = 1 to 11 
            loop for t3 = 1 to 6 
              if big_slurpars{start..} con delim 
                slurpar16(t1,t2,t3) = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
            repeat 
          repeat 
        repeat 
        loop for t1 = 1 to 11 
          loop for t2 = 1 to 11 
            loop for t3 = 1 to 6 
              if big_slurpars{start..} con delim 
                slurpar18(t1,t2,t3) = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
            repeat 
          repeat 
        repeat 
        loop for t1 = 1 to 11 
          loop for t2 = 1 to 11 
            loop for t3 = 1 to 6 
              if big_slurpars{start..} con delim 
                slurpar21(t1,t2,t3) = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
            repeat 
          repeat 
        repeat 
&dA 
&dA &d@    Get tie parameters 
&dA 
        loop for a1 = 1 to 12 
          loop for a2 = 1 to 4 
            loop for a4 = 1 to 12 
              if big_slurpars{start..} con delim 
                temp2 = big_slurpars{start..sub-1} 
                start = sub + 2 
              end 
              a3 = 0 
              t1 = 1 
              t3 = 0 
              sub = 0 
              loop while a3 < ( TIE_DISTS ) 
                if temp2{t1} = "+" 
                  t2 = int(temp2{t1+1..}) 
                  t1 = sub - 1 
                else 
                  t2 = ors(temp2{t1}) 
                  if t2 < 96 
                    t2 -= 64 
                  else 
                    t2 = 96 - t2 
                  end 
                end 
                t3 += t2 
                ++a3 
                tiearr(a1,a2,a3,a4) = t3 
                ++t1 
              repeat 
            repeat 
          repeat 
        repeat 

      return 

&dA &d@ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
&dA &d@³P* 39. load_font_stuff                                                        ³
&dA &d@³                                                                              ³
&dA &d@³    Operation:  This procedure runs only once in this program.                ³
&dA &d@³                It loads the fontspac string from data provided               ³
&dA &d@³                It loads the kernfile string from data provided               ³
&dA &d@³                                                                              ³
&dA &d@³    Inputs:     provided inside the procedure                                 ³
&dA &d@³                                                                              ³
&dA &d@³    Output:     18000 byte fontspac string                                    ³
&dA &d@³                                                                              ³
&dA &d@ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      procedure load_font_stuff 
        str newXFstr.19(12) 
        str ks.4000 

        str temp.800 
        str blanks.32 
        int gg,hh,ii,jj,kk 
        int ksleng 
        int font 
        int t1,t2 
        int a1 
&dA 
&dA &d@    Step 1: Do fontspac and mfontspac 
&dA 
        open [8,8] gfontspac 
        len(fontspac) = sze 
        read [8] fontspac 
        close [8] 
        open [8,8] gmfontspac 
        len(mfontspac) = sze 
        read [8] mfontspac 
        close [8] 
        loop for gg = 1 to 12 
          jj = 32 
          loop for hh = 1 to 196 
            ii = (gg - 1) * 200 + hh 
            Mfontinc(gg,jj) = ors(mfontspac{ii}) 
            ++jj 
            if jj = 132 
              jj = 160 
            end                   
          repeat 
        repeat 
&dA 
&dA &d@    Step 2: Do kernmaps 
&dA 
        open [8,8] gkernspac 
        len(ks) = sze 
        read [8] ks 
        close [8] 

        ksleng = len(ks) 
        blanks = "                                " 

        loop for font = 1 to 30 
          gg = (font - 1) * 4 + 1 
          temp = ks{gg,4} 
          gg = int(temp) 
          gg += 121             /* jump over the offset section 

          temp = "" 
LF_B: 
          hh = ors(ks{gg}) 
          if bit(6,hh) = 1 
            jj = hh & 0x1f 
            if bit(5,hh) = 1 
              temp = temp // blanks{1,jj} // "1" 
            else 
              temp = temp // blanks{1,jj} // "0" 
            end 
          else 
            temp = temp // blanks{1,31} 
          end 
          if len(temp) < 676 and gg < ksleng 
            ++gg 
            goto LF_B 
          end 
          temp = temp // pad(700) 
          temp = temp{1,676} 

          gg = 0 
          loop for t1 = 1 to 26 
            loop for t2 = 1 to 26 
              ++gg 
              if temp{gg} = " " 
                all_real_kernmaps(font,t1,t2) = 0 
              end 
              if temp{gg} = "0" 
                all_real_kernmaps(font,t1,t2) = 1 
              end 
              if temp{gg} = "1" 
                all_real_kernmaps(font,t1,t2) = -1 
              end 
            repeat 
          repeat 
        repeat 

        loop for t1 = 27 to 52 
          loop for t2 = 1 to 26 
            kernmap(t1,t2) = 0 
          repeat 
        repeat 
&dA 
&dA &d@    Step 3: Load the hitestr stuff 
&dA 
        hitestr = "$&#(,&*.'+/(,1).3*/5+06,29.4</5=07?19B2<F4>I6AL7BL8FQ:GS;HU=IV>LZ@N]ATdFYkK]pM]qObwSp‰\p‰\"
        hitestr = hitestr // "+/(+/(+/(+/(.4).4*/5+16,18-4:.5</7=08?1;C3>F5?J6AL7DO9EQ:HS<HV=LX?M\AQaEUgHZjK]nMbuQl…Zl…Z"
        hitestr = hitestr // ",0(,0(,0(,0(-2).4*/5+18,4;.5=/7?08A19B2<G4?J6@L8AL9DP;FS<GT>JY?M]AN]BScFYmJ[lL^tNcwRp‰\p‰\"
&dA 
&dA &d@    Step 4: Do newfont_init stuff 
&dA 
        revsizes(1)  = 1 
        revsizes(2)  = 1 
        revsizes(3)  = 1 
        revsizes(4)  = 1 
        revsizes(5)  = 2 
        revsizes(6)  = 3 
        revsizes(7)  = 4 
        revsizes(8)  = 5 
        revsizes(9)  = 6 
        revsizes(10) = 6 
        revsizes(11) = 7 
        revsizes(12) = 7 
        revsizes(13) = 8 
        revsizes(14) = 8 
        revsizes(15) = 9 
        revsizes(16) = 9 
        revsizes(17) = 10 
        revsizes(18) = 10 
        revsizes(19) = 10 
        revsizes(20) = 11 
        revsizes(21) = 11 
        revsizes(22) = 11 
        revsizes(23) = 12 
        revsizes(24) = 12 

        newXFstr(1)  = "33Qo3Qo4Rp5Sq6Tr8Vt"   /* "  51  51  81 111  51  81 111  52  82 112  53  83 113  54  84 114  56  86 116"
        newXFstr(2)  = "34Rp5Sq6Tr7Us8Vt:Xv"   /* "  51  52  82 112  53  83 113  54  84 114  55  85 115  56  86 116  58  88 118"
        newXFstr(3)  = "36Tr7Us8Vt9Wu:Xv<Zx"   /* "  51  54  84 114  55  85 115  56  86 116  57  87 117  58  88 118  60  90 120"
        newXFstr(4)  = "47Us9Wu:Xv;Yw<Zx?]{"   /* "  52  55  85 115  57  87 117  58  88 118  59  89 119  60  90 120  63  93 123"
        newXFstr(5)  = "59Wu:Xv;Yw=[y>\z@^|"   /* "  53  57  87 117  58  88 118  59  89 119  61  91 121  62  92 122  64  94 124"
        newXFstr(6)  = "7;Yw=[y?]{@^|A_}Db€"   /* "  55  59  89 119  61  91 121  63  93 123  64  94 124  65  95 125  68  98 128"
        newXFstr(7)  = "9>\z@^|A_}CaEcHf„"   /* "  57  62  92 122  64  94 124  65  95 125  67  97 127  69  99 129  72 102 132"
        newXFstr(8)  = ":@^|B`~Db€Fd‚Hf„Jh†"   /* "  58  64  94 124  66  96 126  68  98 128  70 100 130  72 102 132  74 104 134"
        newXFstr(9)  = "<CaEcGeƒIg…Jh†Ljˆ"   /* "  60  67  97 127  69  99 129  71 101 131  73 103 133  74 104 134  76 106 136"
        newXFstr(10) = "=EcGeƒIg…Jh†Ki‡NlŠ"   /* "  61  69  99 129  71 101 131  73 103 133  74 104 134  75 105 135  78 108 138"
        newXFstr(11) = "@Hf„Jh†Ki‡Mk‰NlŠOm‹"   /* "  64  72 102 132  74 104 134  75 105 135  77 107 137  78 108 138  79 109 139"
        newXFstr(12) = "AJh†Ki‡Mk‰NlŠOm‹PnŒ"   /* "  65  74 104 134  75 105 135  77 107 137  78 108 138  79 109 139  80 110 140"

        loop for t1 = 1 to 12 
          loop for t2 = 1 to 19 
            XFonts(t1,t2) = ors(newXFstr(t1){t2}) 
          repeat 
        repeat 

        loop for a1 = 1 to 24 
          revmap(a1) = revsizes(a1) 
        repeat 
        loop for a1 = 1 to 12 
          revmap(100+a1) = a1 + BEAM_OFFSET 
        repeat 
        revmap(114)     = 13 + BEAM_OFFSET 

        revmap(98) = 48 
        revmap(99) = 49 
        revmap(100) = 50 
      return 

      run
